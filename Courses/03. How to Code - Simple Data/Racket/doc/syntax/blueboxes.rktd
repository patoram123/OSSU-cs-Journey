23931
((3) 0 () 34 ((q lib "syntax/id-set.rkt") (q lib "syntax/modcollapse.rkt") (q lib "syntax/id-table.rkt") (q lib "syntax/parse/experimental/reflect.rkt") (q lib "syntax/keyword.rkt") (q lib "syntax/boundmap.rkt") (q lib "syntax/parse.rkt") (q lib "syntax/struct.rkt") (q lib "syntax/module-reader.rkt") (q "(lib syntax/scribblings/syntax.scrbl)") (q lib "syntax/srcloc.rkt") (q lib "syntax/kerncase.rkt") (q lib "syntax/modcode.rkt") (q lib "syntax/macro-testing.rkt") (q lib "syntax/stx.rkt") (q lib "syntax/datum.rkt") (q lib "syntax/location.rkt") (q lib "syntax/parse/experimental/template.rkt") (q lib "syntax/parse/debug.rkt") (q lib "syntax/parse/experimental/eh.rkt") (q 45721 . 4) (q lib "syntax/toplevel.rkt") (q lib "syntax/transformer.rkt") (q lib "syntax/docprovide.rkt") (q lib "syntax/flatten-begin.rkt") (q lib "syntax/parse/lib/function-header.rkt") (q lib "syntax/parse/define.rkt") (q lib "syntax/modresolve.rkt") (q lib "syntax/strip-context.rkt") (q lib "syntax/context.rkt") (q lib "syntax/parse/experimental/provide.rkt") (q lib "syntax/define.rkt") (q lib "syntax/readerr.rkt") (q lib "syntax/modread.rkt")) () (h ! (equal) ((c def c (c (? . 32) q raise-read-eof-error)) q (57168 . 13)) ((c def c (c (? . 1) q collapse-module-path)) q (46498 . 6)) ((c def c (c (? . 4) q check-stx-listof)) q (41071 . 5)) ((c idx c (c gentag c 7 ? . 9)) q (4818 . 4)) ((c def c (c (? . 0) q bound-id-subset?)) q (32592 . 4)) ((c def c (c (? . 12) q get-metadata-path)) q (45219 . 8)) ((c def c (c (? . 14) q stx-map)) q (16311 . 4)) ((c def c (c (? . 0) q free-id-set-copy-clear)) q (27095 . 3)) ((c form c (c (? . 15) q datum)) q (41513 . 2)) ((c def c (c (? . 6) q expr/c)) q (10746 . 19)) ((c def c (c (? . 2) q bound-id-table-update!)) q (22884 . 9)) ((c def c (c (? . 1) q collapse-module-path-index)) q (46767 . 10)) ((c def c (c (? . 2) q bound-id-table?)) q (21494 . 3)) ((c def c (c (? . 3) q reified-syntax-class?)) q (13749 . 3)) ((c def c (c (? . 27) q resolve-module-path)) q (45854 . 7)) ((c def c (c (? . 3) q reified-syntax-class-attributes)) q (13892 . 4)) ((c def c (c (? . 4) q check-stx-boolean)) q (41336 . 4)) ((c def c (c (? . 5) q make-module-identifier-mapping)) q (35439 . 2)) ((q def ((lib "syntax/template.rkt") transform-template)) q (54127 . 24)) ((c def c (c (? . 5) q free-identifier-mapping-get)) q (34572 . 8)) ((c def c (c (? . 0) q bound-id-set-subtract!)) q (32153 . 4)) ((c def c (c (? . 7) q build-struct-names)) q (49558 . 14)) ((c form c (c (? . 6) q define-syntax-class)) q (2468 . 25)) ((c def c (c (? . 0) q bound-id-set-union!)) q (31656 . 4)) ((c form c (c (? . 13) q convert-syntax-error)) q (66515 . 2)) ((c def c (c (? . 7) q struct-declaration-info?)) q (52932 . 3)) ((c def c (c (? . 6) q prop:pattern-expander)) q (8678 . 3)) ((c form c (c (? . 6) q str)) q (10565 . 2)) ((q form ((lib "syntax/quote.rkt") quote-syntax/keep-srcloc)) q (64090 . 3)) ((c form c (c (? . 6) q ~delimit-cut)) q (5101 . 2)) ((c def c (c (? . 0) q bound-id-set-empty?)) q (30000 . 3)) ((c def c (c (? . 5) q free-identifier-mapping?)) q (34502 . 3)) ((c def c (c (? . 6) q syntax-parse-state-set!)) q (12160 . 4)) ((c def c (c (? . 8) q wrap-read-all)) q (60389 . 17)) ((c form c (c (? . 19) q define-eh-alternative-set)) q (15246 . 4)) ((c def c (c (? . 2) q bound-id-table-count)) q (24167 . 3)) ((c def c (c (? . 5) q make-bound-identifier-mapping)) q (33262 . 2)) ((c def c (c (? . 0) q in-bound-id-set)) q (30980 . 3)) ((c def c (c (? . 21) q expand-syntax-top-level-with-compile-time-evals/flatten)) q (64377 . 4)) ((c def c (c (? . 2) q free-id-table-keys)) q (19604 . 3)) ((c def c (c (? . 2) q bound-id-table-iterate-first)) q (24269 . 3)) ((c form c (c (? . 6) q define-literal-set)) q (9198 . 18)) ((c def c (c (? . 0) q free-id-set-remove)) q (26428 . 4)) ((c def c (c (? . 22) q make-variable-like-transformer)) q (55449 . 6)) ((c def c (c (? . 8) q lang-reader-module-paths)) q (60283 . 4)) ((c def c (c (? . 2) q free-id-table-set)) q (18027 . 5)) ((c form c (c (? . 6) q literal-set->predicate)) q (9855 . 2)) ((c def c (c (? . 0) q bound-id-set-union)) q (31525 . 4)) ((c def c (c (? . 4) q check-identifier)) q (40849 . 4)) ((c def c (c (? . 2) q make-free-id-table)) q (16892 . 5)) ((c idx c (c gentag c 2 ? . 9)) q (4619 . 2)) ((c def c (c (? . 5) q make-free-identifier-mapping)) q (34431 . 2)) ((c def c (c (? . 6) q static)) q (10605 . 4)) ((c form c (c (? . 6) q ~!)) q (8013 . 2)) ((c def c (c (? . 0) q free-id-set-union!)) q (27471 . 4)) ((c def c (c (? . 0) q bound-id-set-for-each)) q (32906 . 4)) ((c def c (c (? . 0) q free-id-set-empty?)) q (25860 . 3)) ((c def c (c (? . 2) q immutable-free-id-table?)) q (17498 . 3)) ((c def c (c (? . 2) q bound-id-table-set)) q (22160 . 5)) ((c form c (c (? . 11) q kernel-syntax-case*/phase)) q (16736 . 3)) ((q def ((lib "syntax/apply-transformer.rkt") local-apply-transformer)) q (55878 . 11)) ((c def c (c (? . 23) q lookup-documentation)) q (65047 . 5)) ((c def c (c (? . 10) q source-location?)) q (61141 . 3)) ((c form c (c (? . 6) q exact-integer)) q (10346 . 2)) ((c def c (c (? . 0) q bound-id-set-member?)) q (30163 . 4)) ((c form c (c (? . 6) q character)) q (10582 . 2)) ((c form c (c (? . 6) q ~bind)) q (8017 . 5)) ((c def c (c (? . 4) q options-select-value)) q (40612 . 7)) ((c def c (c (? . 0) q bound-id-set-count)) q (30073 . 3)) ((c def c (c (? . 10) q source-location->string)) q (63160 . 3)) ((c def c (c (? . 5) q module-identifier-mapping-map)) q (36418 . 5)) ((c def c (c (? . 28) q strip-context)) q (37016 . 3)) ((c def c (c (? . 3) q reified-syntax-class-curry)) q (14371 . 8)) ((c form c (c (? . 6) q ~datum)) q (5546 . 2)) ((c def c (c (? . 11) q kernel-form-identifier-list)) q (16825 . 2)) ((c def c (c (? . 2) q free-id-table-iterate-key)) q (20332 . 4)) ((c form c (c (? . 6) q exact-positive-integer)) q (10412 . 2)) ((c form c (c (? . 6) q this-syntax)) q (4247 . 2)) ((c form c (c (? . 6) q ~var)) q (5022 . 2)) ((c def c (c (? . 12) q exn:get-module-code-path)) c (? . 20)) ((c def c (c (? . 3) q reified-syntax-class-arity)) q (14073 . 3)) ((c form c (c (? . 13) q phase1-eval)) q (66284 . 8)) ((c def c (c (? . 0) q in-free-id-set)) q (26816 . 3)) ((c form c (c (? . 6) q ...+)) q (5647 . 2)) ((c form c (c (? . 6) q ~or)) q (5058 . 2)) ((c def c (c (? . 12) q get-module-path)) q (44150 . 21)) ((c form c (c (? . 6) q ~not)) q (5729 . 2)) ((c idx c (c gentag c 11 ? . 9)) q (4987 . 2)) ((c form c (c (? . 6) q ~optional)) q (5134 . 2)) ((c form c (c (? . 26) q define-syntax-parse-rule)) q (8942 . 3)) ((q def ((lib "syntax/to-string.rkt") syntax->string)) q (36637 . 3)) ((c def c (c (? . 5) q free-identifier-mapping-map)) q (35274 . 4)) ((c def c (c (? . 4) q parse-keyword-options/eol)) q (38573 . 30)) ((c form c (c (? . 6) q char)) q (10266 . 2)) ((c def c (c (? . 0) q free-id-set-remove!)) q (26548 . 4)) ((c def c (c (? . 10) q check-source-location!)) q (61339 . 4)) ((c def c (c (? . 31) q normalize-definition/mk-rhs)) q (48676 . 12)) ((c def c (c (? . 6) q syntax-parse-track-literals)) q (12672 . 5)) ((c form c (c (? . 17) q datum-template)) q (15776 . 2)) ((q def ((lib "syntax/name.rkt") syntax-local-infer-name)) q (48009 . 4)) ((c def c (c (? . 2) q free-id-table-map)) q (19478 . 4)) ((c def c (c (? . 2) q bound-id-table/c)) q (24885 . 7)) ((c form c (c (? . 11) q kernel-syntax-case/phase)) q (16667 . 2)) ((c def c (c (? . 10) q build-source-location-syntax)) q (61731 . 3)) ((c def c (c (? . 10) q source-location-vector?)) q (61270 . 3)) ((c def c (c (? . 2) q free-id-table-update!)) q (18737 . 9)) ((c form c (c (? . 3) q ~splicing-reflect)) q (14853 . 2)) ((c def c (c (? . 10) q source-location-list?)) q (61203 . 3)) ((c form c (c (? . 16) q quote-character-span)) q (63811 . 3)) ((c def c (c (? . 14) q stx-list?)) q (16070 . 3)) ((c form c (c (? . 18) q syntax-class-arity)) q (12922 . 2)) ((c form c (c (? . 15) q quasidatum)) q (41651 . 2)) ((c form c (c (? . 16) q quote-srcloc-string)) q (63870 . 3)) ((c def c (c (? . 10) q source-location-source)) q (61907 . 3)) ((c def c (c (? . 14) q stx-null?)) q (15960 . 3)) ((c form c (c (? . 16) q quote-module-name)) q (63984 . 2)) ((c def c (c (? . 10) q update-source-location)) q (62545 . 13)) ((c form c (c (? . 17) q ??)) q (15806 . 2)) ((c def c (c (? . 2) q in-free-id-table)) q (19788 . 3)) ((c def c (c (? . 0) q bound-id-set-symmetric-difference!)) q (32415 . 5)) ((c def c (c (? . 0) q free-id-set-member?)) q (26019 . 4)) ((c def c (c (? . 0) q free-id-set-intersect!)) q (27711 . 4)) ((c form c (c (? . 18) q syntax-class-keywords)) q (12967 . 2)) ((c form c (c (? . 19) q ~eh-var)) q (15349 . 2)) ((c def c (c (? . 6) q pattern-expander?)) q (8785 . 3)) ((q def ((lib "syntax/free-vars.rkt") free-vars)) q (36732 . 8)) ((c def c (c (? . 2) q make-immutable-bound-id-table)) q (21243 . 6)) ((c def c (c (? . 5) q module-identifier-mapping-put!)) q (35940 . 7)) ((c def c (c (? . 2) q free-id-table-for-each)) q (19868 . 4)) ((c def c (c (? . 0) q free-id-set-clear!)) q (27268 . 3)) ((c form c (c (? . 6) q byte-regexp)) q (10468 . 2)) ((c def c (c (? . 6) q pattern-expander)) q (8584 . 3)) ((c form c (c (? . 6) q keyword)) q (10284 . 2)) ((c def c (c (? . 2) q free-id-table-set*)) q (18322 . 5)) ((c form c (c (? . 6) q boolean)) q (10245 . 2)) ((c def c (c (? . 2) q bound-id-table-remove)) q (22745 . 4)) ((c def c (c (? . 10) q source-location-known?)) q (61824 . 3)) ((c form c (c (? . 6) q ~peek)) q (6975 . 2)) ((c def c (c (? . 6) q syntax-parse-state-cons!)) q (12528 . 5)) ((c def c (c (? . 6) q syntax-local-syntax-parse-pattern-introduce)) q (8848 . 3)) ((c def c (c (? . 8) q make-meta-reader)) q (59453 . 17)) ((c def c (c (? . 12) q make-exn:get-module-code)) c (? . 20)) ((c def c (c (? . 2) q make-immutable-free-id-table)) q (17122 . 6)) ((c def c (c (? . 0) q bound-id-set->list)) q (31123 . 3)) ((c def c (c (? . 2) q bound-id-table-map)) q (23636 . 4)) ((c def c (c (? . 14) q stx->list)) q (16125 . 3)) ((c def c (c (? . 2) q free-id-table-set!)) q (17895 . 5)) ((c def c (c (? . 2) q bound-id-table-keys)) q (23764 . 3)) ((c form c (c (? . 6) q ~seq)) q (6551 . 2)) ((c def c (c (? . 2) q free-id-table-remove)) q (18601 . 4)) ((c def c (c (? . 0) q bound-id-set-subtract)) q (32019 . 4)) ((c def c (c (? . 14) q stx-pair?)) q (16015 . 3)) ((c def c (c (? . 0) q free-id-set-copy)) q (27022 . 3)) ((c def c (c (? . 2) q bound-id-table-set!)) q (22026 . 5)) ((c def c (c (? . 10) q source-location->prefix)) q (63243 . 3)) ((c def c (c (? . 21) q eval-compile-time-part-of-top-level/compile)) q (64578 . 4)) ((c form c (c (? . 6) q regexp)) q (10448 . 2)) ((c def c (c (? . 2) q free-id-table-update)) q (19099 . 9)) ((c def c (c (? . 0) q immutable-bound-id-set?)) q (29931 . 3)) ((c form c (c (? . 18) q syntax-class-parse)) q (13015 . 4)) ((c form c (c (? . 6) q ~and)) q (5034 . 2)) ((c def c (c (? . 2) q free-id-table-values)) q (19698 . 3)) ((c def c (c (? . 16) q syntax-source-directory)) q (63326 . 3)) ((c def c (c (? . 0) q immutable-bound-id-set)) q (29572 . 6)) ((c def c (c (? . 29) q generate-expand-context)) q (48207 . 3)) ((c idx c (c gentag c 5 ? . 9)) q (4700 . 2)) ((c def c (c (? . 0) q bound-id-set-rest)) q (30884 . 3)) ((c def c (c (? . 5) q bound-identifier-mapping-put!)) q (33755 . 7)) ((c form c (c (? . 17) q quasitemplate/loc)) q (15733 . 2)) ((c def c (c (? . 2) q free-id-table-remove!)) q (18485 . 4)) ((c def c (c (? . 21) q expand-syntax-top-level-with-compile-time-evals)) q (64188 . 3)) ((c form c (c (? . 15) q with-datum)) q (41538 . 3)) ((c def c (c (? . 0) q mutable-free-id-set)) q (25190 . 5)) ((c def c (c (? . 10) q source-location-line)) q (61987 . 3)) ((c form c (c (? . 25) q function-header)) q (11685 . 2)) ((c def c (c (? . 5) q free-identifier-mapping-for-each)) q (35066 . 5)) ((c def c (c (? . 2) q free-id-table-set*!)) q (18179 . 5)) ((c form c (c (? . 15) q undatum-splicing)) q (41704 . 2)) ((c def c (c (? . 5) q free-identifier-mapping-put!)) q (34916 . 5)) ((c def c (c (? . 6) q prop:syntax-class)) q (4266 . 4)) ((c form c (c (? . 6) q ~alt)) q (7030 . 2)) ((c form c (c (? . 17) q template)) q (15642 . 2)) ((c def c (c (? . 2) q free-id-table-iterate-value)) q (20465 . 5)) ((c def c (c (? . 2) q bound-id-table-set*!)) q (22315 . 5)) ((c idx c (c gentag c 6 ? . 9)) q (4731 . 4)) ((c form c (c (? . 6) q expr)) q (10203 . 2)) ((c def c (c (? . 0) q free-id-subset?)) q (28333 . 4)) ((c form c (c (? . 6) q nat)) q (10548 . 2)) ((c def c (c (? . 14) q stx-cdr)) q (16259 . 3)) ((c def c (c (? . 2) q make-bound-id-table)) q (21010 . 5)) ((c form c (c (? . 3) q ~reflect)) q (14715 . 5)) ((c def c (c (? . 5) q module-identifier-mapping-get)) q (35586 . 8)) ((c form c (c (? . 11) q kernel-syntax-case)) q (16521 . 2)) ((c def c (c (? . 2) q bound-id-table-iterate-next)) q (24371 . 5)) ((q def ((lib "syntax/path-spec.rkt") resolve-path-spec)) q (53810 . 9)) ((c def c (c (? . 2) q mutable-free-id-table?)) q (17430 . 3)) ((c form c (c (? . 13) q convert-compile-time-error)) q (66473 . 2)) ((c def c (c (? . 22) q make-expression-transformer)) q (55753 . 4)) ((c def c (c (? . 0) q free-id-set=?)) q (26116 . 4)) ((c def c (c (? . 0) q bound-id-set=?)) q (30262 . 4)) ((q def ((lib "syntax/for-body.rkt") split-for-body)) q (60928 . 4)) ((c def c (c (? . 10) q build-source-location-list)) q (61517 . 3)) ((c form c (c (? . 30) q syntax-class/c)) q (13682 . 2)) ((c def c (c (? . 2) q free-id-table?)) q (17370 . 3)) ((c form c (c (? . 6) q syntax-parse)) q (104 . 31)) ((c def c (c (? . 24) q flatten-begin)) q (49123 . 3)) ((c def c (c (? . 0) q free-id-set-rest)) q (26723 . 3)) ((c form c (c (? . 6) q ~literal)) q (5438 . 5)) ((c def c (c (? . 2) q immutable-bound-id-table?)) q (21624 . 3)) ((c def c (c (? . 0) q free-id-set?)) q (25668 . 3)) ((c form c (c (? . 6) q ~fail)) q (8135 . 11)) ((c form c (c (? . 23) q provide-and-document)) q (64696 . 9)) ((c def c (c (? . 0) q immutable-free-id-set)) q (25426 . 5)) ((c def c (c (? . 4) q check-stx-string)) q (41227 . 4)) ((c def c (c (? . 2) q bound-id-table-iterate-value)) q (24700 . 5)) ((c def c (c (? . 10) q source-location-span)) q (62322 . 4)) ((c def c (c (? . 2) q bound-id-table-iterate-key)) q (24561 . 4)) ((c def c (c (? . 0) q free-id-set-add!)) q (26329 . 4)) ((q def ((lib "syntax/unsafe/for-transform.rkt") expand-for-clause)) q (61032 . 4)) ((c form c (c (? . 6) q ~between)) q (7659 . 10)) ((c form c (c (? . 6) q integer)) q (10325 . 2)) ((c def c (c (? . 5) q bound-identifier-mapping-get)) q (33406 . 8)) ((c form c (c (? . 16) q quote-column-number)) q (63687 . 3)) ((c def c (c (? . 0) q mutable-bound-id-set)) q (29341 . 5)) ((c def c (c (? . 5) q bound-identifier-mapping-for-each)) q (34005 . 5)) ((c form c (c (? . 18) q debug-parse)) q (13108 . 4)) ((c form c (c (? . 17) q define-template-metafunction)) q (15826 . 3)) ((c idx c (c gentag c 8 ? . 9)) q (4907 . 2)) ((c idx c (c gentag c 10 ? . 9)) q (4958 . 2)) ((c def c (c (? . 12) q default-compiled-sub-path)) q (45163 . 2)) ((c def c (c (? . 5) q module-identifier-mapping?)) q (35514 . 3)) ((c def c (c (? . 3) q reified-splicing-syntax-class?)) q (13816 . 3)) ((c def c (c (? . 0) q bound-id-set-clear)) q (31350 . 3)) ((c form c (c (? . 15) q undatum)) q (41681 . 2)) ((c def c (c (? . 24) q flatten-all-begins)) q (49197 . 3)) ((c def c (c (? . 0) q free-id-set-for-each)) q (28639 . 4)) ((c def c (c (? . 14) q module-or-top-identifier=?)) q (16406 . 4)) ((c def c (c (? . 16) q syntax-source-file-name)) q (63410 . 3)) ((c def c (c (? . 0) q free-id-set-intersect)) q (27580 . 4)) ((c form c (c (? . 6) q ~once)) q (7055 . 10)) ((c def c (c (? . 0) q bound-id-set-add!)) q (30481 . 4)) ((c form c (c (? . 3) q reify-syntax-class)) q (13704 . 2)) ((c def c (c (? . 10) q build-source-location-vector)) q (61622 . 3)) ((c form c (c (? . 15) q datum-case)) q (41446 . 3)) ((c def c (c (? . 7) q build-struct-generation*)) q (50935 . 20)) ((c form c (c (? . 25) q formals)) q (11905 . 2)) ((c def c (c (? . 0) q bound-id-set-intersect)) q (31768 . 4)) ((c def c (c (? . 2) q id-table-iter?)) q (20644 . 3)) ((c def c (c (? . 2) q free-id-table-iterate-first)) q (20099 . 3)) ((c form c (c (? . 6) q id)) q (10532 . 2)) ((c def c (c (? . 2) q in-bound-id-table)) q (23952 . 3)) ((c def c (c (? . 0) q free-id-set->list)) q (26955 . 3)) ((q def ((lib "syntax/contract.rkt") wrap-expr/c)) q (65211 . 23)) ((c def c (c (? . 2) q free-id-table-ref)) q (17568 . 5)) ((c def c (c (? . 2) q bound-id-table-update)) q (23251 . 9)) ((c form c (c (? . 6) q identifier)) q (10221 . 2)) ((c def c (c (? . 10) q source-location-column)) q (62095 . 4)) ((c def c (c (? . 12) q struct:exn:get-module-code)) c (? . 20)) ((c form c (c (? . 6) q ~rest)) q (5825 . 2)) ((c def c (c (? . 0) q free-id-set-add)) q (26212 . 4)) ((c def c (c (? . 14) q stx-car)) q (16207 . 3)) ((c def c (c (? . 0) q bound-id-set-remove)) q (30582 . 4)) ((c def c (c (? . 0) q mutable-free-id-set?)) q (25726 . 3)) ((c def c (c (? . 7) q generate-struct-declaration)) q (53002 . 17)) ((c def c (c (? . 0) q bound-id-set-first)) q (30809 . 3)) ((c def c (c (? . 10) q source-location-position)) q (62209 . 4)) ((c def c (c (? . 12) q moddep-current-open-input-file)) q (45537 . 5)) ((c form c (c (? . 15) q define/with-datum)) q (41603 . 2)) ((c def c (c (? . 5) q bound-identifier-mapping-map)) q (34218 . 5)) ((q form ((lib "syntax/parse/experimental/splicing.rkt") define-primitive-splicing-syntax-class)) q (14926 . 9)) ((c form c (c (? . 17) q template/loc)) q (15666 . 2)) ((c def c (c (? . 4) q check-expression)) q (40962 . 4)) ((c def c (c (? . 21) q eval-compile-time-part-of-top-level)) q (64494 . 3)) ((c def c (c (? . 2) q free-id-table-count)) q (19999 . 3)) ((c form c (c (? . 26) q define-simple-macro)) q (9109 . 3)) ((c form c (c (? . 16) q quote-source-file)) q (63581 . 3)) ((c def c (c (? . 0) q mutable-bound-id-set?)) q (29864 . 3)) ((c def c (c (? . 0) q bound-id-set-clear!)) q (31447 . 3)) ((c form c (c (? . 6) q ~commit)) q (5086 . 2)) ((c def c (c (? . 0) q bound-id-set-copy-clear)) q (31268 . 3)) ((c def c (c (? . 27) q resolve-module-path-index)) q (46163 . 7)) ((c def c (c (? . 6) q syntax-parse-state-ref)) q (12022 . 4)) ((c form c (c (? . 18) q syntax-class-attributes)) q (12872 . 2)) ((c form c (c (? . 6) q define/syntax-parse)) q (2361 . 4)) ((c def c (c (? . 2) q mutable-bound-id-table?)) q (21555 . 3)) ((c def c (c (? . 10) q build-source-location)) q (61431 . 3)) ((c def c (c (? . 2) q bound-id-table-for-each)) q (24034 . 4)) ((c def c (c (? . 28) q replace-context)) q (37078 . 4)) ((c form c (c (? . 25) q formals-no-rest)) q (11955 . 2)) ((c def c (c (? . 2) q bound-id-table-set*)) q (22460 . 6)) ((c def c (c (? . 12) q exn:get-module-code)) c (? . 20)) ((c idx c (c gentag c 3 ? . 9)) q (4643 . 2)) ((c def c (c (? . 4) q options-select)) q (40266 . 4)) ((c idx c (c gentag c 9 ? . 9)) q (4931 . 2)) ((c form c (c (? . 8) q #%module-begin)) q (57709 . 33)) ((c def c (c (? . 2) q bound-id-table-values)) q (23860 . 3)) ((c def c (c (? . 0) q free-id-set-subtract!)) q (27954 . 4)) ((c def c (c (? . 0) q id-set/c)) q (28747 . 8)) ((q def ((lib "syntax/moddep.rkt") show-import-tree)) q (47178 . 11)) ((c def c (c (? . 18) q debug-syntax-parse!)) q (13184 . 2)) ((c def c (c (? . 3) q reified-syntax-class-keywords)) q (14209 . 4)) ((c def c (c (? . 5) q module-identifier-mapping-for-each)) q (36198 . 5)) ((c def c (c (? . 0) q bound-id-set?)) q (29805 . 3)) ((c def c (c (? . 2) q free-id-table-iterate-next)) q (20195 . 4)) ((c form c (c (? . 6) q ~parse)) q (8454 . 2)) ((c def c (c (? . 0) q immutable-free-id-set?)) q (25792 . 3)) ((c form c (c (? . 6) q ~post)) q (5121 . 2)) ((c def c (c (? . 29) q build-expand-context)) q (48127 . 3)) ((c def c (c (? . 0) q free-id-set-count)) q (25931 . 3)) ((c form c (c (? . 16) q quote-srcloc-prefix)) q (63927 . 3)) ((c def c (c (? . 7) q build-struct-generation)) q (50138 . 18)) ((c form c (c (? . 6) q ~undo)) q (8536 . 2)) ((c form c (c (? . 30) q provide-syntax-class/contract)) q (13227 . 12)) ((c def c (c (? . 21) q expand-top-level-with-compile-time-evals)) q (64286 . 3)) ((c form c (c (? . 16) q quote-module-path)) q (64037 . 2)) ((q form ((lib "syntax/parse/experimental/specialize.rkt") define-syntax-class/specialize)) q (15389 . 8)) ((c form c (c (? . 6) q ~or*)) q (5046 . 2)) ((c def c (c (? . 0) q bound-id-set-symmetric-difference)) q (32268 . 5)) ((c form c (c (? . 6) q define-conventions)) q (9898 . 10)) ((c def c (c (? . 2) q free-id-table/c)) q (20704 . 7)) ((c def c (c (? . 33) q with-module-reading-parameterization)) q (41736 . 3)) ((c def c (c (? . 0) q free-id-set-symmetric-difference)) q (28066 . 5)) ((c def c (c (? . 0) q bound-id-set-remove!)) q (30705 . 4)) ((c def c (c (? . 4) q options-select-row)) q (40381 . 7)) ((c form c (c (? . 6) q ~peek-not)) q (6995 . 2)) ((c form c (c (? . 16) q quote-srcloc)) q (63494 . 4)) ((c def c (c (? . 7) q parse-define-struct)) q (49276 . 7)) ((c def c (c (? . 4) q parse-keyword-options)) q (37187 . 25)) ((c def c (c (? . 0) q free-id-set-clear)) q (27174 . 3)) ((c def c (c (? . 0) q free-id-set-subtract)) q (27824 . 4)) ((c def c (c (? . 31) q normalize-definition)) q (48323 . 9)) ((c form c (c (? . 26) q define-syntax-parser)) q (9036 . 2)) ((c def c (c (? . 2) q bound-id-table-remove!)) q (22627 . 4)) ((c def c (c (? . 0) q bound-id-set-intersect!)) q (31903 . 4)) ((c def c (c (? . 0) q bound-id-set-copy)) q (31192 . 3)) ((c def c (c (? . 0) q free-id-set/c)) q (29097 . 6)) ((c def c (c (? . 0) q bound-id-set/c)) q (33016 . 6)) ((c def c (c (? . 0) q bound-id-set-add)) q (30361 . 4)) ((c form c (c (? . 6) q syntax-parser)) q (2305 . 2)) ((c form c (c (? . 6) q number)) q (10305 . 2)) ((c def c (c (? . 2) q free-id-table-ref!)) q (17753 . 5)) ((c form c (c (? . 6) q pattern)) q (4190 . 2)) ((c form c (c (? . 11) q kernel-syntax-case*)) q (16585 . 2)) ((c idx c (c gentag c 4 ? . 9)) q (4666 . 2)) ((c def c (c (? . 2) q bound-id-table-ref)) q (21695 . 5)) ((q def ((lib "syntax/wrap-modbeg.rkt") make-wrapping-module-begin)) q (47774 . 6)) ((c def c (c (? . 0) q bound-id-proper-subset?)) q (32693 . 4)) ((c def c (c (? . 32) q raise-read-error)) q (56408 . 15)) ((c def c (c (? . 6) q syntax-parse-state-update!)) q (12257 . 7)) ((c def c (c (? . 0) q free-id-set-union)) q (27344 . 4)) ((c def c (c (? . 0) q free-id-proper-subset?)) q (28431 . 4)) ((c def c (c (? . 0) q free-id-set-map)) q (28536 . 4)) ((c def c (c (? . 10) q source-location-end)) q (62434 . 4)) ((c def c (c (? . 12) q exn:get-module-code?)) c (? . 20)) ((c form c (c (? . 25) q formal)) q (11770 . 2)) ((c form c (c (? . 6) q attribute)) q (4994 . 2)) ((c def c (c (? . 0) q free-id-set-symmetric-difference!)) q (28209 . 4)) ((c form c (c (? . 6) q ~do)) q (8510 . 2)) ((q def ((lib "syntax/intdef.rkt") internal-definition-context-track)) q (66551 . 5)) ((c def c (c (? . 2) q bound-id-table-ref!)) q (21882 . 5)) ((c form c (c (? . 6) q define-splicing-syntax-class)) q (3989 . 5)) ((c form c (c (? . 6) q exact-nonnegative-integer)) q (10373 . 2)) ((c form c (c (? . 17) q quasitemplate)) q (15704 . 2)) ((c def c (c (? . 0) q free-id-set->stream)) q (26884 . 3)) ((c form c (c (? . 6) q ~describe)) q (5069 . 2)) ((c form c (c (? . 16) q quote-line-number)) q (63634 . 3)) ((c form c (c (? . 16) q quote-character-position)) q (63744 . 3)) ((c def c (c (? . 12) q get-module-code)) q (42113 . 36)) ((c form c (c (? . 17) q ?@)) q (15816 . 2)) ((c def c (c (? . 0) q bound-id-set->stream)) q (31050 . 3)) ((c def c (c (? . 5) q bound-identifier-mapping?)) q (33335 . 3)) ((c def c (c (? . 7) q build-struct-expand-info)) q (51843 . 21)) ((c form c (c (? . 6) q kernel-literals)) q (11662 . 2)) ((c def c (c (? . 0) q bound-id-set-map)) q (32801 . 4)) ((c idx c (c gentag c 1 ? . 9)) q (4429 . 8)) ((c def c (c (? . 33) q check-module-form)) q (41825 . 8)) ((c def c (c (? . 0) q free-id-set-first)) q (26650 . 3))))

(mylet ([var-id rhs-expr] ...) body ...+)
(mylet loop-id ([var-id rhs-expr] ...) body ...+)
syntax
(syntax-parse stx-expr parse-option ... clause ...+)
 
      parse-option = #:context context-expr
                   | #:literals (literal ...)
                   | #:datum-literals (datum-literal ...)
                   | #:literal-sets (literal-set ...)
                   | #:track-literals
                   | #:conventions (convention-id ...)
                   | #:local-conventions (convention-rule ...)
                   | #:disable-colon-notation
                      
           literal = literal-id
                   | (pattern-id literal-id)
                   | (pattern-id literal-id #:phase phase-expr)
                      
     datum-literal = literal-id
                   | (pattern-id literal-id)
                      
       literal-set = literal-set-id
                   | (literal-set-id literal-set-option ...)
                      
literal-set-option = #:at context-id
                   | #:phase phase-expr
                      
            clause = (syntax-pattern pattern-directive ... body ...+)
 
  stx-expr : syntax?
  context-expr : (or/c syntax? symbol? #f
                       (list/c symbol? syntax?))
  phase-expr : (or/c exact-integer? #f)

#:context context-expr
 
  context-expr : (or/c syntax? symbol? #f
                       (list/c symbol? syntax?))

#:literals (literal ...)
 
literal = literal-id
        | (pattern-id literal-id)
        | (pattern-id literal-id #:phase phase-expr)
 
  phase-expr : (or/c exact-integer? #f)

#:datum-literals (datum-literal ...)
 
datum-literal = literal-id
              | (pattern-id literal-id)

#:literal-sets (literal-set ...)
 
       literal-set = literal-set-id
                   | (literal-set-id literal-set-option ...)
                      
literal-set-option = #:at lctx
                   | #:phase phase-expr
 
  phase-expr : (or/c exact-integer? #f)

#:track-literals

#:conventions (conventions-id ...)

#:local-conventions (convention-rule ...)

#:disable-colon-notation
syntax
(syntax-parser parse-option ... clause ...+)
syntax
(define/syntax-parse syntax-pattern pattern-directive ... stx-expr)
 
  stx-expr : syntax?
syntax
(define-syntax-class name-id stxclass-option ...
  stxclass-variant ...+)
(define-syntax-class (name-id . kw-formals) stxclass-option ...
  stxclass-variant ...+)
 
 stxclass-option = #:attributes (attr-arity-decl ...)
                 | #:auto-nested-attributes
                 | #:description description-expr
                 | #:opaque
                 | #:commit
                 | #:no-delimit-cut
                 | #:literals (literal-entry ...)
                 | #:datum-literals (datum-literal-entry ...)
                 | #:literal-sets (literal-set ...)
                 | #:conventions (convention-id ...)
                 | #:local-conventions (convention-rule ...)
                 | #:disable-colon-notation
                    
 attr-arity-decl = attr-name-id
                 | (attr-name-id depth)
                    
stxclass-variant = (pattern syntax-pattern pattern-directive ...)
 
  description-expr : (or/c string? #f)

#:attributes (attr-arity-decl ...)
 
attr-arity-decl = attr-id
                | (attr-id depth)

#:auto-nested-attributes

#:description description-expr
 
  description-expr : (or/c string? #f)

#:opaque

#:commit

#:no-delimit-cut

#:literals (literal-entry ...)

#:datum-literals (datum-literal-entry ...)

#:literal-sets (literal-set ...)

#:conventions (convention-id ...)

#:local-conventions (convention-rule ...)

#:disable-colon-notation
syntax
(define-splicing-syntax-class name-id stxclass-option ...
  stxclass-variant ...+)
(define-splicing-syntax-class (name-id . kw-formals) stxclass-option ...
  stxclass-variant ...+)
syntax
(pattern syntax-pattern pattern-directive ...)
syntax
this-syntax
value
prop:syntax-class
 : (struct-type-property/c (or/c identifier?
                                 (-> any/c identifier?)))

#:declare pvar-id stxclass maybe-role
 
  stxclass = syntax-class-id
           | (syntax-class-id arg ...)
              
maybe-role = 
           | #:role role-expr

#:post action-pattern

#:and action-pattern

#:with syntax-pattern stx-expr

#:attr attr-arity-decl expr

#:fail-when condition-expr message-expr
 
  message-expr : (or/c string? #f)

#:fail-unless condition-expr message-expr
 
  message-expr : (or/c string? #f)

#:when condition-expr

#:do [defn-or-expr ...]

#:undo [defn-or-expr ...]

#:cut
syntax
(attribute attr-id)
syntax
~var
syntax
~and
syntax
~or*
syntax
~or
syntax
~describe
syntax
~commit
syntax
~delimit-cut
syntax
~post
syntax
~optional

id

(~var pvar-id)

(~var pvar-id syntax-class-use maybe-role)
 
syntax-class-use = syntax-class-id
                 | (syntax-class-id arg ...)
                    
      maybe-role = 
                 | #:role role-expr
 
  role-expr : (or/c string? #f)

(~literal literal-id maybe-phase)
 
maybe-phase = 
            | #:phase phase-expr

atomic-datum

(~datum datum)

(H-pattern . S-pattern)

(A-pattern . S-pattern)

(EH-pattern ... . S-pattern)

(H-pattern ...+ . S-pattern)

(~and S/A-pattern ...)

(~or* S-pattern ...)

(~not S-pattern)

#(pattern-part ...)

#s(prefab-struct-key pattern-part ...)

#&S-pattern

(~rest S-pattern)

(~describe maybe-role maybe-opaque expr S-pattern)
 
maybe-opaque = 
             | #:opaque
                
  maybe-role = 
             | #:role role-expr
 
  expr : (or/c string? #f)
  role-expr : (or/c string? #f)

(~commit S-pattern)

(~delimit-cut S-pattern)

(~post S-pattern)

A-pattern

pvar-id:splicing-syntax-class-id

(~var pvar-id splicing-syntax-class-use maybe-role)
 
splicing-syntax-class-use = splicing-syntax-class-id
                          | (splicing-syntax-class-id arg ...)
                             
               maybe-role = 
                          | #:role role-expr
 
  role-expr : (or/c string? #f)

(~seq . L-pattern)

(~and H-pattern ...)

(~or* H-pattern ...)

(~optional H-pattern maybe-optional-option)
 
maybe-optional-option = 
                      | #:defaults ([attr-arity-decl expr] ...)
                         
      attr-arity-decl = attr-id
                      | (attr-id depth)

(~describe expr H-pattern)

(~commit H-pattern)

(~delimit-cut H-pattern)

(~post H-pattern)

(~peek H-pattern)

(~peek-not H-pattern)

S-pattern

(~alt EH-pattern ...)

(~once H-pattern once-option ...)
 
once-option = #:name name-expr
            | #:too-few too-few-message-expr
            | #:too-many too-many-message-expr
 
  name-expr : (or/c string? #f)
  too-few-message-expr : (or/c string? #f)
  too-many-message-expr : (or/c string? #f)

(~optional H-pattern optional-option ...)
 
optional-option = #:name name-expr
                | #:too-many too-many-message-expr
                | #:defaults ([attr-id expr] ...)
 
  name-expr : (or/c string? #f)
  too-many-message-expr : (or/c string? #f)

(~between H-pattern min-number max-number between-option ...)
 
between-option = #:name name-expr
               | #:too-few too-few-message-expr
               | #:too-many too-many-message-expr
 
  name-expr : (or/c string? #f)
  too-few-message-expr : (or/c string? #f)
  too-many-message-expr : (or/c string? #f)

~!

(~bind [attr-arity-decl expr] ...)
 
attr-arity-decl = attr-name-id
                | (attr-name-id depth)

(~fail maybe-fail-condition maybe-message-expr)
 
maybe-fail-condition = 
                     | #:when condition-expr
                     | #:unless condition-expr
                        
  maybe-message-expr = 
                     | message-expr
 
  message-expr : (or/c string? #f)

(~parse S-pattern stx-expr)

(~and A-pattern ...+)

(~do defn-or-expr ...)

(~undo defn-or-expr ...)

(~post A-pattern)
procedure
(pattern-expander proc) -> pattern-expander?
  proc : (-> syntax? syntax?)
value
prop:pattern-expander
 : (struct-type-property/c (-> pattern-expander? (-> syntax? syntax?)))
procedure
(pattern-expander? v) -> boolean?
  v : any/c
procedure
(syntax-local-syntax-parse-pattern-introduce stx) -> syntax?
  stx : syntax?
syntax
(define-syntax-parse-rule (macro-id . pattern) pattern-directive ...
  template)
syntax
(define-syntax-parser macro-id parse-option ... clause ...+)
syntax
(define-simple-macro (macro-id . pattern) pattern-directive ...
  template)
syntax
(define-literal-set id maybe-phase maybe-imports maybe-datum-literals
  (literal ...))
 
             literal = literal-id
                     | (pattern-id literal-id)
                        
         maybe-phase = 
                     | #:for-template
                     | #:for-syntax
                     | #:for-label
                     | #:phase phase-level
                        
maybe-datum-literals = 
                     | #:datum-literals (datum-literal ...)
                        
       maybe-imports = 
                     | #:literal-sets (imported-litset-id ...)
syntax
(literal-set->predicate litset-id)
syntax
(define-conventions name-id convention-rule ...)
 
convention-rule = (name-pattern syntax-class)
                   
   name-pattern = exact-id
                | name-rx
                   
   syntax-class = syntax-class-id
                | (syntax-class-id expr ...)
syntax class
expr
syntax class
identifier
syntax class
boolean
syntax class
char
syntax class
keyword
syntax class
number
syntax class
integer
syntax class
exact-integer
syntax class
exact-nonnegative-integer
syntax class
exact-positive-integer
syntax class
regexp
syntax class
byte-regexp
syntax class
string
syntax class
bytes
syntax class
id
syntax class
nat
syntax class
str
syntax class
character
syntax class
(static predicate description) -> syntax class
  predicate : (-> any/c any/c)
  description : (or/c string? #f)
syntax class
(expr/c  contract-expr            
        [#:arg? arg?              
         #:positive pos-blame     
         #:negative neg-blame     
         #:name expr-name         
         #:macro macro-name       
         #:context context        
         #:phase phase])      -> syntax class
  contract-expr : syntax?
  arg? : any/c = #t
  pos-blame : (or/c syntax? string? module-path-index? 'from-macro 'use-site 'unknown)
            = 'from-macro
  neg-blame : (or/c syntax? string? module-path-index? 'from-macro 'use-site 'unknown)
            = 'use-site
  expr-name : (or/c identifier? string? symbol?) = #f
  macro-name : (or/c identifier? string? symbol?) = #f
  context : (or/c syntax? #f) = determined automatically
  phase : exact-integer? = (syntax-local-phase-level)
syntax
kernel-literals
syntax class
function-header
attribute
name : syntax?
attribute
params : syntax?
splicing syntax class
formal
attribute
name : syntax?
attribute
kw : (or/c syntax? #f)
attribute
default : (or/c syntax? #f)
syntax class
formals
attribute
params : syntax?
splicing syntax class
formals-no-rest
attribute
params : syntax?
procedure
(syntax-parse-state-ref key [default]) -> any/c
  key : any/c
  default : default/c = (lambda () (error ....))
procedure
(syntax-parse-state-set! key value) -> void?
  key : any/c
  value : any/c
procedure
(syntax-parse-state-update!  key           
                             update        
                            [default]) -> void?
  key : any/c
  update : (-> any/c any/c)
  default : default/c = (lambda () (error ....))
procedure
(syntax-parse-state-cons! key value [default]) -> void?
  key : any/c
  value : any/c
  default : default/c = null
procedure
(syntax-parse-track-literals  stx                           
                             [#:introduce? introduce?]) -> syntax?
  stx : syntax?
  introduce? : any/c = #t
syntax
(syntax-class-attributes syntax-class-id)
syntax
(syntax-class-arity syntax-class-id)
syntax
(syntax-class-keywords syntax-class-id)
syntax
(syntax-class-parse syntax-class-id stx-expr arg ...)
 
  stx-expr : syntax?
syntax
(debug-parse stx-expr S-pattern ...+)
 
  stx-expr : syntax?
procedure
(debug-syntax-parse!) -> void?
syntax
(provide-syntax-class/contract
  [syntax-class-id syntax-class-contract] ...)
 
syntax-class-contract = (syntax-class/c (mandatory-arg ...))
                      | (syntax-class/c (mandatory-arg ...)
                                        (optional-arg ...))
                         
                  arg = contract-expr
                      | keyword contract-expr
 
  contract-expr : contract?
syntax
syntax-class/c
syntax
(reify-syntax-class syntax-class-id)
procedure
(reified-syntax-class? x) -> boolean?
  x : any/c
procedure
(reified-splicing-syntax-class? x) -> boolean?
  x : any/c
procedure
(reified-syntax-class-attributes r)
 -> (listof (list/c symbol? exact-nonnegative-integer?))
  r : (or/c reified-syntax-class? reified-splicing-syntax-class?)
procedure
(reified-syntax-class-arity r) -> procedure-arity?
  r : (or/c reified-syntax-class? reified-splicing-syntax-class?)
procedure
(reified-syntax-class-keywords r)
 -> (listof keyword?) (listof keyword?)
  r : (or/c reified-syntax-class? reified-splicing-syntax-class?)
procedure
(reified-syntax-class-curry r                  
                            arg ...            
                            #:<kw> kw-arg ...) 
 -> (or/c reified-syntax-class? reified-splicing-syntax-class?)
  r : (or/c reified-syntax-class? reified-splicing-syntax-class?)
  arg : any/c
  kw-arg : any/c

(~reflect var-id (reified-expr arg-expr ...) maybe-attrs)
 
maybe-attrs = 
            | #:attributes (attr-arity-decl ...)

(~splicing-reflect var-id (reified-expr arg-expr ...) maybe-attrs)
syntax
(define-primitive-splicing-syntax-class (name-id param-id ...)
  #:description description-expr
  #:attributes (attr-arity-decl ...)
  parser-expr)
 
  parser : (-> syntax?
               (->* () ((or/c string? #f) -> any))
               (cons/c exact-positive-integer? list?))
syntax
(define-eh-alternative-set name eh-alternative ...)
 
alternative = (pattern EH-pattern)

(~eh-var name eh-alternative-set-id)
syntax
(define-syntax-class/specialize header syntax-class-use)
 
          header = id
                 | (id . kw-formals)
                    
syntax-class-use = target-stxclass-id
                 | (target-stxclass-id arg ...)
syntax
(template tmpl)
syntax
(template/loc loc-expr tmpl)
syntax
(quasitemplate tmpl)
syntax
(quasitemplate/loc loc-expr tmpl)
syntax
(datum-template tmpl)
syntax
??
syntax
?@
syntax
(define-template-metafunction metafunction-id expr)
(define-template-metafunction (metafunction-id . formals) body ...+)
procedure
(stx-null? v) -> boolean?
  v : any/c
procedure
(stx-pair? v) -> boolean?
  v : any/c
procedure
(stx-list? v) -> boolean?
  v : any/c
procedure
(stx->list stx-list) -> (or/c list? #f)
  stx-list : stx-list?
procedure
(stx-car v) -> any
  v : stx-pair?
procedure
(stx-cdr v) -> any
  v : stx-pair?
procedure
(stx-map proc stxl ...) -> list?
  proc : procedure?
  stxl : stx-list?
procedure
(module-or-top-identifier=? a-id b-id) -> boolean?
  a-id : identifier?
  b-id : identifier?
syntax
(kernel-syntax-case stx-expr trans?-expr clause ...)
syntax
(kernel-syntax-case* stx-expr trans?-expr (extra-id ...) clause ...)
syntax
(kernel-syntax-case/phase stx-expr phase-expr clause ...)
syntax
(kernel-syntax-case*/phase stx-expr phase-expr (extra-id ..)
  clause ...)
procedure
(kernel-form-identifier-list) -> (listof identifier?)
procedure
(make-free-id-table [init-dict           
                     #:phase phase]) -> mutable-free-id-table?
  init-dict : dict? = null
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
procedure
(make-immutable-free-id-table [init-dict       
                               #:phase phase]) 
 -> immutable-free-id-table?
  init-dict : dict? = null
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
procedure
(free-id-table? v) -> boolean?
  v : any/c
procedure
(mutable-free-id-table? v) -> boolean?
  v : any/c
procedure
(immutable-free-id-table? v) -> boolean?
  v : any/c
procedure
(free-id-table-ref table id [failure]) -> any
  table : free-id-table?
  id : identifier?
  failure : any/c = (lambda () (raise (make-exn:fail .....)))
procedure
(free-id-table-ref! table id failure) -> any
  table : mutable-free-id-table?
  id : identifier?
  failure : any/c
procedure
(free-id-table-set! table id v) -> void?
  table : mutable-free-id-table?
  id : identifier?
  v : any/c
procedure
(free-id-table-set table id v) -> immutable-free-id-table?
  table : immutable-free-id-table?
  id : identifier?
  v : any/c
procedure
(free-id-table-set*! table id v ... ...) -> void?
  table : mutable-free-id-table?
  id : identifier?
  v : any/c
procedure
(free-id-table-set* table id v ... ...) -> immutable-free-id-table?
  table : immutable-free-id-table?
  id : identifier?
  v : any/c
procedure
(free-id-table-remove! table id) -> void?
  table : mutable-free-id-table?
  id : identifier?
procedure
(free-id-table-remove table id) -> immutable-free-id-table?
  table : immutable-free-id-table?
  id : identifier?
procedure
(free-id-table-update!  table         
                        id            
                        updater       
                       [failure]) -> void?
  table : mutable-free-id-table?
  id : identifier?
  updater : (any/c . -> . any/c)
  failure : any/c = (lambda () (raise (make-exn:fail .....)))
procedure
(free-id-table-update  table         
                       id            
                       updater       
                      [failure]) -> immutable-free-id-table?
  table : immutable-free-id-table?
  id : identifier?
  updater : (any/c . -> . any/c)
  failure : any/c = (lambda () (raise (make-exn:fail .....)))
procedure
(free-id-table-map table proc) -> list?
  table : free-id-table?
  proc : (-> identifier? any/c any)
procedure
(free-id-table-keys table) -> (listof identifier?)
  table : free-id-table?
procedure
(free-id-table-values table) -> (listof any/c)
  table : free-id-table?
procedure
(in-free-id-table table) -> sequence?
  table : free-id-table?
procedure
(free-id-table-for-each table proc) -> void?
  table : free-id-table?
  proc : (-> identifier? any/c any)
procedure
(free-id-table-count table) -> exact-nonnegative-integer?
  table : free-id-table?
procedure
(free-id-table-iterate-first table) -> id-table-iter?
  table : free-id-table?
procedure
(free-id-table-iterate-next table position) -> id-table-iter?
  table : free-id-table?
  position : id-table-iter?
procedure
(free-id-table-iterate-key table position) -> identifier?
  table : free-id-table?
  position : id-table-iter?
procedure
(free-id-table-iterate-value table         
                             position) -> identifier?
  table : bound-it-table?
  position : id-table-iter?
procedure
(id-table-iter? v) -> boolean?
  v : any/c
procedure
(free-id-table/c  key-ctc                      
                  val-ctc                      
                 [#:immutable immutable?]) -> contract?
  key-ctc : flat-contract?
  val-ctc : chaperone-contract?
  immutable? : (or/c #t #f 'dont-care) = 'dont-care
procedure
(make-bound-id-table [init-dict           
                      #:phase phase]) -> mutable-bound-id-table?
  init-dict : dict? = null
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
procedure
(make-immutable-bound-id-table [init-dict       
                                #:phase phase]) 
 -> immutable-bound-id-table?
  init-dict : dict? = null
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
procedure
(bound-id-table? v) -> boolean?
  v : any/c
procedure
(mutable-bound-id-table? v) -> boolean?
  v : any/c
procedure
(immutable-bound-id-table? v) -> boolean?
  v : any/c
procedure
(bound-id-table-ref table id [failure]) -> any
  table : bound-id-table?
  id : identifier?
  failure : any/c = (lambda () (raise (make-exn:fail .....)))
procedure
(bound-id-table-ref! table id failure) -> any
  table : mutable-bound-id-table?
  id : identifier?
  failure : any/c
procedure
(bound-id-table-set! table id v) -> void?
  table : mutable-bound-id-table?
  id : identifier?
  v : any/c
procedure
(bound-id-table-set table id v) -> immutable-bound-id-table?
  table : immutable-bound-id-table?
  id : identifier?
  v : any/c
procedure
(bound-id-table-set*! table id v ... ...) -> void?
  table : mutable-bound-id-table?
  id : identifier?
  v : any/c
procedure
(bound-id-table-set* table id v ... ...)
 -> immutable-bound-id-table?
  table : immutable-bound-id-table?
  id : identifier?
  v : any/c
procedure
(bound-id-table-remove! table id) -> void?
  table : mutable-bound-id-table?
  id : identifier?
procedure
(bound-id-table-remove table id) -> immutable-bound-id-table?
  table : immutable-bound-id-table?
  id : identifier?
procedure
(bound-id-table-update!  table         
                         id            
                         updater       
                        [failure]) -> void?
  table : mutable-bound-id-table?
  id : identifier?
  updater : (any/c . -> . any/c)
  failure : any/c = (lambda () (raise (make-exn:fail .....)))
procedure
(bound-id-table-update  table         
                        id            
                        updater       
                       [failure]) -> immutable-bound-id-table?
  table : immutable-bound-id-table?
  id : identifier?
  updater : (any/c . -> . any/c)
  failure : any/c = (lambda () (raise (make-exn:fail .....)))
procedure
(bound-id-table-map table proc) -> list?
  table : bound-id-table?
  proc : (-> identifier? any/c any)
procedure
(bound-id-table-keys table) -> (listof identifier?)
  table : bound-id-table?
procedure
(bound-id-table-values table) -> (listof any/c)
  table : bound-id-table?
procedure
(in-bound-id-table table) -> sequence?
  table : bound-id-table?
procedure
(bound-id-table-for-each table proc) -> void?
  table : bound-id-table?
  proc : (-> identifier? any/c any)
procedure
(bound-id-table-count table) -> exact-nonnegative-integer?
  table : bound-id-table?
procedure
(bound-id-table-iterate-first table) -> id-table-position?
  table : bound-id-table?
procedure
(bound-id-table-iterate-next table         
                             position) -> id-table-position?
  table : bound-id-table?
  position : id-table-position?
procedure
(bound-id-table-iterate-key table position) -> identifier?
  table : bound-id-table?
  position : id-table-position?
procedure
(bound-id-table-iterate-value table         
                              position) -> identifier?
  table : bound-id-table?
  position : id-table-position?
procedure
(bound-id-table/c  key-ctc                     
                   val-ctc                     
                  [#:immutable immutable]) -> contract?
  key-ctc : flat-contract?
  val-ctc : chaperone-contract?
  immutable : (or/c #t #f 'dont-care) = 'dont-care
procedure
(mutable-free-id-set [init-set            
                      #:phase phase]) -> mutable-free-id-set?
  init-set : generic-set? = null
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
procedure
(immutable-free-id-set [init-set            
                        #:phase phase]) -> immutable-free-id-set?
  init-set : generic-set? = null
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
procedure
(free-id-set? v) -> boolean?
  v : any/c
procedure
(mutable-free-id-set? v) -> boolean?
  v : any/c
procedure
(immutable-free-id-set? v) -> boolean?
  v : any/c
procedure
(free-id-set-empty? s) -> boolean?
  s : free-id-set?
procedure
(free-id-set-count s) -> exact-nonnegative-integer?
  s : free-id-set?
procedure
(free-id-set-member? s v) -> boolean?
  s : free-id-set?
  v : identifier?
procedure
(free-id-set=? s1 s2) -> boolean?
  s1 : free-id-set?
  s2 : free-id-set?
procedure
(free-id-set-add s v) -> immutable-free-id-set?
  s : immutable-free-id-set?
  v : identifier?
procedure
(free-id-set-add! s v) -> void?
  s : mutable-free-id-set?
  v : identifier?
procedure
(free-id-set-remove s v) -> immutable-free-id-set?
  s : immutable-free-id-set?
  v : identifier?
procedure
(free-id-set-remove! s v) -> void?
  s : mutable-free-id-set?
  v : identifier?
procedure
(free-id-set-first s) -> identifier?
  s : free-id-set?
procedure
(free-id-set-rest s) -> immutable-free-id-set?
  s : immutable-free-id-set?
procedure
(in-free-id-set s) -> sequence?
  s : free-id-set?
procedure
(free-id-set->stream s) -> stream?
  s : free-id-set?
procedure
(free-id-set->list s) -> list?
  s : free-id-set?
procedure
(free-id-set-copy s) -> free-id-set?
  s : free-id-set?
procedure
(free-id-set-copy-clear s) -> free-id-set?
  s : free-id-set?
procedure
(free-id-set-clear s) -> immutable-free-id-set?
  s : immutable-free-id-set?
procedure
(free-id-set-clear! s) -> void?
  s : mutable-free-id-set?
procedure
(free-id-set-union s0 s ...) -> immutable-free-id-set?
  s0 : immutable-free-id-set?
  s : free-id-set?
procedure
(free-id-set-union! s0 s ...) -> void?
  s0 : mutable-free-id-set?
  s : free-id-set?
procedure
(free-id-set-intersect s0 s ...) -> immutable-free-id-set?
  s0 : immutable-free-id-set?
  s : free-id-set?
procedure
(free-id-set-intersect! s0 s ...) -> void?
  s0 : mutable-free-id-set?
  s : free-id-set?
procedure
(free-id-set-subtract s0 s ...) -> immutable-free-id-set?
  s0 : immutable-free-id-set?
  s : free-id-set?
procedure
(free-id-set-subtract! s0 s ...) -> void?
  s0 : mutable-free-id-set?
  s : free-id-set?
procedure
(free-id-set-symmetric-difference s0 s ...)
 -> immutable-free-id-set?
  s0 : immutable-free-id-set?
  s : free-id-set?
procedure
(free-id-set-symmetric-difference! s0 s ...) -> void?
  s0 : mutable-free-id-set?
  s : free-id-set?
procedure
(free-id-subset? s1 s2) -> boolean?
  s1 : free-id-set?
  s2 : free-id-set?
procedure
(free-id-proper-subset? s1 s2) -> boolean?
  s1 : free-id-set?
  s2 : free-id-set?
procedure
(free-id-set-map s f) -> list?
  s : free-id-set?
  f : (-> identifier? any/c)
procedure
(free-id-set-for-each s f) -> void?
  s : free-id-set?
  f : (-> identifier? any/c)
procedure
(id-set/c  elem-ctc                      
          [#:setidtype idsettype         
           #:mutability mutability]) -> contract?
  elem-ctc : flat-contract?
  idsettype : (or/c 'dont-care 'free 'bound) = 'dont-care
  mutability : (or/c 'dont-care 'mutable 'immutable)
             = 'immutable
procedure
(free-id-set/c  elem-ctc                      
               [#:mutability mutability]) -> contract?
  elem-ctc : flat-contract?
  mutability : (or/c 'dont-care 'mutable 'immutable)
             = 'immutable
procedure
(mutable-bound-id-set [init-set            
                       #:phase phase]) -> mutable-bound-id-set?
  init-set : set? = null
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
procedure
(immutable-bound-id-set [init-set        
                         #:phase phase]) 
 -> immutable-bound-id-set?
  init-set : set? = null
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
procedure
(bound-id-set? v) -> boolean?
  v : any/c
procedure
(mutable-bound-id-set? v) -> boolean?
  v : any/c
procedure
(immutable-bound-id-set? v) -> boolean?
  v : any/c
procedure
(bound-id-set-empty? s) -> boolean?
  s : bound-id-set?
procedure
(bound-id-set-count s) -> exact-nonnegative-integer?
  s : bound-id-set?
procedure
(bound-id-set-member? s v) -> boolean?
  s : bound-id-set?
  v : identifier?
procedure
(bound-id-set=? s1 s2) -> boolean?
  s1 : bound-id-set?
  s2 : bound-id-set?
procedure
(bound-id-set-add s v) -> immutable-bound-id-set?
  s : immutable-bound-id-set?
  v : identifier?
procedure
(bound-id-set-add! s v) -> void?
  s : mutable-bound-id-set?
  v : identifier?
procedure
(bound-id-set-remove s v) -> immutable-bound-id-set?
  s : immutable-bound-id-set?
  v : identifier?
procedure
(bound-id-set-remove! s v) -> void?
  s : mutable-bound-id-set?
  v : identifier?
procedure
(bound-id-set-first s) -> identifier?
  s : bound-id-set?
procedure
(bound-id-set-rest s) -> immutable-bound-id-set?
  s : immutable-bound-id-set?
procedure
(in-bound-id-set s) -> sequence?
  s : bound-id-set?
procedure
(bound-id-set->stream s) -> stream?
  s : bound-id-set?
procedure
(bound-id-set->list s) -> list?
  s : bound-id-set?
procedure
(bound-id-set-copy s) -> bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-copy-clear s) -> bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-clear s) -> immutable-bound-id-set?
  s : immutable-bound-id-set?
procedure
(bound-id-set-clear! s) -> void?
  s : mutable-bound-id-set?
procedure
(bound-id-set-union s0 s ...) -> immutable-bound-id-set?
  s0 : immutable-bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-union! s0 s ...) -> void?
  s0 : mutable-bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-intersect s0 s ...) -> immutable-bound-id-set?
  s0 : immutable-bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-intersect! s0 s ...) -> void?
  s0 : mutable-bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-subtract s0 s ...) -> immutable-bound-id-set?
  s0 : immutable-bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-subtract! s0 s ...) -> void?
  s0 : mutable-bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-symmetric-difference s0 s ...)
 -> immutable-bound-id-set?
  s0 : immutable-bound-id-set?
  s : bound-id-set?
procedure
(bound-id-set-symmetric-difference! s0         
                                    s ...) -> void?
  s0 : mutable-bound-id-set?
  s : bound-id-set?
procedure
(bound-id-subset? s1 s2) -> boolean?
  s1 : bound-id-set?
  s2 : bound-id-set?
procedure
(bound-id-proper-subset? s1 s2) -> boolean?
  s1 : bound-id-set?
  s2 : bound-id-set?
procedure
(bound-id-set-map s f) -> list?
  s : bound-id-set?
  f : (-> identifier? any/c)
procedure
(bound-id-set-for-each s f) -> void?
  s : bound-id-set?
  f : (-> identifier? any/c)
procedure
(bound-id-set/c  elem-ctc                      
                [#:mutability mutability]) -> contract?
  elem-ctc : flat-contract?
  mutability : (or/c 'dont-care 'mutable 'immutable)
             = 'immutable
procedure
(make-bound-identifier-mapping) -> bound-identifier-mapping?
procedure
(bound-identifier-mapping? v) -> boolean?
  v : any/c
procedure
(bound-identifier-mapping-get  bound-map           
                               id                  
                              [failure-thunk]) -> any
  bound-map : bound-identifier-mapping?
  id : identifier?
  failure-thunk : (-> any)
                = (lambda () (raise (make-exn:fail ....)))
procedure
(bound-identifier-mapping-put! bound-map     
                               id            
                               v)        -> void?
  bound-map : bound-identifier-mapping?
  id : identifier?
  v : any/c
procedure
(bound-identifier-mapping-for-each bound-map     
                                   proc)     -> void?
  bound-map : boud-identifier-mapping?
  proc : (identifier? any/c . -> . any)
procedure
(bound-identifier-mapping-map bound-map     
                              proc)     -> (listof any?)
  bound-map : bound-identifier-mapping?
  proc : (identifier? any/c . -> . any)
procedure
(make-free-identifier-mapping) -> free-identifier-mapping?
procedure
(free-identifier-mapping? v) -> boolean?
  v : any/c
procedure
(free-identifier-mapping-get  free-map            
                              id                  
                             [failure-thunk]) -> any
  free-map : free-identifier-mapping?
  id : identifier?
  failure-thunk : (-> any)
                = (lambda () (raise (make-exn:fail ....)))
procedure
(free-identifier-mapping-put! free-map id v) -> void?
  free-map : free-identifier-mapping?
  id : identifier?
  v : any/c
procedure
(free-identifier-mapping-for-each free-map     
                                  proc)    -> void?
  free-map : free-identifier-mapping?
  proc : (identifier? any/c . -> . any)
procedure
(free-identifier-mapping-map free-map proc) -> (listof any?)
  free-map : free-identifier-mapping?
  proc : (identifier? any/c . -> . any)
procedure
(make-module-identifier-mapping) -> module-identifier-mapping?
procedure
(module-identifier-mapping? v) -> boolean?
  v : any/c
procedure
(module-identifier-mapping-get  module-map          
                                id                  
                               [failure-thunk]) -> any
  module-map : module-identifier-mapping?
  id : identifier?
  failure-thunk : (-> any)
                = (lambda () (raise (make-exn:fail ....)))
procedure
(module-identifier-mapping-put! module-map     
                                id             
                                v)         -> void?
  module-map : module-identifier-mapping?
  id : identifier?
  v : any/c
procedure
(module-identifier-mapping-for-each module-map     
                                    proc)      -> void?
  module-map : module-identifier-mapping?
  proc : (identifier? any/c . -> . any)
procedure
(module-identifier-mapping-map module-map     
                               proc)      -> (listof any?)
  module-map : module-identifier-mapping?
  proc : (identifier? any/c . -> . any)
procedure
(syntax->string stx-list) -> string?
  stx-list : (and/c syntax? stx-list?)
procedure
(free-vars  expr-stx                        
           [insp                            
            #:module-bound? module-bound?]) 
 -> (listof identifier?)
  expr-stx : syntax?
  insp : inspector? = mod-decl-insp
  module-bound? : any/c = #f
procedure
(strip-context form) -> any/c
  form : any/c
procedure
(replace-context ctx-stx form) -> any/c
  ctx-stx : (or/c syntax? #f)
  form : any/c
procedure
(parse-keyword-options  stx                                      
                        table                                    
                       [#:context ctx                            
                        #:no-duplicates? no-duplicates?          
                        #:incompatible incompatible              
                        #:on-incompatible incompatible-handler   
                        #:on-too-short too-short-handler         
                        #:on-not-in-table not-in-table-handler]) 
 -> options any/c
  stx : syntax?
  table : keyword-table
  ctx : (or/c false/c syntax?) = #f
  no-duplicates? : boolean? = #f
  incompatible : (listof (listof keyword?)) = '()
  incompatible-handler : (-> keyword? keyword?
                             options syntax? syntax?
                             (values options syntax?))
                       = (lambda (....) (error ....))
  too-short-handler : (-> keyword? options syntax? syntax?
                          (values options syntax?))
                    = (lambda (....) (error ....))
  not-in-table-handler : (-> keyword? options syntax? syntax?
                             (values options syntax?))
                       = (lambda (....) (error ....))
procedure
(parse-keyword-options/eol                                         
                            stx                                    
                            table                                  
                           [#:context ctx                          
                            #:no-duplicates? no-duplicates?        
                            #:incompatible incompatible            
                            #:on-incompatible incompatible-handler 
                            #:on-too-short too-short-handler       
                            #:on-not-in-table not-in-table-handler 
                            #:on-not-eol not-eol-handler])         
 -> options
  stx : syntax?
  table : keyword-table
  ctx : (or/c false/c syntax?) = #f
  no-duplicates? : boolean? = #f
  incompatible : (listof (list keyword? keyword?)) = '()
  incompatible-handler : (-> keyword? keyword?
                             options syntax? syntax?
                             (values options syntax?))
                       = (lambda (....) (error ....))
  too-short-handler : (-> keyword? options syntax? syntax?
                          (values options syntax?))
                    = (lambda (....) (error ....))
  not-in-table-handler : (-> keyword? options syntax? syntax?
                             (values options syntax?))
                       = (lambda (....) (error ....))
  not-eol-handler : (-> options syntax? syntax?
                        options)
                  = (lambda (....) (error ....))
procedure
(options-select options keyword) -> (listof list?)
  options : options
  keyword : keyword?
procedure
(options-select-row options                
                    keyword                
                    #:default default) -> any
  options : options
  keyword : keyword?
  default : any/c
procedure
(options-select-value options                
                      keyword                
                      #:default default) -> any
  options : options
  keyword : keyword?
  default : any/c
procedure
(check-identifier stx ctx) -> identifier?
  stx : syntax?
  ctx : (or/c false/c syntax?)
procedure
(check-expression stx ctx) -> syntax?
  stx : syntax?
  ctx : (or/c false/c syntax?)
procedure
((check-stx-listof check) stx ctx) -> (listof any/c)
  check : check-procedure
  stx : syntax?
  ctx : (or/c false/c syntax?)
procedure
(check-stx-string stx ctx) -> syntax?
  stx : syntax?
  ctx : (or/c false/c syntax?)
procedure
(check-stx-boolean stx ctx) -> syntax?
  stx : syntax?
  ctx : (or/c false/c syntax?)
syntax
(datum-case datum-expr (literal-id ...)
  clause ...)
syntax
(datum template)
syntax
(with-datum ([pattern datum-expr] ...)
  body ...+)
syntax
(define/with-datum pattern datum-expr)
syntax
(quasidatum template)
syntax
(undatum expr)
syntax
(undatum-splicing expr)
procedure
(with-module-reading-parameterization thunk) -> any
  thunk : (-> any)
procedure
(check-module-form stx                 
                   expected-module-sym 
                   source-v)           
 -> (or/c syntax? false/c)
  stx : (or/c syntax? eof-object?)
  expected-module-sym : symbol?
  source-v : (or/c string? false/c)
procedure
(get-module-code  path                                 
                 [#:submodule-path submodule-path      
                  #:sub-path compiled-subdir0          
                  compiled-subdir                      
                  #:roots roots                        
                  #:compile compile-proc0              
                  compile-proc                         
                  #:extension-handler ext-proc0        
                  ext-proc                             
                  #:notify notify-proc                 
                  #:source-reader read-syntax-proc     
                  #:rkt-try-ss? rkt-try-ss?            
                  #:choose choose-proc])           -> any
  path : path-string?
  submodule-path : (listof symbol?) = '()
  compiled-subdir0 : (or/c (and/c path-string? relative-path?)
                           (listof (and/c path-string? relative-path?)))
                   = (use-compiled-file-paths)
  compiled-subdir : (or/c (and/c path-string? relative-path?)
                          (listof (and/c path-string? relative-path?)))
                  = compiled-subdir0
  roots : (listof (or/c path-string? 'same))
        = (current-compiled-file-roots)
  compile-proc0 : (any/c . -> . any) = compile
  compile-proc : (any/c . -> . any) = compile-proc0
  ext-proc0 : (or/c false/c (path? boolean? . -> . any)) = #f
  ext-proc : (or/c false/c (path? boolean? . -> . any))
           = ext-proc0
  notify-proc : (any/c . -> . any) = void
  read-syntax-proc : (any/c input-port? . -> . (or/c syntax? eof-object?))
                   = read-syntax
  rkt-try-ss? : boolean? = #t
  choose-proc : (or/c (-> path? path? path?       = #f
                          (or/c 'src 'zo 'so #f))
                      #f)
procedure
(get-module-path  path                        
                  #:submodule? submodule?     
                 [#:sub-path compiled-subdir0 
                  compiled-subdir             
                  #:roots roots               
                  #:rkt-try-ss? rkt-try-ss?   
                  #:choose choose-proc])      
 -> path? (or/c 'src 'zo 'so)
  path : path-string?
  submodule? : boolean?
  compiled-subdir0 : (or/c (and/c path-string? relative-path?)
                           (listof (and/c path-string? relative-path?)))
                   = (use-compiled-file-paths)
  compiled-subdir : (or/c (and/c path-string? relative-path?)
                          (listof (and/c path-string? relative-path?)))
                  = compiled-subdir0
  roots : (listof (or/c path-string? 'same))
        = (current-compiled-file-roots)
  rkt-try-ss? : boolean? = #t
  choose-proc : any/c = #f
procedure
(default-compiled-sub-path) -> path-string?
procedure
(get-metadata-path  path               
                   [#:roots roots]     
                    sub-path ...+) -> path?
  path : path-string?
  roots : (listof (or/c path-string? 'same))
        = (current-compiled-file-roots)
  sub-path : (or/c path-string? 'same)
parameter
(moddep-current-open-input-file)
 -> (path-string? . -> . input-port?)
(moddep-current-open-input-file proc) -> void?
  proc : (path-string? . -> . input-port?)
struct
(struct exn:get-module-code exn:fail (path)
    #:extra-constructor-name make-exn:get-module-code)
  path : path?
procedure
(resolve-module-path  module-path-v   
                     [rel-to-path-v]) 
 -> (or/c path? symbol?
          (cons/c 'submod (cons/c (or/c path? symbol?) (listof symbol?))))
  module-path-v : module-path?
  rel-to-path-v : (or/c #f path-string? (-> any)) = #f
procedure
(resolve-module-path-index  module-path-index 
                           [rel-to-path-v])   
 -> (or/c path? symbol?
          (cons/c 'submod (cons/c (or/c path? symbol?) (listof symbol?))))
  module-path-index : module-path-index?
  rel-to-path-v : (or/c #f path-string? (-> any)) = #f
procedure
(collapse-module-path module-path-v             
                      rel-to-module-path-v) -> module-path?
  module-path-v : module-path?
  rel-to-module-path-v : (or/c module-path?
                               (-> module-path?))
procedure
(collapse-module-path-index module-path-index     
                            rel-to-module-path-v) 
 -> module-path?
  module-path-index : module-path-index?
  rel-to-module-path-v : (or/c module-path?
                               (-> module-path?))
(collapse-module-path-index module-path-index)
 -> (or/c module-path? #f)
  module-path-index : module-path-index?
procedure
(show-import-tree  module-path-v                       
                  [#:dag? dag?                         
                   #:path-to path-to-module-path-v     
                   #:show show])                   -> void?
  module-path-v : module-path?
  dag? : any/c = #f
  path-to-module-path-v : (or/c #f module-path?) = #f
  show : (string? any/c string? (or/c #f exact-integer?) . -> . any)
       = (lambda (indent path require-mode phase)
           (printf "~a~a~a ~a\n" indent path require-mode phase))
procedure
(make-wrapping-module-begin  wrap-form           
                            [module-begin-form]) 
 -> (syntax? . -> . syntax?)
  wrap-form : syntax?
  module-begin-form : syntax? = #'#%plain-module-begin
procedure
(syntax-local-infer-name stx [use-local?]) -> any/c
  stx : syntax?
  use-local? : any/c = #t
procedure
(build-expand-context v) -> list?
  v : (or/c symbol? list?)
procedure
(generate-expand-context [liberal-definitions?]) -> list?
  liberal-definitions? : boolean? = #f
procedure
(normalize-definition  defn-stx           
                       lambda-id-stx      
                      [check-context?     
                       opt+kws?])     -> identifier? syntax?
  defn-stx : syntax?
  lambda-id-stx : identifier?
  check-context? : boolean? = #t
  opt+kws? : boolean? = #f
procedure
(normalize-definition/mk-rhs defn-stx       
                             lambda-id-stx  
                             check-context? 
                             opt+kws?       
                             err-no-body?)  
 -> identifier? (-> syntax? syntax?) syntax?
  defn-stx : syntax?
  lambda-id-stx : identifier?
  check-context? : boolean?
  opt+kws? : boolean?
  err-no-body? : boolean?
procedure
(flatten-begin stx) -> (listof syntax?)
  stx : syntax?
procedure
(flatten-all-begins stx) -> (listof syntax?)
  stx : syntax?
procedure
(parse-define-struct stx orig-stx) -> identifier?
                                      (or/c identifier? false/c)
                                      (listof identifier?)
                                      syntax?
  stx : syntax?
  orig-stx : syntax?
procedure
(build-struct-names  name-id                      
                     field-ids                    
                    [#:constructor-name ctr-name] 
                     omit-sel?                    
                     omit-set?                    
                    [src-stx])                    
 -> (listof identifier?)
  name-id : identifier?
  field-ids : (listof identifier?)
  ctr-name : (or/c identifier? #f) = #f
  omit-sel? : boolean?
  omit-set? : boolean?
  src-stx : (or/c syntax? false/c) = #f
procedure
(build-struct-generation  name-id                      
                          field-ids                    
                         [#:constructor-name ctr-name] 
                          omit-sel?                    
                          omit-set?                    
                         [super-type                   
                          prop-value-list              
                          immutable-k-list])           
 -> (listof identifier?)
  name-id : identifier?
  field-ids : (listof identifier?)
  ctr-name : (or/c identifier? #f) = #f
  omit-sel? : boolean?
  omit-set? : boolean?
  super-type : any/c = #f
  prop-value-list : list? = '(list)
  immutable-k-list : list? = '(list)
procedure
(build-struct-generation*  all-name-ids                 
                           name-id                      
                           field-ids                    
                          [#:constructor-name ctr-name] 
                           omit-sel?                    
                           omit-set?                    
                          [super-type                   
                           prop-value-list              
                           immutable-k-list])           
 -> (listof identifier?)
  all-name-ids : (listof identifier?)
  name-id : identifier?
  field-ids : (listof identifier?)
  ctr-name : (or/c identifier? #f) = #f
  omit-sel? : boolean?
  omit-set? : boolean?
  super-type : any/c = #f
  prop-value-list : list? = '(list)
  immutable-k-list : list? = '(list)
procedure
(build-struct-expand-info  name-id                           
                           field-ids                         
                          [#:omit-constructor? no-ctr?       
                           #:constructor-name ctr-name       
                           #:omit-struct-type? no-type?]     
                           omit-sel?                         
                           omit-set?                         
                           base-name                         
                           base-getters                      
                           base-setters)                 -> any
  name-id : identifier?
  field-ids : (listof identifier?)
  no-ctr? : any/c = #f
  ctr-name : (or/c identifier? #f) = #f
  no-type? : any/c = #f
  omit-sel? : boolean?
  omit-set? : boolean?
  base-name : (or/c identifier? boolean?)
  base-getters : (listof (or/c identifier? false/c))
  base-setters : (listof (or/c identifier? false/c))
procedure
(struct-declaration-info? v) -> boolean?
  v : any/c
procedure
(generate-struct-declaration  orig-stx                  
                              name-id                   
                              super-id-or-false         
                              field-id-list             
                              current-context           
                              make-make-struct-type     
                             [omit-sel?                 
                              omit-set?])           -> syntax?
  orig-stx : syntax?
  name-id : identifier?
  super-id-or-false : (or/c identifier? false/c)
  field-id-list : (listof identifier?)
  current-context : any/c
  make-make-struct-type : procedure?
  omit-sel? : boolean? = #f
  omit-set? : boolean? = #f
procedure
(resolve-path-spec path-spec-stx       
                   source-stx          
                   expr-stx            
                   build-path-stx) -> complete-path?
  path-spec-stx : syntax?
  source-stx : syntax?
  expr-stx : syntax?
  build-path-stx : syntax?
procedure
(transform-template  template-stx                             
                     #:save save-proc                         
                     #:restore-stx restore-proc-stx           
                    [#:leaf-save leaf-save-proc               
                     #:leaf-restore-stx leaf-restore-proc-stx 
                     #:leaf-datum-stx leaf-datum-proc-stx     
                     #:pvar-save pvar-save-proc               
                     #:pvar-restore-stx pvar-restore-stx      
                     #:cons-stx cons-proc-stx                 
                     #:ellipses-end-stx ellipses-end-stx      
                     #:constant-as-leaf? constant-as-leaf?])  
 -> syntax?
  template-stx : syntax?
  save-proc : (syntax? . -> . any/c)
  restore-proc-stx : syntax?
  leaf-save-proc : (syntax? . -> . any/c) = save-proc
  leaf-restore-proc-stx : syntax? = #'(lambda (data stx) stx)
  leaf-datum-proc-stx : syntax? = #'(lambda (v) v)
  pvar-save-proc : (identifier? . -> . any/c) = (lambda (x) #f)
  pvar-restore-stx : syntax? = #'(lambda (d stx) stx)
  cons-proc-stx : syntax? = #'cons
  ellipses-end-stx : syntax? = #'values
  constant-as-leaf? : boolean? = #f
procedure
(make-variable-like-transformer  reference-stx 
                                [setter-stx])  
 -> (and/c set!-transformer? (-> syntax? syntax?))
  reference-stx : (or/c syntax? (-> identifier? syntax?))
  setter-stx : (or/c syntax? (-> syntax? syntax?) #f) = #f
procedure
(make-expression-transformer transformer)
 -> (-> syntax? syntax?)
  transformer : (-> syntax? syntax?)
procedure
(local-apply-transformer transformer     
                         stx             
                         context         
                         intdef-ctx) -> syntax?
  transformer : (or/c (-> syntax? syntax?) set!-transformer?)
  stx : syntax?
  context : (or/c 'expression 'top-level 'module 'module-begin list?)
  intdef-ctx : (or/c internal-definition-context?
                      #f
                      (listof internal-definition-context?))
procedure
(raise-read-error  msg-string                          
                   source                              
                   line                                
                   col                                 
                   pos                                 
                   span                                
                  [#:extra-srclocs extra-srclocs]) -> any
  msg-string : string?
  source : any/c
  line : (or/c exact-positive-integer? false/c)
  col : (or/c exact-nonnegative-integer? false/c)
  pos : (or/c exact-positive-integer? false/c)
  span : (or/c exact-nonnegative-integer? false/c)
  extra-srclocs : (listof srcloc?) = '()
procedure
(raise-read-eof-error msg-string     
                      source         
                      line           
                      col            
                      pos            
                      span)      -> any
  msg-string : string?
  source : any/c
  line : (or/c exact-positive-integer? false/c)
  col : (or/c exact-nonnegative-integer? false/c)
  pos : (or/c exact-positive-integer? false/c)
  span : (or/c exact-nonnegative-integer? false/c)
syntax
(#%module-begin module-path)
(#%module-begin module-path reader-option ... form ....)
(#%module-begin             reader-option ... form ....)
 
reader-option = #:read        read-expr
              | #:read-syntax read-syntax-expr
              | #:whole-body-readers? whole?-expr
              | #:wrapper1    wrapper1-expr
              | #:wrapper2    wrapper2-expr
              | #:module-wrapper module-wrapper-expr
              | #:language    lang-expr
              | #:info        info-expr
              | #:interaction-info interaction-info-expr
              | #:language-info language-info-expr
 
  read-expr : (input-port? . -> . any/c)
  read-syntax-expr : (any/c input-port? . -> . any/c)
  whole?-expr : any/c
  wrapper1-expr : (or/c ((-> any/c) . -> . any/c)
                        ((-> any/c) boolean? . -> . any/c))
  wrapper2-expr : (or/c (input-port? (input-port? . -> . any/c)
                         . -> . any/c)
                        (input-port? (input-port? . -> . any/c)
                         boolean? . -> . any/c))
  module-wrapper-expr : (or/c ((-> any/c) . -> . any/c)
                         ((-> any/c) boolean? . -> . any/c))
  info-expr : (symbol? any/c (symbol? any/c . -> . any/c) . -> . any/c)
  interaction-info-expr : (or/c (symbol? any/c . -> . any/c) #f)
  language-info-expr : (or/c (vector/c module-path? symbol? any/c) #f)
  lang-expr : (or/c module-path?
                    (and/c syntax? (compose module-path? syntax->datum))
                    procedure?)
procedure
(make-meta-reader  self-sym               
                   path-desc-str          
                  [#:read-spec read-spec] 
                   module-path-parser     
                   convert-read           
                   convert-read-syntax    
                   convert-get-info)      
 -> procedure? procedure? procedure?
  self-sym : symbol?
  path-desc-str : string?
  read-spec : (input-port? . -> . any/c) = (lambda (in) ....)
  module-path-parser : (any/c . -> . (or/c module-path? #f
                                           (vectorof module-path?)))
  convert-read : (procedure? . -> . procedure?)
  convert-read-syntax : (procedure? . -> . procedure?)
  convert-get-info : (procedure? . -> . procedure?)
procedure
(lang-reader-module-paths bstr)
 -> (or/c #f (vectorof module-path?))
  bstr : bytes?
procedure
(wrap-read-all mod-path         
               in               
               read             
               mod-path-stx     
               src              
               line             
               col              
               pos)         -> any/c
  mod-path : module-path?
  in : input-port?
  read : (input-port . -> . any/c)
  mod-path-stx : syntax?
  src : (or/c syntax? #f)
  line : number?
  col : number?
  pos : number?
procedure
(split-for-body stx body-stxes) -> syntax?
  stx : syntax?
  body-stxes : syntax?
procedure
(expand-for-clause orig-stx clause) -> syntax?
  orig-stx : syntax?
  clause : syntax?
procedure
(source-location? x) -> boolean?
  x : any/c
procedure
(source-location-list? x) -> boolean?
  x : any/c
procedure
(source-location-vector? x) -> boolean?
  x : any/c
procedure
(check-source-location! name x) -> void?
  name : symbol?
  x : any/c
procedure
(build-source-location loc ...) -> srcloc?
  loc : source-location?
procedure
(build-source-location-list loc ...) -> source-location-list?
  loc : source-location?
procedure
(build-source-location-vector loc ...) -> source-location-vector?
  loc : source-location?
procedure
(build-source-location-syntax loc ...) -> syntax?
  loc : source-location?
procedure
(source-location-known? loc) -> boolean?
  loc : source-location?
procedure
(source-location-source loc) -> any/c
  loc : source-location?
procedure
(source-location-line loc) -> (or/c exact-positive-integer? #f)
  loc : source-location?
procedure
(source-location-column loc)
 -> (or/c exact-nonnegative-integer? #f)
  loc : source-location?
procedure
(source-location-position loc)
 -> (or/c exact-positive-integer? #f)
  loc : source-location?
procedure
(source-location-span loc)
 -> (or/c exact-nonnegative-integer? #f)
  loc : source-location?
procedure
(source-location-end loc)
 -> (or/c exact-nonnegative-integer? #f)
  loc : source-location?
procedure
(update-source-location loc                     
                        #:source source         
                        #:line line             
                        #:column column         
                        #:position position     
                        #:span span)        -> source-location?
  loc : source-location?
  source : any/c
  line : (or/c exact-nonnegative-integer? #f)
  column : (or/c exact-positive-integer? #f)
  position : (or/c exact-nonnegative-integer? #f)
  span : (or/c exact-positive-integer? #f)
procedure
(source-location->string loc) -> string?
  loc : source-location?
procedure
(source-location->prefix loc) -> string?
  loc : source-location?
procedure
(syntax-source-directory stx) -> (or/c path? #f)
  stx : syntax?
procedure
(syntax-source-file-name stx) -> (or/c path? #f)
  stx : syntax?
syntax
(quote-srcloc)
(quote-srcloc form)
(quote-srcloc form #:module-source expr)
syntax
(quote-source-file)
(quote-source-file form)
syntax
(quote-line-number)
(quote-line-number form)
syntax
(quote-column-number)
(quote-column-number form)
syntax
(quote-character-position)
(quote-character-position form)
syntax
(quote-character-span)
(quote-character-span form)
syntax
(quote-srcloc-string)
(quote-srcloc-string form)
syntax
(quote-srcloc-prefix)
(quote-srcloc-prefix form)
syntax
(quote-module-name submod-path-element ...)
syntax
(quote-module-path submod-path-element ...)
syntax
(quote-syntax/keep-srcloc datum)
(quote-syntax/keep-srcloc #:source source-expr datum)
procedure
(expand-syntax-top-level-with-compile-time-evals stx) -> syntax?
  stx : syntax?
procedure
(expand-top-level-with-compile-time-evals stx) -> syntax?
  stx : syntax?
procedure
(expand-syntax-top-level-with-compile-time-evals/flatten stx)
 -> (listof syntax?)
  stx : syntax?
procedure
(eval-compile-time-part-of-top-level stx) -> void?
  stx : syntax?
procedure
(eval-compile-time-part-of-top-level/compile stx)
 -> (listof compiled-expression?)
  stx : syntax?
syntax
(provide-and-document doc-label-id doc-row ...)
 
doc-row = (section-string (name type-datum doc-string ...) ...)
        | (all-from prefix-id module-path doc-label-id)
        | (all-from-except prefix-id module-path doc-label-id id ...)
           
   name = id
        | (local-name-id external-name-id)
procedure
(lookup-documentation module-path-v     
                      label-sym)    -> any
  module-path-v : module-path?
  label-sym : symbol?
procedure
(wrap-expr/c  contract-expr            
              expr                     
             [#:arg? arg?              
              #:positive pos-blame     
              #:negative neg-blame     
              #:name expr-name         
              #:macro macro-name       
              #:context context        
              #:phase phase])      -> syntax?
  contract-expr : syntax?
  expr : syntax?
  arg? : any/c = #t
  pos-blame : (or/c syntax? string? module-path-index?
                    'from-macro 'use-site 'unknown)
            = 'from-macro
  neg-blame : (or/c syntax? string? module-path-index?
                    'from-macro 'use-site 'unknown)
            = 'use-site
  expr-name : (or/c identifier? symbol? string? #f) = #f
  macro-name : (or/c identifier? symbol? string? #f) = #f
  context : (or/c syntax? #f) = (current-syntax-context)
  phase : exact-integer? = (syntax-local-phase-level)
syntax
(phase1-eval ct-expr maybe-quote maybe-catch?)
 
 maybe-quote = 
             | #:quote quote-id
                
maybe-catch? = 
             | #:catch? catch?
syntax
(convert-compile-time-error expr)
syntax
(convert-syntax-error expr)
procedure
(internal-definition-context-track intdef-ctx     
                                   stx)       -> syntax?
  intdef-ctx : internal-definition-context?
  stx : syntax?
