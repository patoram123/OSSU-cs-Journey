25023
((3) 0 () 11 ((q lib "typed-racket/base-env/base-types.rkt") (q lib "typed-racket/base-env/prims.rkt") (q lib "typed/racket/unit.rkt") (q lib "typed-racket/base-env/base-types-extra.rkt") (q lib "typed-racket/typed-racket.rkt") (q lib "typed/racket/class.rkt") (q lib "typed/untyped-utils.rkt") (q lib "typed/racket/unsafe.rkt") (q lib "typed/racket/base.rkt") (q lib "typed-racket/base-env/extra-procs.rkt") (q lib "typed/scheme/base.rkt")) () (h ! (equal) ((c form c (c (? . 1) q :type)) q (25319 . 5)) ((c form c (c (? . 0) q Read-Table)) q (2557 . 2)) ((c form c (c (? . 0) q Positive-Flonum)) q (524 . 2)) ((c form c (c (? . 3) q →)) q (7248 . 2)) ((c form c (c (? . 0) q Immutable-Vectorof)) q (3276 . 2)) ((c form c (c (? . 5) q private)) q (19920 . 2)) ((c form c (c (? . 1) q for*/lists:)) q (28148 . 2)) ((c form c (c (? . 2) q define-values/invoke-unit)) q (21559 . 8)) ((c form c (c (? . 0) q Custodian)) q (2616 . 2)) ((c form c (c (? . 2) q compound-unit)) q (21797 . 9)) ((c form c (c (? . 1) q inst)) q (15247 . 3)) ((c form c (c (? . 0) q Evtof)) q (4276 . 2)) ((c form c (c (? . 1) q for/sum)) q (9956 . 2)) ((c form c (c (? . 1) q cast)) q (15227 . 2)) ((c form c (c (? . 0) q Number)) q (37 . 2)) ((c form c (c (? . 1) q with-asserts)) q (24483 . 5)) ((c form c (c (? . 0) q Async-ChannelTop)) q (3903 . 2)) ((c form c (c (? . 0) q Nonpositive-Flonum)) q (656 . 2)) ((c form c (c (? . 3) q Struct-Type)) q (6984 . 2)) ((c form c (c (? . 0) q Float-Nan)) q (815 . 2)) ((c form c (c (? . 1) q define-typed-struct)) q (28635 . 2)) ((c form c (c (? . 2) q define-compound-unit/infer)) q (22804 . 5)) ((c form c (c (? . 0) q Exact-Number)) q (165 . 2)) ((c form c (c (? . 0) q EOF)) q (2246 . 2)) ((c form c (c (? . 1) q for*/list)) q (10281 . 2)) ((c form c (c (? . 3) q Row)) q (20796 . 2)) ((c form c (c (? . 4) q URL)) q (16600 . 2)) ((c form c (c (? . 0) q Pretty-Print-Style-Table)) q (2453 . 2)) ((c form c (c (? . 1) q letrec-values)) q (7844 . 2)) ((c form c (c (? . 0) q Nonpositive-Real)) q (1482 . 2)) ((c form c (c (? . 4) q #%module-begin)) q (16335 . 2)) ((c form c (c (? . 0) q Intersection)) q (7218 . 2)) ((c form c (c (? . 0) q Thread-Cellof)) q (4136 . 2)) ((c form c (c (? . 0) q String)) q (1938 . 2)) ((c form c (c (? . 6) q require/untyped-contract)) q (24958 . 5)) ((c form c (c (? . 1) q define-struct/exec)) q (27588 . 8)) ((c form c (c (? . 4) q Cursor)) q (17192 . 2)) ((c form c (c (? . 0) q Positive-Float)) q (504 . 2)) ((c form c (c (? . 0) q Inexact-Real-Zero)) q (1255 . 2)) ((c form c (c (? . 3) q Prefab)) q (7027 . 2)) ((c def c (c (? . 8) q prop:procedure)) q (16405 . 2)) ((c form c (c (? . 0) q MPairTop)) q (3191 . 2)) ((c form c (c (? . 1) q assert-typecheck-fail)) q (24858 . 3)) ((c form c (c (? . 0) q Weak-HashTableTop)) q (3766 . 2)) ((c form c (c (? . 1) q for*/or:)) q (28184 . 2)) ((c form c (c (? . 2) q invoke-unit)) q (21477 . 3)) ((c form c (c (? . 1) q for/last:)) q (28461 . 2)) ((c form c (c (? . 1) q for*/vector:)) q (28238 . 2)) ((c form c (c (? . 0) q Namespace-Anchor)) q (2190 . 2)) ((c form c (c (? . 0) q Syntaxof)) q (4304 . 2)) ((c form c (c (? . 0) q Prompt-Tagof)) q (4427 . 2)) ((c form c (c (? . 0) q ExtFlonum-Zero)) q (1865 . 2)) ((c form c (c (? . 4) q for/flvector)) q (16943 . 2)) ((c form c (c (? . 0) q VectorTop)) q (3521 . 2)) ((c form c (c (? . 1) q require/opaque-type)) q (28662 . 2)) ((c form c (c (? . 0) q Mutable-HashTableTop)) q (3740 . 2)) ((c form c (c (? . 5) q augment)) q (19878 . 2)) ((c form c (c (? . 3) q Struct)) q (6966 . 2)) ((c form c (c (? . 1) q for/or:)) q (28529 . 2)) ((c form c (c (? . 5) q define/augment)) q (19426 . 3)) ((c form c (c (? . 1) q for*/product:)) q (28200 . 2)) ((c form c (c (? . 1) q plet:)) q (26939 . 2)) ((c form c (c (? . 4) q Image-Kind)) q (17162 . 2)) ((c form c (c (? . 4) q File-Format)) q (17114 . 2)) ((c form c (c (? . 0) q Inexact-Real-Nan)) q (1278 . 2)) ((c form c (c (? . 4) q Imp)) q (7153 . 2)) ((c form c (c (? . 1) q for*/sum)) q (10863 . 2)) ((c form c (c (? . 0) q Nothing)) q (24 . 2)) ((c form c (c (? . 1) q for*/hashalw)) q (10614 . 2)) ((c form c (c (? . 0) q Regexp)) q (2104 . 2)) ((c form c (c (? . 0) q Vectorof)) q (3245 . 2)) ((c form c (c (? . 1) q for*/hash:)) q (28032 . 2)) ((c form c (c (? . 4) q Threshold)) q (17131 . 2)) ((c form c (c (? . 1) q for/first)) q (11272 . 2)) ((c form c (c (? . 1) q for*:)) q (28258 . 2)) ((c form c (c (? . 4) q Draw-Caret)) q (17146 . 2)) ((c form c (c (? . 0) q Compiled-Module-Expression)) q (2363 . 2)) ((c form c (c (? . 4) q GIF-Colormap)) q (16468 . 2)) ((c form c (c (? . 1) q require/typed)) q (15392 . 20)) ((c form c (c (? . 1) q define-typed-struct/exec)) q (29443 . 2)) ((c form c (c (? . 4) q PortT)) q (16628 . 2)) ((c form c (c (? . 1) q for*)) q (12137 . 2)) ((c form c (c (? . 1) q define-struct/exec:)) q (27873 . 2)) ((c form c (c (? . 4) q Read/Write-Format)) q (17091 . 2)) ((c form c (c (? . 0) q Variable-Reference)) q (2212 . 2)) ((c form c (c (? . 0) q Positive-Fixnum)) q (1600 . 2)) ((c form c (c (? . 0) q Log-Level)) q (2730 . 2)) ((c form c (c (? . 1) q let*-values)) q (7904 . 2)) ((c form c (c (? . 1) q for/and:)) q (28271 . 2)) ((c form c (c (? . 4) q SSL-Context)) q (16722 . 2)) ((c form c (c (? . 0) q Module-Path-Index)) q (2314 . 2)) ((c form c (c (? . 7) q unsafe-provide)) q (25859 . 2)) ((c form c (c (? . 0) q Weak-BoxTop)) q (4225 . 2)) ((c form c (c (? . 0) q Option)) q (7303 . 2)) ((c form c (c (? . 0) q Pair)) q (28866 . 2)) ((c form c (c (? . 0) q TCP-Listener)) q (2682 . 2)) ((c form c (c (? . 1) q for/list)) q (9381 . 2)) ((c form c (c (? . 0) q Inspector)) q (2631 . 2)) ((c form c (c (? . 0) q Impersonator-Property)) q (2530 . 2)) ((c form c (c (? . 0) q Single-Flonum-Zero)) q (1030 . 2)) ((c form c (c (? . 3) q Bot)) q (6662 . 2)) ((c form c (c (? . 1) q letrec)) q (7709 . 2)) ((c form c (c (? . 5) q field)) q (19652 . 2)) ((c form c (c (? . 0) q Nonnegative-Inexact-Real)) q (1104 . 2)) ((c form c (c (? . 0) q Prompt-TagTop)) q (4465 . 2)) ((c form c (c (? . 0) q True)) q (1917 . 2)) ((c form c (c (? . 0) q UnitTop)) q (23749 . 2)) ((c form c (c (? . 0) q Special-Comment)) q (2483 . 2)) ((c form c (c (? . 3) q PrefabTop)) q (7069 . 2)) ((c form c (c (? . 1) q define-predicate)) q (15075 . 2)) ((c form c (c (? . 1) q :query-type/args)) q (25427 . 2)) ((c form c (c (? . 1) q struct:)) q (27836 . 2)) ((c form c (c (? . 3) q Object)) q (20636 . 5)) ((c form c (c (? . 0) q BoxTop)) q (3233 . 2)) ((c form c (c (? . 0) q Sexpof)) q (4377 . 2)) ((c form c (c (? . 0) q Nonnegative-Flonum)) q (568 . 2)) ((c form c (c (? . 0) q Inexact-Complex)) q (229 . 2)) ((c form c (c (? . 0) q Custodian-Boxof)) q (4098 . 2)) ((c form c (c (? . 0) q Exact-Complex)) q (265 . 2)) ((c form c (c (? . 0) q Positive-Real)) q (1422 . 2)) ((c form c (c (? . 0) q Positive-Integer)) q (328 . 2)) ((c form c (c (? . 1) q for/product)) q (10036 . 2)) ((c form c (c (? . 0) q Un)) q (28786 . 2)) ((c form c (c (? . 0) q Futureof)) q (4009 . 2)) ((c form c (c (? . 1) q for*/fold:)) q (27995 . 2)) ((c form c (c (? . 0) q Byte)) q (1528 . 2)) ((c def c (c (? . 9) q defined?)) q (24587 . 3)) ((c form c (c (? . 10) q require-typed-struct)) q (29359 . 2)) ((c form c (c (? . 0) q Nonpositive-Exact-Rational)) q (1390 . 2)) ((c form c (c (? . 0) q Nonpositive-Single-Flonum)) q (933 . 2)) ((c form c (c (? . 1) q pcase-lambda:)) q (26736 . 3)) ((c form c (c (? . 0) q Vector)) q (3356 . 2)) ((c form c (c (? . 3) q Refinement)) q (29419 . 2)) ((c form c (c (? . 4) q IMAP-Connection)) q (16563 . 2)) ((c form c (c (? . 1) q for/vector:)) q (28580 . 2)) ((c form c (c (? . 1) q struct)) q (13966 . 16)) ((c form c (c (? . 0) q MListof)) q (3128 . 2)) ((c form c (c (? . 0) q ChannelTop)) q (3849 . 2)) ((c form c (c (? . 1) q for:)) q (27900 . 2)) ((c form c (c (? . 0) q Immutable-HashTable)) q (3594 . 2)) ((c form c (c (? . 3) q Self)) q (7143 . 2)) ((c form c (c (? . 2) q unit-from-context)) q (23279 . 2)) ((c form c (c (? . 1) q for*/and)) q (11354 . 2)) ((c form c (c (? . 1) q for/hashalw)) q (9710 . 2)) ((c form c (c (? . 1) q for*/last:)) q (28112 . 2)) ((c form c (c (? . 0) q ExtFlonum)) q (1690 . 2)) ((c form c (c (? . 0) q Single-Flonum-Positive-Zero)) q (997 . 2)) ((c form c (c (? . 0) q Nonpositive-Integer)) q (469 . 2)) ((c form c (c (? . 0) q Syntax)) q (4351 . 2)) ((c form c (c (? . 0) q Mutable-Vectorof)) q (3317 . 2)) ((c form c (c (? . 0) q Internal-Definition-Context)) q (2420 . 2)) ((c form c (c (? . 1) q for*/sum:)) q (28221 . 2)) ((c form c (c (? . 0) q Flonum)) q (86 . 2)) ((c form c (c (? . 1) q for/product:)) q (28544 . 2)) ((c form c (c (? . 1) q :kind)) q (25498 . 2)) ((c form c (c (? . 0) q Integer)) q (62 . 2)) ((c form c (c (? . 3) q Struct-Property)) q (7104 . 2)) ((c form c (c (? . 1) q for/hasheqv)) q (9626 . 2)) ((c form c (c (? . 1) q let)) q (7361 . 13)) ((c form c (c (? . 0) q Natural)) q (434 . 2)) ((c form c (c (? . 2) q define-unit)) q (22036 . 7)) ((c form c (c (? . 1) q let/cc:)) q (27271 . 2)) ((c form c (c (? . 0) q Float-Complex)) q (183 . 2)) ((c form c (c (? . 3) q Unit)) q (23364 . 13)) ((c form c (c (? . 0) q Union)) q (7195 . 2)) ((c form c (c (? . 5) q override)) q (19835 . 2)) ((c form c (c (? . 2) q unit)) q (21015 . 16)) ((c form c (c (? . 0) q Path-For-Some-System)) q (2078 . 2)) ((c form c (c (? . 0) q Float)) q (75 . 2)) ((c form c (c (? . 0) q Imaginary)) q (250 . 2)) ((c form c (c (? . 4) q for*/flvector)) q (17010 . 2)) ((c form c (c (? . 0) q Real-Zero)) q (1504 . 2)) ((c form c (c (? . 1) q for*/first:)) q (27929 . 2)) ((c form c (c (? . 1) q for*/list:)) q (28130 . 2)) ((c form c (c (? . 0) q Float-Negative-Zero)) q (680 . 2)) ((c form c (c (? . 1) q do:)) q (28599 . 2)) ((c form c (c (? . 0) q Syntax-E)) q (4363 . 2)) ((c form c (c (? . 0) q Char)) q (1975 . 2)) ((c form c (c (? . 1) q typecheck-fail)) q (24693 . 8)) ((c form c (c (? . 2) q define-compound-unit)) q (22681 . 5)) ((c form c (c (? . 1) q λ)) q (8819 . 2)) ((c form c (c (? . 1) q for*/hasheqv:)) q (28070 . 2)) ((c def c (c (? . 6) q syntax-local-typed-context?)) q (25265 . 2)) ((c form c (c (? . 4) q Char-Set)) q (17178 . 2)) ((c form c (c (? . 1) q for/last)) q (10120 . 2)) ((c form c (c (? . 3) q mu)) q (28806 . 2)) ((c form c (c (? . 1) q for/set:)) q (28513 . 2)) ((c form c (c (? . 1) q λ:)) q (26192 . 2)) ((c form c (c (? . 0) q Semaphore)) q (2821 . 2)) ((c form c (c (? . 3) q ->*)) q (6245 . 15)) ((c form c (c (? . 3) q Opaque)) q (7332 . 2)) ((c form c (c (? . 1) q let/ec)) q (7995 . 2)) ((c form c (c (? . 0) q Unquoted-Printing-String)) q (2028 . 2)) ((c form c (c (? . 5) q pubment)) q (19793 . 2)) ((c form c (c (? . 0) q Exact-Nonnegative-Integer)) q (403 . 2)) ((c form c (c (? . 1) q :)) q (15110 . 3)) ((c form c (c (? . 0) q Thread)) q (2745 . 2)) ((c form c (c (? . 1) q case-lambda)) q (8872 . 2)) ((c form c (c (? . 0) q ExtFlonum-Nan)) q (1885 . 2)) ((c form c (c (? . 0) q Continuation-Mark-Set)) q (2255 . 2)) ((c form c (c (? . 0) q Keyword)) q (1950 . 2)) ((c form c (c (? . 0) q Inexact-Real)) q (117 . 2)) ((c form c (c (? . 0) q SequenceTop)) q (4081 . 2)) ((c form c (c (? . 1) q define-struct)) q (14526 . 12)) ((c form c (c (? . 0) q Exact-Imaginary)) q (284 . 2)) ((c form c (c (? . 0) q Place)) q (2791 . 2)) ((c form c (c (? . 0) q FSemaphore)) q (2836 . 2)) ((c form c (c (? . 1) q for)) q (8928 . 16)) ((c form c (c (? . 4) q HTTP-Connection)) q (16542 . 2)) ((c form c (c (? . 4) q for*/extflvector)) q (16870 . 2)) ((c form c (c (? . 7) q unsafe-require/typed)) q (25810 . 2)) ((c form c (c (? . 1) q for*/hashalw:)) q (28091 . 2)) ((c form c (c (? . 1) q for/list:)) q (28478 . 2)) ((c form c (c (? . 5) q public)) q (19752 . 2)) ((c form c (c (? . 0) q Port)) q (2058 . 2)) ((c form c (c (? . 0) q Nonpositive-ExtFlonum)) q (1780 . 2)) ((c form c (c (? . 1) q for*/product)) q (10944 . 2)) ((c form c (c (? . 1) q for*/hasheq)) q (10445 . 2)) ((c form c (c (? . 1) q for/sum:)) q (28564 . 2)) ((c form c (c (? . 2) q define-unit-from-context)) q (23316 . 2)) ((c form c (c (? . 0) q Place-Channel)) q (2802 . 2)) ((c form c (c (? . 0) q Setof)) q (3789 . 2)) ((c form c (c (? . 0) q Nonnegative-Exact-Rational)) q (1329 . 2)) ((c form c (c (? . 0) q Input-Port)) q (1995 . 2)) ((c form c (c (? . 0) q Negative-Inexact-Real)) q (1134 . 2)) ((c form c (c (? . 0) q Output-Port)) q (2011 . 2)) ((c form c (c (? . 1) q :query-type/result)) q (25464 . 2)) ((c form c (c (? . 0) q Byte-PRegexp)) q (2146 . 2)) ((c form c (c (? . 0) q Security-Guard)) q (2646 . 2)) ((c form c (c (? . 0) q Struct-TypeTop)) q (7007 . 2)) ((c form c (c (? . 1) q for/hasheq:)) q (28402 . 2)) ((c form c (c (? . 1) q for/fold)) q (11699 . 6)) ((c form c (c (? . 0) q Compiled-Expression)) q (2395 . 2)) ((c form c (c (? . 0) q Single-Flonum-Complex)) q (202 . 2)) ((c form c (c (? . 1) q require-typed-struct/provide)) q (28717 . 2)) ((c form c (c (? . 1) q popt-lambda:)) q (26595 . 3)) ((c form c (c (? . 3) q AnyValues)) q (9 . 2)) ((c form c (c (? . 0) q Mutable-HashTable)) q (3639 . 2)) ((c form c (c (? . 1) q let*:)) q (27046 . 2)) ((c form c (c (? . 0) q Index)) q (1557 . 2)) ((c form c (c (? . 0) q ExtFlonum-Positive-Zero)) q (1836 . 2)) ((c form c (c (? . 1) q for/first:)) q (28287 . 2)) ((c form c (c (? . 0) q Promise)) q (3979 . 2)) ((c form c (c (? . 0) q Environment-Variables)) q (2900 . 2)) ((c form c (c (? . 1) q let/cc)) q (7962 . 2)) ((c form c (c (? . 1) q define:)) q (27339 . 7)) ((c form c (c (? . 0) q Float-Zero)) q (782 . 2)) ((c form c (c (? . 1) q for*/set:)) q (28167 . 2)) ((c form c (c (? . 0) q Negative-Float)) q (592 . 2)) ((c form c (c (? . 1) q for/foldr)) q (11884 . 9)) ((c form c (c (? . 3) q Refine)) q (29541 . 32)) ((c form c (c (? . 8) q values)) q (28888 . 2)) ((c form c (c (? . 3) q Top)) q (6653 . 2)) ((c form c (c (? . 3) q Some)) q (6858 . 2)) ((c form c (c (? . 1) q make-predicate)) q (15048 . 2)) ((c form c (c (? . 1) q for*/last)) q (11029 . 2)) ((c form c (c (? . 0) q Exact-Positive-Integer)) q (350 . 2)) ((c form c (c (? . 0) q ExtFlVector)) q (3490 . 2)) ((c form c (c (? . 0) q UDP-Socket)) q (2666 . 2)) ((c def c (c (? . 9) q assert)) q (24368 . 6)) ((c form c (c (? . 1) q define-new-subtype)) q (29489 . 2)) ((c form c (c (? . 0) q Nonpositive-Inexact-Real)) q (1161 . 2)) ((c form c (c (? . 1) q for/hasheq)) q (9543 . 2)) ((c form c (c (? . 5) q class)) q (17224 . 45)) ((c form c (c (? . 5) q define/private)) q (19506 . 3)) ((c form c (c (? . 0) q Symbol)) q (1963 . 2)) ((c form c (c (? . 0) q Flonum-Nan)) q (830 . 2)) ((c form c (c (? . 0) q Identifier)) q (4335 . 2)) ((c form c (c (? . 4) q Time)) q (17204 . 2)) ((c form c (c (? . 4) q FTP-Connection)) q (16522 . 2)) ((c def c (c (? . 1) q default-continuation-prompt-tag)) q (16243 . 3)) ((c form c (c (? . 1) q for/and)) q (11192 . 2)) ((c form c (c (? . 4) q with-type)) q (25516 . 10)) ((c form c (c (? . 0) q Subprocess)) q (2775 . 2)) ((c form c (c (? . 1) q plambda:)) q (26233 . 3)) ((c form c (c (? . 1) q letrec:)) q (27000 . 2)) ((c form c (c (? . 0) q Positive-Exact-Rational)) q (1300 . 2)) ((c form c (c (? . 0) q HashTable)) q (3559 . 2)) ((c form c (c (? . 0) q Single-Flonum-Negative-Zero)) q (964 . 2)) ((c form c (c (? . 2) q define-signature)) q (20833 . 8)) ((c form c (c (? . 0) q Single-Flonum-Nan)) q (1054 . 2)) ((c form c (c (? . 0) q Logger)) q (2700 . 2)) ((c form c (c (? . 0) q Fixnum)) q (1588 . 2)) ((c form c (c (? . 1) q for*/fold)) q (12402 . 6)) ((c form c (c (? . 0) q Undefined)) q (2282 . 2)) ((c form c (c (? . 0) q Path)) q (2068 . 2)) ((c form c (c (? . 1) q with-handlers*)) q (16221 . 2)) ((c form c (c (? . 0) q Weak-HashTable)) q (3682 . 2)) ((c form c (c (? . 0) q ∩)) q (6715 . 2)) ((c form c (c (? . 1) q for/flvector:)) q (28305 . 2)) ((c form c (c (? . 0) q Sexp)) q (4406 . 2)) ((c form c (c (? . 1) q for/lists)) q (11518 . 6)) ((c form c (c (? . 0) q Positive-Index)) q (1568 . 2)) ((c form c (c (? . 3) q Parameterof)) q (3925 . 3)) ((c form c (c (? . 0) q Nonnegative-Integer)) q (378 . 2)) ((c form c (c (? . 0) q Channelof)) q (3817 . 2)) ((c form c (c (? . 5) q inherit)) q (19951 . 2)) ((c form c (c (? . 1) q for*/lists)) q (12214 . 6)) ((c form c (c (? . 3) q Class)) q (19993 . 17)) ((c form c (c (? . 1) q for/foldr:)) q (28367 . 2)) ((c form c (c (? . 3) q Instance)) q (20761 . 2)) ((c form c (c (? . 1) q for/hash)) q (9462 . 2)) ((c form c (c (? . 1) q for/hash:)) q (28385 . 2)) ((c form c (c (? . 4) q SSL-Verify-Source)) q (16757 . 2)) ((c form c (c (? . 1) q ann)) q (15189 . 2)) ((c form c (c (? . 1) q pdefine:)) q (28753 . 2)) ((c form c (c (? . 0) q Bytes-Converter)) q (2573 . 2)) ((c form c (c (? . 4) q Edit-Op)) q (17078 . 2)) ((c form c (c (? . 1) q let*-values:)) q (27211 . 2)) ((c form c (c (? . 0) q Inexact-Real-Positive-Zero)) q (1223 . 2)) ((c form c (c (? . 0) q Procedure)) q (6671 . 2)) ((c form c (c (? . 0) q Negative-Fixnum)) q (1645 . 2)) ((c form c (c (? . 1) q for/fold:)) q (28350 . 2)) ((c form c (c (? . 0) q Flonum-Zero)) q (798 . 2)) ((c form c (c (? . 5) q init)) q (19586 . 2)) ((c form c (c (? . 0) q Parameterization)) q (2594 . 2)) ((c form c (c (? . 1) q row-inst)) q (15305 . 2)) ((c form c (c (? . 4) q GIF-Stream)) q (16452 . 2)) ((c form c (c (? . 8) q define-type)) q (14887 . 6)) ((c form c (c (? . 1) q require-typed-struct)) q (28689 . 2)) ((c form c (c (? . 1) q for*/hasheq:)) q (28050 . 2)) ((c form c (c (? . 4) q SSL-Client-Context)) q (16698 . 2)) ((c form c (c (? . 0) q Positive-Byte)) q (1538 . 2)) ((c form c (c (? . 1) q let/ec:)) q (27305 . 2)) ((c form c (c (? . 0) q Zero)) q (494 . 2)) ((c form c (c (? . 1) q for*/extflvector:)) q (27970 . 2)) ((c form c (c (? . 1) q :print-type)) q (25403 . 2)) ((c form c (c (? . 5) q init-rest)) q (19724 . 2)) ((c form c (c (? . 0) q FlVector)) q (3476 . 2)) ((c form c (c (? . 3) q Rec)) q (6949 . 2)) ((c form c (c (? . 1) q for*/first)) q (11435 . 2)) ((c form c (c (? . 0) q Will-Executor)) q (2852 . 2)) ((c form c (c (? . 2) q invoke-unit/infer)) q (22949 . 5)) ((c form c (c (? . 5) q define/pubment)) q (19346 . 3)) ((c form c (c (? . 0) q Continuation-Mark-KeyTop)) q (4530 . 2)) ((c form c (c (? . 1) q for*/flvector:)) q (27948 . 2)) ((c form c (c (? . 3) q List)) q (3005 . 2)) ((c form c (c (? . 3) q !)) q (30657 . 2)) ((c form c (c (? . 5) q define/public)) q (19186 . 3)) ((c form c (c (? . 1) q for*/hasheqv)) q (10529 . 2)) ((c form c (c (? . 2) q compound-unit/infer)) q (22179 . 15)) ((c form c (c (? . 6) q define-typed/untyped-identifier)) q (25091 . 2)) ((c form c (c (? . 0) q Float-Positive-Zero)) q (731 . 2)) ((c form c (c (? . 4) q Path/Param)) q (16584 . 2)) ((c form c (c (? . 1) q let-values)) q (7787 . 2)) ((c form c (c (? . 1) q lambda)) q (8028 . 26)) ((c form c (c (? . 0) q Null)) q (2236 . 2)) ((c form c (c (? . 0) q Struct-Type-Property)) q (2504 . 2)) ((c form c (c (? . 1) q define-struct:)) q (27851 . 2)) ((c form c (c (? . 0) q Pairof)) q (2944 . 2)) ((c form c (c (? . 0) q Module-Path)) q (2297 . 2)) ((c form c (c (? . 3) q ∀)) q (7294 . 2)) ((c form c (c (? . 0) q Real)) q (155 . 2)) ((c form c (c (? . 0) q Negative-Flonum)) q (612 . 2)) ((c form c (c (? . 3) q List*)) q (3088 . 2)) ((c form c (c (? . 0) q Positive-ExtFlonum)) q (1705 . 2)) ((c form c (c (? . 3) q case→)) q (7269 . 2)) ((c form c (c (? . 1) q let:)) q (26847 . 3)) ((c form c (c (? . 1) q for/set)) q (10201 . 2)) ((c form c (c (? . 1) q letrec-values:)) q (27149 . 2)) ((c form c (c (? . 1) q provide:)) q (15140 . 2)) ((c form c (c (? . 1) q for*/and:)) q (27912 . 2)) ((c form c (c (? . 1) q define)) q (13036 . 30)) ((c form c (c (? . 1) q for*/foldr:)) q (28013 . 2)) ((c form c (c (? . 4) q SSL-Protocol)) q (16656 . 2)) ((c form c (c (? . 0) q Positive-Inexact-Real)) q (1077 . 2)) ((c form c (c (? . 0) q Any)) q (0 . 2)) ((c form c (c (? . 0) q Single-Flonum)) q (98 . 2)) ((c form c (c (? . 1) q for*/vector)) q (10699 . 2)) ((c form c (c (? . 0) q Nonnegative-Float)) q (545 . 2)) ((c form c (c (? . 1) q for/hashalw:)) q (28441 . 2)) ((c form c (c (? . 1) q for*/or)) q (10783 . 2)) ((c form c (c (? . 3) q pred)) q (28769 . 2)) ((c form c (c (? . 1) q let-values:)) q (27090 . 2)) ((c form c (c (? . 0) q Namespace)) q (2175 . 2)) ((c form c (c (? . 3) q ->)) q (4560 . 53)) ((c form c (c (? . 1) q for/hasheqv:)) q (28421 . 2)) ((c form c (c (? . 4) q for/extflvector)) q (16798 . 2)) ((c form c (c (? . 0) q ExtFlonum-Negative-Zero)) q (1807 . 2)) ((c form c (c (? . 0) q HashTableTop)) q (3722 . 2)) ((c form c (c (? . 3) q case->)) q (6746 . 2)) ((c form c (c (? . 0) q Positive-Single-Flonum)) q (846 . 2)) ((c form c (c (? . 0) q False)) q (1927 . 2)) ((c form c (c (? . 0) q Inexact-Imaginary)) q (305 . 2)) ((c form c (c (? . 0) q Flonum-Positive-Zero)) q (756 . 2)) ((c form c (c (? . 1) q for/or)) q (9877 . 2)) ((c form c (c (? . 10) q require/typed)) q (28912 . 12)) ((c form c (c (? . 1) q define-type-alias)) q (28610 . 2)) ((c form c (c (? . 1) q opt-lambda:)) q (26346 . 6)) ((c form c (c (? . 1) q do)) q (12854 . 7)) ((c form c (c (? . 5) q define/override)) q (19264 . 3)) ((c form c (c (? . 0) q Boxof)) q (3205 . 2)) ((c form c (c (? . 3) q Has-Struct-Property)) q (7162 . 2)) ((c form c (c (? . 1) q for*/set)) q (11111 . 2)) ((c form c (c (? . 0) q Exact-Rational)) q (135 . 2)) ((c form c (c (? . 4) q Date)) q (17214 . 2)) ((c form c (c (? . 0) q Negative-Real)) q (1463 . 2)) ((c form c (c (? . 3) q Sequenceof)) q (4040 . 2)) ((c form c (c (? . 0) q Log-Receiver)) q (2712 . 2)) ((c form c (c (? . 0) q Complex)) q (49 . 2)) ((c form c (c (? . 0) q Weak-Boxof)) q (4192 . 2)) ((c form c (c (? . 4) q #%top-interaction)) q (16370 . 2)) ((c form c (c (? . 0) q Negative-Exact-Rational)) q (1361 . 2)) ((c form c (c (? . 0) q Ephemeronof)) q (4242 . 2)) ((c form c (c (? . 1) q for/extflvector:)) q (28326 . 2)) ((c form c (c (? . 3) q All)) q (6807 . 3)) ((c form c (c (? . 0) q Mutable-VectorTop)) q (3536 . 2)) ((c form c (c (? . 0) q MPairof)) q (3158 . 2)) ((c form c (c (? . 0) q Continuation-Mark-Keyof)) q (4484 . 2)) ((c form c (c (? . 4) q Cookie)) q (16498 . 2)) ((c form c (c (? . 0) q Nonnegative-ExtFlonum)) q (1729 . 2)) ((c form c (c (? . 5) q inherit-field)) q (19684 . 2)) ((c form c (c (? . 0) q Nonpositive-Fixnum)) q (1666 . 2)) ((c form c (c (? . 0) q PRegexp)) q (2116 . 2)) ((c form c (c (? . 1) q for/vector)) q (9794 . 2)) ((c form c (c (? . 4) q LoadFileKind)) q (16780 . 2)) ((c form c (c (? . 1) q with-handlers)) q (16200 . 2)) ((c form c (c (? . 0) q Negative-Integer)) q (447 . 2)) ((c form c (c (? . 0) q Nonpositive-Float)) q (633 . 2)) ((c form c (c (? . 1) q for/lists:)) q (28495 . 2)) ((c form c (c (? . 2) q define-values/invoke-unit/infer)) q (23053 . 8)) ((c form c (c (? . 1) q require/typed/provide)) q (16150 . 2)) ((c form c (c (? . 0) q ClassTop)) q (20620 . 2)) ((c form c (c (? . 1) q for*/hash)) q (10363 . 2)) ((c form c (c (? . 0) q One)) q (1519 . 2)) ((c form c (c (? . 0) q Nonnegative-Single-Flonum)) q (874 . 2)) ((c form c (c (? . 0) q Nonnegative-Real)) q (1441 . 2)) ((c form c (c (? . 0) q FxVector)) q (3507 . 2)) ((c form c (c (? . 0) q Async-Channelof)) q (3865 . 2)) ((c form c (c (? . 0) q Thread-CellTop)) q (4172 . 2)) ((c form c (c (? . 1) q lambda:)) q (25959 . 9)) ((c form c (c (? . 4) q JSExpr)) q (16486 . 2)) ((c form c (c (? . 0) q Resolved-Module-Path)) q (2337 . 2)) ((c form c (c (? . 0) q Listof)) q (2976 . 2)) ((c form c (c (? . 3) q Values)) q (6883 . 2)) ((c form c (c (? . 0) q Boolean)) q (1904 . 2)) ((c form c (c (? . 4) q SSL-Listener)) q (16739 . 2)) ((c form c (c (? . 0) q Byte-Regexp)) q (2129 . 2)) ((c form c (c (? . 1) q declare-refinement)) q (29387 . 2)) ((c form c (c (? . 0) q Thread-Group)) q (2757 . 2)) ((c form c (c (? . 0) q Path-String)) q (2927 . 2)) ((c form c (c (? . 7) q unsafe-require/typed/provide)) q (25902 . 2)) ((c form c (c (? . 0) q Datum)) q (4416 . 2)) ((c def c (c (? . 1) q index?)) q (24641 . 3)) ((c form c (c (? . 0) q Inexact-Real-Negative-Zero)) q (1191 . 2)) ((c form c (c (? . 0) q Mutable-Vector)) q (3434 . 2)) ((c form c (c (? . 0) q Pseudo-Random-Generator)) q (2871 . 2)) ((c form c (c (? . 0) q Negative-ExtFlonum)) q (1756 . 2)) ((c form c (c (? . 0) q Immutable-Vector)) q (3390 . 2)) ((c form c (c (? . 4) q SSL-Server-Context)) q (16674 . 2)) ((c form c (c (? . 0) q U)) q (6686 . 2)) ((c form c (c (? . 1) q let*)) q (7749 . 2)) ((c form c (c (? . 0) q Flonum-Negative-Zero)) q (705 . 2)) ((c form c (c (? . 5) q init-field)) q (19616 . 2)) ((c form c (c (? . 4) q URL-Exception)) q (16609 . 2)) ((c form c (c (? . 0) q Void)) q (1985 . 2)) ((c form c (c (? . 0) q Negative-Single-Flonum)) q (905 . 2)) ((c form c (c (? . 0) q Nonnegative-Fixnum)) q (1621 . 2)) ((c form c (c (? . 1) q for*/foldr)) q (12594 . 9)) ((c form c (c (? . 0) q Bytes)) q (2164 . 2)) ((c form c (c (? . 3) q Parameter)) q (28839 . 2)) ((c form c (c (? . 1) q case-lambda:)) q (26716 . 2)) ((c form c (c (? . 4) q PortT/Bytes)) q (16639 . 2)) ((c form c (c (? . 3) q Tuple)) q (28816 . 2))))
type
Any
type
AnyValues
type
Nothing
type
Number
type
Complex
type
Integer
type
Float
type
Flonum
type
Single-Flonum
type
Inexact-Real
type
Exact-Rational
type
Real
type
Exact-Number
type
Float-Complex
type
Single-Flonum-Complex
type
Inexact-Complex
type
Imaginary
type
Exact-Complex
type
Exact-Imaginary
type
Inexact-Imaginary
type
Positive-Integer
type
Exact-Positive-Integer
type
Nonnegative-Integer
type
Exact-Nonnegative-Integer
type
Natural
type
Negative-Integer
type
Nonpositive-Integer
type
Zero
type
Positive-Float
type
Positive-Flonum
type
Nonnegative-Float
type
Nonnegative-Flonum
type
Negative-Float
type
Negative-Flonum
type
Nonpositive-Float
type
Nonpositive-Flonum
type
Float-Negative-Zero
type
Flonum-Negative-Zero
type
Float-Positive-Zero
type
Flonum-Positive-Zero
type
Float-Zero
type
Flonum-Zero
type
Float-Nan
type
Flonum-Nan
type
Positive-Single-Flonum
type
Nonnegative-Single-Flonum
type
Negative-Single-Flonum
type
Nonpositive-Single-Flonum
type
Single-Flonum-Negative-Zero
type
Single-Flonum-Positive-Zero
type
Single-Flonum-Zero
type
Single-Flonum-Nan
type
Positive-Inexact-Real
type
Nonnegative-Inexact-Real
type
Negative-Inexact-Real
type
Nonpositive-Inexact-Real
type
Inexact-Real-Negative-Zero
type
Inexact-Real-Positive-Zero
type
Inexact-Real-Zero
type
Inexact-Real-Nan
type
Positive-Exact-Rational
type
Nonnegative-Exact-Rational
type
Negative-Exact-Rational
type
Nonpositive-Exact-Rational
type
Positive-Real
type
Nonnegative-Real
type
Negative-Real
type
Nonpositive-Real
type
Real-Zero
type
One
type
Byte
type
Positive-Byte
type
Index
type
Positive-Index
type
Fixnum
type
Positive-Fixnum
type
Nonnegative-Fixnum
type
Negative-Fixnum
type
Nonpositive-Fixnum
type
ExtFlonum
type
Positive-ExtFlonum
type
Nonnegative-ExtFlonum
type
Negative-ExtFlonum
type
Nonpositive-ExtFlonum
type
ExtFlonum-Negative-Zero
type
ExtFlonum-Positive-Zero
type
ExtFlonum-Zero
type
ExtFlonum-Nan
type
Boolean
type
True
type
False
type
String
type
Keyword
type
Symbol
type
Char
type
Void
type
Input-Port
type
Output-Port
type
Unquoted-Printing-String
type
Port
type
Path
type
Path-For-Some-System
type
Regexp
type
PRegexp
type
Byte-Regexp
type
Byte-PRegexp
type
Bytes
type
Namespace
type
Namespace-Anchor
type
Variable-Reference
type
Null
type
EOF
type
Continuation-Mark-Set
type
Undefined
type
Module-Path
type
Module-Path-Index
type
Resolved-Module-Path
type
Compiled-Module-Expression
type
Compiled-Expression
type
Internal-Definition-Context
type
Pretty-Print-Style-Table
type
Special-Comment
type
Struct-Type-Property
type
Impersonator-Property
type
Read-Table
type
Bytes-Converter
type
Parameterization
type
Custodian
type
Inspector
type
Security-Guard
type
UDP-Socket
type
TCP-Listener
type
Logger
type
Log-Receiver
type
Log-Level
type
Thread
type
Thread-Group
type
Subprocess
type
Place
type
Place-Channel
type
Semaphore
type
FSemaphore
type
Will-Executor
type
Pseudo-Random-Generator
type
Environment-Variables
type
Path-String
type constructor
(Pairof s t)
type constructor
(Listof t)
type constructor
(List t ...)
type constructor
(List t ... trest ... bound)
type constructor
(List* t t1 ... s)
type constructor
(MListof t)
type constructor
(MPairof t u)
type
MPairTop
type constructor
(Boxof t)
type
BoxTop
type constructor
(Vectorof t)
type constructor
(Immutable-Vectorof t)
type constructor
(Mutable-Vectorof t)
type constructor
(Vector t ...)
type constructor
(Immutable-Vector t ...)
type constructor
(Mutable-Vector t ...)
type
FlVector
type
ExtFlVector
type
FxVector
type
VectorTop
type
Mutable-VectorTop
type constructor
(HashTable k v)
type constructor
(Immutable-HashTable k v)
type constructor
(Mutable-HashTable k v)
type constructor
(Weak-HashTable k v)
type
HashTableTop
type
Mutable-HashTableTop
type
Weak-HashTableTop
type constructor
(Setof t)
type constructor
(Channelof t)
type
ChannelTop
type constructor
(Async-Channelof t)
type
Async-ChannelTop
type constructor
(Parameterof t)
(Parameterof s t)
type constructor
(Promise t)
type constructor
(Futureof t)
type constructor
(Sequenceof t t ...)
type
SequenceTop
type constructor
(Custodian-Boxof t)
type constructor
(Thread-Cellof t)
type
Thread-CellTop
type constructor
(Weak-Boxof t)
type
Weak-BoxTop
type constructor
(Ephemeronof t)
type constructor
(Evtof t)
type constructor
(Syntaxof t)
type
Identifier
type
Syntax
type
Syntax-E
type constructor
(Sexpof t)
type
Sexp
type
Datum
type constructor
(Prompt-Tagof s t)
type
Prompt-TagTop
type constructor
(Continuation-Mark-Keyof t)
type
Continuation-Mark-KeyTop
type constructor
(-> dom ... rng opt-proposition)
(-> dom ... rest * rng)
(-> dom ... rest ooo bound rng)
(dom ... -> rng opt-proposition)
(dom ... rest * -> rng)
(dom ... rest ooo bound -> rng)
 
            ooo = ...
                   
            dom = type
                | mandatory-kw
                | opt-kw
                   
            rng = type
                | (Some (a ...) type : #:+ proposition)
                | (Values type ...)
                   
   mandatory-kw = keyword type
                   
         opt-kw = [keyword type]
                   
opt-proposition = 
                | : type
                | : pos-proposition
                    neg-proposition
                  object
                   
pos-proposition = 
                | #:+ proposition ...
                   
neg-proposition = 
                | #:- proposition ...
                   
         object = 
                | #:object index
                   
    proposition = Top
                | Bot
                | type
                | (! type)
                | (type @ path-elem ... index)
                | (! type @ path-elem ... index)
                | (and proposition ...)
                | (or proposition ...)
                | (implies proposition ...)
                   
      path-elem = car
                | cdr
                   
          index = positive-integer
                | (positive-integer positive-integer)
                | identifier
type constructor
(->* (mandatory-dom ...) optional-doms rest rng)
 
mandatory-dom = type
              | keyword type
                 
optional-doms = 
              | (optional-dom ...)
                 
 optional-dom = type
              | keyword type
                 
         rest = 
              | #:rest type
              | #:rest-star (type ...)
type
Top
type
Bot
type
Procedure
type constructor
(U t ...)
type constructor
(∩ t ...)
type constructor
(case-> fun-ty ...)
type
(t t1 t2 ...)
type
(All (a ...) t)
(All (a ... a ooo) t)
type
(Some (a ...) t)
type constructor
(Values t ...)
type
v
type
(quote val)
type
i
type
(Rec n t)
type
(Struct st)
type
(Struct-Type st)
type
Struct-TypeTop
type constructor
(Prefab key type ...)
type
(PrefabTop key field-count)
type constructor
(Struct-Property ty)
type
Self
type
Imp
type
(Has-Struct-Property prop)
type constructor
Union
type constructor
Intersection
type constructor
→
type constructor
case→
type
∀
type constructor
(Option t)
type constructor
(Opaque t)
syntax
(let maybe-tvars (binding ...) maybe-ret . body)
(let loop maybe-ret (binding ...) . body)
 
    binding = [var e]
            | [var : type e]
               
maybe-tvars = 
            | #:forall (tvar ...)
            | #:∀ (tvar ...)
               
  maybe-ret = 
            | : type0
syntax
(letrec (binding ...) . body)
syntax
(let* (binding ...) . body)
syntax
(let-values ([(var+type ...) e] ...) . body)
syntax
(letrec-values ([(var+type ...) e] ...) . body)
syntax
(let*-values ([(var+type ...) e] ...) . body)
syntax
(let/cc v : t . body)
syntax
(let/ec v : t . body)
syntax
(lambda maybe-tvars formals maybe-ret . body)
 
    formals = (formal ...)
            | (formal ... . rst)
               
     formal = var
            | [var default-expr]
            | [var : type]
            | [var : type default-expr]
            | keyword var
            | keyword [var : type]
            | keyword [var : type default-expr]
               
        rst = var
            | [var : type *]
            | [var : type ooo bound]
               
maybe-tvars = 
            | #:forall (tvar ...)
            | #:∀ (tvar ...)
            | #:forall (tvar ... ooo)
            | #:∀ (tvar ... ooo)
               
  maybe-ret = 
            | : type
syntax
(λ maybe-tvars formals maybe-ret . body)
syntax
(case-lambda maybe-tvars [formals body] ...)
syntax
(for void-ann-maybe (for-clause ...) void-ann-maybe expr ...+)
 
void-ann-maybe = 
               | : Void
                  
type-ann-maybe = 
               | : u
                  
    for-clause = [id : t seq-expr]
               | [(binding ...) seq-expr]
               | [id seq-expr]
               | #:when guard
                  
       binding = id
               | [id : t]
syntax
(for/list type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/hash type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/hasheq type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/hasheqv type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/hashalw type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/vector type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/or type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/sum type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/product type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/last type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/set type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/list type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/hash type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/hasheq type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/hasheqv type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/hashalw type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/vector type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/or type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/sum type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/product type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/last type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/set type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/and type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/first type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/and type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for*/first type-ann-maybe (for-clause ...) type-ann-maybe expr ...+)
syntax
(for/lists type-ann-maybe
           ([id : t] ... maybe-result)
           (for-clause ...)
           type-ann-maybe
  expr ...+)
syntax
(for/fold type-ann-maybe
          ([id : t init-expr] ... maybe-result)
          (for-clause ...)
          type-ann-maybe
  expr ...+)
syntax
(for/foldr type-ann-maybe
           ([id : t init-expr] ... maybe-result)
           (for-clause ...)
           type-ann-maybe
  expr ...+)
 
maybe-result = 
             | #:result result-expr
syntax
(for* void-ann-maybe (for-clause ...) void-ann-maybe expr ...+)
syntax
(for*/lists type-ann-maybe
            ([id : t] ... maybe-result)
            (for-clause ...)
            type-ann-maybe
  expr ...+)
syntax
(for*/fold type-ann-maybe
           ([id : t init-expr] ... maybe-result)
           (for-clause ...)
           type-ann-maybe
  expr ...+)
syntax
(for*/foldr type-ann-maybe
            ([id : t init-expr] ... maybe-result)
            (for-clause ...)
            type-ann-maybe
  expr ...+)
 
maybe-result = 
             | #:result result-expr
syntax
(do : u ([id : t init-expr step-expr-maybe] ...)
        (stop?-expr finish-expr ...)
  expr ...+)
 
step-expr-maybe = 
                | step-expr
syntax
(define maybe-tvars v maybe-ann e)
(define maybe-tvars header maybe-ann . body)
 
     header = (function-name . formals)
            | (header . formals)
               
    formals = (formal ...)
            | (formal ... . rst)
               
     formal = var
            | [var default-expr]
            | [var : type]
            | [var : type default-expr]
            | keyword var
            | keyword [var : type]
            | keyword [var : type default-expr]
               
        rst = var
            | [var : type *]
            | [var : type ooo bound]
               
maybe-tvars = 
            | #:forall (tvar ...)
            | #:∀ (tvar ...)
            | #:forall (tvar ... ooo)
            | #:∀ (tvar ... ooo)
               
  maybe-ann = 
            | : type
syntax
(struct maybe-type-vars name-spec ([f : t] ...) options ...)
 
maybe-type-vars = 
                | (v ...)
                   
      name-spec = name-id
                | name-id parent
                   
        options = #:transparent
                | #:mutable
                | #:prefab
                | #:constructor-name constructor-id
                | #:extra-constructor-name constructor-id
                | #:property property-id property-expr
                | #:type-name type-id
syntax
(define-struct maybe-type-vars name-spec ([f : t] ...) options ...)
 
maybe-type-vars = 
                | (v ...)
                   
      name-spec = name-id
                | (name-id parent)
                   
        options = #:transparent
                | #:mutable
                | #:type-name type-id
syntax
(define-type name t maybe-omit-def)
(define-type (name v ...) t maybe-omit-def)
 
maybe-omit-def = #:omit-define-syntaxes
               | 
syntax
(make-predicate t)
syntax
(define-predicate name t)
syntax
(: v t)
(: v : t)
syntax
(provide: [v t] ...)
syntax
#{v : t}
syntax
(ann e t)
syntax
#{e :: t}
syntax
(cast e t)
syntax
(inst e t ...)
(inst e t ... t ooo bound)
syntax
(row-inst e row)
syntax
#{e @ t ...}
syntax
#{e @ t ... t ooo bound}
syntax
(require/typed m rt-clause ...)
 
    rt-clause = [maybe-renamed t]
              | [#:struct maybe-tvars name-id ([f : t] ...)
                     struct-option ...]
              | [#:struct maybe-tvars (name-id parent) ([f : t] ...)
                     struct-option ...]
              | [#:opaque t pred]
              | [#:signature name ([id : t] ...)]
                 
maybe-renamed = id
              | (orig-id new-id)
                 
  maybe-tvars = 
              | (type-variable ...)
                 
struct-option = #:constructor-name constructor-id
              | #:extra-constructor-name constructor-id
              | #:type-name type-id
syntax
(require/typed/provide m rt-clause ...)
syntax
with-handlers
syntax
with-handlers*
procedure
(default-continuation-prompt-tag)
 -> (-> (Prompt-Tagof Any (Any -> Any)))
syntax
(#%module-begin form ...)
syntax
(#%top-interaction . form)
value
prop:procedure : struct-type-property?
type
GIF-Stream
type
GIF-Colormap
type
JSExpr
type
Cookie
type
Cookie
type
FTP-Connection
type
HTTP-Connection
type
IMAP-Connection
type
Path/Param
type
URL
type
URL-Exception
type
PortT
type
PortT/Bytes
type
SSL-Protocol
type
SSL-Server-Context
type
SSL-Client-Context
type
SSL-Context
type
SSL-Listener
type
SSL-Verify-Source
type
LoadFileKind
syntax
(for/extflvector type-ann-maybe (for-clause ...) expr ...+)
syntax
(for*/extflvector type-ann-maybe (for-clause ...) expr ...+)
syntax
(for/flvector maybe-length (for-clause ...) expr ...+)
syntax
(for*/flvector maybe-length (for-clause ...) expr ...+)
type
Edit-Op
type
Read/Write-Format
type
File-Format
type
Threshold
type
Draw-Caret
type
Image-Kind
type
Char-Set
type
Cursor
type
Time
type
Date
syntax
(class superclass-expr
  maybe-type-parameters
  class-clause ...)
 
         class-clause = (inspect inspector-expr)
                      | (init init-decl ...)
                      | (init-field init-decl ...)
                      | (init-rest id/type)
                      | (field field-decl ...)
                      | (inherit-field field-decl ...)
                      | (public maybe-renamed/type ...)
                      | (pubment maybe-renamed/type ...)
                      | (override maybe-renamed/type ...)
                      | (augment maybe-renamed/type ...)
                      | (private id/type ...)
                      | (inherit id ...)
                      | method-definition
                      | definition
                      | expr
                      | (begin class-clause ...)
                         
maybe-type-parameters = 
                      | #:forall (type-variable ...)
                      | #:∀ (type-variable ...)
                         
            init-decl = id/type
                      | [renamed]
                      | [renamed : type-expr]
                      | [maybe-renamed default-value-expr]
                      | [maybe-renamed : type-expr default-value-expr]
                         
           field-decl = (maybe-renamed default-value-expr)
                      | (maybe-renamed : type-expr default-value-expr)
                         
              id/type = id
                      | [id : type-expr]
                         
   maybe-renamed/type = maybe-renamed
                      | [maybe-renamed : type-expr]
                         
        maybe-renamed = id
                      | renamed
                         
              renamed = (internal-id external-id)
syntax
(define/public id expr)
(define/public (id . formals) body ...+)
syntax
(define/override id expr)
(define/override (id . formals) body ...+)
syntax
(define/pubment id expr)
(define/pubment (id . formals) body ...+)
syntax
(define/augment id expr)
(define/augment (id . formals) body ...+)
syntax
(define/private id expr)
(define/private (id . formals) body ...+)
syntax
(init init-decl ...)
syntax
(init-field init-decl ...)
syntax
(field field-decl ...)
syntax
(inherit-field field-decl ...)
syntax
(init-rest id/type)
syntax
(public maybe-renamed/type ...)
syntax
(pubment maybe-renamed/type ...)
syntax
(override maybe-renamed/type ...)
syntax
(augment maybe-renamed/type ...)
syntax
(private id/type ...)
syntax
(inherit maybe-renamed/type ...)
syntax
(Class class-type-clause ...)
 
class-type-clause = name+type
                  | (init init-type ...)
                  | (init-field init-type ...)
                  | (init-rest name+type)
                  | (field name+type ...)
                  | (augment name+type ...)
                  | #:implements type-alias-id
                  | #:implements/inits inits-id
                  | #:row-var row-var-id
                     
        init-type = name+type
                  | [id type #:optional]
                     
        name+type = [id type]
syntax
ClassTop
syntax
(Object object-type-clause ...)
 
object-type-clause = name+type
                   | (field name+type ...)
syntax
(Instance class-type-expr)
syntax
(Row class-type-clause ...)
syntax
(define-signature id extension-decl
  (sig-elem ...))
 
extension-decl = 
               | extends sig-id
                  
      sig-elem = [id : type]
syntax
(unit
  (import sig-spec ...)
  (export sig-spec ...)
  init-depends-decl
  unit-body-expr-or-defn
  ...)
 
         sig-spec = sig-id
                  | (prefix id sig-spec)
                  | (rename sig-spec (id id) ...)
                  | (only sig-spec id ...)
                  | (except sig-spec id ...)
                     
init-depends-decl = 
                  | (init-depend sig-id ...)
syntax
(invoke-unit unit-expr)
(invoke-unit unit-expr (import sig-spec ...))
syntax
(define-values/invoke-unit unit-expr
  (import def-sig-spec ...)
  (export def-sig-spec ...))
 
def-sig-spec = sig-id
             | (prefix id def-sig-spec)
             | (rename def-sig-spec (id id) ...)
syntax
(compound-unit
  (import link-binding ...)
  (export link-id ...)
  (link linkage-decl ...))
 
link-binding = (link-id : sig-id)
                
linkage-decl = ((link-binding ...) unit-expr link-id ...)
syntax
(define-unit unit-id
  (import sig-spec ...)
  (export sig-spec ...)
  init-depends-decl
  unit-body-expr-or-defn
  ...)
syntax
(compound-unit/infer
  (import infer-link-import ...)
  (export infer-link-export ...)
  (link infer-linkage-decl ...))
 
 infer-link-import = sig-id
                   | (link-id : sig-id)
                      
 infer-link-export = link-id
                   | sig-id
                      
infer-linkage-decl = ((link-binding ...) unit-id
                                         tagged-link-id ...)
                   | unit-id
syntax
(define-compound-unit id
  (import link-binding ...)
  (export link-id ...)
  (link linkage-decl ...))
syntax
(define-compound-unit/infer id
  (import link-binding ...)
  (export infer-link-export ...)
  (link infer-linkage-decl ...))
syntax
(invoke-unit/infer unit-spec)
 
unit-spec = unit-id
          | (link link-unit-id ...)
syntax
(define-values/invoke-unit/infer maybe-exports unit-spec)
 
maybe-exports = 
              | (export sig-sepc ...)
                 
    unit-spec = unit-id
              | (link link-unit-id ...)
syntax
(unit-from-context sig-spec)
syntax
(define-unit-from-context id sig-spec)
syntax
(Unit
  (import sig-id ...)
  (export sig-id ...)
  optional-init-depend-clause
  optional-body-type-clause)
 
optional-init-depend-clause = 
                            | (init-depend sig-id ...)
                               
  optional-body-type-clause = 
                            | type
                            | (Values type ...)
syntax
UnitTop
syntax
(require/typed m rt-clause ...)
 
    rt-clause = [maybe-renamed t]
              | [#:struct name ([f : t] ...)
                     struct-option ...]
              | [#:struct (name parent) ([f : t] ...)
                     struct-option ...]
              | [#:opaque t pred]
              | [#:signature name ([id : t] ...)]
                 
maybe-renamed = id
              | (orig-id new-id)
                 
struct-option = #:constructor-name constructor-id
              | #:extra-constructor-name constructor-id
procedure
(assert v) -> A
  v : (U #f A)
(assert v p?) -> B
  v : A
  p? : (A -> Any : B)
syntax
(with-asserts ([id maybe-pred] ...) body ...+)
 
maybe-pred = 
           | predicate
procedure
(defined? v) -> boolean?
  v : any/c
procedure
(index? v) -> boolean?
  v : any/c
syntax
(typecheck-fail orig-stx maybe-msg maybe-id)
 
maybe-msg = 
          | msg-string
             
 maybe-id = 
          | #:covered-id id
syntax
(assert-typecheck-fail body-expr)
(assert-typecheck-fail body-expr #:result result-expr)
syntax
(require/untyped-contract maybe-begin module [name subtype] ...)
 
maybe-begin = 
            | (begin expr ...)
syntax
(define-typed/untyped-identifier name typed-name untyped-name)
syntax
(define-typed/untyped-identifier name deep-name untyped-name shallow-name optional-name)
procedure
(syntax-local-typed-context?) -> boolean?
syntax
(:type maybe-verbose t)
 
maybe-verbose = 
              | #:verbose
syntax
(:print-type e)
syntax
(:query-type/args f t ...)
syntax
(:query-type/result f t)
syntax
(:kind e)
syntax
(with-type result-spec fv-clause body ...+)
(with-type export-spec fv-clause body ...+)
 
  fv-clause = 
            | #:freevars ([id fv-type] ...)
               
result-spec = #:result type
               
export-spec = ([export-id export-type] ...)
syntax
(unsafe-require/typed m rt-clause ...)
syntax
(unsafe-provide provide-spec ...)
syntax
(unsafe-require/typed/provide m rt-clause ...)
syntax
(lambda: formals maybe-ret . body)
 
maybe-ret = 
          | : type
             
  formals = ([v : t] ...)
          | ([v : t] ... v : t *)
          | ([v : t] ... v : t ooo bound)
syntax
(λ: formals maybe-ret . body)
syntax
(plambda: (a ...) formals maybe-ret . body)
(plambda: (a ... b ooo) formals maybe-ret . body)
syntax
(opt-lambda: formals maybe-ret . body)
 
formals = ([v : t] ... [v : t default] ...)
        | ([v : t] ... [v : t default] ... v : t *)
        | ([v : t] ... [v : t default] ... v : t ooo bound)
syntax
(popt-lambda: (a ...) formals maybe-ret . body)
(popt-lambda: (a ... a ooo) formals maybe-ret . body)
syntax
case-lambda:
syntax
(pcase-lambda: (a ...) [formals body] ...)
(pcase-lambda: (a ... b ooo) [formals body] ...)
syntax
(let: ([v : t e] ...) . body)
(let: loop : t0 ([v : t e] ...) . body)
syntax
(plet: (a ...) ([v : t e] ...) : t0 . body)
syntax
(letrec: ([v : t e] ...) . body)
syntax
(let*: ([v : t e] ...) . body)
syntax
(let-values: ([([v : t] ...) e] ...) . body)
syntax
(letrec-values: ([([v : t] ...) e] ...) . body)
syntax
(let*-values: ([([v : t] ...) e] ...) . body)
syntax
(let/cc: v : t . body)
syntax
(let/ec: v : t . body)
syntax
(define: v : t e)
(define: (a ...) v : t e)
(define: (a ... a ooo) v : t e)
(define: (f . formals) : t . body)
(define: (a ...) (f . formals) : t . body)
(define: (a ... a ooo) (f . formals) : t . body)
syntax
(define-struct/exec name-spec ([f : t] ...) [e : proc-t] maybe-type-name)
 
      name-spec = name-id
                | (name-id parent)
                   
maybe-type-name = 
                | #:type-name type-id
syntax
struct:
syntax
define-struct:
syntax
define-struct/exec:
syntax
for:
syntax
for*/and:
syntax
for*/first:
syntax
for*/flvector:
syntax
for*/extflvector:
syntax
for*/fold:
syntax
for*/foldr:
syntax
for*/hash:
syntax
for*/hasheq:
syntax
for*/hasheqv:
syntax
for*/hashalw:
syntax
for*/last:
syntax
for*/list:
syntax
for*/lists:
syntax
for*/set:
syntax
for*/or:
syntax
for*/product:
syntax
for*/sum:
syntax
for*/vector:
syntax
for*:
syntax
for/and:
syntax
for/first:
syntax
for/flvector:
syntax
for/extflvector:
syntax
for/fold:
syntax
for/foldr:
syntax
for/hash:
syntax
for/hasheq:
syntax
for/hasheqv:
syntax
for/hashalw:
syntax
for/last:
syntax
for/list:
syntax
for/lists:
syntax
for/set:
syntax
for/or:
syntax
for/product:
syntax
for/sum:
syntax
for/vector:
syntax
do:
syntax
define-type-alias
syntax
define-typed-struct
syntax
require/opaque-type
syntax
require-typed-struct
syntax
require-typed-struct/provide
syntax
pdefine:
syntax
(pred t)
type constructor
Un
syntax
mu
type constructor
Tuple
type constructor
Parameter
type constructor
Pair
type constructor
values
syntax
(require/typed m rt-clause ...)
 
    rt-clause = [r t]
              | [struct name ([f : t] ...)
                     struct-option ...]
              | [struct (name parent) ([f : t] ...)
                     struct-option ...]
              | [opaque t pred]
                 
struct-option = #:constructor-name constructor-id
              | #:extra-constructor-name constructor-id
syntax
require-typed-struct
syntax
(declare-refinement id)
syntax
(Refinement id)
syntax
(define-typed-struct/exec forms ...)
syntax
(define-new-subtype name (constructor t))
syntax
(Refine [id : type] proposition)
 
    proposition = Top
                | Bot
                | (: symbolic-object type)
                | (! symbolic-object type)
                | (and proposition ...)
                | (or proposition ...)
                | (when proposition proposition)
                | (unless proposition proposition)
                | (if proposition proposition proposition)
                | (linear-comp symbolic-object symbolic-object)
                   
    linear-comp = <
                | <=
                | =
                | >=
                | >
                   
symbolic-object = exact-integer
                | symbolic-path
                | (+ symbolic-object ...)
                | (- symbolic-object ...)
                | (* exact-integer symbolic-object)
                   
  symbolic-path = id
                | (path-elem symbolic-path)
                   
      path-elem = car
                | cdr
                | vector-length
syntax
(! sym-obj type)
syntax
(-> ([id : opt-deps arg-type] ...)
    opt-pre
    range-type
    opt-props)
 
    opt-deps = 
             | (id ...)
                
     opt-pre = 
             | #:pre (id ...) prop
                
   opt-props = 
             | opt-pos-prop opt-neg-prop opt-obj
                
opt-pos-prop = 
             | #:+ prop
                
opt-neg-prop = 
             | #:- prop
                
     opt-obj = 
             | #:object obj
