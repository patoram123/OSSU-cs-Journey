194401
((3) 0 () 144 ((q quote #%kernel) (q lib "racket/unsafe/ops.rkt") (q lib "racket/dict.rkt") (q lib "racket/require-transform.rkt") (q lib "racket/system.rkt") (q lib "racket/function.rkt") (q lib "racket/private/base.rkt") (q lib "racket/stream.rkt") (q lib "racket/list.rkt") (q lib "racket/private/class-internal.rkt") (q lib "racket/vector.rkt") (q lib "racket/fixnum.rkt") (q lib "racket/sandbox.rkt") (q lib "racket/set.rkt") (q lib "racket/place.rkt") (q lib "racket/port.rkt") (q lib "racket/extflonum.rkt") (q lib "racket/file.rkt") (q lib "racket/format.rkt") (q lib "racket/contract/collapsible.rkt") (q lib "racket/tcp.rkt") (q lib "racket/linklet.rkt") (q lib "racket/sequence.rkt") (q lib "racket/contract/base.rkt") (q lib "racket/provide-transform.rkt") (q lib "racket/pretty.rkt") (q lib "racket/contract/private/misc.rkt") (q lib "racket/private/letstx-scheme.rkt") (q 308474 . 17) (q lib "racket/string.rkt") (q lib "racket/private/more-scheme.rkt") (q lib "racket/control.rkt") (q lib "racket/generic.rkt") (q 308997 . 5) (q lib "racket/trait.rkt") (q 241119 . 5) (q 240367 . 9) (q lib "racket/udp.rkt") (q lib "racket/class.rkt") (q lib "racket/trace.rkt") (q lib "racket/contract/private/guts.rkt") (q lib "racket/unit.rkt") (q lib "racket/private/list.rkt") (q lib "racket/private/misc.rkt") (q lib "racket/flonum.rkt") (q 161625 . 4) (q lib "racket/serialize.rkt") (q 256031 . 6) (q lib "racket/match.rkt") (q lib "racket/private/stxcase-scheme.rkt") (q 417723 . 40) (q lib "racket/path.rkt") (q 257604 . 5) (q lib "racket/contract/private/base.rkt") (q lib "racket/splicing.rkt") (q lib "racket/require.rkt") (q lib "racket/future.rkt") (q lib "racket/contract.rkt") (q 258089 . 4) (q 260499 . 9) (q 481087 . 23) (q lib "racket/contract/private/prop.rkt") (q lib "racket/random.rkt") (q 481747 . 5) (q lib "racket/private/qqstx.rkt") (q lib "racket/promise.rkt") (q lib "racket/contract/private/blame.rkt") (q lib "racket/runtime-path.rkt") (q 310809 . 8) (q 259870 . 5) (q 225255 . 4) (q 260024 . 4) (q lib "racket/async-channel.rkt") (q lib "racket/struct-info.rkt") (q 256221 . 4) (q lib "racket/engine.rkt") (q lib "racket/syntax.rkt") (q 427221 . 6) (q lib "racket/private/serialize.rkt") (q 258911 . 7) (q lib "racket/date.rkt") (q lib "racket/contract/combinator.rkt") (q lib "racket/math.rkt") (q 259130 . 4) (q 258680 . 5) (q 257795 . 5) (q 258521 . 4) (q 259478 . 4) (q lib "racket/phase+space.rkt") (q 258232 . 4) (q lib "racket/contract/private/opt.rkt") (q lib "racket/contract/private/ds.rkt") (q lib "racket/unit-exptime.rkt") (q lib "racket/generator.rkt") (q 240209 . 5) (q 259256 . 5) (q lib "racket/lazy-require.rkt") (q 256777 . 5) (q lib "racket/contract/private/vector.rkt") (q lib "racket/cmdline.rkt") (q lib "racket/logging.rkt") (q 428427 . 6) (q lib "racket/bool.rkt") (q lib "racket/contract/region.rkt") (q 257296 . 5) (q lib "racket/performance-hint.rkt") (q 190728 . 3) (q lib "racket/include.rkt") (q 256957 . 4) (q 170250 . 3) (q lib "racket/os.rkt") (q 256454 . 4) (q lib "racket/fasl.rkt") (q 240966 . 5) (q 257956 . 4) (q lib "racket/struct.rkt") (q lib "racket/private/map.rkt") (q 347769 . 29) (q 256603 . 5) (q 259616 . 4) (q 257120 . 5) (q 260153 . 4) (q lib "racket/unsafe/undefined.rkt") (q lib "racket/contract/private/hash.rkt") (q 241347 . 4) (q 259750 . 4) (q 256326 . 4) (q lib "racket/contract/private/box.rkt") (q lib "racket/contract/parametric.rkt") (q 258364 . 4) (q lib "racket/hash.rkt") (q 420238 . 5) (q lib "racket/enter.rkt") (q lib "racket/contract/private/struct-dc.rkt") (q lib "racket/bytes.rkt") (q lib "racket/keyword-transform.rkt") (q lib "racket/stxparam.rkt") (q lib "racket/provide.rkt") (q 257457 . 4) (q 426855 . 5) (q lib "racket/require-syntax.rkt") (q lib "racket/provide-syntax.rkt") (q lib "racket/contract/private/provide.rkt") (q lib "racket/stxparam-exptime.rkt")) () (h ! (equal) ((c def c (c (? . 0) q write-special)) q (360389 . 4)) ((c def c (c (? . 4) q system)) q (472686 . 4)) ((c def c (c (? . 0) q exn:fail:filesystem:errno-errno)) c (? . 84)) ((c def c (c (? . 10) q vector-split-at-right)) q (110102 . 4)) ((c def c (c (? . 0) q struct:exn:break:hang-up)) c (? . 71)) ((c def c (c (? . 6) q exn:fail:filesystem)) c (? . 89)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-key)) q (505470 . 5)) ((c def c (c (? . 0) q evt?)) q (272719 . 3)) ((c def c (c (? . 132) q dynamic-enter!)) q (519850 . 7)) ((c def c (c (? . 8) q tenth)) q (99190 . 3)) ((c def c (c (? . 1) q unsafe-fx-)) q (491157 . 4)) ((c def c (c (? . 2) q dict-map)) q (140606 . 4)) ((c form c (c (? . 7) q stream)) q (135660 . 2)) ((c form c (c (? . 38) q case->m)) q (184884 . 2)) ((c def c (c (? . 0) q raise-arity-mask-error)) q (252118 . 5)) ((c def c (c (? . 0) q vector-set-performance-stats!)) q (486877 . 5)) ((c def c (c (? . 0) q struct-type-info)) q (416077 . 11)) ((c def c (c (? . 2) q dict-clear!)) q (141219 . 3)) ((c def c (c (? . 0) q variable-reference-from-unsafe?)) q (385973 . 3)) ((c def c (c (? . 2) q dict-iterate-next)) q (139178 . 4)) ((c form c (c (? . 0) q begin-for-syntax)) q (14289 . 2)) ((c def c (c (? . 1) q unsafe-list-tail)) q (497086 . 4)) ((q form ((lib "racket/block.rkt") block)) q (19407 . 2)) ((c def c (c (? . 16) q extflround)) q (42586 . 3)) ((c def c (c (? . 0) q current-continuation-marks)) q (267644 . 5)) ((c def c (c (? . 17) q preferences-lock-file-mode)) q (457424 . 2)) ((c def c (c (? . 0) q hash-iterate-key+value)) q (122554 . 4)) ((c def c (c (? . 73) q prop:struct-field-info)) q (174325 . 2)) ((c def c (c (? . 0) q printf)) q (366175 . 4)) ((c def c (c (? . 0) q cdar)) q (96173 . 3)) ((c def c (c (? . 1) q unsafe-vector-length)) q (497832 . 3)) ((c def c (c (? . 0) q current-readtable)) q (364349 . 4)) ((c def c (c (? . 0) q thread-suspend-evt)) q (272270 . 3)) ((c def c (c (? . 3) q import)) c (? . 28)) ((c def c (c (? . 0) q raise)) q (246241 . 4)) ((c def c (c (? . 22) q sequence-ref)) q (133575 . 4)) ((c def c (c (? . 37) q udp-connect!)) q (462702 . 7)) ((c def c (c (? . 0) q string-locale-ci<?)) q (50283 . 4)) ((c def c (c (? . 3) q import-source-mode)) c (? . 33)) ((c def c (c (? . 0) q continuation-mark-set->context)) q (270085 . 5)) ((q form ((lib "racket/unreachable.rkt") with-assert-unreachable)) q (271104 . 3)) ((c def c (c (? . 12) q call-with-trusted-sandbox-configuration)) q (420408 . 3)) ((c def c (c (? . 11) q fxnot)) q (38375 . 3)) ((c def c (c (? . 56) q make-fsemaphore)) q (279777 . 3)) ((c def c (c (? . 5) q arity=?)) q (163709 . 4)) ((c def c (c (? . 4) q system*)) q (472876 . 13)) ((c form c (c (? . 13) q for*/seteqv)) q (149433 . 2)) ((c def c (c (? . 0) q module-path-index-join)) q (394534 . 5)) ((c def c (c (? . 0) q environment-variables-ref)) q (484806 . 5)) ((c form c (c (? . 0) q #%expression)) q (10914 . 2)) ((c def c (c (? . 1) q unsafe-set-box*!)) q (497607 . 4)) ((c def c (c (? . 5) q const)) q (162827 . 3)) ((c form c (c (? . 9) q override)) q (177958 . 2)) ((c def c (c (? . 0) q module-compiled-realm)) q (396921 . 3)) ((c def c (c (? . 6) q make-base-namespace)) q (380233 . 2)) ((c def c (c (? . 0) q impersonate-prompt-tag)) q (404239 . 18)) ((c def c (c (? . 0) q current-subprocess-keep-file-descriptors)) q (472165 . 5)) ((c def c (c (? . 93) q yield)) q (137514 . 3)) ((c def c (c (? . 7) q gen:stream)) q (137207 . 2)) ((c def c (c (? . 24) q prop:provide-pre-transformer)) q (310612 . 2)) ((c def c (c (? . 8) q seventh)) q (99037 . 3)) ((c form c (c (? . 14) q place)) q (282189 . 2)) ((c def c (c (? . 6) q in-input-port-chars)) q (125979 . 3)) ((c def c (c (? . 1) q unsafe-char->integer)) q (496423 . 3)) ((c def c (c (? . 8) q dropf-right)) q (101313 . 4)) ((c def c (c (? . 15) q make-pipe-with-specials)) q (339796 . 7)) ((c def c (c (? . 1) q unsafe-extfl->fx)) q (513872 . 3)) ((c def c (c (? . 0) q sin)) q (25565 . 3)) ((c form c (c (? . 9) q define/augment-final)) q (179478 . 3)) ((c def c (c (? . 20) q tcp-accept-ready?)) q (461400 . 3)) ((c def c (c (? . 10) q vector-drop-right)) q (109871 . 4)) ((c form c (c (? . 39) q trace)) q (520426 . 2)) ((c def c (c (? . 6) q prop:procedure)) q (161761 . 2)) ((c def c (c (? . 0) q primitive-closure?)) q (162626 . 3)) ((c def c (c (? . 0) q module-compiled-language-info)) q (396595 . 4)) ((c def c (c (? . 49) q generate-temporaries)) q (291664 . 3)) ((c def c (c (? . 82) q pi)) q (32371 . 2)) ((c form c (c (? . 11) q for/fxvector)) q (40900 . 2)) ((c def c (c (? . 1) q unsafe-fxabs)) q (491556 . 3)) ((c def c (c (? . 18) q ~e)) q (57037 . 25)) ((c def c (c (? . 0) q string-port?)) q (328254 . 3)) ((c def c (c (? . 8) q shuffle)) q (104307 . 3)) ((c def c (c (? . 12) q set-eval-handler)) q (426703 . 4)) ((c def c (c (? . 0) q vector-set!)) q (107123 . 5)) ((c def c (c (? . 0) q read-string)) q (350127 . 4)) ((c form c (c (? . 5) q thunk)) q (162939 . 2)) ((c def c (c (? . 11) q fxand)) q (38204 . 3)) ((c def c (c (? . 0) q length)) q (92586 . 3)) ((c def c (c (? . 13) q set-rest)) q (152204 . 3)) ((c def c (c (? . 0) q hash-ref-key)) q (118583 . 7)) ((c def c (c (? . 92) q unit-static-signatures)) q (198382 . 9)) ((c def c (c (? . 0) q impersonator-property-accessor-procedure?)) q (412714 . 3)) ((c form c (c (? . 14) q place*)) q (282220 . 9)) ((c def c (c (? . 0) q raise-arity-error)) q (251252 . 9)) ((c def c (c (? . 6) q arity-at-least)) c (? . 45)) ((c def c (c (? . 0) q hash-set!)) q (117784 . 5)) ((c form c (c (? . 9) q rename-inner)) q (178407 . 2)) ((c def c (c (? . 0) q syntax-taint)) q (314125 . 3)) ((c def c (c (? . 2) q dict-update)) q (140327 . 8)) ((c form c (c (? . 0) q module*)) q (1695 . 3)) ((c form c (c (? . 9) q pubment*)) q (178477 . 2)) ((c def c (c (? . 0) q values)) q (246074 . 3)) ((c def c (c (? . 0) q semaphore-wait)) q (274990 . 3)) ((c def c (c (? . 51) q path-only)) q (443080 . 3)) ((c def c (c (? . 21) q eval-linklet)) q (431479 . 3)) ((c def c (c (? . 6) q apply)) q (157686 . 6)) ((c def c (c (? . 0) q exact?)) q (22831 . 3)) ((c def c (c (? . 6) q real->decimal-string)) q (30235 . 4)) ((c def c (c (? . 0) q make-shared-bytes)) q (65178 . 4)) ((c def c (c (? . 0) q round)) q (24237 . 3)) ((c form c (c (? . 6) q for*/hasheq)) q (16952 . 2)) ((c def c (c (? . 0) q chaperone?)) q (399145 . 3)) ((c form c (c (? . 6) q submod)) q (5390 . 4)) ((c def c (c (? . 0) q file-or-directory-stat)) q (445910 . 5)) ((c def c (c (? . 0) q syntax-local-submodules)) q (305609 . 2)) ((c def c (c (? . 0) q call-with-values)) q (246126 . 4)) ((c form c (c (? . 9) q send*)) q (181436 . 5)) ((c def c (c (? . 15) q reencode-input-port)) q (340939 . 16)) ((c def c (c (? . 61) q build-contract-property)) q (231965 . 50)) ((c def c (c (? . 0) q output-port?)) q (319882 . 3)) ((c form c (c (? . 6) q for-syntax)) q (7051 . 2)) ((c def c (c (? . 16) q extflvector)) q (44025 . 3)) ((c def c (c (? . 1) q unsafe-flatan)) q (494831 . 3)) ((c def c (c (? . 11) q fxquotient)) q (37919 . 4)) ((c def c (c (? . 0) q quotient/remainder)) q (23689 . 4)) ((c def c (c (? . 0) q cdaddr)) q (98057 . 3)) ((c def c (c (? . 13) q set-copy-clear)) q (152433 . 3)) ((c def c (c (? . 0) q stencil-vector-ref)) q (113013 . 4)) ((c def c (c (? . 0) q path->bytes)) q (437467 . 3)) ((c def c (c (? . 1) q unsafe-f64vector-ref)) q (500567 . 4)) ((c def c (c (? . 19) q collapsible-leaf/c-missing-party-list)) c (? . 36)) ((c def c (c (? . 0) q regexp-match-peek)) q (80618 . 15)) ((c def c (c (? . 0) q local-transformer-expand)) q (298975 . 11)) ((c def c (c (? . 0) q memory-order-acquire)) q (282888 . 2)) ((c def c (c (? . 0) q integer-sqrt)) q (25215 . 3)) ((c def c (c (? . 15) q merge-input)) q (340197 . 5)) ((c def c (c (? . 0) q identifier-prune-to-source-module)) q (291984 . 3)) ((c def c (c (? . 0) q executable-yield-handler)) q (270920 . 4)) ((c def c (c (? . 0) q current-thread-initial-stack-size)) q (486712 . 4)) ((c def c (c (? . 80) q julian/scaliger->string)) q (484070 . 3)) ((c def c (c (? . 17) q file->string)) q (448831 . 4)) ((c def c (c (? . 18) q ~r)) q (58273 . 31)) ((c def c (c (? . 11) q fx=)) q (39188 . 4)) ((c def c (c (? . 29) q string-split)) q (52251 . 9)) ((c def c (c (? . 0) q exn:missing-module?)) q (260995 . 3)) ((c def c (c (? . 2) q dict-mutable?)) q (138143 . 3)) ((c def c (c (? . 25) q pretty-print-columns)) q (370321 . 5)) ((c def c (c (? . 0) q string<=?)) q (48513 . 4)) ((c form c (c (? . 13) q for/setalw)) q (149282 . 2)) ((c def c (c (? . 26) q flat-contract-with-explanation)) q (199354 . 6)) ((c form c (c (? . 30) q with-handlers)) q (254584 . 3)) ((c form c (c (? . 0) q define-syntaxes)) q (13679 . 2)) ((c def c (c (? . 1) q unsafe-fxvector-set!)) q (500189 . 5)) ((c def c (c (? . 0) q string-grapheme-span)) q (50647 . 5)) ((c form c (c (? . 13) q for*/mutable-setalw)) q (149945 . 2)) ((c def c (c (? . 0) q namespace-base-phase)) q (380745 . 3)) ((c def c (c (? . 0) q impersonator-of?)) q (399201 . 4)) ((c def c (c (? . 23) q one-of/c)) q (201130 . 3)) ((c def c (c (? . 19) q struct:collapsible-count-property)) c (? . 35)) ((c def c (c (? . 20) q tcp-accept-evt)) q (461618 . 3)) ((c def c (c (? . 0) q datum->syntax)) q (288687 . 20)) ((c def c (c (? . 21) q instance-name)) q (433759 . 3)) ((c def c (c (? . 12) q sandbox-propagate-exceptions)) q (422333 . 4)) ((c def c (c (? . 0) q print)) q (365495 . 5)) ((c def c (c (? . 2) q make-custom-hash)) q (143780 . 14)) ((c def c (c (? . 22) q sequence-tail)) q (133672 . 4)) ((c def c (c (? . 0) q chaperone-vector)) q (407202 . 14)) ((c def c (c (? . 21) q instance-unset-variable!)) q (434583 . 4)) ((c form c (c (? . 32) q chaperone-generics)) q (170763 . 4)) ((c def c (c (? . 14) q place-wait)) q (281362 . 3)) ((c def c (c (? . 0) q bytes-convert)) q (68914 . 21)) ((c def c (c (? . 0) q exn:fail:read?)) c (? . 85)) ((c form c (c (? . 9) q inherit-field)) q (177765 . 2)) ((c form c (c (? . 34) q trait-exclude-field)) q (183573 . 2)) ((c form c (c (? . 6) q for/product)) q (15765 . 2)) ((c def c (c (? . 0) q list->bytes)) q (65109 . 3)) ((c def c (c (? . 0) q struct:date*)) c (? . 63)) ((c def c (c (? . 88) q phase+space-shift+)) q (319551 . 4)) ((c form c (c (? . 9) q field)) q (177733 . 2)) ((c def c (c (? . 23) q integer-in)) q (200749 . 4)) ((c def c (c (? . 0) q read-char)) q (349480 . 3)) ((c def c (c (? . 2) q dict-count)) q (141022 . 3)) ((c def c (c (? . 6) q exn:fail:syntax:missing-module)) c (? . 52)) ((c def c (c (? . 0) q current-logger)) q (477735 . 4)) ((c def c (c (? . 1) q unsafe-extflcos)) q (513165 . 3)) ((c form c (c (? . 64) q quasisyntax/loc)) q (286539 . 14)) ((c def c (c (? . 1) q unsafe-fxand)) q (491615 . 3)) ((c def c (c (? . 14) q place-channel-put)) q (281714 . 4)) ((c def c (c (? . 24) q syntax-local-provide-certifier)) q (311049 . 4)) ((c def c (c (? . 0) q module-compiled-submodules)) q (395298 . 13)) ((c form c (c (? . 46) q define-serializable-struct/versions)) q (377527 . 4)) ((c def c (c (? . 9) q interface?)) q (188870 . 3)) ((c def c (c (? . 0) q chaperone-continuation-mark-key)) q (411974 . 13)) ((c def c (c (? . 2) q dict-clear)) q (141160 . 3)) ((c form c (c (? . 27) q let*)) q (11955 . 2)) ((c def c (c (? . 15) q special-filter-input-port)) q (346341 . 8)) ((c def c (c (? . 0) q prop:impersonator-of)) q (405579 . 2)) ((c def c (c (? . 0) q real->floating-point-bytes)) q (31818 . 12)) ((c def c (c (? . 25) q pretty-print-pre-print-hook)) q (373078 . 5)) ((c def c (c (? . 23) q predicate/c)) q (212505 . 2)) ((c def c (c (? . 1) q unsafe-set-immutable-cdr!)) q (497298 . 4)) ((c def c (c (? . 26) q >=/c)) q (200535 . 3)) ((c form c (c (? . 27) q else)) q (13068 . 2)) ((c form c (c (? . 11) q for*/fxvector)) q (40966 . 9)) ((c def c (c (? . 6) q exn:fail:syntax:unbound)) c (? . 138)) ((c def c (c (? . 0) q make-semaphore)) q (274825 . 3)) ((c def c (c (? . 100) q log-level/c)) q (479604 . 3)) ((c def c (c (? . 17) q group-execute-bit)) q (459941 . 2)) ((c def c (c (? . 3) q make-import)) c (? . 28)) ((c def c (c (? . 16) q extflsin)) q (42843 . 3)) ((c def c (c (? . 24) q make-provide-pre-transformer)) q (310391 . 5)) ((c def c (c (? . 29) q string-join)) q (51174 . 11)) ((c def c (c (? . 0) q variable-reference->module-base-phase)) q (385739 . 3)) ((c def c (c (? . 26) q promise/c)) q (206029 . 3)) ((c form c (c (? . 91) q define-contract-struct)) q (213025 . 2)) ((c def c (c (? . 0) q raise-result-arity-error*)) q (252936 . 11)) ((c def c (c (? . 0) q error-syntax->string-handler)) q (255723 . 9)) ((q def ((lib "racket/exn.rkt") exn->string)) q (261176 . 3)) ((c def c (c (? . 0) q bitwise-and)) q (26422 . 3)) ((c def c (c (? . 11) q make-fxvector)) q (40026 . 4)) ((c form c (c (? . 31) q prompt0-at)) q (266867 . 2)) ((c form c (c (? . 23) q struct-guard/c)) q (214215 . 2)) ((c def c (c (? . 0) q channel?)) q (274325 . 3)) ((c def c (c (? . 0) q struct-type-authentic?)) q (416464 . 3)) ((c def c (c (? . 15) q read-string-evt)) q (347201 . 4)) ((c form c (c (? . 6) q for*/first)) q (17407 . 2)) ((c def c (c (? . 40) q contract?)) q (235969 . 3)) ((c def c (c (? . 9) q class-info)) q (190457 . 10)) ((c form c (c (? . 27) q quasiquote)) q (19246 . 2)) ((c form c (c (? . 9) q class-field-mutator)) q (182132 . 2)) ((c def c (c (? . 48) q prop:legacy-match-expander)) q (245431 . 2)) ((c def c (c (? . 6) q exn:fail:contract:variable)) c (? . 120)) ((c def c (c (? . 13) q set-eqv?)) q (146482 . 3)) ((c def c (c (? . 0) q global-port-print-handler)) q (369096 . 6)) ((c def c (c (? . 13) q set-add!)) q (151717 . 4)) ((c def c (c (? . 0) q uncaught-exception-handler)) q (254445 . 4)) ((c def c (c (? . 1) q unsafe-string-ref)) q (498837 . 5)) ((c def c (c (? . 12) q sandbox-namespace-specs)) q (422467 . 6)) ((c form c (c (? . 30) q log-info)) q (479230 . 3)) ((c def c (c (? . 0) q peek-char-or-special)) q (356611 . 10)) ((c def c (c (? . 0) q struct:exn:break)) c (? . 69)) ((c def c (c (? . 2) q in-dict-values)) q (141581 . 3)) ((c def c (c (? . 19) q has-impersonator-prop:collapsible?)) q (240794 . 3)) ((c def c (c (? . 0) q peek-char)) q (356251 . 4)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-next)) q (503131 . 4)) ((c form c (c (? . 133) q struct/c)) q (203354 . 2)) ((c def c (c (? . 31) q spawn)) q (267070 . 3)) ((c def c (c (? . 14) q dynamic-place*)) q (280736 . 14)) ((c def c (c (? . 32) q struct:exn:fail:support)) c (? . 109)) ((c def c (c (? . 0) q module-provide-protected?)) q (384634 . 5)) ((c form c (c (? . 30) q case)) q (13137 . 5)) ((c def c (c (? . 3) q import-source)) c (? . 33)) ((c def c (c (? . 13) q set-implements?)) q (150705 . 4)) ((c def c (c (? . 78) q serializable?)) q (375502 . 3)) ((c def c (c (? . 0) q custodian-box-value)) q (415056 . 3)) ((c def c (c (? . 7) q prop:stream)) q (137234 . 2)) ((c form c (c (? . 13) q for*/setalw)) q (149485 . 2)) ((c def c (c (? . 5) q negate)) q (162996 . 3)) ((c def c (c (? . 12) q exn:fail:sandbox-terminated-reason)) c (? . 131)) ((c def c (c (? . 0) q simplify-path)) q (440184 . 4)) ((c form c (c (? . 34) q trait-exclude)) q (183534 . 2)) ((c def c (c (? . 26) q make-none/c)) q (236937 . 3)) ((c form c (c (? . 54) q splicing-let-values)) q (312455 . 2)) ((c form c (c (? . 9) q super)) q (179784 . 3)) ((c form c (c (? . 6) q relative-in)) q (4824 . 2)) ((c def c (c (? . 19) q merge)) q (238928 . 6)) ((c form c (c (? . 53) q recursive-contract)) q (237011 . 10)) ((c form c (c (? . 41) q define-unit)) q (194517 . 7)) ((c def c (c (? . 0) q identifier-transformer-binding)) q (294479 . 15)) ((c form c (c (? . 9) q define/override)) q (179060 . 3)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-key+value)) q (510372 . 5)) ((c def c (c (? . 0) q port-count-lines!)) q (321605 . 3)) ((c def c (c (? . 0) q char-lower-case?)) q (71991 . 3)) ((c def c (c (? . 0) q syntax-bound-phases)) q (297508 . 3)) ((c def c (c (? . 2) q dict-empty?)) q (140959 . 3)) ((c form c (c (? . 30) q let/cc)) q (264933 . 2)) ((c def c (c (? . 0) q string-locale-ci=?)) q (50179 . 4)) ((c def c (c (? . 0) q syntax-local-context)) q (305254 . 3)) ((c def c (c (? . 8) q index-of)) q (99733 . 5)) ((c def c (c (? . 0) q expand-once)) q (314451 . 4)) ((c def c (c (? . 0) q regexp-match-peek-positions-immediate)) q (82869 . 19)) ((c def c (c (? . 19) q collapsible-count-property?)) c (? . 35)) ((c def c (c (? . 0) q syntax-local-transforming-module-provides?)) q (307368 . 2)) ((c def c (c (? . 19) q collapsible-leaf/c-blame-list)) c (? . 36)) ((c def c (c (? . 43) q println)) q (365895 . 5)) ((c def c (c (? . 6) q namespace-anchor?)) q (380318 . 3)) ((c def c (c (? . 81) q make-flat-contract)) q (220254 . 32)) ((c def c (c (? . 0) q struct:exn:fail:read:eof)) c (? . 114)) ((c def c (c (? . 0) q number?)) q (21757 . 3)) ((c def c (c (? . 0) q caaddr)) q (97257 . 3)) ((c def c (c (? . 0) q environment-variables-set!)) q (484990 . 10)) ((c def c (c (? . 0) q namespace-require/constant)) q (382594 . 5)) ((c def c (c (? . 0) q syntax-local-introduce)) q (306595 . 3)) ((c form c (c (? . 6) q for/foldr)) q (16303 . 9)) ((c def c (c (? . 37) q udp-send-to/enable-break)) q (464316 . 13)) ((c def c (c (? . 0) q peek-byte)) q (356431 . 4)) ((c def c (c (? . 0) q set-mcar!)) q (106446 . 4)) ((c form c (c (? . 31) q control-at)) q (266527 . 2)) ((c def c (c (? . 0) q chaperone-box)) q (408344 . 12)) ((c def c (c (? . 2) q in-dict-pairs)) q (141648 . 3)) ((c def c (c (? . 0) q port-commit-peeked)) q (357779 . 6)) ((c def c (c (? . 29) q string-suffix?)) q (53240 . 4)) ((c def c (c (? . 0) q dynamic-require-for-syntax)) q (397343 . 7)) ((c form c (c (? . 6) q lambda)) q (11223 . 2)) ((c form c (c (? . 6) q for/hash)) q (15320 . 2)) ((c def c (c (? . 0) q current-directory)) q (447217 . 4)) ((c def c (c (? . 0) q module->language-info)) q (397804 . 6)) ((c def c (c (? . 0) q syntax-local-make-delta-introducer)) q (305942 . 3)) ((c def c (c (? . 6) q hash->list)) q (120978 . 4)) ((c def c (c (? . 62) q crypto-random-bytes)) q (28697 . 3)) ((c def c (c (? . 0) q struct:exn)) c (? . 47)) ((c def c (c (? . 8) q filter-map)) q (103544 . 4)) ((c def c (c (? . 14) q place-kill)) q (281482 . 3)) ((c def c (c (? . 1) q unsafe-extflfloor)) q (512882 . 3)) ((c form c (c (? . 55) q path-up)) q (10585 . 2)) ((c def c (c (? . 25) q pretty-print-exact-as-decimal)) q (370668 . 4)) ((c def c (c (? . 8) q group-by)) q (105022 . 5)) ((c form c (c (? . 31) q reset0)) q (266773 . 2)) ((c def c (c (? . 0) q stencil-vector-set!)) q (113132 . 5)) ((c def c (c (? . 24) q struct:export)) c (? . 68)) ((c def c (c (? . 38) q is-a?/c)) q (188108 . 3)) ((c def c (c (? . 0) q hash-iterate-next)) q (121607 . 5)) ((c def c (c (? . 0) q regexp-max-lookbehind)) q (75306 . 3)) ((c form c (c (? . 6) q for/fold/derived)) q (17787 . 4)) ((c form c (c (? . 6) q #%top-interaction)) q (19372 . 2)) ((c def c (c (? . 0) q unquoted-printing-string)) q (254143 . 3)) ((c def c (c (? . 1) q unsafe-fl>)) q (493799 . 4)) ((c def c (c (? . 6) q hash-set*!)) q (117914 . 5)) ((c def c (c (? . 0) q raise-arguments-error)) q (248648 . 10)) ((c def c (c (? . 13) q set-remove)) q (151796 . 4)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-value)) q (507914 . 4)) ((c def c (c (? . 6) q namespace-anchor->empty-namespace)) q (380381 . 3)) ((c def c (c (? . 19) q struct:collapsible-property)) c (? . 113)) ((c def c (c (? . 6) q syntax-recertify)) q (292082 . 9)) ((c form c (c (? . 6) q except-in)) q (4641 . 2)) ((c form c (c (? . 9) q inherit/inner)) q (178328 . 2)) ((c def c (c (? . 0) q logger?)) q (477177 . 3)) ((c def c (c (? . 21) q hash->linklet-directory)) q (432503 . 3)) ((c def c (c (? . 1) q unsafe-fxior)) q (491679 . 3)) ((c def c (c (? . 5) q curry)) q (163229 . 6)) ((c def c (c (? . 2) q dict-set*)) q (139670 . 5)) ((c def c (c (? . 16) q extflexp)) q (43273 . 3)) ((c form c (c (? . 9) q pubment)) q (177879 . 2)) ((c form c (c (? . 38) q object/c)) q (185093 . 11)) ((c def c (c (? . 0) q port-waiting-peer?)) q (320710 . 3)) ((c form c (c (? . 32) q define-generics)) q (169365 . 22)) ((c def c (c (? . 0) q syntax-local-expand-expression)) q (298763 . 6)) ((c def c (c (? . 7) q stream-empty?)) q (135092 . 3)) ((c def c (c (? . 0) q compile-syntax)) q (390396 . 3)) ((c def c (c (? . 39) q current-trace-notify)) q (520740 . 4)) ((c def c (c (? . 19) q collapsible-ho/c)) c (? . 94)) ((c def c (c (? . 0) q integer-bytes->integer)) q (30378 . 11)) ((c form c (c (? . 6) q for*/list)) q (16651 . 2)) ((c def c (c (? . 42) q remq)) q (93812 . 4)) ((c def c (c (? . 0) q exn:fail:read:non-char?)) c (? . 58)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-first)) q (505168 . 3)) ((c def c (c (? . 2) q dict-map/copy)) q (140722 . 4)) ((c def c (c (? . 6) q make-exn:fail:network)) c (? . 83)) ((c def c (c (? . 26) q evt/c)) q (205788 . 3)) ((c def c (c (? . 6) q for-clause-syntax-protect)) q (18886 . 3)) ((c def c (c (? . 16) q extflmax)) q (42501 . 4)) ((c form c (c (? . 90) q define-opt/c)) q (237510 . 2)) ((c form c (c (? . 6) q for)) q (14464 . 18)) ((c form c (c (? . 65) q delay/idle)) q (262627 . 8)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-key+value)) q (508300 . 5)) ((c def c (c (? . 0) q custodian?)) q (413727 . 3)) ((c def c (c (? . 0) q stencil-vector?)) q (112466 . 3)) ((c def c (c (? . 44) q flrandom)) q (36104 . 3)) ((c form c (c (? . 31) q prompt-at)) q (266479 . 2)) ((c def c (c (? . 6) q make-keyword-procedure)) q (160142 . 5)) ((c form c (c (? . 9) q instantiate)) q (180545 . 2)) ((c form c (c (? . 6) q only-meta-in)) q (4877 . 2)) ((c def c (c (? . 13) q set-union)) q (152678 . 4)) ((c form c (c (? . 40) q with-collapsible-contract-continuation-mark)) q (238739 . 2)) ((c def c (c (? . 25) q pretty-print)) q (369362 . 9)) ((c def c (c (? . 1) q unsafe-char>?)) q (496172 . 4)) ((c def c (c (? . 0) q srcloc-position)) c (? . 59)) ((c def c (c (? . 0) q >)) q (25021 . 4)) ((c def c (c (? . 0) q custom-write?)) q (375134 . 3)) ((c def c (c (? . 0) q prop:authentic)) q (405632 . 2)) ((c form c (c (? . 41) q define-unit/s)) q (196760 . 6)) ((c def c (c (? . 42) q memf)) q (95233 . 4)) ((c def c (c (? . 15) q peek-string!-evt)) c (? . 117)) ((c def c (c (? . 31) q new-prompt)) q (267306 . 2)) ((c def c (c (? . 0) q hash-iterate-key)) q (121751 . 4)) ((c def c (c (? . 0) q open-output-bytes)) q (328580 . 3)) ((c def c (c (? . 43) q string-environment-variable-name?)) q (485910 . 3)) ((c def c (c (? . 17) q make-handle-get-preference-locked)) q (457496 . 16)) ((c def c (c (? . 3) q prop:require-transformer)) q (308351 . 2)) ((c def c (c (? . 44) q flvector-length)) q (36452 . 3)) ((c def c (c (? . 0) q arity-at-least-value)) c (? . 45)) ((c def c (c (? . 0) q byte-pregexp)) q (74903 . 6)) ((c def c (c (? . 44) q shared-flvector)) q (37539 . 3)) ((c def c (c (? . 1) q unsafe-extfl+)) q (511758 . 4)) ((c def c (c (? . 0) q chaperone-struct)) q (406414 . 18)) ((c def c (c (? . 0) q module-compiled-indirect-exports)) q (396411 . 4)) ((c def c (c (? . 0) q prop:equal+hash)) q (21145 . 2)) ((c def c (c (? . 38) q subclass?/c)) q (188284 . 3)) ((c def c (c (? . 12) q put-input)) q (427004 . 6)) ((c def c (c (? . 43) q find-executable-path)) q (443930 . 7)) ((c def c (c (? . 10) q vector-member)) q (110922 . 4)) ((c def c (c (? . 0) q bytes-append)) q (64970 . 3)) ((c def c (c (? . 13) q set/c)) q (150884 . 14)) ((c def c (c (? . 15) q eof-evt)) q (346792 . 3)) ((c form c (c (? . 96) q lazy-require-syntax)) q (19961 . 5)) ((c def c (c (? . 8) q combinations)) q (104361 . 6)) ((c def c (c (? . 16) q extflvector?)) q (43967 . 3)) ((c def c (c (? . 0) q primitive-result-arity)) q (162689 . 3)) ((c form c (c (? . 46) q define-serializable-struct)) q (377017 . 3)) ((c def c (c (? . 1) q unsafe-extflmax)) q (512720 . 4)) ((c form c (c (? . 67) q define-runtime-path)) q (448358 . 5)) ((c def c (c (? . 0) q port-try-file-lock?)) q (327950 . 4)) ((c def c (c (? . 16) q extflonum-available?)) q (41569 . 2)) ((c def c (c (? . 0) q placeholder-set!)) q (105613 . 4)) ((c def c (c (? . 0) q eqv?)) q (20261 . 4)) ((c def c (c (? . 6) q make-exn)) c (? . 47)) ((c def c (c (? . 0) q handle-evt?)) q (274042 . 3)) ((c def c (c (? . 24) q pre-expand-export)) q (309837 . 4)) ((c def c (c (? . 0) q log-all-levels)) q (478731 . 5)) ((c def c (c (? . 13) q in-weak-set)) q (150583 . 3)) ((c def c (c (? . 0) q thread/suspend-to-kill)) q (271307 . 3)) ((c def c (c (? . 1) q unsafe-fx<=)) q (492942 . 4)) ((c form c (c (? . 27) q when)) q (14326 . 2)) ((c def c (c (? . 110) q gethostname)) q (489473 . 2)) ((c def c (c (? . 0) q exact-integer?)) q (22024 . 3)) ((c def c (c (? . 26) q procedure-arity-includes/c)) q (204747 . 3)) ((c def c (c (? . 0) q make-derived-parameter)) q (278548 . 7)) ((c form c (c (? . 48) q ==)) q (245986 . 3)) ((c def c (c (? . 20) q tcp-listen)) q (460125 . 9)) ((c form c (c (? . 9) q private)) q (178195 . 2)) ((c form c (c (? . 9) q public*)) q (178443 . 2)) ((c def c (c (? . 0) q srcloc->string)) q (260856 . 3)) ((c def c (c (? . 0) q set!-transformer?)) q (297604 . 3)) ((c def c (c (? . 6) q member)) q (94747 . 5)) ((c def c (c (? . 0) q syntax-local-value)) q (303605 . 9)) ((c def c (c (? . 37) q udp-send/enable-break)) q (464838 . 9)) ((c def c (c (? . 0) q truncate)) q (24488 . 3)) ((c def c (c (? . 0) q prop:rename-transformer)) q (298212 . 2)) ((c def c (c (? . 13) q set-equal-always?)) q (146419 . 3)) ((c def c (c (? . 12) q sandbox-eval-handlers)) q (424855 . 7)) ((c def c (c (? . 6) q collection-path)) q (517869 . 8)) ((c def c (c (? . 12) q make-module-evaluator)) c (? . 50)) ((c def c (c (? . 0) q peek-byte-or-special)) q (357034 . 12)) ((c form c (c (? . 49) q syntax)) q (284574 . 22)) ((c def c (c (? . 0) q thread-cell-set!)) q (277844 . 4)) ((c def c (c (? . 1) q unsafe-extflexp)) q (513576 . 3)) ((c def c (c (? . 44) q flabs)) q (33963 . 3)) ((c def c (c (? . 15) q read-line-evt)) q (347427 . 5)) ((c def c (c (? . 38) q make-mixin-contract)) q (188010 . 3)) ((c def c (c (? . 0) q syntax-local-phase-level)) q (305356 . 2)) ((c def c (c (? . 12) q make-evaluator)) c (? . 50)) ((c def c (c (? . 43) q load-relative-extension)) q (387893 . 3)) ((c def c (c (? . 22) q sequence/c)) q (134667 . 5)) ((c def c (c (? . 8) q drop)) q (100453 . 4)) ((c def c (c (? . 0) q tan)) q (25665 . 3)) ((c def c (c (? . 12) q set-eval-limits)) q (426502 . 5)) ((c def c (c (? . 18) q ~.s)) q (62266 . 25)) ((c form c (c (? . 9) q override-final)) q (178034 . 2)) ((c def c (c (? . 8) q last)) q (99240 . 3)) ((c def c (c (? . 0) q string-locale>?)) q (50078 . 4)) ((c form c (c (? . 48) q define-match-expander)) q (245283 . 3)) ((c form c (c (? . 6) q for*/foldr)) q (17647 . 4)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-next)) q (509266 . 5)) ((c def c (c (? . 0) q <=)) q (24949 . 4)) ((c def c (c (? . 0) q char=?)) q (70984 . 4)) ((c def c (c (? . 134) q bytes-join)) q (70499 . 4)) ((c def c (c (? . 2) q dict-for-each)) q (140850 . 4)) ((c def c (c (? . 51) q path-has-extension?)) q (441994 . 4)) ((c def c (c (? . 0) q local-transformer-expand/capture-lifts)) q (300118 . 13)) ((c def c (c (? . 0) q string-append-immutable)) q (47942 . 3)) ((c def c (c (? . 0) q eq?)) q (20334 . 4)) ((c def c (c (? . 12) q sandbox-exit-handler)) q (424204 . 4)) ((c def c (c (? . 0) q write-bytes-avail*)) q (359585 . 10)) ((c def c (c (? . 1) q unsafe-make-srcloc)) q (511316 . 11)) ((c def c (c (? . 0) q collect-garbage)) q (490499 . 3)) ((c def c (c (? . 12) q get-output)) c (? . 77)) ((c def c (c (? . 13) q weak-seteq)) q (147817 . 3)) ((c form c (c (? . 9) q send-generic)) q (182229 . 3)) ((c def c (c (? . 0) q namespace-attach-module)) q (383062 . 7)) ((c def c (c (? . 0) q exn:fail:syntax:missing-module?)) c (? . 52)) ((c def c (c (? . 0) q module-compiled-imports)) q (395868 . 5)) ((c def c (c (? . 0) q bytes-copy!)) q (64436 . 11)) ((c def c (c (? . 0) q quotient)) q (23530 . 4)) ((c def c (c (? . 13) q set-add)) q (151632 . 4)) ((c def c (c (? . 0) q string-locale-upcase)) q (50491 . 3)) ((c form c (c (? . 9) q augment-final*)) q (178736 . 2)) ((c def c (c (? . 0) q current-inexact-milliseconds)) q (480858 . 2)) ((c def c (c (? . 0) q mcdr)) q (106398 . 3)) ((c def c (c (? . 57) q contract-random-generate-stash)) q (243440 . 5)) ((c def c (c (? . 0) q make-thread-cell)) q (277663 . 4)) ((c def c (c (? . 0) q namespace-module-registry)) q (383991 . 3)) ((c def c (c (? . 0) q struct-predicate-procedure?)) q (172495 . 3)) ((c def c (c (? . 0) q procedure-arity-includes?)) q (159077 . 5)) ((c def c (c (? . 11) q fxmodulo)) q (38076 . 4)) ((c def c (c (? . 1) q unsafe-struct*-ref)) q (502606 . 4)) ((c def c (c (? . 0) q exact-nonnegative-integer?)) q (22084 . 3)) ((c form c (c (? . 53) q invariant-assertion)) q (215535 . 2)) ((c def c (c (? . 0) q custodian-box?)) q (414996 . 3)) ((c form c (c (? . 23) q ->i)) q (207611 . 60)) ((c form c (c (? . 6) q prefix-out)) q (6647 . 2)) ((c def c (c (? . 0) q syntax->datum)) q (288625 . 3)) ((c def c (c (? . 6) q date)) c (? . 60)) ((c def c (c (? . 6) q random)) q (27154 . 13)) ((c def c (c (? . 0) q variable-reference->namespace)) q (385112 . 3)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-pair)) q (508762 . 4)) ((c def c (c (? . 1) q unsafe-stencil-vector-set!)) q (501830 . 5)) ((c form c (c (? . 54) q splicing-let-syntaxes)) q (312569 . 2)) ((c def c (c (? . 42) q assv)) q (95713 . 4)) ((c def c (c (? . 0) q bytes->list)) q (65038 . 3)) ((c def c (c (? . 0) q hash-set)) q (118055 . 5)) ((c def c (c (? . 0) q continuation-mark-key?)) q (269949 . 3)) ((c form c (c (? . 55) q multi-in)) q (10619 . 8)) ((c def c (c (? . 16) q ->extfl)) q (43482 . 3)) ((c def c (c (? . 0) q write-bytes-avail/enable-break)) q (359969 . 10)) ((c def c (c (? . 9) q object->vector)) q (189231 . 4)) ((c def c (c (? . 9) q make-object)) q (180396 . 4)) ((c def c (c (? . 1) q unsafe-make-flrectangular)) q (495150 . 7)) ((c def c (c (? . 0) q thread-cell-ref)) q (277775 . 3)) ((c form c (c (? . 9) q define-local-member-name)) q (179948 . 2)) ((c def c (c (? . 0) q fprintf)) q (366063 . 5)) ((c def c (c (? . 6) q in-immutable-hash-pairs)) q (128842 . 3)) ((c form c (c (? . 56) q for*/async)) q (279712 . 2)) ((c def c (c (? . 1) q unsafe-flasin)) q (494711 . 3)) ((c def c (c (? . 0) q acos)) q (25766 . 3)) ((c def c (c (? . 44) q ->fl)) q (35380 . 3)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-key)) q (509456 . 5)) ((c def c (c (? . 0) q syntax-position)) q (288066 . 3)) ((c def c (c (? . 57) q contract-random-generate)) q (242617 . 5)) ((c def c (c (? . 6) q chaperone-procedure*)) q (406044 . 11)) ((c def c (c (? . 0) q build-path/convention-type)) q (438820 . 9)) ((c def c (c (? . 0) q port-read-handler)) q (364906 . 10)) ((c def c (c (? . 4) q bytes-no-nuls?)) q (477117 . 3)) ((c form c (c (? . 9) q class*)) q (174874 . 59)) ((c def c (c (? . 0) q syntax-line)) q (287881 . 3)) ((c def c (c (? . 29) q string-append*)) q (51067 . 4)) ((c def c (c (? . 0) q make-immutable-hasheq)) q (117643 . 4)) ((c def c (c (? . 1) q unsafe-assert-unreachable)) q (515881 . 2)) ((c def c (c (? . 0) q struct:exn:fail:read:non-char)) c (? . 58)) ((c def c (c (? . 0) q file-truncate)) q (321462 . 4)) ((c def c (c (? . 17) q socket-type-bits)) q (459305 . 2)) ((c form c (c (? . 6) q #%plain-lambda)) q (11811 . 2)) ((c form c (c (? . 0) q module)) q (1651 . 2)) ((c form c (c (? . 6) q for*/fold/derived)) q (17920 . 4)) ((c def c (c (? . 0) q read-bytes)) q (350283 . 4)) ((c def c (c (? . 0) q syntax-local-lift-provide)) q (305105 . 3)) ((c form c (c (? . 41) q except)) q (193640 . 2)) ((c def c (c (? . 0) q struct:srcloc)) c (? . 59)) ((c def c (c (? . 1) q unsafe-flround)) q (494223 . 3)) ((c def c (c (? . 0) q pregexp)) q (74572 . 6)) ((c def c (c (? . 2) q dict-values)) q (141337 . 3)) ((c def c (c (? . 8) q takef)) q (100654 . 4)) ((c def c (c (? . 0) q *)) q (23364 . 3)) ((c def c (c (? . 76) q record-disappeared-uses)) q (318173 . 4)) ((c def c (c (? . 15) q transplant-output-port)) q (344332 . 19)) ((c def c (c (? . 9) q class?)) q (188818 . 3)) ((c def c (c (? . 12) q sandbox-make-inspector)) q (425319 . 4)) ((c def c (c (? . 0) q box-cas!)) q (114223 . 5)) ((c def c (c (? . 1) q unsafe-fx+/wraparound)) q (492329 . 4)) ((c def c (c (? . 0) q hash-keys-subset?)) q (121110 . 4)) ((c def c (c (? . 102) q symbol=?)) q (21401 . 4)) ((c def c (c (? . 11) q fxpopcount32)) q (38665 . 3)) ((c form c (c (? . 9) q inner)) q (179852 . 3)) ((c form c (c (? . 39) q trace-let)) q (520658 . 2)) ((c def c (c (? . 0) q /)) q (23417 . 6)) ((c def c (c (? . 0) q date-week-day)) c (? . 60)) ((c def c (c (? . 0) q numerator)) q (24574 . 3)) ((c form c (c (? . 6) q for*/foldr/derived)) q (18193 . 4)) ((c def c (c (? . 6) q exn:fail:contract:divide-by-zero)) c (? . 118)) ((c def c (c (? . 0) q caaaar)) q (96957 . 3)) ((c def c (c (? . 6) q in-naturals)) q (124846 . 3)) ((c form c (c (? . 41) q define-unit/contract)) q (197926 . 15)) ((c def c (c (? . 8) q fifth)) q (98937 . 3)) ((c def c (c (? . 0) q make-polar)) q (26006 . 4)) ((c def c (c (? . 0) q custodian-limit-memory)) q (414622 . 7)) ((c def c (c (? . 135) q syntax-procedure-converted-arguments-property)) q (311513 . 8)) ((c form c (c (? . 6) q define-sequence-syntax)) q (18333 . 8)) ((c def c (c (? . 61) q chaperone-contract-property?)) q (235156 . 3)) ((c def c (c (? . 6) q exn:fail:filesystem:missing-module)) c (? . 79)) ((c def c (c (? . 62) q random-sample)) q (28944 . 10)) ((c def c (c (? . 6) q make-date*)) c (? . 63)) ((c def c (c (? . 99) q parse-command-line)) q (488751 . 15)) ((c def c (c (? . 0) q byte-regexp)) q (74731 . 6)) ((c def c (c (? . 42) q assq)) q (95820 . 4)) ((c def c (c (? . 6) q procedure-reduce-arity-mask)) q (159560 . 9)) ((c def c (c (? . 0) q make-hasheqv-placeholder)) q (106032 . 3)) ((c def c (c (? . 0) q procedure-result-arity)) q (160043 . 3)) ((c def c (c (? . 0) q exn:fail:contract:non-fixnum-result?)) c (? . 97)) ((c def c (c (? . 0) q exn:fail:network:errno?)) c (? . 95)) ((c def c (c (? . 17) q fold-files)) q (453278 . 12)) ((c def c (c (? . 0) q sub1)) q (23916 . 3)) ((c def c (c (? . 0) q unbox)) q (113858 . 3)) ((c form c (c (? . 64) q quasisyntax)) q (285634 . 2)) ((c def c (c (? . 8) q remf*)) q (105347 . 4)) ((c def c (c (? . 2) q keyword-apply/dict)) q (145979 . 11)) ((c def c (c (? . 48) q exn:misc:match?)) q (245200 . 3)) ((c def c (c (? . 2) q dict->list)) q (141397 . 3)) ((c def c (c (? . 0) q date-second)) c (? . 60)) ((c def c (c (? . 0) q symbol->string)) q (73630 . 3)) ((c def c (c (? . 0) q port-writes-atomic?)) q (361127 . 3)) ((c def c (c (? . 0) q hash-ref)) q (118348 . 7)) ((c def c (c (? . 13) q set-first)) q (152113 . 3)) ((c def c (c (? . 57) q contract-random-generate-fail?)) q (243289 . 3)) ((c def c (c (? . 0) q internal-definition-context-introduce)) q (302820 . 7)) ((c def c (c (? . 2) q dict-value-contract)) q (141829 . 3)) ((c def c (c (? . 0) q fixnum?)) q (22284 . 3)) ((c def c (c (? . 13) q set->stream)) q (152301 . 3)) ((c def c (c (? . 66) q struct:exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 0) q cons)) q (92091 . 4)) ((c def c (c (? . 31) q fcontrol)) q (266297 . 4)) ((c def c (c (? . 10) q vector-take)) q (109547 . 4)) ((c def c (c (? . 37) q udp-multicast-interface)) q (469213 . 3)) ((c def c (c (? . 1) q unsafe-extfltruncate)) q (513024 . 3)) ((c form c (c (? . 30) q set!-values)) q (14426 . 2)) ((c def c (c (? . 42) q compose)) q (157832 . 3)) ((c def c (c (? . 4) q process/ports)) q (475337 . 11)) ((c def c (c (? . 6) q exn:fail:filesystem:version)) c (? . 86)) ((c def c (c (? . 0) q find-compiled-file-roots)) q (389186 . 2)) ((c def c (c (? . 0) q regexp-match)) q (75427 . 17)) ((c def c (c (? . 2) q dict-update!)) q (139930 . 10)) ((c form c (c (? . 0) q begin0)) q (14261 . 2)) ((c def c (c (? . 37) q udp-close)) q (466678 . 3)) ((c def c (c (? . 43) q rationalize)) q (24714 . 4)) ((c def c (c (? . 0) q custodian-shutdown-all)) q (413931 . 3)) ((c form c (c (? . 55) q subtract-in)) q (10482 . 2)) ((c def c (c (? . 65) q promise-forced?)) q (262196 . 3)) ((c def c (c (? . 0) q current-milliseconds)) q (481948 . 2)) ((c def c (c (? . 12) q get-user-custodian)) q (426410 . 3)) ((c def c (c (? . 0) q module->indirect-exports)) q (398562 . 5)) ((c def c (c (? . 48) q syntax-local-match-introduce)) q (245619 . 3)) ((c def c (c (? . 66) q blame-negative)) q (224334 . 3)) ((c def c (c (? . 1) q unsafe-flvector-ref)) q (500369 . 4)) ((c def c (c (? . 30) q call-with-parameterization)) q (279009 . 5)) ((c def c (c (? . 37) q udp-multicast-loopback?)) q (469635 . 3)) ((c def c (c (? . 17) q make-lock-file-name)) q (459038 . 6)) ((c def c (c (? . 17) q delete-directory/files)) q (452193 . 5)) ((c def c (c (? . 1) q unsafe-flsin)) q (494534 . 3)) ((c form c (c (? . 6) q for/list)) q (15008 . 2)) ((c form c (c (? . 41) q init-depend)) q (193900 . 2)) ((c form c (c (? . 31) q control0)) q (266801 . 2)) ((c def c (c (? . 0) q raise-argument-error*)) q (247284 . 16)) ((c def c (c (? . 0) q struct:exn:fail:out-of-memory)) c (? . 87)) ((c def c (c (? . 4) q process)) q (474344 . 9)) ((c form c (c (? . 48) q match*)) q (243835 . 6)) ((c def c (c (? . 4) q process*)) q (474720 . 15)) ((c def c (c (? . 1) q unsafe-extfl/)) q (512028 . 4)) ((c def c (c (? . 8) q third)) q (98836 . 3)) ((c def c (c (? . 0) q vector-fill!)) q (108143 . 4)) ((c def c (c (? . 0) q sync/enable-break)) q (272966 . 3)) ((c def c (c (? . 15) q with-output-to-bytes)) q (336238 . 3)) ((c def c (c (? . 15) q peeking-input-port)) q (340521 . 10)) ((c def c (c (? . 15) q with-input-from-bytes)) q (336640 . 4)) ((c def c (c (? . 1) q unsafe-struct*-cas!)) q (502828 . 6)) ((c form c (c (? . 6) q require)) q (2182 . 56)) ((c form c (c (? . 48) q match-let*-values)) q (244926 . 2)) ((c def c (c (? . 0) q string-normalize-nfkd)) q (49642 . 3)) ((c def c (c (? . 56) q would-be-future)) q (279519 . 3)) ((c form c (c (? . 34) q trait)) q (182560 . 18)) ((c form c (c (? . 6) q rename-in)) q (4727 . 2)) ((c def c (c (? . 0) q prop:object-name)) q (416936 . 2)) ((c def c (c (? . 44) q flsqrt)) q (35253 . 3)) ((c def c (c (? . 1) q unsafe-mcar)) q (496594 . 3)) ((c def c (c (? . 0) q local-expand/capture-lifts)) q (299487 . 13)) ((c def c (c (? . 0) q read)) q (361280 . 3)) ((q def ((lib "racket/private/stx.rkt") identifier?)) q (287762 . 3)) ((c def c (c (? . 0) q char-general-category)) q (72739 . 3)) ((c form c (c (? . 6) q except-out)) q (6594 . 2)) ((c def c (c (? . 13) q list->weak-set)) q (148720 . 4)) ((c def c (c (? . 0) q current-thread)) q (271267 . 2)) ((c def c (c (? . 0) q impersonate-vector)) q (401023 . 15)) ((c def c (c (? . 66) q blame-missing-party?)) q (225005 . 3)) ((c def c (c (? . 24) q provide-pre-transformer?)) q (310739 . 3)) ((c def c (c (? . 25) q pretty-print-.-symbol-without-bars)) q (370806 . 4)) ((q form ((lib "racket/shared.rkt") shared)) q (12711 . 2)) ((c def c (c (? . 0) q string-normalize-nfkc)) q (49797 . 3)) ((c form c (c (? . 54) q splicing-syntax-parameterize)) q (312720 . 2)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-pair)) q (504728 . 4)) ((c form c (c (? . 32) q generic-instance/c)) q (170365 . 4)) ((c def c (c (? . 0) q date-year)) c (? . 60)) ((c def c (c (? . 15) q input-port-append)) q (336738 . 7)) ((c def c (c (? . 0) q input-port?)) q (319825 . 3)) ((c def c (c (? . 0) q cddar)) q (96793 . 3)) ((c def c (c (? . 1) q unsafe-unbox)) q (497385 . 3)) ((c def c (c (? . 3) q import-src-mod-path)) c (? . 28)) ((c def c (c (? . 0) q bytes=?)) q (65348 . 4)) ((c def c (c (? . 17) q find-files)) q (452392 . 11)) ((c def c (c (? . 0) q file-or-directory-modify-seconds)) q (444825 . 16)) ((c def c (c (? . 0) q cddddr)) q (98457 . 3)) ((c def c (c (? . 0) q cleanse-path)) q (439997 . 3)) ((c def c (c (? . 0) q make-hash)) q (115420 . 4)) ((c def c (c (? . 0) q subprocess)) q (469903 . 37)) ((c def c (c (? . 44) q flround)) q (34558 . 3)) ((c def c (c (? . 30) q hash-has-key?)) q (118941 . 4)) ((c def c (c (? . 61) q prop:flat-contract)) q (225679 . 2)) ((c def c (c (? . 0) q custom-write-accessor)) q (375193 . 4)) ((c form c (c (? . 6) q only-space-in)) q (4931 . 2)) ((c def c (c (? . 0) q current-library-collection-paths)) q (518169 . 5)) ((c def c (c (? . 0) q chaperone-vector*)) q (407746 . 14)) ((c def c (c (? . 0) q void?)) q (163905 . 3)) ((c form c (c (? . 67) q define-runtime-path-list)) q (448558 . 2)) ((c def c (c (? . 0) q use-compiled-file-paths)) q (388821 . 5)) ((c def c (c (? . 8) q list-prefix?)) q (101500 . 5)) ((c def c (c (? . 11) q fx-/wraparound)) q (38937 . 4)) ((c def c (c (? . 24) q export-mode)) c (? . 68)) ((c def c (c (? . 6) q in-ephemeron-hash-keys)) q (130184 . 3)) ((c form c (c (? . 54) q splicing-letrec-values)) q (312482 . 2)) ((c def c (c (? . 0) q bitwise-not)) q (26576 . 3)) ((c def c (c (? . 0) q make-syntax-delta-introducer)) q (306985 . 9)) ((c def c (c (? . 40) q contract-first-order-passes?)) q (235775 . 4)) ((c def c (c (? . 20) q tcp-abandon-port)) q (461696 . 3)) ((c def c (c (? . 0) q module-path-index-split)) q (394251 . 5)) ((c def c (c (? . 0) q current-load-relative-directory)) q (388607 . 5)) ((c def c (c (? . 40) q coerce-contracts)) q (222269 . 4)) ((c def c (c (? . 141) q syntax-local-provide-introduce)) q (14134 . 3)) ((c def c (c (? . 9) q object-method-arity-includes?)) q (190047 . 7)) ((c form c (c (? . 40) q define/final-prop)) q (235299 . 6)) ((c def c (c (? . 3) q import-source-mod-path-stx)) c (? . 33)) ((c def c (c (? . 0) q cdr)) q (92203 . 3)) ((c def c (c (? . 0) q make-vector)) q (106643 . 4)) ((c form c (c (? . 41) q define-unit-binding)) q (195680 . 6)) ((c def c (c (? . 6) q in-parallel)) q (131576 . 3)) ((c def c (c (? . 13) q make-custom-set-types)) q (156519 . 25)) ((c form c (c (? . 48) q match-letrec)) q (244992 . 2)) ((c def c (c (? . 0) q impersonate-hash)) q (402642 . 22)) ((c form c (c (? . 6) q for-template)) q (7090 . 2)) ((c def c (c (? . 0) q read-bytes-avail!*)) q (351376 . 10)) ((c def c (c (? . 37) q udp-multicast-leave-group!)) q (468948 . 7)) ((c def c (c (? . 1) q unsafe-stencil-vector-length)) q (501571 . 4)) ((c def c (c (? . 0) q print-mpair-curly-braces)) q (366531 . 4)) ((c def c (c (? . 7) q stream?)) q (135039 . 3)) ((c def c (c (? . 26) q none/c)) q (199963 . 2)) ((c def c (c (? . 1) q unsafe-string-set!)) q (498985 . 5)) ((c def c (c (? . 0) q char-utf-8-length)) q (70905 . 3)) ((c def c (c (? . 0) q prop:evt)) q (274102 . 2)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-value)) q (503727 . 5)) ((c def c (c (? . 37) q udp-open-socket)) q (462195 . 5)) ((c def c (c (? . 43) q path-replace-suffix)) q (441233 . 4)) ((c def c (c (? . 0) q syntax-local-lift-context)) q (304643 . 2)) ((c def c (c (? . 6) q in-hash-keys)) q (126584 . 6)) ((c def c (c (? . 0) q current-input-port)) q (320256 . 4)) ((c def c (c (? . 0) q semaphore-post)) q (274922 . 3)) ((c form c (c (? . 41) q unit/new-import-export)) q (196262 . 6)) ((c def c (c (? . 0) q equal?/recur)) q (20406 . 5)) ((c def c (c (? . 7) q stream-take)) q (136131 . 4)) ((c def c (c (? . 13) q set-weak?)) q (146697 . 3)) ((c def c (c (? . 0) q exn:break?)) c (? . 69)) ((c def c (c (? . 18) q ~.a)) q (59774 . 25)) ((c form c (c (? . 9) q overment)) q (177996 . 2)) ((c def c (c (? . 6) q in-mutable-hash-pairs)) q (127880 . 3)) ((c def c (c (? . 0) q exit-handler)) q (270803 . 4)) ((c def c (c (? . 0) q call-with-semaphore/enable-break)) q (275690 . 9)) ((c def c (c (? . 44) q in-flvector)) q (36970 . 6)) ((c def c (c (? . 0) q char-ready?)) q (358077 . 3)) ((c def c (c (? . 9) q subclass?)) q (189590 . 4)) ((c def c (c (? . 6) q double-flonum?)) q (22390 . 3)) ((c def c (c (? . 66) q exn:fail:contract:blame?)) c (? . 70)) ((c def c (c (? . 0) q struct-mutator-procedure?)) q (172640 . 3)) ((c def c (c (? . 37) q udp-multicast-ttl)) q (469826 . 3)) ((c def c (c (? . 6) q in-value)) q (131316 . 3)) ((c def c (c (? . 0) q string-copy!)) q (47323 . 11)) ((c def c (c (? . 9) q object%)) q (174849 . 2)) ((c def c (c (? . 0) q terminal-port?)) q (320650 . 3)) ((c def c (c (? . 37) q udp-receive!)) q (465196 . 11)) ((c def c (c (? . 0) q string=?)) q (48325 . 4)) ((c def c (c (? . 1) q unsafe-unbox*)) q (497519 . 3)) ((c def c (c (? . 0) q exn:break:hang-up?)) c (? . 71)) ((c def c (c (? . 0) q string-length)) q (46745 . 3)) ((c def c (c (? . 6) q make-exn:fail)) c (? . 74)) ((c form c (c (? . 31) q cupto)) q (267376 . 2)) ((c def c (c (? . 37) q udp-send*)) q (464077 . 6)) ((c def c (c (? . 20) q tcp-close)) q (461485 . 3)) ((c def c (c (? . 3) q make-import-source)) c (? . 33)) ((c def c (c (? . 1) q unsafe-extfl<)) q (512274 . 4)) ((c def c (c (? . 13) q in-mutable-set)) q (150513 . 3)) ((c form c (c (? . 27) q let/ec)) q (264964 . 2)) ((c def c (c (? . 75) q engine?)) q (282599 . 3)) ((c def c (c (? . 17) q set-user-id-bit)) q (459587 . 2)) ((c def c (c (? . 11) q fxabs)) q (38152 . 3)) ((c form c (c (? . 13) q for*/mutable-seteq)) q (149826 . 2)) ((c form c (c (? . 13) q for/mutable-setalw)) q (149710 . 2)) ((c def c (c (? . 0) q read-accept-graph)) q (363343 . 4)) ((c def c (c (? . 0) q syntax-local-lift-values-expression)) q (304502 . 5)) ((c form c (c (? . 128) q parametric->/c)) q (212643 . 2)) ((c def c (c (? . 0) q impersonator-property?)) q (412646 . 3)) ((c def c (c (? . 72) q async-channel-get)) q (276243 . 3)) ((c def c (c (? . 72) q async-channel-try-get)) q (276316 . 3)) ((c def c (c (? . 12) q sandbox-memory-limit)) q (424343 . 4)) ((c def c (c (? . 0) q hashalw)) q (115011 . 5)) ((c form c (c (? . 9) q define/pubment)) q (178890 . 3)) ((c def c (c (? . 6) q impersonate-procedure)) q (399508 . 11)) ((c def c (c (? . 98) q vectorof)) q (201267 . 9)) ((c def c (c (? . 6) q make-exn:break:hang-up)) c (? . 71)) ((c def c (c (? . 0) q print-as-expression)) q (367419 . 4)) ((c def c (c (? . 37) q udp-ttl)) q (468619 . 3)) ((c form c (c (? . 41) q define-signature-form)) q (196896 . 4)) ((c def c (c (? . 2) q dict-ref!)) q (139822 . 5)) ((c form c (c (? . 41) q define-values-for-export)) q (193515 . 2)) ((c def c (c (? . 37) q udp-bound?)) q (466797 . 3)) ((c form c (c (? . 9) q define-member-name)) q (179991 . 2)) ((c def c (c (? . 43) q channel-get)) q (274418 . 3)) ((c def c (c (? . 17) q pathlist-closure)) q (452942 . 8)) ((c def c (c (? . 0) q current-module-path-for-load)) q (393443 . 11)) ((c def c (c (? . 0) q syntax-local-lift-module)) q (304692 . 3)) ((c def c (c (? . 72) q impersonate-async-channel)) q (276646 . 13)) ((c def c (c (? . 5) q curryr)) q (163365 . 6)) ((c def c (c (? . 0) q write-bytes-avail-evt)) q (360630 . 9)) ((c def c (c (? . 13) q set)) q (146752 . 3)) ((c def c (c (? . 0) q symbol<?)) q (73998 . 4)) ((c def c (c (? . 40) q coerce-contract/f)) q (222822 . 3)) ((c def c (c (? . 0) q equal-always?)) q (20179 . 4)) ((c def c (c (? . 31) q abort)) q (266164 . 3)) ((c def c (c (? . 0) q print-pair-curly-braces)) q (366421 . 4)) ((c def c (c (? . 0) q exp)) q (25429 . 3)) ((c def c (c (? . 0) q explode-path)) q (440707 . 4)) ((c def c (c (? . 25) q make-tentative-pretty-print-output-port)) q (373530 . 8)) ((c def c (c (? . 8) q indexes-of)) q (100045 . 6)) ((c def c (c (? . 0) q variable-reference->resolved-module-path)) q (385213 . 4)) ((c def c (c (? . 116) q andmap)) q (93124 . 4)) ((c def c (c (? . 10) q vector-sort)) q (111230 . 13)) ((c form c (c (? . 9) q class-field-accessor)) q (182080 . 2)) ((c def c (c (? . 73) q struct-auto-info?)) q (174131 . 3)) ((c form c (c (? . 6) q define-struct/derived)) q (165531 . 3)) ((c def c (c (? . 8) q split-common-prefix)) q (101936 . 5)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-key+value)) q (506366 . 5)) ((c form c (c (? . 13) q for/weak-seteqv)) q (150113 . 2)) ((c def c (c (? . 0) q thread-receive-evt)) q (272610 . 2)) ((c form c (c (? . 6) q file)) q (5245 . 2)) ((c def c (c (? . 0) q error-value->string-handler)) q (255433 . 9)) ((c def c (c (? . 0) q arithmetic-shift)) q (26974 . 4)) ((c def c (c (? . 0) q will-execute)) q (490324 . 3)) ((c def c (c (? . 12) q evaluator-alive?)) q (426140 . 3)) ((c def c (c (? . 0) q make-will-executor)) q (490075 . 2)) ((c def c (c (? . 0) q hash-weak?)) q (114749 . 3)) ((c def c (c (? . 43) q putenv)) q (485787 . 4)) ((c def c (c (? . 0) q vector*-set!)) q (107530 . 5)) ((c def c (c (? . 1) q unsafe-car)) q (496488 . 3)) ((c form c (c (? . 6) q λ)) q (11263 . 11)) ((c def c (c (? . 0) q continuation-prompt-tag?)) q (265349 . 3)) ((c def c (c (? . 1) q unsafe-vector*-ref)) q (498190 . 4)) ((c def c (c (? . 42) q build-vector)) q (108887 . 4)) ((c def c (c (? . 1) q unsafe-fl-)) q (493344 . 4)) ((c def c (c (? . 21) q linklet-bundle->hash)) q (433017 . 4)) ((c def c (c (? . 0) q string-locale-ci>?)) q (50387 . 4)) ((c def c (c (? . 0) q cdadr)) q (96711 . 3)) ((c def c (c (? . 12) q sandbox-reader)) q (420607 . 4)) ((c form c (c (? . 54) q splicing-let-syntax)) q (312512 . 2)) ((c def c (c (? . 6) q exn:fail)) c (? . 74)) ((c form c (c (? . 103) q define-struct/contract)) q (215194 . 6)) ((c def c (c (? . 0) q cadr)) q (96109 . 3)) ((c def c (c (? . 14) q place-location?)) q (282128 . 3)) ((c def c (c (? . 19) q collapsible-leaf/c)) c (? . 36)) ((c def c (c (? . 14) q place-message-allowed?)) q (282008 . 3)) ((c def c (c (? . 0) q shell-execute)) q (472359 . 11)) ((c def c (c (? . 1) q unsafe-extfl>=)) q (512539 . 4)) ((c def c (c (? . 0) q parameter?)) q (278797 . 3)) ((c def c (c (? . 0) q char-extended-pictographic?)) q (72660 . 3)) ((c def c (c (? . 13) q set-union!)) q (152781 . 4)) ((c def c (c (? . 8) q in-permutations)) q (104742 . 3)) ((c def c (c (? . 0) q char-upper-case?)) q (72059 . 3)) ((c def c (c (? . 11) q fl->fx)) q (39784 . 3)) ((c def c (c (? . 0) q cadar)) q (96465 . 3)) ((c def c (c (? . 0) q chaperone-prompt-tag)) q (411194 . 18)) ((c def c (c (? . 12) q exn:fail:resource?)) c (? . 101)) ((c def c (c (? . 40) q contract-first-order)) q (235886 . 3)) ((c def c (c (? . 12) q sandbox-override-collection-paths)) q (422897 . 4)) ((c def c (c (? . 16) q extfl<=)) q (42252 . 4)) ((c def c (c (? . 72) q async-channel-put)) q (276393 . 4)) ((c def c (c (? . 0) q namespace-symbol->identifier)) q (380662 . 3)) ((c form c (c (? . 48) q match-define-values)) q (245147 . 2)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-value)) q (509909 . 5)) ((c def c (c (? . 0) q impersonator?)) q (399086 . 3)) ((c def c (c (? . 3) q import-orig-mode)) c (? . 28)) ((c def c (c (? . 0) q print-struct)) q (366825 . 4)) ((c def c (c (? . 22) q sequence->list)) q (133431 . 3)) ((c def c (c (? . 0) q syntax-tainted?)) q (313571 . 3)) ((c def c (c (? . 0) q list)) q (92321 . 3)) ((c def c (c (? . 11) q fxrshift)) q (38503 . 4)) ((c def c (c (? . 0) q open-input-string)) q (328446 . 4)) ((c def c (c (? . 0) q regexp-replace)) q (89577 . 15)) ((c def c (c (? . 112) q s-exp->fasl)) q (378491 . 14)) ((c def c (c (? . 0) q syntax-disarm)) q (313867 . 4)) ((c form c (c (? . 6) q #%module-begin)) q (1801 . 2)) ((c form c (c (? . 32) q impersonate-generics)) q (170463 . 10)) ((c def c (c (? . 75) q engine-result)) q (282756 . 3)) ((c def c (c (? . 6) q sequence-generate*)) q (133264 . 5)) ((c def c (c (? . 14) q place-channel)) q (281652 . 2)) ((c def c (c (? . 0) q make-rename-transformer)) q (298012 . 3)) ((c def c (c (? . 22) q sequence-length)) q (133492 . 3)) ((c form c (c (? . 0) q #%declare)) q (1921 . 8)) ((c def c (c (? . 13) q proper-subset?)) q (153704 . 4)) ((c def c (c (? . 0) q exn:fail:user?)) c (? . 125)) ((c def c (c (? . 1) q unsafe-flvector-set!)) q (500458 . 5)) ((c def c (c (? . 6) q in-sequences)) q (131436 . 3)) ((c def c (c (? . 0) q procedure-specialize)) q (162491 . 3)) ((c def c (c (? . 1) q unsafe-extflvector-set!)) q (514113 . 5)) ((c def c (c (? . 6) q in-mutable-hash)) q (127067 . 3)) ((c def c (c (? . 0) q regexp-match-positions)) q (77844 . 19)) ((c def c (c (? . 7) q stream-length)) q (135861 . 3)) ((c def c (c (? . 44) q fl->exact-integer)) q (35438 . 3)) ((c def c (c (? . 6) q copy-file)) q (446301 . 13)) ((c def c (c (? . 6) q raise-syntax-error)) q (253366 . 18)) ((c def c (c (? . 12) q sandbox-make-plumber)) q (425704 . 4)) ((c def c (c (? . 0) q char-titlecase)) q (73206 . 3)) ((c def c (c (? . 12) q sandbox-propagate-breaks)) q (422207 . 4)) ((c def c (c (? . 16) q extfl*)) q (41782 . 4)) ((c def c (c (? . 0) q current-memory-use)) q (490613 . 3)) ((c form c (c (? . 6) q for*/product)) q (17340 . 2)) ((c def c (c (? . 40) q impersonator-prop:blame)) q (225883 . 2)) ((c def c (c (? . 76) q syntax-local-eval)) q (318626 . 7)) ((c def c (c (? . 0) q syntax-e)) q (288495 . 3)) ((c def c (c (? . 0) q char-iso-control?)) q (72591 . 3)) ((c form c (c (? . 0) q define-values)) q (13564 . 2)) ((c form c (c (? . 9) q inherit/super)) q (178285 . 2)) ((c def c (c (? . 0) q read-single-flonum)) q (363663 . 4)) ((c def c (c (? . 0) q prop:set!-transformer)) q (297893 . 2)) ((c def c (c (? . 12) q sandbox-eval-limits)) q (424480 . 8)) ((c def c (c (? . 3) q import-src-sym)) c (? . 28)) ((c def c (c (? . 1) q unsafe-fxlshift)) q (491866 . 4)) ((c def c (c (? . 15) q call-with-output-string)) q (335972 . 3)) ((c def c (c (? . 20) q listen-port-number?)) q (462155 . 2)) ((c def c (c (? . 0) q current-error-message-adjuster)) q (261802 . 5)) ((c def c (c (? . 24) q export?)) c (? . 68)) ((c def c (c (? . 0) q make-prefab-struct)) q (172792 . 4)) ((c def c (c (? . 44) q fl<=)) q (34246 . 4)) ((c def c (c (? . 37) q udp-connected?)) q (466870 . 3)) ((c def c (c (? . 0) q current-compiled-file-roots)) q (389010 . 4)) ((c def c (c (? . 0) q not)) q (21247 . 3)) ((c def c (c (? . 0) q date-dst?)) c (? . 60)) ((c def c (c (? . 8) q partition)) q (103746 . 4)) ((c def c (c (? . 0) q thread-try-receive)) q (272568 . 2)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-value)) q (505913 . 5)) ((c def c (c (? . 6) q syntax-serialize)) q (315011 . 12)) ((c def c (c (? . 0) q bytes-close-converter)) q (68824 . 3)) ((c def c (c (? . 13) q mutable-seteq)) q (147419 . 4)) ((c def c (c (? . 0) q port-closed-evt)) q (320193 . 3)) ((c def c (c (? . 0) q delete-file)) q (444512 . 3)) ((c form c (c (? . 65) q delay)) q (262097 . 2)) ((c def c (c (? . 1) q unsafe-f64vector-set!)) q (500662 . 5)) ((c def c (c (? . 0) q exn:fail:contract:arity?)) c (? . 111)) ((c def c (c (? . 0) q bytes-copy)) q (64375 . 3)) ((c def c (c (? . 1) q unsafe-fxvector-length)) q (500029 . 3)) ((c def c (c (? . 0) q read-accept-reader)) q (364153 . 4)) ((c def c (c (? . 8) q second)) q (98785 . 3)) ((c def c (c (? . 0) q expt)) q (25357 . 4)) ((c def c (c (? . 11) q fx->fl)) q (39731 . 3)) ((c def c (c (? . 0) q hash-iterate-first)) q (121506 . 4)) ((c def c (c (? . 10) q vector-count)) q (110604 . 4)) ((c def c (c (? . 0) q single-flonum-available?)) q (22510 . 2)) ((c def c (c (? . 66) q blame-value)) q (224450 . 3)) ((c def c (c (? . 0) q char>?)) q (71261 . 4)) ((c def c (c (? . 29) q string-contains?)) q (53046 . 4)) ((c def c (c (? . 6) q in-ephemeron-hash)) q (129953 . 3)) ((c def c (c (? . 66) q make-exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 0) q read/recursive)) q (361551 . 6)) ((c def c (c (? . 16) q shared-extflvector)) q (45363 . 3)) ((c def c (c (? . 1) q unsafe-extflceiling)) q (512952 . 3)) ((c def c (c (? . 0) q bytes-length)) q (63867 . 3)) ((c def c (c (? . 12) q sandbox-coverage-enabled)) q (422085 . 4)) ((c def c (c (? . 0) q syntax-local-module-required-identifiers)) q (307522 . 8)) ((c def c (c (? . 0) q hash-count)) q (121363 . 3)) ((c def c (c (? . 0) q string->keyword)) q (91707 . 3)) ((c def c (c (? . 0) q stencil-vector-mask)) q (112752 . 4)) ((c def c (c (? . 0) q immutable?)) q (21296 . 3)) ((c def c (c (? . 8) q filter-not)) q (104208 . 4)) ((c def c (c (? . 0) q current-load-extension)) q (387274 . 15)) ((c def c (c (? . 2) q dict-has-key?)) q (139441 . 4)) ((c def c (c (? . 0) q continuation-mark-set->iterator)) q (268618 . 11)) ((c def c (c (? . 1) q unsafe-extflabs)) q (512118 . 3)) ((c def c (c (? . 1) q unsafe-set-mcar!)) q (496704 . 4)) ((c def c (c (? . 25) q pretty-print-remap-stylable)) q (371791 . 5)) ((c def c (c (? . 0) q box-immutable)) q (113782 . 3)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-pair)) q (506842 . 5)) ((c def c (c (? . 1) q unsafe-stencil-vector-mask)) q (501429 . 4)) ((c def c (c (? . 6) q call-with-input-file*)) q (325529 . 7)) ((c def c (c (? . 0) q environment-variables-names)) q (485425 . 4)) ((c def c (c (? . 43) q bytes-environment-variable-name?)) q (484566 . 3)) ((c def c (c (? . 0) q arity-at-least?)) c (? . 45)) ((c def c (c (? . 6) q in-indexed)) q (131371 . 3)) ((c def c (c (? . 0) q procedure-arity)) q (158851 . 3)) ((c form c (c (? . 6) q for*/lists)) q (16715 . 3)) ((c def c (c (? . 0) q variable-reference->empty-namespace)) q (385005 . 3)) ((c def c (c (? . 6) q in-port)) q (125765 . 4)) ((c def c (c (? . 0) q bytes->path-element)) q (437766 . 8)) ((c def c (c (? . 12) q get-error-output)) c (? . 77)) ((c def c (c (? . 11) q in-fxvector)) q (40660 . 6)) ((c def c (c (? . 16) q extflexpt)) q (43396 . 4)) ((c def c (c (? . 4) q string-no-nuls?)) q (477056 . 3)) ((c def c (c (? . 44) q flvector?)) q (36217 . 3)) ((c def c (c (? . 6) q regexp-match-peek-positions*)) q (83918 . 17)) ((c def c (c (? . 73) q struct-auto-info-lists)) q (174194 . 4)) ((c form c (c (? . 26) q any)) q (206018 . 2)) ((c def c (c (? . 21) q linklet-export-variables)) q (432345 . 3)) ((c def c (c (? . 7) q empty-stream)) q (135773 . 2)) ((c def c (c (? . 0) q use-compiled-file-check)) q (389259 . 4)) ((c def c (c (? . 40) q chaperone-contract?)) q (236024 . 3)) ((c def c (c (? . 0) q syntax-local-value/immediate)) q (303999 . 9)) ((c form c (c (? . 49) q ~@)) q (285545 . 2)) ((c def c (c (? . 0) q vector*-length)) q (107276 . 3)) ((c def c (c (? . 9) q field-names)) q (190290 . 3)) ((c def c (c (? . 0) q make-ephemeron-hasheqv)) q (116898 . 4)) ((c def c (c (? . 0) q port-provides-progress-evts?)) q (357698 . 3)) ((c def c (c (? . 0) q chaperone-channel)) q (410686 . 12)) ((q def ((lib "racket/rerequire.rkt") dynamic-rerequire)) q (520202 . 5)) ((c def c (c (? . 0) q char-ci>?)) q (71732 . 4)) ((c def c (c (? . 66) q blame-replace-negative)) q (224741 . 4)) ((c def c (c (? . 0) q exn-continuation-marks)) c (? . 47)) ((c def c (c (? . 0) q thread-resume-evt)) q (272205 . 3)) ((c form c (c (? . 9) q public-final)) q (177916 . 2)) ((c def c (c (? . 51) q file-name-from-path)) q (441742 . 3)) ((c form c (c (? . 30) q define-logger)) q (477834 . 7)) ((c def c (c (? . 17) q directory-type-bits)) q (459468 . 2)) ((c def c (c (? . 23) q cons/c)) q (202715 . 4)) ((c def c (c (? . 56) q fsemaphore-post)) q (279925 . 3)) ((c def c (c (? . 0) q dynamic-require)) q (397047 . 7)) ((c def c (c (? . 1) q unsafe-vector*-length)) q (498089 . 3)) ((c def c (c (? . 0) q make-immutable-hashalw)) q (117348 . 4)) ((c form c (c (? . 27) q let-syntax)) q (12245 . 2)) ((c def c (c (? . 0) q path-for-some-system?)) q (437136 . 3)) ((c def c (c (? . 0) q make-empty-namespace)) q (380130 . 2)) ((c def c (c (? . 26) q flat-contract-predicate)) q (206183 . 3)) ((c def c (c (? . 0) q variable-reference?)) q (384842 . 3)) ((c def c (c (? . 57) q raise-contract-error)) q (242064 . 13)) ((c def c (c (? . 16) q extfl->exact-integer)) q (43546 . 3)) ((c def c (c (? . 0) q shared-bytes)) q (65287 . 3)) ((c def c (c (? . 78) q serialized=?)) q (376533 . 4)) ((c def c (c (? . 15) q with-output-to-string)) q (336162 . 3)) ((c def c (c (? . 22) q sequence-andmap)) q (133934 . 4)) ((c def c (c (? . 48) q match-equality-test)) q (245698 . 4)) ((c def c (c (? . 0) q error-print-source-location)) q (255305 . 4)) ((c def c (c (? . 0) q call-with-escape-continuation)) q (264659 . 3)) ((c def c (c (? . 75) q engine)) q (282508 . 3)) ((c def c (c (? . 8) q remf)) q (105266 . 4)) ((c def c (c (? . 0) q string->bytes/latin-1)) q (67094 . 9)) ((c def c (c (? . 44) q fl>)) q (34169 . 4)) ((c form c (c (? . 34) q trait-rename)) q (183663 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:missing-module-path)) c (? . 79)) ((c def c (c (? . 0) q error-message->adjusted-string)) q (261250 . 9)) ((c def c (c (? . 0) q syntax-local-module-interned-scope-symbols)) q (305668 . 3)) ((c def c (c (? . 76) q format-symbol)) q (317207 . 5)) ((c def c (c (? . 0) q string>?)) q (48608 . 4)) ((c form c (c (? . 6) q for-space)) q (7169 . 2)) ((c def c (c (? . 80) q date->seconds)) q (483219 . 4)) ((c def c (c (? . 0) q make-log-receiver)) q (479431 . 5)) ((c def c (c (? . 17) q file->list)) q (449256 . 5)) ((c def c (c (? . 0) q print-graph)) q (366739 . 4)) ((c def c (c (? . 21) q linklet-directory?)) q (432439 . 3)) ((c def c (c (? . 21) q correlated-line)) q (435283 . 3)) ((c def c (c (? . 81) q make-chaperone-contract)) q (218338 . 32)) ((c def c (c (? . 0) q custodian-memory-accounting-available?)) q (414299 . 2)) ((c def c (c (? . 0) q namespace-mapped-symbols)) q (382034 . 3)) ((c form c (c (? . 6) q for*/sum)) q (17277 . 2)) ((c def c (c (? . 15) q make-input-port/read-to-peek)) q (336989 . 50)) ((c def c (c (? . 13) q set->list)) q (153803 . 3)) ((c def c (c (? . 8) q fourth)) q (98886 . 3)) ((c def c (c (? . 1) q unsafe-flexp)) q (494950 . 3)) ((c def c (c (? . 0) q syntax-local-name)) q (305213 . 2)) ((c def c (c (? . 0) q raise-arguments-error*)) q (248951 . 12)) ((c def c (c (? . 0) q internal-definition-context?)) q (301301 . 3)) ((c def c (c (? . 22) q empty-sequence)) q (133396 . 2)) ((c def c (c (? . 66) q exn:fail:contract:blame-object)) c (? . 70)) ((c def c (c (? . 82) q pi.f)) q (32392 . 2)) ((c def c (c (? . 6) q procedure->method)) q (158191 . 3)) ((c def c (c (? . 17) q call-with-file-lock/timeout)) q (458263 . 15)) ((c def c (c (? . 40) q build-compound-type-name)) q (222110 . 3)) ((c form c (c (? . 31) q prompt)) q (266418 . 2)) ((c form c (c (? . 41) q define-signature)) q (192569 . 25)) ((c def c (c (? . 0) q hash?)) q (114380 . 3)) ((c form c (c (? . 48) q match-define)) q (245114 . 2)) ((c form c (c (? . 46) q serializable-struct)) q (376896 . 3)) ((c form c (c (? . 30) q log-error)) q (479082 . 3)) ((c form c (c (? . 6) q define-syntax)) q (13604 . 3)) ((c form c (c (? . 107) q include-at/relative-to)) q (316084 . 2)) ((c def c (c (? . 6) q exn:fail:network)) c (? . 83)) ((c form c (c (? . 31) q reset0-at)) q (266916 . 2)) ((c def c (c (? . 0) q subprocess-group-enabled)) q (472053 . 4)) ((c def c (c (? . 82) q degrees->radians)) q (32439 . 3)) ((c form c (c (? . 30) q parameterize-break)) q (270363 . 2)) ((c form c (c (? . 9) q get-field)) q (181741 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:errno?)) c (? . 84)) ((c def c (c (? . 0) q syntax-transforming-with-lifts?)) q (306239 . 2)) ((c def c (c (? . 11) q most-negative-fixnum)) q (41467 . 2)) ((c def c (c (? . 17) q sticky-bit)) q (459658 . 2)) ((c def c (c (? . 0) q struct:exn:fail:network)) c (? . 83)) ((c def c (c (? . 0) q current-process-milliseconds)) q (482001 . 3)) ((c def c (c (? . 0) q module-path-index?)) q (393912 . 3)) ((c def c (c (? . 16) q extflvector-copy)) q (44579 . 5)) ((c form c (c (? . 13) q for/mutable-seteq)) q (149593 . 2)) ((c def c (c (? . 0) q make-special-comment)) q (374840 . 3)) ((c def c (c (? . 0) q rename-transformer?)) q (297947 . 3)) ((c def c (c (? . 44) q make-flrectangular)) q (35509 . 7)) ((c def c (c (? . 6) q make-exn:fail:read)) c (? . 85)) ((c def c (c (? . 9) q member-name-key?)) q (180124 . 3)) ((c def c (c (? . 43) q read-eval-print-loop)) q (389424 . 2)) ((c def c (c (? . 0) q syntax-local-get-shadower)) q (305747 . 5)) ((c def c (c (? . 0) q path<?)) q (438247 . 4)) ((c form c (c (? . 27) q =>)) q (13080 . 2)) ((c def c (c (? . 7) q stream-force)) q (135601 . 3)) ((c def c (c (? . 13) q set-intersect)) q (152878 . 4)) ((c form c (c (? . 48) q match/values)) q (244031 . 2)) ((c def c (c (? . 43) q path-add-extension)) q (441019 . 5)) ((c def c (c (? . 21) q variable-reference->instance)) q (434922 . 6)) ((c def c (c (? . 9) q object-interface)) q (189417 . 3)) ((c def c (c (? . 0) q string>=?)) q (48702 . 4)) ((c form c (c (? . 41) q define-compound-unit/infer)) q (195528 . 5)) ((c def c (c (? . 17) q user-permission-bits)) q (459688 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:version?)) c (? . 86)) ((c def c (c (? . 15) q call-with-input-string)) q (336312 . 4)) ((c form c (c (? . 48) q match)) q (243676 . 6)) ((c def c (c (? . 0) q make-portal-syntax)) q (311927 . 3)) ((c def c (c (? . 1) q unsafe-extfl<=)) q (512450 . 4)) ((c def c (c (? . 29) q string-prefix?)) q (53147 . 4)) ((c def c (c (? . 56) q fsemaphore?)) q (279868 . 3)) ((c form c (c (? . 9) q class/derived)) q (179650 . 5)) ((c def c (c (? . 7) q stream-append)) q (136229 . 3)) ((c def c (c (? . 6) q make-exn:fail:out-of-memory)) c (? . 87)) ((c def c (c (? . 17) q fifo-type-bits)) q (459553 . 2)) ((c def c (c (? . 40) q get/build-collapsible-late-neg-projection)) q (238506 . 4)) ((c def c (c (? . 82) q order-of-magnitude)) q (33183 . 3)) ((c def c (c (? . 82) q sgn)) q (32607 . 3)) ((c form c (c (? . 64) q unsyntax-splicing)) q (285689 . 2)) ((c def c (c (? . 127) q box/c)) q (202081 . 9)) ((c def c (c (? . 0) q make-thread-group)) q (415127 . 3)) ((c def c (c (? . 17) q file->lines)) q (449463 . 8)) ((c def c (c (? . 11) q fxxor)) q (38318 . 3)) ((c def c (c (? . 0) q file-or-directory-permissions)) q (445524 . 11)) ((c def c (c (? . 0) q current-load)) q (386509 . 15)) ((c def c (c (? . 0) q current-plumber)) q (417195 . 4)) ((c def c (c (? . 0) q channel-put-evt)) q (274614 . 4)) ((c form c (c (? . 105) q define-inline)) q (19530 . 14)) ((c form c (c (? . 30) q log-debug)) q (479300 . 3)) ((c def c (c (? . 6) q in-weak-hash-keys)) q (129286 . 3)) ((c def c (c (? . 8) q argmin)) q (104808 . 4)) ((c def c (c (? . 0) q bytes-fill!)) q (64860 . 4)) ((c def c (c (? . 0) q list-tail)) q (92759 . 4)) ((c form c (c (? . 6) q prefix-in)) q (4683 . 2)) ((c def c (c (? . 40) q collapsible-contract-continuation-mark-key)) q (238662 . 3)) ((c def c (c (? . 0) q thread?)) q (271215 . 3)) ((c def c (c (? . 0) q current-print)) q (390016 . 4)) ((c def c (c (? . 3) q require-transformer?)) q (308408 . 3)) ((c def c (c (? . 0) q internal-definition-context-splice-binding-identifier)) q (301835 . 7)) ((c def c (c (? . 30) q hash-update)) q (119457 . 9)) ((c def c (c (? . 0) q raise-argument-error)) q (246888 . 13)) ((c def c (c (? . 0) q version)) q (486432 . 2)) ((c def c (c (? . 42) q assoc)) q (95430 . 5)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-key)) q (507536 . 4)) ((c def c (c (? . 0) q current-inspector)) q (415887 . 4)) ((c def c (c (? . 0) q string-utf-8-length)) q (67455 . 5)) ((c def c (c (? . 40) q get/build-late-neg-projection)) q (238395 . 4)) ((c def c (c (? . 2) q dict-iterate-key)) q (139267 . 4)) ((c def c (c (? . 37) q udp-multicast-set-loopback!)) q (469474 . 5)) ((c def c (c (? . 0) q chaperone-hash)) q (408780 . 22)) ((c def c (c (? . 6) q stop-after)) q (131900 . 4)) ((c def c (c (? . 0) q load-on-demand-enabled)) q (391540 . 4)) ((c def c (c (? . 1) q unsafe-bytes-set!)) q (499387 . 5)) ((c def c (c (? . 0) q make-weak-box)) q (489549 . 3)) ((c def c (c (? . 0) q date-day)) c (? . 60)) ((c def c (c (? . 0) q filesystem-root-list)) q (447968 . 2)) ((c def c (c (? . 88) q phase+space)) q (319132 . 4)) ((c def c (c (? . 24) q export-local-id)) c (? . 68)) ((c def c (c (? . 0) q read-curly-brace-as-paren)) q (362691 . 4)) ((c def c (c (? . 0) q date-month)) c (? . 60)) ((c def c (c (? . 0) q namespace-undefine-variable!)) q (381842 . 5)) ((c def c (c (? . 6) q gen:custom-write)) q (375051 . 2)) ((c def c (c (? . 9) q make-exn:fail:object)) c (? . 106)) ((c def c (c (? . 3) q struct:import-source)) c (? . 33)) ((c def c (c (? . 6) q regexp-quote)) q (75078 . 7)) ((c form c (c (? . 9) q interface)) q (174538 . 5)) ((c def c (c (? . 0) q exn:fail:filesystem?)) c (? . 89)) ((c def c (c (? . 13) q list->weak-seteq)) q (149034 . 3)) ((c def c (c (? . 9) q writable<%>)) q (188732 . 2)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-first)) q (502993 . 3)) ((c def c (c (? . 8) q append-map)) q (104115 . 4)) ((c def c (c (? . 0) q bytes>?)) q (65538 . 4)) ((c def c (c (? . 0) q variable-reference->module-declaration-inspector)) q (385852 . 4)) ((c def c (c (? . 0) q absolute-path?)) q (439268 . 3)) ((c def c (c (? . 0) q compile)) q (390305 . 3)) ((c form c (c (? . 6) q struct)) q (164034 . 33)) ((c def c (c (? . 34) q trait-sum)) q (183472 . 3)) ((c def c (c (? . 72) q make-async-channel)) q (276126 . 3)) ((c def c (c (? . 0) q variable-reference-constant?)) q (384907 . 3)) ((c def c (c (? . 0) q namespace-call-with-registry-lock)) q (384078 . 5)) ((c def c (c (? . 6) q syntax-deserialize)) q (315634 . 7)) ((c def c (c (? . 38) q instanceof/c)) q (185384 . 3)) ((c def c (c (? . 0) q file-stream-port?)) q (320587 . 3)) ((c def c (c (? . 0) q chaperone-struct-type)) q (409833 . 15)) ((c def c (c (? . 0) q vector-length)) q (106937 . 3)) ((c def c (c (? . 0) q error)) q (246329 . 10)) ((c def c (c (? . 0) q prefab-struct-type-key+field-count)) q (172889 . 4)) ((c def c (c (? . 18) q ~s)) q (55801 . 25)) ((c def c (c (? . 0) q exn:fail:syntax-exprs)) c (? . 104)) ((c def c (c (? . 1) q unsafe-string-length)) q (498766 . 3)) ((c def c (c (? . 66) q blame?)) q (223189 . 3)) ((c def c (c (? . 13) q list->seteqv)) q (148102 . 3)) ((c def c (c (? . 0) q cdddar)) q (98357 . 3)) ((c def c (c (? . 0) q struct->vector)) q (172211 . 4)) ((c def c (c (? . 0) q make-custodian-box)) q (414896 . 4)) ((c def c (c (? . 0) q close-input-port)) q (319991 . 3)) ((c def c (c (? . 19) q struct:collapsible-leaf/c)) c (? . 36)) ((c def c (c (? . 23) q first-or/c)) q (200069 . 3)) ((c def c (c (? . 1) q unsafe-s16vector-set!)) q (500892 . 5)) ((c def c (c (? . 0) q vector-immutable)) q (106809 . 4)) ((c form c (c (? . 41) q define-values/invoke-unit)) q (194045 . 4)) ((c form c (c (? . 90) q opt/c)) q (237416 . 5)) ((c def c (c (? . 0) q compile-context-preservation-enabled)) q (390898 . 4)) ((c form c (c (? . 91) q contract-struct)) q (212850 . 2)) ((c def c (c (? . 23) q *list/c)) q (203174 . 4)) ((c def c (c (? . 6) q open-input-output-file)) q (323445 . 16)) ((c def c (c (? . 0) q hasheqv)) q (115286 . 5)) ((c def c (c (? . 40) q value-blame)) q (236477 . 3)) ((c def c (c (? . 0) q read-installation-configuration-table)) q (519280 . 3)) ((c def c (c (? . 0) q prefab-key?)) q (173171 . 3)) ((c def c (c (? . 0) q prefab-struct-key)) q (172711 . 3)) ((c def c (c (? . 6) q make-exn:fail:read:non-char)) c (? . 58)) ((c def c (c (? . 0) q module-compiled-exports)) q (396101 . 7)) ((c form c (c (? . 48) q match/derived)) q (245853 . 2)) ((c def c (c (? . 0) q read-on-demand-source)) q (364718 . 5)) ((c form c (c (? . 39) q untrace)) q (520714 . 2)) ((c def c (c (? . 21) q linklet-bundle?)) q (432816 . 3)) ((c def c (c (? . 13) q set-symmetric-difference)) q (153292 . 4)) ((c def c (c (? . 38) q implementation?/c)) q (188194 . 3)) ((c def c (c (? . 48) q match-expander?)) q (245490 . 3)) ((c form c (c (? . 54) q splicing-let)) q (312412 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:missing-module?)) c (? . 79)) ((c def c (c (? . 37) q udp-set-ttl!)) q (468524 . 4)) ((c def c (c (? . 16) q extflvector-set!)) q (44436 . 5)) ((c form c (c (? . 48) q match-lambda*)) q (244684 . 2)) ((c def c (c (? . 0) q chaperone-evt)) q (410447 . 7)) ((c def c (c (? . 0) q read-bytes-avail!/enable-break)) q (351778 . 10)) ((c def c (c (? . 92) q signature-members)) q (198728 . 8)) ((c def c (c (? . 44) q flvector-set!)) q (36648 . 5)) ((c def c (c (? . 25) q pretty-print-show-inexactness)) q (370938 . 4)) ((c def c (c (? . 0) q symbol-unreadable?)) q (73560 . 3)) ((c def c (c (? . 40) q has-blame?)) q (236549 . 3)) ((c def c (c (? . 4) q system*/exit-code)) q (473664 . 15)) ((c def c (c (? . 0) q set-box*!)) q (114095 . 4)) ((c form c (c (? . 9) q inspect)) q (177634 . 2)) ((c def c (c (? . 0) q syntax-shift-phase-level)) q (291541 . 4)) ((c def c (c (? . 26) q real-in)) q (200671 . 4)) ((c def c (c (? . 1) q unsafe-fl+)) q (493282 . 3)) ((c def c (c (? . 0) q make-inspector)) q (415476 . 3)) ((c def c (c (? . 0) q string-locale-downcase)) q (50568 . 3)) ((c def c (c (? . 17) q set-group-id-bit)) q (459622 . 2)) ((c form c (c (? . 9) q init-rest)) q (177808 . 3)) ((c def c (c (? . 0) q prop:exn:missing-module)) q (260939 . 2)) ((c def c (c (? . 0) q use-user-specific-search-paths)) q (519042 . 4)) ((c def c (c (? . 7) q stream-for-each)) q (136576 . 4)) ((c def c (c (? . 0) q thread-dead-evt)) q (272142 . 3)) ((c def c (c (? . 13) q list->mutable-seteqv)) q (148506 . 4)) ((c def c (c (? . 0) q eval)) q (386191 . 6)) ((c def c (c (? . 15) q port->bytes)) q (334863 . 4)) ((c def c (c (? . 93) q generator?)) q (137337 . 3)) ((c form c (c (? . 65) q for/list/concurrent)) q (262858 . 8)) ((c def c (c (? . 0) q integer-sqrt/remainder)) q (25276 . 3)) ((c def c (c (? . 12) q sandbox-network-guard)) q (423796 . 13)) ((c def c (c (? . 6) q syntax-binding-set-extend)) q (289994 . 25)) ((c def c (c (? . 0) q hash-iterate-pair)) q (122265 . 4)) ((c form c (c (? . 55) q matching-identifiers-in)) q (10427 . 2)) ((c def c (c (? . 82) q conjugate)) q (32701 . 3)) ((c def c (c (? . 44) q fl<)) q (34092 . 4)) ((c def c (c (? . 0) q peek-bytes-avail!/enable-break)) q (354923 . 14)) ((c def c (c (? . 16) q extfltruncate)) q (42777 . 3)) ((c def c (c (? . 76) q internal-definition-context-apply)) q (318431 . 5)) ((c def c (c (? . 26) q any/c)) q (199932 . 2)) ((q form ((lib "racket/surrogate.rkt") surrogate)) q (191529 . 11)) ((c def c (c (? . 7) q stream/c)) q (137278 . 3)) ((c def c (c (? . 6) q make-arity-at-least)) c (? . 45)) ((c def c (c (? . 0) q continuation-marks)) q (267420 . 5)) ((c def c (c (? . 13) q set?)) q (146589 . 3)) ((c def c (c (? . 40) q prop:contracted)) q (225730 . 2)) ((c def c (c (? . 0) q make-weak-hash)) q (115994 . 4)) ((c def c (c (? . 37) q udp-receive!*)) q (465646 . 12)) ((c def c (c (? . 0) q max)) q (24015 . 3)) ((c def c (c (? . 0) q caaadr)) q (97057 . 3)) ((c def c (c (? . 0) q prop:custom-print-quotable)) q (375325 . 2)) ((c form c (c (? . 6) q for-meta)) q (7001 . 2)) ((c def c (c (? . 9) q externalizable<%>)) q (188655 . 2)) ((c def c (c (? . 6) q exn:fail:contract:continuation)) c (? . 108)) ((c def c (c (? . 10) q vector-drop)) q (109765 . 4)) ((c def c (c (? . 16) q real->extfl)) q (43623 . 3)) ((c def c (c (? . 0) q plumber-add-flush!)) q (417442 . 5)) ((c def c (c (? . 0) q read-case-sensitive)) q (362469 . 4)) ((c def c (c (? . 19) q collapsible-ho/c-missing-party)) c (? . 94)) ((c def c (c (? . 25) q pretty-write)) q (369706 . 5)) ((c def c (c (? . 0) q current-eval)) q (386074 . 4)) ((c def c (c (? . 0) q namespace-unprotect-module)) q (383713 . 7)) ((c def c (c (? . 0) q syntax-local-identifier-as-binding)) q (306362 . 5)) ((c form c (c (? . 9) q send/apply)) q (180909 . 2)) ((c def c (c (? . 7) q stream-count)) q (136790 . 4)) ((c def c (c (? . 0) q resolved-module-path?)) q (391648 . 3)) ((c form c (c (? . 9) q define/public)) q (178812 . 3)) ((c def c (c (? . 37) q udp-addresses)) q (468257 . 7)) ((c def c (c (? . 6) q call-with-output-file)) q (324588 . 18)) ((c def c (c (? . 0) q struct:exn:fail:network:errno)) c (? . 95)) ((c def c (c (? . 0) q sync/timeout/enable-break)) q (273032 . 4)) ((c def c (c (? . 66) q blame-replaced-negative?)) q (224831 . 3)) ((c def c (c (? . 0) q regexp-match?)) q (79860 . 13)) ((c def c (c (? . 0) q sha224-bytes)) q (379676 . 5)) ((c def c (c (? . 10) q vector-filter)) q (110412 . 4)) ((c def c (c (? . 0) q struct:arity-at-least)) c (? . 45)) ((c def c (c (? . 11) q fx>=)) q (39497 . 4)) ((c def c (c (? . 0) q system-idle-evt)) q (273899 . 2)) ((c def c (c (? . 0) q subprocess-wait)) q (471382 . 3)) ((c def c (c (? . 8) q split-at-right)) q (101113 . 4)) ((c def c (c (? . 61) q make-contract)) q (216542 . 32)) ((c def c (c (? . 0) q bitwise-bit-field)) q (26759 . 6)) ((c def c (c (? . 0) q environment-variables?)) q (484345 . 3)) ((c def c (c (? . 0) q read-bytes-line)) q (349909 . 5)) ((c def c (c (? . 13) q in-set)) q (154079 . 3)) ((c def c (c (? . 0) q procedure-impersonator*?)) q (399438 . 3)) ((c form c (c (? . 6) q for/hasheq)) q (15383 . 2)) ((c def c (c (? . 0) q string->bytes/locale)) q (66847 . 6)) ((c def c (c (? . 9) q class->interface)) q (189344 . 3)) ((c form c (c (? . 49) q syntax-case*)) q (284426 . 3)) ((c def c (c (? . 37) q udp-send-to-evt)) q (467104 . 13)) ((c def c (c (? . 0) q date-minute)) c (? . 60)) ((c def c (c (? . 0) q identifier-binding-symbol)) q (296687 . 6)) ((c def c (c (? . 0) q syntax-column)) q (287971 . 3)) ((c def c (c (? . 66) q blame-source)) q (224505 . 3)) ((c def c (c (? . 0) q make-hashalw-placeholder)) q (106131 . 3)) ((c def c (c (? . 80) q date->julian/scalinger)) q (484167 . 3)) ((c def c (c (? . 9) q member-name-key=?)) q (180186 . 4)) ((c def c (c (? . 0) q string<?)) q (48419 . 4)) ((c def c (c (? . 25) q pretty-print-print-line)) q (372095 . 15)) ((c def c (c (? . 0) q procedure-arity-mask)) q (158994 . 3)) ((c def c (c (? . 26) q <=/c)) q (200479 . 3)) ((c form c (c (? . 96) q lazy-require)) q (19837 . 5)) ((c form c (c (? . 67) q define-runtime-paths)) q (448492 . 2)) ((c def c (c (? . 1) q unsafe-extfllog)) q (513508 . 3)) ((c form c (c (? . 49) q ~?)) q (285569 . 2)) ((c form c (c (? . 49) q syntax-rules)) q (287393 . 3)) ((c def c (c (? . 0) q syntax-local-make-definition-context)) q (301375 . 6)) ((c def c (c (? . 40) q coerce-chaperone-contracts)) q (222482 . 5)) ((c def c (c (? . 1) q unsafe-extflmin)) q (512628 . 4)) ((c def c (c (? . 0) q thread-cell-values?)) q (278120 . 3)) ((c def c (c (? . 17) q make-temporary-directory*)) q (455155 . 8)) ((c def c (c (? . 0) q module->namespace)) q (384252 . 6)) ((c def c (c (? . 78) q prop:serializable)) q (377941 . 2)) ((c form c (c (? . 27) q and)) q (13090 . 2)) ((c form c (c (? . 0) q if)) q (12758 . 2)) ((c def c (c (? . 6) q exn:fail:contract:non-fixnum-result)) c (? . 97)) ((c form c (c (? . 39) q trace-define)) q (520450 . 3)) ((c def c (c (? . 1) q unsafe-chaperone-procedure)) q (514654 . 11)) ((c def c (c (? . 0) q syntax-local-lift-require)) q (304854 . 7)) ((c def c (c (? . 16) q extflmin)) q (42416 . 4)) ((c def c (c (? . 0) q path->string)) q (437404 . 3)) ((c def c (c (? . 15) q convert-stream)) q (349103 . 9)) ((c def c (c (? . 0) q error-print-width)) q (254993 . 4)) ((c def c (c (? . 12) q gui?)) q (427995 . 2)) ((c def c (c (? . 0) q current-pseudo-random-generator)) q (27986 . 4)) ((c def c (c (? . 0) q impersonator-ephemeron)) q (399368 . 3)) ((c def c (c (? . 6) q exn:fail:network:errno)) c (? . 95)) ((c def c (c (? . 0) q read-accept-bar-quote)) q (363237 . 4)) ((c def c (c (? . 98) q vector/c)) q (201704 . 8)) ((c def c (c (? . 0) q struct:exn:fail:contract)) c (? . 126)) ((c def c (c (? . 37) q udp-send)) q (463389 . 6)) ((c def c (c (? . 43) q displayln)) q (365777 . 4)) ((q def ((lib "racket/interaction-info.rkt") current-interaction-info)) q (519467 . 5)) ((c def c (c (? . 6) q in-weak-hash-pairs)) q (129730 . 3)) ((c form c (c (? . 16) q for/extflvector)) q (45025 . 2)) ((c def c (c (? . 0) q poll-guard-evt)) q (273631 . 3)) ((c def c (c (? . 0) q make-struct-type-property)) q (168185 . 19)) ((c def c (c (? . 24) q export-out-sym)) c (? . 68)) ((c form c (c (? . 12) q with-limits)) q (428200 . 2)) ((c def c (c (? . 15) q read-bytes!-evt)) q (346953 . 4)) ((c def c (c (? . 11) q fxvector-copy)) q (40469 . 5)) ((c def c (c (? . 19) q collapsible-leaf/c-proj-list)) c (? . 36)) ((c def c (c (? . 0) q custodian-shut-down?)) q (414007 . 3)) ((c def c (c (? . 0) q checked-procedure-check-and-extract)) q (162089 . 11)) ((c form c (c (? . 0) q quote)) q (10866 . 2)) ((c def c (c (? . 88) q phase+space?)) q (319074 . 3)) ((c def c (c (? . 8) q count)) q (103637 . 4)) ((c def c (c (? . 0) q handle-evt)) q (273347 . 4)) ((c def c (c (? . 0) q resolve-path)) q (439929 . 3)) ((c def c (c (? . 0) q plumber-flush-all)) q (417300 . 3)) ((c def c (c (? . 0) q format)) q (366338 . 4)) ((c def c (c (? . 0) q thread-running?)) q (271961 . 3)) ((c def c (c (? . 17) q user-write-bit)) q (459761 . 2)) ((c def c (c (? . 10) q vector-filter-not)) q (110506 . 4)) ((c def c (c (? . 0) q never-evt)) q (273874 . 2)) ((c def c (c (? . 1) q unsafe-extflvector-ref)) q (514015 . 4)) ((c def c (c (? . 0) q identifier-template-binding)) q (295096 . 12)) ((c def c (c (? . 0) q exit)) q (270749 . 3)) ((c def c (c (? . 0) q port-next-location)) q (321741 . 6)) ((c form c (c (? . 99) q command-line)) q (487064 . 43)) ((c def c (c (? . 0) q string->number)) q (29489 . 19)) ((c def c (c (? . 0) q read-syntax/recursive)) q (361799 . 11)) ((c def c (c (? . 13) q list->set)) q (147911 . 3)) ((c def c (c (? . 0) q char-foldcase)) q (73269 . 3)) ((c form c (c (? . 31) q reset-at)) q (266638 . 2)) ((c def c (c (? . 6) q make-exn:fail:filesystem:missing-module)) c (? . 79)) ((c def c (c (? . 0) q bytes-set!)) q (64049 . 5)) ((c def c (c (? . 0) q read-curly-brace-with-tag)) q (362925 . 4)) ((c def c (c (? . 1) q unsafe-fx<)) q (492774 . 4)) ((c def c (c (? . 0) q read-string!)) q (350437 . 7)) ((c def c (c (? . 0) q zero?)) q (22561 . 3)) ((c def c (c (? . 13) q set-clear!)) q (152616 . 3)) ((c def c (c (? . 0) q peek-bytes!)) q (353170 . 12)) ((q def ((lib "racket/undefined.rkt") undefined)) q (164008 . 2)) ((c def c (c (? . 0) q current-namespace)) q (380561 . 4)) ((c def c (c (? . 2) q dict-key-contract)) q (141765 . 3)) ((c def c (c (? . 44) q flvector-copy)) q (36779 . 5)) ((c def c (c (? . 12) q sandbox-gui-available)) q (422785 . 4)) ((c def c (c (? . 0) q string-locale=?)) q (49875 . 4)) ((c def c (c (? . 10) q vector-append)) q (109478 . 3)) ((c form c (c (? . 9) q send)) q (180809 . 3)) ((c form c (c (? . 31) q control)) q (266446 . 2)) ((c def c (c (? . 0) q rename-file-or-directory)) q (444579 . 7)) ((c def c (c (? . 0) q syntax-property-preserved?)) q (313157 . 4)) ((c def c (c (? . 0) q char-downcase)) q (73144 . 3)) ((c def c (c (? . 6) q in-producer)) q (131119 . 7)) ((c def c (c (? . 0) q struct:exn:fail)) c (? . 74)) ((c def c (c (? . 0) q date*-nanosecond)) c (? . 63)) ((c def c (c (? . 0) q syntax-binding-set?)) q (289698 . 3)) ((c def c (c (? . 0) q bytes-utf-8-index)) q (68254 . 12)) ((c def c (c (? . 1) q unsafe-extfltan)) q (513233 . 3)) ((c def c (c (? . 37) q udp-receive!/enable-break)) q (466068 . 12)) ((c form c (c (? . 6) q struct-field-index)) q (165168 . 2)) ((c def c (c (? . 65) q promise/name?)) q (262381 . 3)) ((c def c (c (? . 44) q fltruncate)) q (34722 . 3)) ((c def c (c (? . 100) q with-intercepted-logging)) q (479661 . 17)) ((c form c (c (? . 13) q for*/weak-seteq)) q (150279 . 2)) ((c def c (c (? . 0) q will-executor?)) q (490126 . 3)) ((c def c (c (? . 0) q string-grapheme-count)) q (50856 . 6)) ((c def c (c (? . 2) q dict-iter-contract)) q (141895 . 3)) ((c def c (c (? . 21) q instance-variable-value)) q (434001 . 7)) ((c def c (c (? . 0) q string-ci>?)) q (49089 . 4)) ((c def c (c (? . 13) q weak-set)) q (147520 . 3)) ((c def c (c (? . 1) q unsafe-extflsqrt)) q (513644 . 3)) ((c def c (c (? . 19) q collapsible-ho/c?)) c (? . 94)) ((c def c (c (? . 0) q real?)) q (21864 . 3)) ((c def c (c (? . 3) q import-local-id)) c (? . 28)) ((c form c (c (? . 6) q module+)) q (1769 . 2)) ((c def c (c (? . 8) q in-combinations)) q (104515 . 6)) ((c form c (c (? . 65) q delay/strict)) q (262452 . 2)) ((c def c (c (? . 0) q read-square-bracket-as-paren)) q (362571 . 4)) ((c def c (c (? . 0) q string-titlecase)) q (49420 . 3)) ((c def c (c (? . 12) q kill-evaluator)) q (426233 . 3)) ((c form c (c (? . 65) q delay/thread)) q (262518 . 5)) ((c def c (c (? . 0) q exn:break-continuation)) c (? . 69)) ((c def c (c (? . 12) q exn:fail:resource-resource)) c (? . 101)) ((c def c (c (? . 16) q extflsqrt)) q (43334 . 3)) ((c def c (c (? . 18) q ~v)) q (54565 . 25)) ((c def c (c (? . 61) q prop:chaperone-contract)) q (225623 . 2)) ((c def c (c (? . 0) q struct:exn:break:terminate)) c (? . 121)) ((c def c (c (? . 14) q dynamic-place)) q (280396 . 9)) ((c def c (c (? . 0) q log-receiver?)) q (479372 . 3)) ((c def c (c (? . 0) q list->vector)) q (107986 . 3)) ((c def c (c (? . 0) q print-syntax-width)) q (367521 . 5)) ((c def c (c (? . 2) q in-dict-keys)) q (141516 . 3)) ((c form c (c (? . 142) q provide/contract)) q (214142 . 2)) ((c def c (c (? . 66) q blame-context)) q (224199 . 3)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:version)) c (? . 86)) ((c def c (c (? . 80) q current-date)) q (482416 . 2)) ((c def c (c (? . 0) q regexp-match-peek-positions/end)) q (86622 . 22)) ((c form c (c (? . 0) q #%require)) q (7214 . 41)) ((c def c (c (? . 0) q call-with-current-continuation)) q (263941 . 6)) ((c def c (c (? . 81) q build-chaperone-contract-property)) q (228685 . 51)) ((c def c (c (? . 0) q free-template-identifier=?)) q (293362 . 4)) ((c def c (c (? . 8) q dropf)) q (100736 . 4)) ((c form c (c (? . 102) q nand)) q (21610 . 2)) ((c def c (c (? . 0) q current-inexact-monotonic-milliseconds)) q (480910 . 2)) ((c def c (c (? . 23) q listof)) q (202470 . 3)) ((c form c (c (? . 103) q define/contract)) q (214719 . 3)) ((c def c (c (? . 0) q struct:exn:fail:syntax)) c (? . 104)) ((c def c (c (? . 0) q path?)) q (437027 . 3)) ((c form c (c (? . 105) q begin-encourage-inline)) q (19487 . 2)) ((c def c (c (? . 16) q extflceiling)) q (42712 . 3)) ((c def c (c (? . 6) q exn:fail:syntax)) c (? . 104)) ((c def c (c (? . 43) q getenv)) q (485682 . 3)) ((c def c (c (? . 3) q expand-import)) q (307993 . 4)) ((c form c (c (? . 39) q trace-define-syntax)) q (520523 . 3)) ((c def c (c (? . 0) q portal-syntax-content)) q (312003 . 3)) ((c def c (c (? . 6) q syntax-local-certifier)) q (306040 . 5)) ((c form c (c (? . 48) q match-letrec-values)) q (245046 . 2)) ((c def c (c (? . 0) q caar)) q (96045 . 3)) ((c def c (c (? . 0) q internal-definition-context-seal)) q (303139 . 3)) ((c def c (c (? . 9) q make-generic)) q (182351 . 4)) ((c def c (c (? . 0) q append)) q (92859 . 6)) ((c def c (c (? . 0) q peek-bytes-avail!*)) q (354291 . 14)) ((c def c (c (? . 25) q pretty-print-print-hook)) q (372886 . 5)) ((c def c (c (? . 0) q system-language+country)) q (486266 . 2)) ((c def c (c (? . 9) q exn:fail:object?)) c (? . 106)) ((c def c (c (? . 2) q dict-implements?)) q (137971 . 4)) ((c def c (c (? . 0) q channel-put-evt?)) q (274707 . 3)) ((c def c (c (? . 26) q >/c)) q (200424 . 3)) ((c def c (c (? . 1) q unsafe-fl>=)) q (493968 . 4)) ((c form c (c (? . 30) q time)) q (482390 . 2)) ((c def c (c (? . 0) q print-box)) q (366913 . 4)) ((c def c (c (? . 0) q port-file-unlock)) q (328080 . 3)) ((c def c (c (? . 8) q ninth)) q (99140 . 3)) ((c def c (c (? . 0) q default-continuation-prompt-tag)) q (263867 . 2)) ((c def c (c (? . 0) q make-set!-transformer)) q (297667 . 3)) ((c def c (c (? . 16) q extfl/)) q (41865 . 4)) ((c def c (c (? . 40) q coerce-flat-contracts)) q (222706 . 4)) ((c def c (c (? . 0) q byte?)) q (63816 . 3)) ((c form c (c (? . 31) q shift0-at)) q (267018 . 2)) ((c def c (c (? . 82) q cosh)) q (32808 . 3)) ((c def c (c (? . 0) q find-library-collection-links)) q (516851 . 5)) ((c def c (c (? . 21) q linklet-directory->hash)) q (432649 . 4)) ((c def c (c (? . 44) q fltan)) q (34938 . 3)) ((c def c (c (? . 0) q vector*-ref)) q (107393 . 4)) ((c def c (c (? . 43) q channel-put)) q (274536 . 4)) ((c def c (c (? . 0) q custodian-require-memory)) q (414364 . 7)) ((c def c (c (? . 1) q unsafe-vector*-set!)) q (498307 . 5)) ((c def c (c (? . 8) q list-set)) q (99593 . 5)) ((c def c (c (? . 0) q char->integer)) q (70645 . 3)) ((c def c (c (? . 13) q set-empty?)) q (151966 . 3)) ((c def c (c (? . 0) q hash-equal-always?)) q (114494 . 3)) ((c def c (c (? . 0) q floating-point-bytes->real)) q (31415 . 9)) ((c form c (c (? . 9) q interface*)) q (174663 . 7)) ((c def c (c (? . 0) q inexact-real?)) q (22225 . 3)) ((c form c (c (? . 41) q define-compound-unit)) q (195398 . 5)) ((c def c (c (? . 6) q in-immutable-hash)) q (128155 . 3)) ((c def c (c (? . 0) q char>=?)) q (71353 . 4)) ((c def c (c (? . 0) q hash-eqv?)) q (114564 . 3)) ((c def c (c (? . 0) q syntax-local-module-exports)) q (305413 . 5)) ((c def c (c (? . 122) q check-not-unsafe-undefined/assign)) q (516107 . 5)) ((c form c (c (? . 107) q include)) q (315967 . 6)) ((c def c (c (? . 12) q sandbox-error-output)) q (421585 . 14)) ((c def c (c (? . 1) q unsafe-bytes-ref)) q (499300 . 4)) ((c form c (c (? . 9) q inherit)) q (178248 . 2)) ((c def c (c (? . 1) q unsafe-fl=)) q (493631 . 4)) ((c def c (c (? . 1) q unsafe-u16vector-ref)) q (501027 . 4)) ((c def c (c (? . 0) q namespace?)) q (380074 . 3)) ((c def c (c (? . 13) q chaperone-hash-set)) q (155092 . 21)) ((c def c (c (? . 21) q correlated-source)) q (435213 . 3)) ((c def c (c (? . 15) q read-string!-evt)) q (347306 . 4)) ((c def c (c (? . 7) q stream-andmap)) q (136375 . 4)) ((c def c (c (? . 1) q unsafe-flimag-part)) q (495569 . 5)) ((c def c (c (? . 0) q replace-evt)) q (273729 . 4)) ((c def c (c (? . 0) q cddadr)) q (98257 . 3)) ((c def c (c (? . 0) q regexp-match-peek-positions-immediate/end)) q (87744 . 22)) ((c def c (c (? . 0) q plumber-flush-handle-remove!)) q (417626 . 3)) ((c def c (c (? . 0) q port-count-lines-enabled)) q (322292 . 4)) ((c def c (c (? . 30) q call-with-exception-handler)) q (254331 . 4)) ((c form c (c (? . 6) q for/hasheqv)) q (15448 . 2)) ((c def c (c (? . 0) q keyword?)) q (91578 . 3)) ((c def c (c (? . 42) q assf)) q (95927 . 4)) ((c def c (c (? . 16) q extfl->fx)) q (43759 . 3)) ((c def c (c (? . 51) q find-relative-path)) q (442262 . 12)) ((c def c (c (? . 12) q call-with-deep-time-limit)) q (428251 . 4)) ((c def c (c (? . 73) q checked-struct-info?)) q (173725 . 3)) ((c def c (c (? . 0) q struct:exn:fail:contract:continuation)) c (? . 108)) ((c def c (c (? . 0) q set-mcdr!)) q (106518 . 4)) ((c def c (c (? . 13) q weak-setalw)) q (147615 . 4)) ((c def c (c (? . 0) q write-string)) q (358639 . 7)) ((c def c (c (? . 0) q make-impersonator-property)) q (412484 . 6)) ((c def c (c (? . 43) q load-relative)) q (387146 . 3)) ((c def c (c (? . 19) q collapsible-wrapper-property)) c (? . 124)) ((c form c (c (? . 7) q for/stream)) q (137076 . 2)) ((c form c (c (? . 41) q prefix)) q (193716 . 2)) ((c def c (c (? . 15) q relocate-output-port)) q (343043 . 13)) ((c def c (c (? . 20) q tcp-listener?)) q (461559 . 3)) ((c def c (c (? . 0) q exn:fail?)) c (? . 74)) ((c def c (c (? . 19) q get-impersonator-prop:collapsible)) q (240874 . 3)) ((c def c (c (? . 13) q setalw)) q (146837 . 3)) ((c def c (c (? . 0) q current-module-declare-source)) q (393231 . 5)) ((c def c (c (? . 0) q always-evt)) q (273848 . 2)) ((c def c (c (? . 17) q group-write-bit)) q (459906 . 2)) ((c def c (c (? . 0) q real-part)) q (26104 . 3)) ((c def c (c (? . 0) q log-max-level)) q (478595 . 4)) ((c def c (c (? . 40) q value-contract)) q (236337 . 3)) ((c def c (c (? . 0) q gcd)) q (24119 . 3)) ((c def c (c (? . 0) q srcloc-source)) c (? . 59)) ((c def c (c (? . 1) q unsafe-s16vector-ref)) q (500777 . 4)) ((c form c (c (? . 136) q syntax-parameterize)) q (312131 . 2)) ((c def c (c (? . 0) q read-accept-infix-dot)) q (363857 . 4)) ((c def c (c (? . 9) q printable<%>)) q (188698 . 2)) ((c def c (c (? . 19) q collapsible-ho/c-latest-blame)) c (? . 94)) ((c def c (c (? . 0) q boolean?)) q (21193 . 3)) ((c def c (c (? . 0) q make-continuation-prompt-tag)) q (263708 . 4)) ((c form c (c (? . 54) q splicing-parameterize)) q (312691 . 2)) ((c def c (c (? . 1) q unsafe-fxmodulo)) q (491473 . 4)) ((c def c (c (? . 73) q prop:struct-auto-info)) q (174077 . 2)) ((c def c (c (? . 21) q correlated->datum)) q (435760 . 3)) ((c def c (c (? . 0) q identifier-binding)) q (293696 . 20)) ((c def c (c (? . 6) q in-weak-hash)) q (129075 . 3)) ((c def c (c (? . 72) q async-channel/c)) q (276580 . 3)) ((c form c (c (? . 49) q ...)) q (287599 . 2)) ((c def c (c (? . 51) q shrink-path-wrt)) q (443499 . 4)) ((c def c (c (? . 13) q set-map)) q (153864 . 4)) ((c form c (c (? . 6) q for*/and)) q (17152 . 2)) ((c def c (c (? . 0) q date*?)) c (? . 63)) ((c def c (c (? . 12) q sandbox-input)) q (420728 . 12)) ((c form c (c (? . 41) q invoke-unit)) q (193956 . 3)) ((c def c (c (? . 39) q current-prefix-in)) q (522000 . 4)) ((c def c (c (? . 21) q instance-variable-names)) q (433907 . 3)) ((c def c (c (? . 0) q hash)) q (114878 . 5)) ((c form c (c (? . 67) q define-runtime-module-path-index)) q (448621 . 2)) ((c def c (c (? . 0) q syntax-arm)) q (313638 . 5)) ((c def c (c (? . 1) q unsafe-fx>)) q (492858 . 4)) ((c def c (c (? . 88) q phase+space-phase)) q (319230 . 3)) ((c def c (c (? . 0) q read-accept-dot)) q (363763 . 4)) ((c form c (c (? . 53) q contract-first-order-try-less-hard)) q (238019 . 2)) ((c def c (c (? . 0) q hash-strong?)) q (114685 . 3)) ((c def c (c (? . 15) q read-bytes-evt)) q (346849 . 4)) ((c def c (c (? . 0) q raise-arity-mask-error*)) q (252275 . 9)) ((c def c (c (? . 21) q correlated-e)) q (435695 . 3)) ((c def c (c (? . 0) q read-language)) q (362271 . 5)) ((c def c (c (? . 82) q tanh)) q (32859 . 3)) ((c def c (c (? . 3) q make-require-transformer)) q (308112 . 5)) ((c form c (c (? . 54) q splicing-local)) q (312669 . 2)) ((c def c (c (? . 21) q compile-linklet)) q (429008 . 27)) ((c def c (c (? . 43) q path-add-suffix)) q (441396 . 4)) ((c def c (c (? . 1) q unsafe-flsqrt)) q (495009 . 3)) ((c def c (c (? . 2) q dict-set)) q (138731 . 5)) ((c def c (c (? . 8) q range)) q (103839 . 7)) ((c def c (c (? . 0) q integer->char)) q (70716 . 5)) ((c def c (c (? . 123) q hash/c)) q (204846 . 9)) ((c def c (c (? . 0) q will-register)) q (490186 . 5)) ((c def c (c (? . 78) q deserialize-module-guard)) q (376614 . 7)) ((c def c (c (? . 93) q generator-state)) q (137706 . 3)) ((c form c (c (? . 6) q protect-out)) q (6756 . 2)) ((c def c (c (? . 8) q splitf-at-right)) q (101401 . 4)) ((c def c (c (? . 44) q flexpt)) q (35306 . 4)) ((c def c (c (? . 0) q pseudo-random-generator->vector)) q (28157 . 4)) ((c def c (c (? . 0) q make-placeholder)) q (105547 . 3)) ((c def c (c (? . 23) q list/c)) q (203107 . 3)) ((c form c (c (? . 53) q contract)) q (216117 . 9)) ((c def c (c (? . 0) q mcons)) q (106282 . 4)) ((c def c (c (? . 0) q gensym)) q (73912 . 3)) ((c def c (c (? . 1) q unsafe-flabs)) q (493572 . 3)) ((c def c (c (? . 6) q in-range)) q (124555 . 7)) ((c def c (c (? . 22) q sequence-for-each)) q (134143 . 4)) ((c def c (c (? . 12) q break-evaluator)) q (426321 . 3)) ((c def c (c (? . 0) q make-channel)) q (274379 . 2)) ((c def c (c (? . 1) q unsafe-flceiling)) q (494345 . 3)) ((c def c (c (? . 16) q extflfloor)) q (42649 . 3)) ((c def c (c (? . 6) q in-mlist)) q (124995 . 3)) ((c def c (c (? . 17) q put-preferences)) q (457089 . 9)) ((c def c (c (? . 0) q abort-current-continuation)) q (263557 . 5)) ((c def c (c (? . 66) q blame-positive)) q (224276 . 3)) ((c def c (c (? . 40) q coerce-flat-contract)) q (222611 . 4)) ((c def c (c (? . 0) q -)) q (23251 . 6)) ((c def c (c (? . 0) q make-struct-field-accessor)) q (166934 . 12)) ((c def c (c (? . 0) q prop:liberal-define-context)) q (307864 . 2)) ((c def c (c (? . 66) q current-blame-format)) q (225410 . 4)) ((c def c (c (? . 0) q exn:fail:syntax:missing-module-path)) c (? . 52)) ((c def c (c (? . 0) q caadr)) q (96383 . 3)) ((c def c (c (? . 0) q vector-copy!)) q (108253 . 11)) ((c form c (c (? . 9) q rename-super)) q (178371 . 2)) ((c form c (c (? . 31) q shift0)) q (266835 . 2)) ((c def c (c (? . 3) q convert-relative-module-path)) q (309361 . 6)) ((c def c (c (? . 76) q current-recorded-disappeared-uses)) q (317767 . 5)) ((c form c (c (? . 0) q let-values)) q (12055 . 2)) ((c form c (c (? . 41) q unit/s)) q (196640 . 6)) ((c def c (c (? . 1) q unsafe-extfl>)) q (512362 . 4)) ((c form c (c (? . 30) q parameterize)) q (278362 . 5)) ((c def c (c (? . 0) q ephemeron-value)) q (489862 . 5)) ((c def c (c (? . 30) q hash-update!)) q (119029 . 11)) ((c def c (c (? . 15) q call-with-input-bytes)) q (336427 . 4)) ((c form c (c (? . 9) q define/augride)) q (179398 . 3)) ((c def c (c (? . 0) q portal-syntax?)) q (311867 . 3)) ((c def c (c (? . 0) q read-line)) q (349696 . 5)) ((c def c (c (? . 0) q lcm)) q (24178 . 3)) ((c def c (c (? . 82) q nonpositive-integer?)) q (33515 . 3)) ((c def c (c (? . 0) q current-gc-milliseconds)) q (482127 . 2)) ((c def c (c (? . 20) q tcp-accept)) q (461197 . 3)) ((c form c (c (? . 6) q provide)) q (5573 . 24)) ((c form c (c (? . 6) q all-from-out)) q (6507 . 2)) ((c def c (c (? . 6) q make-exn:fail:filesystem:errno)) c (? . 84)) ((c def c (c (? . 6) q regexp-match-positions*)) q (78823 . 17)) ((c def c (c (? . 25) q pretty-printing)) q (373436 . 4)) ((c def c (c (? . 0) q exn:fail:network:errno-errno)) c (? . 95)) ((c def c (c (? . 0) q continuation?)) q (265290 . 3)) ((c form c (c (? . 31) q %)) q (266215 . 4)) ((c def c (c (? . 18) q ~a)) q (53333 . 25)) ((c def c (c (? . 26) q not/c)) q (200224 . 3)) ((c def c (c (? . 0) q write-byte)) q (358433 . 4)) ((c def c (c (? . 32) q exn:fail:support?)) c (? . 109)) ((c def c (c (? . 0) q read-accept-box)) q (363039 . 4)) ((c def c (c (? . 25) q pretty-print-size-hook)) q (372600 . 9)) ((c def c (c (? . 26) q parameter/c)) q (204475 . 7)) ((c def c (c (? . 13) q list->setalw)) q (148001 . 4)) ((c def c (c (? . 0) q unquoted-printing-string?)) q (254072 . 3)) ((c def c (c (? . 51) q path-get-extension)) q (441876 . 3)) ((c def c (c (? . 76) q wrong-syntax)) q (317639 . 5)) ((c def c (c (? . 13) q mutable-set)) q (147102 . 4)) ((c def c (c (? . 0) q use-collection-link-paths)) q (519166 . 4)) ((c def c (c (? . 93) q sequence->generator)) q (137771 . 3)) ((c def c (c (? . 1) q unsafe-vector-ref)) q (497899 . 4)) ((c def c (c (? . 26) q char-in)) q (200872 . 4)) ((c def c (c (? . 0) q vector->list)) q (107925 . 3)) ((c form c (c (? . 9) q this)) q (177609 . 2)) ((c def c (c (? . 0) q dynamic-wind)) q (265419 . 7)) ((c def c (c (? . 30) q current-parameterization)) q (278949 . 2)) ((c def c (c (? . 17) q other-read-bit)) q (460019 . 2)) ((c form c (c (? . 27) q let)) q (11856 . 3)) ((c def c (c (? . 0) q current-read-interaction)) q (389857 . 4)) ((c form c (c (? . 27) q unless)) q (14363 . 2)) ((c def c (c (? . 0) q call-with-continuation-barrier)) q (264995 . 3)) ((c def c (c (? . 0) q current-custodian)) q (414084 . 4)) ((c def c (c (? . 73) q struct:struct-info)) q (173986 . 2)) ((c form c (c (? . 41) q unit/c)) q (197473 . 16)) ((c def c (c (? . 0) q current-code-inspector)) q (416985 . 4)) ((c def c (c (? . 1) q unsafe-fl<)) q (493715 . 4)) ((c def c (c (? . 0) q current-module-name-resolver)) q (392456 . 19)) ((c def c (c (? . 0) q syntax-binding-set->syntax)) q (289819 . 5)) ((c form c (c (? . 0) q case-lambda)) q (11681 . 6)) ((c def c (c (? . 6) q regexp-replace-quote)) q (91446 . 5)) ((c def c (c (? . 16) q extflacos)) q (43088 . 3)) ((c def c (c (? . 75) q engine-run)) q (282647 . 4)) ((c def c (c (? . 1) q unsafe-vector*->immutable-vector!)) q (498631 . 4)) ((c def c (c (? . 0) q peek-string)) q (352228 . 5)) ((c def c (c (? . 0) q call-with-semaphore)) q (275366 . 9)) ((c def c (c (? . 0) q resolved-module-path-name)) q (392059 . 8)) ((c def c (c (? . 37) q udp-set-receive-buffer-size!)) q (466502 . 5)) ((c def c (c (? . 6) q in-ephemeron-hash-values)) q (130425 . 3)) ((c def c (c (? . 29) q string-replace)) q (52077 . 6)) ((c def c (c (? . 0) q read-accept-quasiquote)) q (364045 . 4)) ((c def c (c (? . 42) q filter)) q (93614 . 4)) ((c def c (c (? . 0) q symbol?)) q (73439 . 3)) ((c form c (c (? . 102) q nor)) q (21635 . 2)) ((c def c (c (? . 42) q compose1)) q (157903 . 3)) ((c def c (c (? . 43) q reroot-path)) q (441555 . 4)) ((c def c (c (? . 15) q relocate-input-port)) q (342523 . 13)) ((c def c (c (? . 0) q read-accept-lang)) q (364253 . 4)) ((c def c (c (? . 15) q copy-port)) q (349384 . 4)) ((c def c (c (? . 0) q load/use-compiled)) q (388536 . 3)) ((c form c (c (? . 46) q serializable-struct/versions)) q (377160 . 7)) ((c def c (c (? . 2) q prop:dict/contract)) q (141714 . 2)) ((c def c (c (? . 0) q list->string)) q (48113 . 3)) ((c def c (c (? . 0) q prop:checked-procedure)) q (162034 . 2)) ((c def c (c (? . 51) q simple-form-path)) q (443204 . 3)) ((c def c (c (? . 0) q make-security-guard)) q (412930 . 16)) ((c def c (c (? . 1) q unsafe-extflsin)) q (513097 . 3)) ((c def c (c (? . 6) q memw)) q (94921 . 4)) ((c def c (c (? . 40) q impersonator-contract?)) q (236089 . 3)) ((c def c (c (? . 19) q build-collapsible-contract-property)) q (239337 . 15)) ((c def c (c (? . 0) q current-thread-group)) q (415299 . 4)) ((c def c (c (? . 0) q >=)) q (25092 . 4)) ((c def c (c (? . 10) q vector-argmin)) q (110722 . 4)) ((c form c (c (? . 9) q new)) q (180495 . 2)) ((c def c (c (? . 20) q port-number?)) q (462122 . 2)) ((c def c (c (? . 0) q current-environment-variables)) q (484413 . 4)) ((c def c (c (? . 32) q raise-support-error)) q (170160 . 4)) ((c def c (c (? . 0) q srcloc-column)) c (? . 59)) ((c def c (c (? . 0) q char-blank?)) q (72528 . 3)) ((c def c (c (? . 11) q fxmin)) q (39575 . 4)) ((c def c (c (? . 110) q getpid)) q (489510 . 2)) ((c def c (c (? . 25) q pretty-print-extend-style-table)) q (371458 . 8)) ((c form c (c (? . 93) q generator)) q (137393 . 6)) ((c def c (c (? . 6) q make-exn:fail:contract:arity)) c (? . 111)) ((c form c (c (? . 9) q augride*)) q (178701 . 2)) ((c def c (c (? . 5) q conjoin)) q (163061 . 4)) ((c form c (c (? . 30) q log-warning)) q (479154 . 3)) ((c def c (c (? . 112) q fasl->s-exp)) q (379089 . 9)) ((c def c (c (? . 8) q append*)) q (102591 . 7)) ((c def c (c (? . 115) q make-constructor-style-printer)) q (173228 . 6)) ((c def c (c (? . 43) q channel-try-get)) q (274475 . 3)) ((c def c (c (? . 9) q class-unseal)) q (191382 . 5)) ((c def c (c (? . 22) q sequence-ormap)) q (134039 . 4)) ((c def c (c (? . 0) q bytes->string/latin-1)) q (66239 . 9)) ((c def c (c (? . 0) q subprocess-status)) q (471458 . 4)) ((c def c (c (? . 9) q struct:exn:fail:object)) c (? . 106)) ((c def c (c (? . 0) q environment-variables-copy)) q (485575 . 3)) ((c def c (c (? . 29) q non-empty-string?)) q (52983 . 3)) ((c def c (c (? . 1) q unsafe-fx+)) q (491095 . 3)) ((c def c (c (? . 12) q call-with-killing-threads)) c (? . 139)) ((c def c (c (? . 6) q regexp-match-exact?)) q (80448 . 4)) ((c def c (c (? . 73) q struct-field-info-list)) q (174444 . 3)) ((c def c (c (? . 9) q generate-member-key)) q (180070 . 2)) ((c form c (c (? . 9) q send/keyword-apply)) q (180975 . 4)) ((c def c (c (? . 1) q unsafe-flmax)) q (494138 . 4)) ((c def c (c (? . 11) q fxmax)) q (39653 . 4)) ((c def c (c (? . 0) q system-path-convention-type)) q (438446 . 2)) ((c form c (c (? . 23) q flat-murec-contract)) q (205939 . 2)) ((c def c (c (? . 16) q extflcos)) q (42904 . 3)) ((c form c (c (? . 7) q stream*)) q (135684 . 2)) ((c def c (c (? . 0) q exn:fail:read-srclocs)) c (? . 85)) ((c def c (c (? . 0) q bytes-convert-end)) q (69756 . 13)) ((c def c (c (? . 1) q unsafe-fxxor)) q (491743 . 3)) ((c def c (c (? . 81) q skip-projection-wrapper?)) q (222898 . 5)) ((c def c (c (? . 42) q remw)) q (93952 . 4)) ((c def c (c (? . 39) q current-trace-print-args)) q (521006 . 14)) ((c def c (c (? . 6) q in-hash-pairs)) q (126906 . 6)) ((c def c (c (? . 0) q eqv-hash-code)) q (21020 . 3)) ((c def c (c (? . 0) q read-char-or-special)) q (355627 . 8)) ((c def c (c (? . 16) q extfl->floating-point-bytes)) q (45987 . 10)) ((c def c (c (? . 0) q make-hash-placeholder)) q (105838 . 3)) ((c def c (c (? . 26) q if/c)) q (238066 . 5)) ((c def c (c (? . 42) q reverse)) q (92984 . 3)) ((c def c (c (? . 37) q udp-multicast-set-interface!)) q (469298 . 5)) ((c def c (c (? . 0) q syntax-bound-symbols)) q (297189 . 8)) ((c def c (c (? . 2) q in-dict)) q (141456 . 3)) ((c form c (c (? . 56) q for/async)) q (279648 . 2)) ((c def c (c (? . 0) q liberal-define-context?)) q (307924 . 3)) ((c def c (c (? . 23) q the-unsupplied-arg)) q (212537 . 2)) ((c def c (c (? . 1) q unsafe-flsingle)) q (494472 . 3)) ((c def c (c (? . 0) q mcar)) q (106350 . 3)) ((c def c (c (? . 2) q prop:dict)) q (138355 . 2)) ((c def c (c (? . 19) q collapsible-property-neg-party)) c (? . 113)) ((c def c (c (? . 0) q atan)) q (25817 . 6)) ((c def c (c (? . 23) q symbols)) q (201196 . 3)) ((c def c (c (? . 80) q find-seconds)) q (483449 . 15)) ((c def c (c (? . 18) q ~.v)) q (61018 . 25)) ((c def c (c (? . 0) q ephemeron?)) q (490019 . 3)) ((c def c (c (? . 9) q object?)) q (188765 . 3)) ((c def c (c (? . 0) q equal-secondary-hash-code)) q (20749 . 3)) ((c form c (c (? . 6) q #%app)) q (11097 . 2)) ((c def c (c (? . 6) q exn:fail:read:eof)) c (? . 114)) ((c def c (c (? . 0) q regexp-match/end)) q (84953 . 20)) ((c def c (c (? . 17) q user-execute-bit)) q (459795 . 2)) ((c def c (c (? . 0) q error-escape-handler)) q (254729 . 4)) ((c def c (c (? . 0) q object-name)) q (416884 . 3)) ((c def c (c (? . 0) q print-boolean-long-form)) q (367193 . 4)) ((c def c (c (? . 24) q export-protect?)) c (? . 68)) ((c def c (c (? . 5) q normalize-arity)) q (163574 . 4)) ((c def c (c (? . 12) q sandbox-security-guard)) q (423062 . 5)) ((c def c (c (? . 0) q exn:fail:unsupported?)) c (? . 119)) ((c def c (c (? . 2) q dict-can-functional-set?)) q (138269 . 3)) ((c def c (c (? . 6) q regexp-try-match)) q (77252 . 14)) ((c def c (c (? . 115) q struct->list)) q (173508 . 4)) ((c def c (c (? . 1) q unsafe-stencil-vector-ref)) q (501704 . 4)) ((c def c (c (? . 42) q remw*)) q (94304 . 4)) ((c def c (c (? . 0) q syntax-transforming?)) q (306192 . 2)) ((c def c (c (? . 0) q prop:sealed)) q (168141 . 2)) ((c def c (c (? . 0) q variable-reference->module-source)) q (385479 . 4)) ((c def c (c (? . 7) q stream-filter)) q (136892 . 4)) ((c form c (c (? . 9) q define-serializable-class)) q (188571 . 3)) ((c def c (c (? . 0) q string-foldcase)) q (49493 . 3)) ((c def c (c (? . 0) q set-port-next-location!)) q (321922 . 9)) ((c def c (c (? . 0) q readtable-mapping)) q (374597 . 9)) ((c def c (c (? . 0) q internal-definition-context-binding-identifiers)) q (302672 . 4)) ((c def c (c (? . 13) q set-symmetric-difference!)) q (153410 . 4)) ((c form c (c (? . 5) q thunk*)) q (162968 . 2)) ((c def c (c (? . 40) q contract-projection)) q (236727 . 3)) ((c def c (c (? . 16) q extfl-)) q (41699 . 4)) ((c def c (c (? . 0) q string)) q (46587 . 3)) ((c def c (c (? . 13) q set-clear)) q (152527 . 3)) ((c def c (c (? . 15) q filter-read-input-port)) q (345101 . 27)) ((c def c (c (? . 0) q date?)) c (? . 60)) ((c def c (c (? . 0) q set-box!)) q (113909 . 4)) ((c def c (c (? . 130) q hash-union)) q (123010 . 12)) ((c def c (c (? . 44) q flacos)) q (35043 . 3)) ((c def c (c (? . 1) q unsafe-fl*)) q (493427 . 3)) ((c def c (c (? . 78) q make-deserialize-info)) q (377803 . 4)) ((c def c (c (? . 5) q identity)) q (162776 . 3)) ((c def c (c (? . 0) q char-upcase)) q (73084 . 3)) ((c def c (c (? . 0) q caddr)) q (96547 . 3)) ((c def c (c (? . 0) q angle)) q (26295 . 3)) ((c def c (c (? . 6) q hash-set*)) q (118196 . 5)) ((c def c (c (? . 116) q map)) q (93038 . 4)) ((c def c (c (? . 0) q procedure-struct-type?)) q (161808 . 3)) ((c form c (c (? . 9) q init)) q (177667 . 2)) ((c def c (c (? . 12) q sandbox-output)) q (421127 . 14)) ((c def c (c (? . 0) q module-compiled-name)) q (394855 . 9)) ((c def c (c (? . 15) q peek-bytes-evt)) c (? . 117)) ((c def c (c (? . 0) q make-parameter)) q (278185 . 5)) ((c def c (c (? . 0) q system-library-subpath)) q (486315 . 3)) ((c def c (c (? . 0) q port-file-identity)) q (328157 . 3)) ((c form c (c (? . 6) q for/foldr/derived)) q (18054 . 4)) ((c def c (c (? . 0) q close-output-port)) q (320058 . 3)) ((c form c (c (? . 23) q case->)) q (211097 . 9)) ((c def c (c (? . 43) q port?)) q (319940 . 3)) ((c def c (c (? . 14) q place-break)) q (281536 . 4)) ((c def c (c (? . 0) q impersonator-prop:application-mark)) q (412801 . 2)) ((c form c (c (? . 13) q for/seteq)) q (149181 . 2)) ((c form c (c (? . 40) q define/subexpression-pos-prop)) q (235435 . 6)) ((c def c (c (? . 6) q exn:fail:read:non-char)) c (? . 58)) ((c form c (c (? . 0) q letrec-values)) q (12180 . 2)) ((c def c (c (? . 41) q unit?)) q (197371 . 3)) ((c def c (c (? . 0) q raise-result-arity-error)) q (252584 . 9)) ((c def c (c (? . 7) q stream-ormap)) q (136476 . 4)) ((c def c (c (? . 0) q locale-string-encoding)) q (70352 . 2)) ((c def c (c (? . 0) q parameter-procedure=?)) q (278853 . 4)) ((c def c (c (? . 6) q gen:equal-mode+hash)) q (21109 . 2)) ((c def c (c (? . 0) q file-exists?)) q (444195 . 3)) ((c def c (c (? . 0) q write-bytes)) q (358919 . 7)) ((c form c (c (? . 9) q generic)) q (182183 . 2)) ((c def c (c (? . 0) q exn:fail:contract:divide-by-zero?)) c (? . 118)) ((c def c (c (? . 0) q struct:exn:fail:unsupported)) c (? . 119)) ((c def c (c (? . 0) q find-system-path)) q (443620 . 3)) ((c def c (c (? . 0) q system-type)) q (485989 . 6)) ((c def c (c (? . 0) q readtable?)) q (374150 . 3)) ((c def c (c (? . 102) q false)) q (21376 . 2)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-next)) q (507402 . 4)) ((c def c (c (? . 0) q free-transformer-identifier=?)) q (293244 . 4)) ((c def c (c (? . 43) q path-replace-extension)) q (440853 . 4)) ((c def c (c (? . 44) q flimag-part)) q (35914 . 5)) ((c def c (c (? . 17) q other-write-bit)) q (460053 . 2)) ((c def c (c (? . 116) q ormap)) q (93211 . 4)) ((c form c (c (? . 2) q define-custom-hash-types)) q (141960 . 12)) ((c def c (c (? . 56) q future?)) q (279466 . 3)) ((c def c (c (? . 21) q correlated-span)) q (435592 . 3)) ((c def c (c (? . 8) q take-right)) q (100911 . 4)) ((c form c (c (? . 0) q #%provide)) q (9130 . 31)) ((c def c (c (? . 0) q rational?)) q (21915 . 3)) ((c def c (c (? . 9) q member-name-key-hash-code)) q (180306 . 3)) ((c def c (c (? . 0) q integer?)) q (21970 . 3)) ((c def c (c (? . 0) q integer->integer-bytes)) q (30842 . 14)) ((c form c (c (? . 9) q private*)) q (178777 . 2)) ((c form c (c (? . 34) q trait-rename-field)) q (183709 . 2)) ((c form c (c (? . 6) q planet)) q (5267 . 5)) ((c def c (c (? . 0) q file-or-directory-type)) q (444337 . 5)) ((c def c (c (? . 6) q make-exn:fail:contract:variable)) c (? . 120)) ((c def c (c (? . 57) q contract-exercise)) q (242815 . 7)) ((c def c (c (? . 16) q extflatan)) q (43150 . 3)) ((c def c (c (? . 73) q struct-field-info?)) q (174380 . 3)) ((c def c (c (? . 0) q dump-memory-stats)) q (490740 . 3)) ((c def c (c (? . 0) q namespace-set-variable-value!)) q (381392 . 11)) ((c def c (c (? . 26) q between/c)) q (200591 . 4)) ((c def c (c (? . 0) q syntax-transforming-module-expression?)) q (306297 . 2)) ((c def c (c (? . 44) q flvector-ref)) q (36539 . 4)) ((c def c (c (? . 6) q exn:break:terminate)) c (? . 121)) ((c def c (c (? . 0) q impersonate-box)) q (402161 . 12)) ((c def c (c (? . 0) q syntax->list)) q (288552 . 3)) ((c def c (c (? . 0) q eval-syntax)) q (386363 . 6)) ((c def c (c (? . 11) q fx+/wraparound)) q (38855 . 4)) ((c def c (c (? . 122) q check-not-unsafe-undefined)) q (515964 . 5)) ((c def c (c (? . 15) q transplant-input-port)) q (343573 . 19)) ((c form c (c (? . 54) q splicing-letrec-syntaxes)) q (312598 . 2)) ((c def c (c (? . 48) q prop:match-expander)) q (245379 . 2)) ((c def c (c (? . 43) q load/cd)) q (387213 . 3)) ((c def c (c (? . 72) q chaperone-async-channel)) q (277133 . 13)) ((c def c (c (? . 76) q generate-temporary)) q (318339 . 3)) ((c def c (c (? . 0) q integer-length)) q (27079 . 3)) ((c def c (c (? . 0) q syntax-original?)) q (288253 . 3)) ((c def c (c (? . 6) q hash-map/copy)) q (120532 . 5)) ((c def c (c (? . 0) q cddaar)) q (98157 . 3)) ((c def c (c (? . 0) q procedure?)) q (157630 . 3)) ((c def c (c (? . 2) q make-custom-hash-types)) q (142453 . 24)) ((c def c (c (? . 82) q exact-floor)) q (32977 . 3)) ((c def c (c (? . 73) q struct-info?)) q (173667 . 3)) ((c def c (c (? . 2) q make-weak-custom-hash)) q (144493 . 14)) ((c def c (c (? . 31) q call/comp)) q (265974 . 5)) ((c form c (c (? . 31) q shift)) q (266607 . 2)) ((c def c (c (? . 0) q module-compiled-cross-phase-persistent?)) q (396775 . 4)) ((c def c (c (? . 116) q for-each)) q (93297 . 4)) ((c form c (c (? . 27) q or)) q (13114 . 2)) ((c def c (c (? . 0) q subprocess-pid)) q (471722 . 3)) ((c def c (c (? . 1) q unsafe-flfloor)) q (494284 . 3)) ((c def c (c (? . 0) q cdddr)) q (96875 . 3)) ((c def c (c (? . 88) q phase+space+)) q (319438 . 4)) ((c def c (c (? . 0) q set!-transformer-procedure)) q (297770 . 4)) ((c def c (c (? . 65) q promise-running?)) q (262272 . 3)) ((c def c (c (? . 49) q syntax-pattern-variable?)) q (287639 . 3)) ((c def c (c (? . 42) q findf)) q (95348 . 4)) ((c def c (c (? . 0) q write-special-evt)) q (361010 . 4)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-first)) q (507290 . 3)) ((c def c (c (? . 51) q path-element?)) q (443015 . 3)) ((c def c (c (? . 23) q dynamic->*)) q (211283 . 19)) ((c def c (c (? . 1) q unsafe-fx-/wraparound)) q (492418 . 4)) ((c def c (c (? . 30) q hash-ref!)) q (118822 . 5)) ((c def c (c (? . 0) q raise-mismatch-error)) q (251017 . 8)) ((c def c (c (? . 0) q string-fill!)) q (47755 . 4)) ((c def c (c (? . 6) q regexp-match*)) q (76235 . 20)) ((c def c (c (? . 40) q has-contract?)) q (236418 . 3)) ((c def c (c (? . 13) q set-subtract)) q (153086 . 4)) ((c form c (c (? . 41) q unit-from-context)) q (196163 . 2)) ((c def c (c (? . 0) q prop:output-port)) q (329597 . 2)) ((c def c (c (? . 0) q make-reader-graph)) q (105429 . 3)) ((c def c (c (? . 0) q variable-reference->phase)) q (385626 . 3)) ((c def c (c (? . 82) q radians->degrees)) q (32498 . 3)) ((c def c (c (? . 0) q struct-type-property-accessor-procedure?)) q (169071 . 3)) ((c def c (c (? . 26) q string-len/c)) q (200992 . 3)) ((c def c (c (? . 29) q string-normalize-spaces)) q (51620 . 11)) ((c def c (c (? . 2) q make-immutable-custom-hash)) q (145226 . 14)) ((c def c (c (? . 0) q pseudo-random-generator-vector?)) q (28620 . 3)) ((c def c (c (? . 0) q bound-identifier=?)) q (292619 . 6)) ((c def c (c (? . 11) q fx-)) q (37788 . 4)) ((c def c (c (? . 0) q make-file-or-directory-link)) q (446964 . 4)) ((c def c (c (? . 6) q in-bytes)) q (125529 . 6)) ((c def c (c (? . 0) q struct:exn:fail:contract:non-fixnum-result)) c (? . 97)) ((c def c (c (? . 1) q unsafe-fl/)) q (493489 . 4)) ((c def c (c (? . 6) q procedure-keywords)) q (159898 . 4)) ((c def c (c (? . 0) q date*-time-zone-name)) c (? . 63)) ((c def c (c (? . 0) q continuation-mark-set->list)) q (267823 . 8)) ((c def c (c (? . 17) q make-temporary-file)) q (453928 . 13)) ((c def c (c (? . 0) q date-year-day)) c (? . 60)) ((c def c (c (? . 7) q stream-tail)) q (136033 . 4)) ((c def c (c (? . 15) q port->string)) q (334725 . 4)) ((c def c (c (? . 1) q unsafe-bytes->immutable-bytes!)) q (499926 . 4)) ((c def c (c (? . 93) q sequence->repeated-generator)) q (137841 . 3)) ((c form c (c (? . 38) q class/c)) q (183761 . 28)) ((c def c (c (? . 6) q procedure-reduce-keyword-arity)) q (160386 . 14)) ((c def c (c (? . 1) q unsafe-fx=)) q (492690 . 4)) ((c def c (c (? . 8) q take-common-prefix)) q (101641 . 5)) ((c def c (c (? . 1) q unsafe-char=?)) q (496006 . 4)) ((c form c (c (? . 65) q delay/sync)) q (262486 . 2)) ((c def c (c (? . 0) q read-syntax)) q (361360 . 4)) ((c def c (c (? . 57) q contract-random-generate-env?)) q (243365 . 3)) ((c form c (c (? . 41) q rename)) q (193675 . 2)) ((c def c (c (? . 0) q current-get-interaction-input-port)) q (389575 . 4)) ((c def c (c (? . 42) q build-list)) q (92451 . 4)) ((c def c (c (? . 0) q byte-pregexp?)) q (74357 . 3)) ((c form c (c (? . 0) q unquote)) q (19273 . 2)) ((c def c (c (? . 0) q hash-equal?)) q (114431 . 3)) ((c def c (c (? . 0) q break-enabled)) q (270273 . 4)) ((c def c (c (? . 0) q syntax-debug-info)) q (292346 . 5)) ((c def c (c (? . 42) q remove*)) q (94022 . 5)) ((c def c (c (? . 1) q unsafe-fxmax)) q (493197 . 4)) ((c def c (c (? . 0) q file-position*)) q (321366 . 3)) ((c form c (c (? . 6) q for*/fold)) q (17536 . 3)) ((c def c (c (? . 1) q unsafe-fx->extfl)) q (513806 . 3)) ((c form c (c (? . 0) q set!)) q (14402 . 2)) ((c def c (c (? . 0) q filesystem-change-evt?)) q (448022 . 3)) ((c form c (c (? . 6) q #%plain-app)) q (11162 . 3)) ((c def c (c (? . 0) q inspector?)) q (415420 . 3)) ((c def c (c (? . 11) q fx*/wraparound)) q (39019 . 4)) ((c def c (c (? . 0) q call-with-continuation-prompt)) q (263146 . 10)) ((c def c (c (? . 1) q unsafe-fx*)) q (491240 . 3)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-pair)) q (510858 . 5)) ((c form c (c (? . 123) q hash/dc)) q (205175 . 7)) ((c def c (c (? . 0) q module-path?)) q (392398 . 3)) ((c form c (c (? . 30) q log-fatal)) q (479010 . 3)) ((c def c (c (? . 56) q current-future)) q (279414 . 2)) ((c form c (c (? . 23) q ->)) q (206577 . 12)) ((c form c (c (? . 41) q link)) q (193822 . 2)) ((c def c (c (? . 0) q pregexp?)) q (74245 . 3)) ((c def c (c (? . 0) q hasheq)) q (115154 . 5)) ((c def c (c (? . 82) q negative-integer?)) q (33452 . 3)) ((c def c (c (? . 21) q linklet-body-reserved-symbol?)) q (433172 . 3)) ((c def c (c (? . 6) q hash-keys)) q (120748 . 4)) ((c def c (c (? . 0) q syntax-binding-set)) q (289763 . 2)) ((c def c (c (? . 10) q vector-map)) q (109253 . 4)) ((c form c (c (? . 6) q :do-in)) q (18596 . 9)) ((c form c (c (? . 48) q failure-cont)) q (245261 . 2)) ((c def c (c (? . 0) q file-position)) q (321166 . 6)) ((c def c (c (? . 23) q property/c)) q (206271 . 5)) ((c def c (c (? . 0) q syntax-property-remove)) q (313061 . 4)) ((c def c (c (? . 0) q continuation-prompt-available?)) q (265078 . 5)) ((c def c (c (? . 0) q make-environment-variables)) q (484644 . 5)) ((c def c (c (? . 98) q vector-immutableof)) q (201635 . 3)) ((c form c (c (? . 107) q include-at/relative-to/reader)) q (316192 . 2)) ((c def c (c (? . 13) q weak-seteqv)) q (147721 . 3)) ((c def c (c (? . 6) q sequence?)) q (124500 . 3)) ((c def c (c (? . 7) q stream-fold)) q (136671 . 5)) ((c def c (c (? . 42) q sort)) q (94383 . 9)) ((c def c (c (? . 15) q call-with-output-bytes)) q (336068 . 3)) ((c def c (c (? . 9) q dynamic-get-field)) q (181774 . 4)) ((c def c (c (? . 0) q struct:date)) c (? . 60)) ((c def c (c (? . 0) q cadadr)) q (97457 . 3)) ((c def c (c (? . 26) q flat-named-contract)) q (199618 . 8)) ((c def c (c (? . 19) q collapsible-property-ref)) c (? . 113)) ((c def c (c (? . 0) q semaphore-peek-evt)) q (275215 . 3)) ((c def c (c (? . 10) q vector-take-right)) q (109653 . 4)) ((c def c (c (? . 30) q break-parameterization?)) q (270680 . 3)) ((c def c (c (? . 0) q call-with-composable-continuation)) q (264391 . 6)) ((c def c (c (? . 0) q string->uninterned-symbol)) q (73760 . 3)) ((c def c (c (? . 19) q struct:collapsible-wrapper-property)) c (? . 124)) ((c def c (c (? . 0) q hash-for-each)) q (121208 . 5)) ((c form c (c (? . 9) q mixin)) q (182477 . 3)) ((c def c (c (? . 1) q unsafe-stencil-vector)) q (501267 . 4)) ((c def c (c (? . 44) q fl=)) q (34015 . 4)) ((q form ((lib "racket/local.rkt") local)) q (12665 . 2)) ((c def c (c (? . 0) q read-decimal-as-inexact)) q (363553 . 4)) ((c def c (c (? . 40) q contract-equivalent?)) q (235678 . 4)) ((c def c (c (? . 1) q unsafe-struct-set!)) q (502501 . 5)) ((c def c (c (? . 16) q extflabs)) q (41948 . 3)) ((c def c (c (? . 100) q with-logging-to-port)) q (480347 . 12)) ((c def c (c (? . 0) q struct-type-make-constructor)) q (416559 . 6)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:errno)) c (? . 84)) ((c def c (c (? . 0) q file-size)) q (446215 . 3)) ((c form c (c (? . 27) q letrec-syntaxes)) q (12428 . 2)) ((c def c (c (? . 0) q peek-string!)) q (352670 . 12)) ((c def c (c (? . 0) q =)) q (24803 . 4)) ((c form c (c (? . 13) q for/weak-setalw)) q (150169 . 2)) ((c form c (c (? . 30) q with-handlers*)) q (254656 . 3)) ((c def c (c (? . 78) q make-serialize-info)) q (377979 . 13)) ((c def c (c (? . 88) q phase+space-shift?)) q (319374 . 3)) ((c def c (c (? . 6) q make-date)) c (? . 60)) ((c def c (c (? . 0) q exn:fail:read:eof?)) c (? . 114)) ((c def c (c (? . 0) q current-directory-for-user)) q (447346 . 4)) ((c def c (c (? . 0) q bitwise-ior)) q (26345 . 3)) ((c def c (c (? . 13) q impersonate-hash-set)) q (154141 . 21)) ((c def c (c (? . 6) q chaperone-procedure)) q (405679 . 11)) ((c def c (c (? . 29) q string-trim)) q (52587 . 11)) ((c def c (c (? . 25) q pretty-print-post-print-hook)) q (373256 . 5)) ((c def c (c (? . 0) q read-bytes!)) q (350764 . 7)) ((c def c (c (? . 0) q char-numeric?)) q (72195 . 3)) ((c def c (c (? . 0) q build-path)) q (438515 . 6)) ((c form c (c (? . 107) q include/reader)) q (316144 . 2)) ((c def c (c (? . 0) q stencil-vector-length)) q (112887 . 4)) ((c def c (c (? . 19) q collapsible-property?)) c (? . 113)) ((c def c (c (? . 10) q vector-set*!)) q (109089 . 5)) ((c def c (c (? . 1) q unsafe-fxpopcount32)) q (492125 . 3)) ((c def c (c (? . 15) q port->list)) q (334576 . 4)) ((c form c (c (? . 27) q let-syntaxes)) q (12362 . 2)) ((c form c (c (? . 6) q for*/hashalw)) q (17085 . 2)) ((c def c (c (? . 6) q procedure-realm)) q (158120 . 3)) ((c def c (c (? . 61) q contract-property?)) q (235092 . 3)) ((c form c (c (? . 76) q with-disappeared-uses)) q (317961 . 4)) ((q form ((lib "racket/private/define.rkt") define-values-for-syntax)) q (13804 . 2)) ((c def c (c (? . 0) q sync)) q (272769 . 3)) ((c def c (c (? . 6) q procedure-rename)) q (157975 . 5)) ((c def c (c (? . 40) q coerce-contract)) q (222184 . 4)) ((c def c (c (? . 0) q thread-send)) q (272336 . 6)) ((c def c (c (? . 17) q call-with-atomic-output-file)) q (455457 . 12)) ((c form c (c (? . 54) q splicing-letrec-syntaxes+values)) q (312630 . 2)) ((c def c (c (? . 61) q flat-contract-property?)) q (235230 . 3)) ((c def c (c (? . 6) q exn)) c (? . 47)) ((c def c (c (? . 78) q serialize)) q (375561 . 16)) ((c form c (c (? . 6) q #%printing-module-begin)) q (1836 . 2)) ((c form c (c (? . 67) q define-runtime-module-path)) q (448742 . 2)) ((c def c (c (? . 19) q collapsible-property)) c (? . 113)) ((c def c (c (? . 0) q find-library-collection-paths)) q (516397 . 9)) ((c def c (c (? . 88) q phase+space-space)) q (319302 . 3)) ((c form c (c (? . 9) q overment*)) q (178588 . 2)) ((c def c (c (? . 0) q thread-receive)) q (272530 . 2)) ((c def c (c (? . 0) q make-weak-hasheqv)) q (116292 . 4)) ((c def c (c (? . 51) q normalize-path)) q (442856 . 5)) ((c def c (c (? . 2) q dict?)) q (137920 . 3)) ((c def c (c (? . 25) q tentative-pretty-print-port-transfer)) q (373840 . 5)) ((c def c (c (? . 14) q place-enabled?)) q (280243 . 2)) ((c def c (c (? . 16) q extflonum?)) q (41513 . 3)) ((c def c (c (? . 0) q local-expand)) q (298268 . 11)) ((c def c (c (? . 26) q </c)) q (200369 . 3)) ((c def c (c (? . 7) q stream-first)) q (135153 . 3)) ((c def c (c (? . 0) q system-big-endian?)) q (32326 . 2)) ((c def c (c (? . 24) q make-export)) c (? . 68)) ((c def c (c (? . 0) q memory-order-release)) q (282932 . 2)) ((c def c (c (? . 21) q correlated-property)) q (436728 . 8)) ((c def c (c (? . 12) q call-with-limits)) q (428019 . 5)) ((c def c (c (? . 8) q permutations)) q (104683 . 3)) ((c def c (c (? . 0) q current-subprocess-custodian-mode)) q (471875 . 5)) ((c form c (c (? . 38) q ->m)) q (184784 . 2)) ((c def c (c (? . 0) q inexact?)) q (22885 . 3)) ((c def c (c (? . 0) q identifier-binding-portal-syntax)) q (296927 . 7)) ((c def c (c (? . 81) q build-flat-contract-property)) q (225940 . 42)) ((c def c (c (? . 0) q eof)) q (320780 . 2)) ((c def c (c (? . 40) q contract-stronger?)) q (235583 . 4)) ((c def c (c (? . 0) q exn:missing-module-accessor)) q (261060 . 4)) ((c def c (c (? . 11) q shared-fxvector)) q (41229 . 3)) ((c def c (c (? . 9) q class-seal)) q (190830 . 15)) ((c def c (c (? . 0) q expand-syntax-once)) q (314594 . 4)) ((c def c (c (? . 72) q async-channel-put-evt)) q (276485 . 4)) ((c form c (c (? . 6) q struct-copy)) q (172079 . 5)) ((c def c (c (? . 0) q identifier-distinct-binding)) q (295975 . 18)) ((c def c (c (? . 6) q exn:break:hang-up)) c (? . 71)) ((c def c (c (? . 15) q open-output-nowhere)) q (340385 . 4)) ((c def c (c (? . 0) q security-guard?)) q (412869 . 3)) ((c def c (c (? . 15) q make-limited-input-port)) q (339529 . 7)) ((c def c (c (? . 16) q extflasin)) q (43026 . 3)) ((c def c (c (? . 2) q dict-remove)) q (138986 . 4)) ((c def c (c (? . 9) q object-or-false=?)) q (189057 . 4)) ((c def c (c (? . 3) q import-req-mode)) c (? . 28)) ((c def c (c (? . 8) q empty?)) q (98630 . 3)) ((c def c (c (? . 0) q path->complete-path)) q (439586 . 5)) ((c def c (c (? . 0) q module-declared?)) q (397625 . 5)) ((c def c (c (? . 7) q stream-rest)) q (135241 . 3)) ((c def c (c (? . 43) q guard-evt)) q (273458 . 3)) ((c def c (c (? . 13) q set=?)) q (153522 . 4)) ((c form c (c (? . 137) q matching-identifiers-out)) q (10763 . 2)) ((c def c (c (? . 19) q collapsible-ho/c-latest-ctc)) c (? . 94)) ((c def c (c (? . 0) q prop:custom-write)) q (375084 . 2)) ((c def c (c (? . 22) q sequence-append)) q (133776 . 3)) ((c def c (c (? . 0) q exact->inexact)) q (23001 . 3)) ((c def c (c (? . 0) q current-compile-realm)) q (391333 . 4)) ((c def c (c (? . 0) q read-byte)) q (349588 . 3)) ((c def c (c (? . 13) q set-implements/c)) q (150805 . 3)) ((c def c (c (? . 26) q channel/c)) q (205439 . 3)) ((c def c (c (? . 0) q error-display-handler)) q (254840 . 4)) ((c def c (c (? . 6) q exn:fail:out-of-memory)) c (? . 87)) ((c def c (c (? . 14) q place-dead-evt)) q (281425 . 3)) ((c def c (c (? . 0) q port-progress-evt)) q (357549 . 4)) ((c def c (c (? . 0) q struct:exn:fail:contract:arity)) c (? . 111)) ((c def c (c (? . 8) q list-update)) q (99433 . 5)) ((c form c (c (? . 0) q letrec-syntaxes+values)) q (12497 . 4)) ((c def c (c (? . 0) q make-input-port)) q (329646 . 50)) ((c def c (c (? . 2) q dict-set!)) q (138601 . 5)) ((c def c (c (? . 0) q stencil-vector)) q (112597 . 4)) ((c def c (c (? . 0) q hash-ephemeron?)) q (114811 . 3)) ((c def c (c (? . 1) q unsafe-struct*-set!)) q (502705 . 5)) ((c def c (c (? . 6) q make-srcloc)) c (? . 59)) ((c def c (c (? . 0) q string-ci>=?)) q (49186 . 4)) ((c def c (c (? . 21) q correlated-column)) q (435383 . 3)) ((c form c (c (? . 6) q combine-in)) q (4785 . 2)) ((c def c (c (? . 0) q print-vector-length)) q (366995 . 4)) ((c def c (c (? . 0) q min)) q (24067 . 3)) ((c form c (c (? . 49) q syntax/loc)) q (285722 . 14)) ((c def c (c (? . 8) q rest)) q (98734 . 3)) ((c def c (c (? . 0) q syntax-rearm)) q (313983 . 5)) ((c def c (c (? . 0) q keyword<?)) q (91774 . 4)) ((c form c (c (? . 140) q define-require-syntax)) q (13855 . 3)) ((c form c (c (? . 54) q splicing-letrec-syntax)) q (312539 . 2)) ((c form c (c (? . 6) q combine-out)) q (6716 . 2)) ((c def c (c (? . 0) q keyword->string)) q (91632 . 3)) ((c def c (c (? . 0) q prop:arity-string)) q (161984 . 2)) ((c def c (c (? . 0) q make-directory)) q (447606 . 4)) ((c form c (c (? . 32) q make-struct-type-property/generic)) q (170984 . 29)) ((c def c (c (? . 72) q async-channel?)) q (276066 . 3)) ((c def c (c (? . 62) q random-ref)) q (28778 . 5)) ((c def c (c (? . 0) q modulo)) q (23788 . 4)) ((c def c (c (? . 6) q exn:fail:contract:arity)) c (? . 111)) ((c def c (c (? . 23) q failure-result/c)) q (238240 . 2)) ((c form c (c (? . 6) q define)) q (13271 . 14)) ((c form c (c (? . 67) q runtime-paths)) q (448795 . 2)) ((c def c (c (? . 73) q make-struct-info)) q (173791 . 3)) ((c def c (c (? . 6) q gen:equal+hash)) q (21078 . 2)) ((c def c (c (? . 11) q fxvector-length)) q (40142 . 3)) ((c def c (c (? . 0) q string->path)) q (437203 . 3)) ((c def c (c (? . 0) q compiled-expression?)) q (390578 . 3)) ((c def c (c (? . 0) q equal-hash-code)) q (20689 . 3)) ((c form c (c (? . 0) q begin)) q (14215 . 3)) ((c def c (c (? . 34) q trait?)) q (183343 . 3)) ((c def c (c (? . 0) q bytes-ref)) q (63950 . 4)) ((c def c (c (? . 0) q exn-message)) c (? . 47)) ((c def c (c (? . 0) q choice-evt)) q (273189 . 3)) ((c def c (c (? . 6) q make-exn:fail:user)) c (? . 125)) ((c def c (c (? . 1) q unsafe-flrandom)) q (495886 . 3)) ((c def c (c (? . 0) q write-special-avail*)) q (360506 . 4)) ((c def c (c (? . 22) q sequence-filter)) q (134471 . 4)) ((c def c (c (? . 40) q get/build-val-first-projection)) q (238277 . 4)) ((c def c (c (? . 1) q unsafe-impersonate-procedure)) q (514231 . 11)) ((c def c (c (? . 0) q log-level?)) q (478444 . 5)) ((c def c (c (? . 82) q sinh)) q (32757 . 3)) ((c def c (c (? . 0) q continuation-mark-set?)) q (270017 . 3)) ((c form c (c (? . 23) q recontract-out)) q (214109 . 2)) ((c form c (c (? . 34) q trait-alias)) q (183618 . 2)) ((c form c (c (? . 23) q cons/dc)) q (202811 . 8)) ((c def c (c (? . 0) q module-path-index-resolve)) q (393976 . 7)) ((c def c (c (? . 6) q in-vector)) q (125057 . 6)) ((c def c (c (? . 0) q char<=?)) q (71168 . 4)) ((c def c (c (? . 15) q with-input-from-string)) q (336542 . 4)) ((c def c (c (? . 17) q user-read-bit)) q (459728 . 2)) ((c form c (c (? . 6) q for/last)) q (16069 . 2)) ((c def c (c (? . 0) q make-hashalw)) q (115561 . 4)) ((c def c (c (? . 0) q subprocess-kill)) q (471617 . 4)) ((c def c (c (? . 0) q struct-type-sealed?)) q (416372 . 3)) ((c def c (c (? . 0) q abs)) q (23967 . 3)) ((c def c (c (? . 0) q subprocess?)) q (471818 . 3)) ((c form c (c (? . 49) q _)) q (287610 . 2)) ((c def c (c (? . 1) q unsafe-extflacos)) q (513370 . 3)) ((c def c (c (? . 0) q thread-suspend)) q (271516 . 3)) ((c def c (c (? . 44) q flmin)) q (34402 . 4)) ((c def c (c (? . 31) q splitter)) q (267152 . 5)) ((c def c (c (? . 6) q open-output-file)) q (322706 . 15)) ((c def c (c (? . 6) q collection-file-path)) q (517078 . 16)) ((c def c (c (? . 0) q raise-user-error)) q (246592 . 10)) ((c def c (c (? . 0) q weak-box-value)) q (489609 . 4)) ((c def c (c (? . 56) q fsemaphore-count)) q (280149 . 3)) ((c def c (c (? . 0) q syntax-source)) q (287819 . 3)) ((c def c (c (? . 0) q char-grapheme-break-property)) q (72811 . 3)) ((c def c (c (? . 1) q unsafe-fxpopcount)) q (492032 . 3)) ((c form c (c (? . 41) q define-values/invoke-unit/infer)) q (195930 . 8)) ((c def c (c (? . 0) q exn:fail:contract?)) c (? . 126)) ((c def c (c (? . 6) q in-immutable-hash-keys)) q (128376 . 3)) ((c def c (c (? . 44) q flsingle)) q (34779 . 3)) ((c def c (c (? . 0) q single-flonum?)) q (22450 . 3)) ((c def c (c (? . 44) q flreal-part)) q (35724 . 5)) ((c def c (c (? . 0) q make-custodian)) q (413783 . 4)) ((c def c (c (? . 7) q stream->list)) q (135804 . 3)) ((c def c (c (? . 0) q relative-path?)) q (439374 . 3)) ((c form c (c (? . 9) q super-instantiate)) q (180648 . 2)) ((c def c (c (? . 75) q engine-kill)) q (282822 . 3)) ((c def c (c (? . 5) q arity-includes?)) q (163803 . 4)) ((c def c (c (? . 20) q tcp-connect/enable-break)) q (460817 . 10)) ((c def c (c (? . 13) q mutable-seteqv)) q (147316 . 4)) ((c def c (c (? . 0) q string->unreadable-symbol)) q (73836 . 3)) ((c form c (c (? . 6) q for*/or)) q (17215 . 2)) ((c def c (c (? . 0) q inexact->exact)) q (22941 . 3)) ((c form c (c (? . 41) q struct/ctc)) q (197066 . 10)) ((c def c (c (? . 44) q fl/)) q (33887 . 4)) ((c form c (c (? . 31) q shift-at)) q (266685 . 2)) ((c def c (c (? . 4) q process*/ports)) q (475849 . 27)) ((c def c (c (? . 17) q file-type-bits)) q (459271 . 2)) ((c def c (c (? . 0) q void)) q (163956 . 3)) ((c def c (c (? . 40) q prop:blame)) q (225840 . 2)) ((c def c (c (? . 44) q make-shared-flvector)) q (37608 . 4)) ((c def c (c (? . 0) q string-normalize-nfd)) q (49565 . 3)) ((c def c (c (? . 0) q pseudo-random-generator?)) q (27916 . 3)) ((c def c (c (? . 0) q make-plumber)) q (417156 . 2)) ((c def c (c (? . 0) q namespace-require/copy)) q (382372 . 5)) ((c def c (c (? . 0) q byte-ready?)) q (357985 . 3)) ((c def c (c (? . 0) q assert-unreachable)) q (271061 . 2)) ((c form c (c (? . 9) q define/overment)) q (179142 . 3)) ((c def c (c (? . 19) q collapsible-guard)) q (239125 . 5)) ((c def c (c (? . 6) q exn:fail:contract)) c (? . 126)) ((c def c (c (? . 1) q unsafe-fxmin)) q (493112 . 4)) ((c def c (c (? . 0) q vector?)) q (106590 . 3)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:missing-module)) c (? . 79)) ((c def c (c (? . 0) q char-title-case?)) q (72127 . 3)) ((c def c (c (? . 8) q make-list)) q (99341 . 4)) ((c def c (c (? . 0) q call-with-immediate-continuation-mark)) q (269517 . 7)) ((c def c (c (? . 0) q char-grapheme-step)) q (73331 . 4)) ((c def c (c (? . 40) q contract-name)) q (236277 . 3)) ((c def c (c (? . 1) q unsafe-flacos)) q (494771 . 3)) ((c def c (c (? . 13) q generic-set?)) q (150647 . 3)) ((c def c (c (? . 21) q make-instance)) q (433308 . 12)) ((c def c (c (? . 16) q extfllog)) q (43212 . 3)) ((c form c (c (? . 30) q parameterize*)) q (278473 . 3)) ((c def c (c (? . 0) q read-accept-compiled)) q (363133 . 4)) ((c def c (c (? . 0) q box?)) q (113687 . 3)) ((c def c (c (? . 0) q regexp?)) q (74192 . 3)) ((c def c (c (? . 13) q seteq)) q (147018 . 3)) ((c def c (c (? . 0) q namespace-module-identifier)) q (380864 . 4)) ((c def c (c (? . 17) q file->bytes-lines)) q (449816 . 8)) ((c def c (c (? . 0) q raise-range-error*)) q (249988 . 19)) ((c def c (c (? . 0) q exn:fail:contract:continuation?)) c (? . 108)) ((c def c (c (? . 17) q display-lines-to-file)) q (451104 . 13)) ((c def c (c (? . 0) q namespace-require/expansion-time)) q (382824 . 6)) ((c def c (c (? . 0) q make-weak-hasheq)) q (116437 . 4)) ((c def c (c (? . 21) q instance?)) q (433253 . 3)) ((c def c (c (? . 0) q hash-clear!)) q (120027 . 3)) ((c form c (c (? . 54) q splicing-letrec)) q (312432 . 2)) ((c def c (c (? . 2) q dict-iterate-value)) q (139353 . 4)) ((c def c (c (? . 143) q syntax-parameter-value)) q (312251 . 3)) ((c def c (c (? . 13) q set-remove!)) q (151884 . 4)) ((c def c (c (? . 6) q in-mutable-hash-values)) q (127603 . 3)) ((c def c (c (? . 15) q port->bytes-lines)) q (335343 . 8)) ((c form c (c (? . 6) q #%plain-module-begin)) q (1880 . 2)) ((c def c (c (? . 6) q in-values-sequence)) q (131647 . 3)) ((c def c (c (? . 1) q unsafe-fltruncate)) q (494408 . 3)) ((c def c (c (? . 0) q string-ref)) q (46828 . 4)) ((c def c (c (? . 8) q index-where)) q (99912 . 4)) ((c def c (c (? . 0) q struct-type-property?)) q (169004 . 3)) ((c def c (c (? . 10) q vector-memq)) q (111128 . 4)) ((c def c (c (? . 0) q equal-always-hash-code)) q (20819 . 3)) ((c def c (c (? . 25) q pretty-display)) q (369876 . 5)) ((c def c (c (? . 22) q sequence-map)) q (133847 . 4)) ((c def c (c (? . 12) q get-uncovered-expressions)) q (427456 . 7)) ((c def c (c (? . 1) q unsafe-flcos)) q (494593 . 3)) ((c def c (c (? . 1) q unsafe-extflround)) q (512812 . 3)) ((c def c (c (? . 51) q string->some-system-path)) q (443367 . 4)) ((c def c (c (? . 0) q link-exists?)) q (444266 . 3)) ((c form c (c (? . 9) q super-make-object)) q (180623 . 2)) ((c def c (c (? . 0) q variable-reference->module-path-index)) q (385349 . 4)) ((c def c (c (? . 44) q flfloor)) q (34612 . 3)) ((c def c (c (? . 0) q bytes-utf-8-length)) q (67669 . 7)) ((c def c (c (? . 51) q filename-extension)) q (442144 . 3)) ((c def c (c (? . 8) q cartesian-product)) q (105187 . 3)) ((c form c (c (? . 9) q class)) q (177558 . 2)) ((c def c (c (? . 0) q error-message-adjuster-key)) q (261998 . 2)) ((c form c (c (? . 6) q for/vector)) q (15071 . 8)) ((c form c (c (? . 103) q with-contract)) q (214259 . 12)) ((c def c (c (? . 56) q fsemaphore-try-wait?)) q (280069 . 3)) ((c def c (c (? . 0) q get-output-string)) q (329150 . 3)) ((c def c (c (? . 3) q struct:import)) c (? . 28)) ((c form c (c (? . 13) q for*/mutable-seteqv)) q (149885 . 2)) ((c form c (c (? . 49) q quote-syntax/prune)) q (287361 . 2)) ((c form c (c (? . 49) q syntax-id-rules)) q (287471 . 3)) ((c def c (c (? . 8) q add-between)) q (102095 . 13)) ((c def c (c (? . 16) q extfltan)) q (42965 . 3)) ((c def c (c (? . 0) q make-hasheq)) q (115854 . 4)) ((c def c (c (? . 102) q false?)) q (21558 . 3)) ((c def c (c (? . 21) q linklet-import-variables)) q (432241 . 3)) ((c def c (c (? . 0) q namespace-syntax-introduce)) q (384491 . 4)) ((c def c (c (? . 0) q char-graphic?)) q (72395 . 3)) ((c def c (c (? . 0) q flonum?)) q (22337 . 3)) ((c def c (c (? . 0) q bytes-utf-8-ref)) q (67948 . 7)) ((c def c (c (? . 44) q fl>=)) q (34324 . 4)) ((c form c (c (? . 32) q make-generic-struct-type-property)) q (171991 . 5)) ((c def c (c (? . 8) q inclusive-range)) q (103993 . 5)) ((c def c (c (? . 56) q touch)) q (279323 . 3)) ((c form c (c (? . 43) q define-syntax-rule)) q (287544 . 2)) ((c def c (c (? . 57) q contract-random-generate-get-current-environment)) q (243579 . 3)) ((c def c (c (? . 15) q peek-string-evt)) c (? . 117)) ((c def c (c (? . 88) q phase?)) q (318970 . 3)) ((c def c (c (? . 127) q box-immutable/c)) q (202404 . 3)) ((c def c (c (? . 76) q format-id)) q (316272 . 19)) ((c def c (c (? . 0) q compile-enforce-module-constants)) q (390644 . 4)) ((c def c (c (? . 0) q vector-cas!)) q (107710 . 6)) ((c def c (c (? . 9) q exn:fail:object)) c (? . 106)) ((c form c (c (? . 7) q stream-cons)) q (135332 . 5)) ((c def c (c (? . 56) q future)) q (279260 . 3)) ((c def c (c (? . 11) q fxlshift/wraparound)) q (39101 . 4)) ((c form c (c (? . 44) q for*/flvector)) q (37276 . 9)) ((c form c (c (? . 48) q define/match)) q (244082 . 18)) ((c def c (c (? . 0) q directory-exists?)) q (447530 . 3)) ((c def c (c (? . 66) q blame-swap)) q (224563 . 3)) ((c def c (c (? . 0) q bytes->string/utf-8)) q (65633 . 6)) ((c def c (c (? . 6) q make-exn:fail:contract:divide-by-zero)) c (? . 118)) ((c def c (c (? . 12) q sandbox-make-namespace)) q (422734 . 2)) ((c def c (c (? . 0) q make-bytes)) q (63566 . 4)) ((c def c (c (? . 15) q peek-bytes!-evt)) c (? . 117)) ((c def c (c (? . 6) q exn:fail:unsupported)) c (? . 119)) ((c def c (c (? . 16) q in-extflvector)) q (44779 . 6)) ((c form c (c (? . 6) q for*)) q (16592 . 2)) ((c def c (c (? . 0) q bytes->immutable-bytes)) q (63722 . 3)) ((c form c (c (? . 31) q prompt0)) q (266744 . 2)) ((c def c (c (? . 6) q make-exn:fail:read:eof)) c (? . 114)) ((c def c (c (? . 0) q namespace-require)) q (382160 . 5)) ((c def c (c (? . 8) q take)) q (100358 . 4)) ((c def c (c (? . 26) q natural-number/c)) q (200950 . 2)) ((c def c (c (? . 0) q make-hasheq-placeholder)) q (105934 . 3)) ((c def c (c (? . 0) q cos)) q (25615 . 3)) ((c def c (c (? . 0) q string-ci<=?)) q (48991 . 4)) ((c def c (c (? . 11) q fxlshift)) q (38427 . 4)) ((c def c (c (? . 13) q list->mutable-set)) q (148282 . 4)) ((c form c (c (? . 53) q current-contract-region)) q (215586 . 2)) ((c def c (c (? . 26) q false/c)) q (201060 . 2)) ((c form c (c (? . 12) q with-deep-time-limit)) q (428375 . 2)) ((c def c (c (? . 14) q prop:place-location)) q (282076 . 2)) ((c def c (c (? . 73) q prop:struct-info)) q (174028 . 2)) ((c def c (c (? . 14) q place-channel-get)) q (281822 . 3)) ((c def c (c (? . 24) q expand-export)) q (309701 . 4)) ((c def c (c (? . 6) q in-mutable-hash-keys)) q (127330 . 3)) ((c def c (c (? . 44) q flsin)) q (34834 . 3)) ((c def c (c (? . 25) q pretty-print-style-table?)) q (371206 . 3)) ((c def c (c (? . 5) q disjoin)) q (163145 . 4)) ((c form c (c (? . 31) q control0-at)) q (266964 . 2)) ((c def c (c (? . 0) q struct-type-property-predicate-procedure?)) q (169157 . 5)) ((c def c (c (? . 0) q error-contract->adjusted-string)) q (261609 . 5)) ((c def c (c (? . 3) q current-require-module-path)) q (309180 . 4)) ((c form c (c (? . 41) q define-unit/new-import-export)) q (196443 . 6)) ((c def c (c (? . 66) q blame-update)) q (224902 . 5)) ((c def c (c (? . 56) q fsemaphore-wait)) q (279997 . 3)) ((c def c (c (? . 0) q null?)) q (92040 . 3)) ((c form c (c (? . 6) q define-namespace-anchor)) q (380281 . 2)) ((c def c (c (? . 6) q in-hash)) q (126435 . 6)) ((c def c (c (? . 0) q current-prompt-read)) q (389466 . 4)) ((c form c (c (? . 6) q for*/hash)) q (16888 . 2)) ((c def c (c (? . 0) q kill-thread)) q (271713 . 3)) ((c def c (c (? . 0) q syntax-local-lift-module-end-declaration)) q (304765 . 3)) ((c def c (c (? . 82) q natural?)) q (33647 . 3)) ((c def c (c (? . 17) q make-parent-directory*)) q (453850 . 3)) ((c def c (c (? . 0) q compile-target-machine?)) q (391258 . 3)) ((c form c (c (? . 13) q for/seteqv)) q (149231 . 2)) ((c def c (c (? . 12) q sandbox-make-code-inspector)) q (425448 . 4)) ((c def c (c (? . 0) q caddar)) q (97557 . 3)) ((c def c (c (? . 128) q new-∀/c)) q (212680 . 3)) ((c def c (c (? . 0) q raise-result-error*)) q (248165 . 16)) ((c def c (c (? . 0) q logger-name)) q (477655 . 3)) ((c def c (c (? . 0) q bytes<?)) q (65443 . 4)) ((c form c (c (? . 41) q invoke-unit/infer)) q (195826 . 5)) ((c def c (c (? . 37) q udp?)) q (466747 . 3)) ((c def c (c (? . 38) q dynamic-object/c)) q (185473 . 9)) ((c def c (c (? . 8) q flatten)) q (102759 . 3)) ((c def c (c (? . 0) q list-ref)) q (92660 . 4)) ((c def c (c (? . 9) q generic?)) q (188926 . 3)) ((c def c (c (? . 0) q custodian-managed-list)) q (414191 . 4)) ((c def c (c (? . 65) q promise?)) q (262043 . 3)) ((c def c (c (? . 80) q date-display-format)) q (482552 . 18)) ((c def c (c (? . 0) q current-compile)) q (390127 . 5)) ((c def c (c (? . 19) q collapsible-property-c-c)) c (? . 113)) ((c def c (c (? . 14) q place-channel-put/get)) q (281912 . 4)) ((c def c (c (? . 0) q print-unreadable)) q (366643 . 4)) ((c def c (c (? . 13) q set-copy)) q (152366 . 3)) ((c def c (c (? . 0) q filesystem-change-evt)) q (448090 . 5)) ((c def c (c (? . 6) q procedure-reduce-arity)) q (159239 . 9)) ((c def c (c (? . 6) q make-exn:break:terminate)) c (? . 121)) ((c def c (c (? . 39) q current-trace-print-results)) q (521582 . 10)) ((c def c (c (? . 1) q unsafe-char<=?)) q (496255 . 4)) ((c def c (c (? . 0) q read-bytes-avail!)) q (351061 . 7)) ((c def c (c (? . 22) q sequence-add-between)) q (134577 . 4)) ((c form c (c (? . 30) q do)) q (19020 . 7)) ((c form c (c (? . 41) q compound-unit/infer)) q (194674 . 18)) ((c def c (c (? . 2) q dict-remove!)) q (138872 . 4)) ((c def c (c (? . 0) q exact-positive-integer?)) q (22156 . 3)) ((c def c (c (? . 34) q trait->mixin)) q (183395 . 3)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-next)) q (505285 . 5)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-key+value)) q (504216 . 5)) ((c def c (c (? . 0) q current-module-declare-name)) q (393057 . 5)) ((c def c (c (? . 2) q dict-set*!)) q (139529 . 5)) ((c def c (c (? . 20) q tcp-port?)) q (462067 . 3)) ((c form c (c (? . 41) q export)) q (193784 . 2)) ((c def c (c (? . 0) q bitwise-bit-set?)) q (26648 . 4)) ((c def c (c (? . 42) q foldl)) q (93388 . 5)) ((c form c (c (? . 13) q for/weak-set)) q (150005 . 2)) ((c form c (c (? . 9) q define/private)) q (179570 . 3)) ((c def c (c (? . 21) q datum->correlated)) q (435845 . 16)) ((c def c (c (? . 1) q unsafe-fxpopcount16)) q (492229 . 3)) ((c def c (c (? . 37) q udp-send-evt)) q (467571 . 9)) ((c def c (c (? . 0) q pair?)) q (91989 . 3)) ((c def c (c (? . 32) q exn:fail:support)) c (? . 109)) ((c def c (c (? . 1) q unsafe-char>=?)) q (496339 . 4)) ((c def c (c (? . 0) q plumber?)) q (417102 . 3)) ((c def c (c (? . 0) q make-sibling-inspector)) q (415585 . 3)) ((c def c (c (? . 11) q fx<)) q (39265 . 4)) ((c def c (c (? . 6) q in-ephemeron-hash-pairs)) q (130668 . 3)) ((c def c (c (? . 0) q char-ci<?)) q (71541 . 4)) ((c def c (c (? . 9) q method-in-interface?)) q (189856 . 4)) ((c def c (c (? . 13) q list->weak-seteqv)) q (148932 . 4)) ((c def c (c (? . 0) q impersonate-struct)) q (400269 . 17)) ((c def c (c (? . 0) q expand)) q (314188 . 4)) ((c form c (c (? . 44) q for/flvector)) q (37210 . 2)) ((c def c (c (? . 11) q fx<=)) q (39419 . 4)) ((c form c (c (? . 13) q for*/weak-seteqv)) q (150335 . 2)) ((c form c (c (? . 41) q extends)) q (193941 . 2)) ((c def c (c (? . 0) q free-label-identifier=?)) q (293477 . 4)) ((c def c (c (? . 128) q new-∃/c)) q (212765 . 3)) ((c def c (c (? . 12) q sandbox-make-logger)) q (425587 . 4)) ((c def c (c (? . 1) q unsafe-extfl*)) q (511938 . 4)) ((c def c (c (? . 6) q srcloc)) c (? . 59)) ((c def c (c (? . 0) q caaar)) q (96301 . 3)) ((c def c (c (? . 0) q char-symbolic?)) q (72260 . 3)) ((c form c (c (? . 38) q ->*m)) q (184814 . 2)) ((c def c (c (? . 22) q sequence-fold)) q (134242 . 5)) ((c def c (c (? . 17) q other-execute-bit)) q (460088 . 2)) ((c def c (c (? . 0) q flush-output)) q (320863 . 3)) ((c form c (c (? . 6) q define-for-syntax)) q (13721 . 3)) ((c def c (c (? . 0) q +)) q (23198 . 3)) ((c def c (c (? . 1) q unsafe-fxlshift/wraparound)) q (492596 . 4)) ((c def c (c (? . 0) q will-try-execute)) q (490400 . 4)) ((c def c (c (? . 10) q vector-map!)) q (109350 . 4)) ((c def c (c (? . 0) q char-ci=?)) q (71446 . 4)) ((c def c (c (? . 6) q print-value-columns)) q (367717 . 5)) ((c def c (c (? . 0) q denominator)) q (24633 . 3)) ((c def c (c (? . 0) q syntax-local-module-defined-identifiers)) q (307437 . 3)) ((c def c (c (? . 13) q set-for-each)) q (153975 . 4)) ((c def c (c (? . 0) q time-apply)) q (482183 . 7)) ((c def c (c (? . 1) q unsafe-vector-set!)) q (497982 . 5)) ((c def c (c (? . 5) q normalized-arity?)) q (163503 . 3)) ((c def c (c (? . 0) q date-hour)) c (? . 60)) ((c def c (c (? . 0) q write-bytes-avail)) q (359199 . 9)) ((c form c (c (? . 31) q reset)) q (266580 . 2)) ((c def c (c (? . 0) q namespace-attach-module-declaration)) q (383384 . 7)) ((c form c (c (? . 7) q stream-lazy)) q (135523 . 3)) ((c def c (c (? . 61) q prop:contract)) q (225577 . 2)) ((c def c (c (? . 22) q in-slice)) q (134929 . 4)) ((c def c (c (? . 0) q placeholder-get)) q (105708 . 3)) ((c def c (c (? . 11) q fxvector-set!)) q (40338 . 5)) ((c form c (c (? . 48) q match-let-values)) q (244861 . 2)) ((c def c (c (? . 0) q set-phantom-bytes!)) q (490954 . 4)) ((c def c (c (? . 0) q current-force-delete-permissions)) q (447075 . 5)) ((c def c (c (? . 0) q custom-print-quotable?)) q (375384 . 2)) ((c form c (c (? . 32) q define/generic)) q (170320 . 2)) ((c form c (c (? . 6) q lib)) q (5210 . 2)) ((c form c (c (? . 0) q #%stratified-body)) q (19441 . 2)) ((c def c (c (? . 0) q print-reader-abbreviations)) q (367303 . 4)) ((c def c (c (? . 0) q string-set!)) q (46927 . 5)) ((c def c (c (? . 9) q dynamic-set-field!)) q (181919 . 5)) ((c def c (c (? . 37) q udp-receive-ready-evt)) q (467024 . 3)) ((c def c (c (? . 39) q current-prefix-out)) q (522105 . 4)) ((c form c (c (? . 6) q for*/last)) q (17472 . 2)) ((c def c (c (? . 0) q syntax-property)) q (312756 . 9)) ((c def c (c (? . 0) q string->symbol)) q (73695 . 3)) ((c def c (c (? . 1) q unsafe-set-mcdr!)) q (496783 . 4)) ((c def c (c (? . 16) q extfl+)) q (41616 . 4)) ((c form c (c (? . 9) q field-bound?)) q (182044 . 2)) ((c def c (c (? . 0) q module->realm)) q (398759 . 4)) ((c def c (c (? . 11) q fxior)) q (38261 . 3)) ((c form c (c (? . 9) q define/override-final)) q (179224 . 3)) ((c def c (c (? . 12) q sandbox-run-submodules)) q (425174 . 4)) ((c def c (c (? . 0) q display)) q (365379 . 4)) ((c def c (c (? . 82) q sqr)) q (32557 . 3)) ((c def c (c (? . 0) q syntax-property-symbol-keys)) q (313287 . 3)) ((c form c (c (? . 39) q trace-lambda)) q (520610 . 2)) ((c def c (c (? . 0) q struct:exn:fail:user)) c (? . 125)) ((c def c (c (? . 15) q regexp-match-evt)) q (348966 . 4)) ((c form c (c (? . 6) q for/sum)) q (15703 . 2)) ((c def c (c (? . 16) q extfl<)) q (42090 . 4)) ((c def c (c (? . 0) q sleep)) q (271895 . 3)) ((c def c (c (? . 0) q equal-always?/recur)) q (20544 . 5)) ((c def c (c (? . 1) q unsafe-fl->fx)) q (495826 . 3)) ((c def c (c (? . 6) q exn:fail:read)) c (? . 85)) ((c def c (c (? . 2) q dict-copy)) q (141102 . 3)) ((c def c (c (? . 0) q char-whitespace?)) q (72460 . 3)) ((c def c (c (? . 13) q set-subtract!)) q (153192 . 4)) ((c def c (c (? . 98) q vector-immutable/c)) q (202007 . 3)) ((q def ((lib "racket/keyword.rkt") keyword->immutable-string)) q (91891 . 3)) ((c form c (c (? . 13) q for/mutable-set)) q (149537 . 2)) ((c def c (c (? . 0) q make-struct-field-mutator)) q (167541 . 12)) ((c def c (c (? . 43) q path-list-string->path-list)) q (443687 . 6)) ((c def c (c (? . 66) q blame-contract)) q (224392 . 3)) ((c def c (c (? . 0) q call-in-continuation)) q (264835 . 4)) ((c def c (c (? . 0) q continuation-mark-set-first)) q (269095 . 10)) ((c def c (c (? . 0) q negative?)) q (22669 . 3)) ((c def c (c (? . 12) q call-in-sandbox-context)) q (427726 . 7)) ((c def c (c (? . 13) q seteqv)) q (146932 . 3)) ((c def c (c (? . 0) q exn:fail:out-of-memory?)) c (? . 87)) ((c def c (c (? . 0) q vector)) q (106753 . 3)) ((c def c (c (? . 0) q char-ci>=?)) q (71827 . 4)) ((c def c (c (? . 19) q collapsible-wrapper-property?)) c (? . 124)) ((c def c (c (? . 0) q path-element->bytes)) q (438170 . 3)) ((c def c (c (? . 0) q cdadar)) q (97957 . 3)) ((c form c (c (? . 65) q lazy)) q (262124 . 2)) ((c def c (c (? . 82) q exact-truncate)) q (33113 . 3)) ((c def c (c (? . 9) q object-info)) q (190368 . 3)) ((c def c (c (? . 0) q namespace-variable-value)) q (381017 . 9)) ((c def c (c (? . 7) q stream-ref)) q (135940 . 4)) ((c def c (c (? . 6) q namespace-anchor->namespace)) q (380474 . 3)) ((c def c (c (? . 78) q deserialize)) q (376481 . 3)) ((c form c (c (? . 0) q with-continuation-mark)) q (19181 . 2)) ((c form c (c (? . 49) q with-syntax)) q (284510 . 3)) ((c def c (c (? . 80) q julian/scalinger->string)) q (484247 . 3)) ((c def c (c (? . 26) q printable/c)) q (201093 . 2)) ((c def c (c (? . 2) q dict-can-remove-keys?)) q (138202 . 3)) ((c form c (c (? . 13) q for*/seteq)) q (149382 . 2)) ((c def c (c (? . 0) q continuation-mark-set->list*)) q (268165 . 10)) ((c def c (c (? . 0) q plumber-flush-handle?)) q (417375 . 3)) ((c def c (c (? . 0) q inspector-superior?)) q (415702 . 5)) ((c def c (c (? . 7) q in-stream)) q (135715 . 3)) ((c form c (c (? . 6) q only-in)) q (4587 . 2)) ((c def c (c (? . 0) q load)) q (387088 . 3)) ((c form c (c (? . 102) q implies)) q (21659 . 2)) ((c def c (c (? . 82) q nonnegative-integer?)) q (33581 . 3)) ((c form c (c (? . 48) q match-let*)) q (244809 . 2)) ((c def c (c (? . 16) q extfl=)) q (42009 . 4)) ((c def c (c (? . 0) q identifier-label-binding)) q (295530 . 12)) ((c def c (c (? . 3) q import-mode)) c (? . 28)) ((c form c (c (? . 27) q cond)) q (12803 . 7)) ((c form c (c (? . 38) q ->dm)) q (184935 . 6)) ((c def c (c (? . 0) q exn:fail:contract:variable?)) c (? . 120)) ((c def c (c (? . 3) q import-orig-stx)) c (? . 28)) ((c def c (c (? . 0) q exn:fail:filesystem:exists?)) c (? . 129)) ((c def c (c (? . 26) q =/c)) q (200314 . 3)) ((c def c (c (? . 17) q make-temporary-file*)) q (454768 . 10)) ((c def c (c (? . 21) q instantiate-linklet)) q (431552 . 17)) ((c def c (c (? . 0) q error-print-context-length)) q (255150 . 4)) ((c def c (c (? . 0) q expand-syntax)) q (314326 . 4)) ((c form c (c (? . 6) q for/hashalw)) q (15514 . 2)) ((c def c (c (? . 92) q unit-static-init-dependencies)) q (199086 . 7)) ((c def c (c (? . 0) q exn:srclocs?)) q (260335 . 3)) ((c def c (c (? . 80) q date->string)) q (482453 . 4)) ((c def c (c (? . 0) q parameterization?)) q (279197 . 3)) ((c def c (c (? . 21) q correlated-property-symbol-keys)) q (436941 . 3)) ((c def c (c (? . 0) q sqrt)) q (25164 . 3)) ((c def c (c (? . 40) q impersonator-prop:contracted)) q (225778 . 2)) ((c def c (c (? . 11) q most-positive-fixnum)) q (41421 . 2)) ((c def c (c (? . 0) q bytes)) q (63668 . 3)) ((c def c (c (? . 22) q in-syntax)) q (134867 . 3)) ((c form c (c (? . 6) q struct-out)) q (6692 . 2)) ((c def c (c (? . 102) q xor)) q (21690 . 4)) ((c def c (c (? . 6) q make-exn:fail:filesystem)) c (? . 89)) ((c def c (c (? . 6) q prop:sequence)) q (133061 . 2)) ((c def c (c (? . 0) q <)) q (24878 . 4)) ((c def c (c (? . 26) q flat-contract)) q (206089 . 3)) ((c def c (c (? . 12) q sandbox-init-hook)) q (420500 . 4)) ((c def c (c (? . 1) q unsafe-bytes-length)) q (499229 . 3)) ((c def c (c (? . 0) q string-locale<?)) q (49976 . 4)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:exists)) c (? . 129)) ((c form c (c (? . 38) q object-contract)) q (185838 . 51)) ((c def c (c (? . 1) q unsafe-extfl-)) q (511848 . 4)) ((c def c (c (? . 8) q drop-common-prefix)) q (101785 . 5)) ((c form c (c (? . 55) q filtered-in)) q (10539 . 2)) ((c def c (c (? . 12) q sandbox-path-permissions)) q (423254 . 9)) ((c def c (c (? . 15) q port->lines)) q (334999 . 8)) ((c def c (c (? . 0) q struct?)) q (172314 . 3)) ((c def c (c (? . 17) q file->bytes)) q (448975 . 4)) ((c form c (c (? . 9) q super-new)) q (180720 . 2)) ((c def c (c (? . 1) q unsafe-bytes-copy!)) q (499524 . 11)) ((c def c (c (? . 0) q make-logger)) q (477230 . 10)) ((c def c (c (? . 130) q hash-intersect)) q (123994 . 12)) ((c def c (c (? . 17) q block-device-type-bits)) q (459426 . 2)) ((c def c (c (? . 8) q splitf-at)) q (100818 . 4)) ((c def c (c (? . 13) q list->seteq)) q (148193 . 3)) ((c def c (c (? . 13) q in-immutable-set)) q (150449 . 3)) ((c def c (c (? . 0) q thread-dead?)) q (272023 . 3)) ((c def c (c (? . 0) q file-or-directory-identity)) q (446072 . 5)) ((c def c (c (? . 0) q struct-constructor-procedure?)) q (172420 . 3)) ((c def c (c (? . 0) q thread-wait)) q (272082 . 3)) ((c def c (c (? . 1) q unsafe-extflexpt)) q (513713 . 4)) ((c def c (c (? . 6) q directory-list)) q (447816 . 4)) ((c form c (c (? . 41) q provide-signature-elements)) q (197422 . 2)) ((c def c (c (? . 0) q string-append)) q (47873 . 3)) ((c def c (c (? . 30) q call/cc)) q (264203 . 5)) ((c form c (c (? . 48) q match*/derived)) q (245915 . 2)) ((c def c (c (? . 0) q semaphore-wait/enable-break)) q (275134 . 3)) ((c def c (c (? . 40) q list-contract?)) q (236217 . 3)) ((c form c (c (? . 49) q syntax-case)) q (282976 . 31)) ((c def c (c (? . 0) q date-time-zone-offset)) c (? . 60)) ((c def c (c (? . 0) q pipe-content-length)) q (329450 . 3)) ((c def c (c (? . 44) q fl*)) q (33832 . 3)) ((c def c (c (? . 37) q udp-receive!-evt)) q (467892 . 9)) ((c def c (c (? . 15) q peek-bytes-avail!-evt)) c (? . 117)) ((c def c (c (? . 43) q writeln)) q (365661 . 4)) ((c form c (c (? . 9) q augment-final)) q (178152 . 2)) ((c def c (c (? . 0) q hash-map)) q (120370 . 5)) ((c def c (c (? . 0) q make-phantom-bytes)) q (490863 . 3)) ((c def c (c (? . 16) q extflvector-ref)) q (44318 . 4)) ((c def c (c (? . 25) q pretty-format)) q (370048 . 5)) ((c form c (c (? . 23) q unconstrained-domain->)) q (212456 . 2)) ((c def c (c (? . 21) q instance-set-variable-value!)) q (434249 . 9)) ((c def c (c (? . 0) q cadddr)) q (97657 . 3)) ((c def c (c (? . 0) q make-pseudo-random-generator)) q (27845 . 2)) ((c def c (c (? . 12) q exn:fail:sandbox-terminated?)) c (? . 131)) ((c def c (c (? . 13) q list->mutable-setalw)) q (148389 . 4)) ((c form c (c (? . 9) q absent)) q (184750 . 2)) ((c def c (c (? . 0) q syntax-local-lift-expression)) q (304419 . 3)) ((c def c (c (? . 10) q vector-sort!)) q (111831 . 13)) ((c def c (c (? . 11) q fxpopcount16)) q (38762 . 3)) ((c def c (c (? . 26) q suggest/c)) q (206455 . 5)) ((c def c (c (? . 44) q flexp)) q (35201 . 3)) ((c def c (c (? . 9) q object=-hash-code)) q (189167 . 3)) ((c def c (c (? . 17) q regular-file-type-bits)) q (459384 . 2)) ((c def c (c (? . 0) q make-ephemeron-hasheq)) q (117053 . 4)) ((c def c (c (? . 0) q current-command-line-arguments)) q (486539 . 5)) ((c def c (c (? . 6) q open-input-file)) q (322404 . 7)) ((c def c (c (? . 31) q abort/cc)) q (265883 . 4)) ((c def c (c (? . 21) q correlated-position)) q (435488 . 3)) ((c def c (c (? . 0) q char-punctuation?)) q (72326 . 3)) ((c def c (c (? . 2) q dict-ref)) q (138397 . 6)) ((c def c (c (? . 0) q prop:exn:srclocs)) q (260286 . 2)) ((c def c (c (? . 0) q thread-group?)) q (415240 . 3)) ((c def c (c (? . 0) q bitwise-xor)) q (26499 . 3)) ((c def c (c (? . 0) q print-hash-table)) q (367097 . 4)) ((c def c (c (? . 0) q make-interned-syntax-introducer)) q (306821 . 4)) ((c form c (c (? . 6) q for/or)) q (15642 . 2)) ((c def c (c (? . 38) q mixin-contract)) q (187975 . 2)) ((c def c (c (? . 11) q make-shared-fxvector)) q (41298 . 4)) ((c form c (c (? . 48) q struct*)) q (246025 . 2)) ((c def c (c (? . 0) q cddr)) q (96237 . 3)) ((c def c (c (? . 23) q unsupplied-arg?)) q (212582 . 3)) ((c def c (c (? . 0) q eof-object?)) q (320806 . 3)) ((c def c (c (? . 0) q read-syntax-accept-graph)) q (363441 . 4)) ((c def c (c (? . 0) q port-closed?)) q (320129 . 3)) ((c def c (c (? . 14) q place-channel?)) q (280336 . 3)) ((c def c (c (? . 0) q placeholder?)) q (105489 . 3)) ((c def c (c (? . 37) q udp-bind!)) q (462403 . 9)) ((c def c (c (? . 6) q keyword-apply)) q (158431 . 13)) ((c def c (c (? . 122) q unsafe-undefined)) q (515931 . 2)) ((c def c (c (? . 0) q syntax-local-bind-syntaxes)) q (302138 . 12)) ((c def c (c (? . 0) q path->directory-path)) q (439806 . 3)) ((c def c (c (? . 8) q argmax)) q (104915 . 4)) ((c def c (c (? . 10) q vector-split-at)) q (109983 . 4)) ((c def c (c (? . 40) q contract-continuation-mark-key)) q (237553 . 2)) ((c def c (c (? . 44) q flmax)) q (34480 . 4)) ((c def c (c (? . 30) q current-break-parameterization)) q (270417 . 2)) ((c def c (c (? . 25) q pretty-print-abbreviate-read-macros)) q (371064 . 4)) ((c def c (c (? . 0) q expand-syntax-to-top-form)) q (314874 . 4)) ((c def c (c (? . 0) q vector->values)) q (108685 . 5)) ((c def c (c (? . 0) q real->single-flonum)) q (23063 . 3)) ((c form c (c (? . 0) q #%top)) q (10952 . 2)) ((c form c (c (? . 16) q for*/extflvector)) q (45094 . 9)) ((c def c (c (? . 0) q seconds->date)) q (480972 . 4)) ((c form c (c (? . 9) q set-field!)) q (181879 . 2)) ((c def c (c (? . 0) q exn:fail:contract:variable-id)) c (? . 120)) ((c def c (c (? . 0) q make-struct-type)) q (165634 . 31)) ((c def c (c (? . 0) q floor)) q (24320 . 3)) ((c def c (c (? . 6) q hash-copy-clear)) q (120218 . 4)) ((c def c (c (? . 0) q free-identifier=?)) q (292827 . 10)) ((c def c (c (? . 0) q log-level-evt)) q (478943 . 3)) ((c def c (c (? . 0) q procedure-closure-contents-eq?)) q (158267 . 5)) ((c def c (c (? . 76) q syntax-local-value/record)) q (318046 . 4)) ((c def c (c (? . 0) q module-path-index-submodule)) q (394412 . 4)) ((c def c (c (? . 6) q with-output-to-file)) q (327040 . 18)) ((c def c (c (? . 10) q vector-memv)) q (111026 . 4)) ((c def c (c (? . 8) q last-pair)) q (99289 . 3)) ((c def c (c (? . 0) q string->immutable-string)) q (46649 . 3)) ((c form c (c (? . 0) q #%variable-reference)) q (10973 . 4)) ((c def c (c (? . 21) q hash->linklet-bundle)) q (432877 . 3)) ((c def c (c (? . 13) q set-count)) q (152031 . 3)) ((c form c (c (? . 6) q rename-out)) q (6547 . 2)) ((c def c (c (? . 0) q break-thread)) q (271773 . 4)) ((c def c (c (? . 1) q unsafe-set-immutable-car!)) q (497211 . 4)) ((c def c (c (? . 0) q random-seed)) q (27758 . 3)) ((c def c (c (? . 6) q regexp-replace*)) q (90213 . 15)) ((c form c (c (? . 6) q for*/hasheqv)) q (17018 . 2)) ((c def c (c (? . 15) q reencode-output-port)) q (341623 . 16)) ((c def c (c (? . 0) q make-rectangular)) q (25926 . 4)) ((c def c (c (? . 0) q get-output-bytes)) q (328801 . 9)) ((c form c (c (? . 6) q for-label)) q (7131 . 2)) ((c def c (c (? . 66) q exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 0) q log)) q (25479 . 4)) ((c def c (c (? . 0) q current-reader-guard)) q (364585 . 4)) ((c def c (c (? . 13) q list->mutable-seteq)) q (148614 . 4)) ((c form c (c (? . 9) q with-method)) q (181669 . 3)) ((c def c (c (? . 42) q remq*)) q (94146 . 4)) ((c def c (c (? . 16) q extflvector-length)) q (44225 . 3)) ((c def c (c (? . 0) q stencil-vector-update)) q (113272 . 9)) ((c form c (c (? . 0) q #%datum)) q (10888 . 2)) ((c def c (c (? . 0) q imag-part)) q (26158 . 3)) ((c def c (c (? . 6) q regexp-replaces)) q (90960 . 8)) ((c def c (c (? . 21) q instance-data)) q (433833 . 3)) ((c form c (c (? . 6) q for/first)) q (16005 . 2)) ((c def c (c (? . 11) q fx>)) q (39342 . 4)) ((c def c (c (? . 1) q unsafe-fx->fl)) q (495766 . 3)) ((c def c (c (? . 0) q current-load/use-compiled)) q (387970 . 13)) ((c def c (c (? . 6) q in-bytes-lines)) q (126241 . 5)) ((c def c (c (? . 0) q syntax-source-module)) q (288321 . 5)) ((c def c (c (? . 0) q string-downcase)) q (49348 . 3)) ((c form c (c (? . 103) q struct/contract)) q (214869 . 6)) ((c def c (c (? . 0) q vector->immutable-vector)) q (108047 . 3)) ((c def c (c (? . 17) q write-to-file)) q (450649 . 11)) ((c def c (c (? . 0) q add1)) q (23865 . 3)) ((c def c (c (? . 0) q string->bytes/utf-8)) q (66601 . 6)) ((c def c (c (? . 4) q system/exit-code)) q (473424 . 5)) ((c def c (c (? . 0) q make-immutable-hasheqv)) q (117500 . 4)) ((q def ((lib "racket/syntax-srcloc.rkt") syntax-srcloc)) q (292543 . 3)) ((c def c (c (? . 16) q pi.t)) q (43941 . 2)) ((c def c (c (? . 56) q processor-count)) q (279591 . 2)) ((c def c (c (? . 44) q fllog)) q (35149 . 3)) ((c form c (c (? . 132) q enter!)) q (519673 . 9)) ((c def c (c (? . 2) q dict-keys)) q (141279 . 3)) ((c def c (c (? . 0) q procedure-arity?)) q (158932 . 3)) ((c def c (c (? . 0) q module-cache-clear!)) q (399043 . 2)) ((c form c (c (? . 41) q define-unit-from-context)) q (196207 . 2)) ((c def c (c (? . 0) q syntax-local-apply-transformer)) q (300785 . 11)) ((c def c (c (? . 49) q check-duplicate-identifier)) q (293589 . 3)) ((c def c (c (? . 51) q some-system-path->string)) q (443276 . 3)) ((c def c (c (? . 49) q syntax-protect)) q (313802 . 3)) ((c def c (c (? . 6) q exn:break)) c (? . 69)) ((c def c (c (? . 8) q check-duplicates)) q (102809 . 9)) ((c def c (c (? . 0) q struct-accessor-procedure?)) q (172568 . 3)) ((c def c (c (? . 21) q correlated?)) q (435156 . 3)) ((c def c (c (? . 6) q stop-before)) q (131794 . 4)) ((c form c (c (? . 23) q ->*)) q (206845 . 26)) ((c def c (c (? . 26) q syntax/c)) q (203285 . 3)) ((c def c (c (? . 0) q vector-ref)) q (107020 . 4)) ((c def c (c (? . 88) q space?)) q (319022 . 3)) ((c def c (c (? . 102) q boolean=?)) q (21478 . 4)) ((c def c (c (? . 0) q compiled-module-expression?)) q (394782 . 3)) ((c def c (c (? . 25) q pretty-print-current-style-table)) q (371277 . 4)) ((c def c (c (? . 44) q make-flvector)) q (36334 . 4)) ((c form c (c (? . 65) q for*/list/concurrent)) q (263055 . 3)) ((c def c (c (? . 1) q unsafe-vector*-cas!)) q (498448 . 6)) ((c def c (c (? . 0) q char?)) q (70594 . 3)) ((c def c (c (? . 0) q list?)) q (92270 . 3)) ((c def c (c (? . 6) q exn:fail:filesystem:errno)) c (? . 84)) ((c def c (c (? . 6) q make-exn:fail:contract)) c (? . 126)) ((c def c (c (? . 0) q make-syntax-introducer)) q (306668 . 4)) ((c form c (c (? . 41) q only)) q (193607 . 2)) ((c def c (c (? . 15) q combine-output)) q (340084 . 4)) ((c def c (c (? . 19) q collapsible-count-property-prev)) c (? . 35)) ((c def c (c (? . 17) q copy-directory/files)) q (451686 . 11)) ((c def c (c (? . 43) q normal-case-path)) q (440359 . 3)) ((c def c (c (? . 16) q make-shared-extflvector)) q (45441 . 4)) ((c form c (c (? . 13) q for/set)) q (149133 . 2)) ((c form c (c (? . 13) q for*/weak-set)) q (150225 . 2)) ((c def c (c (? . 3) q import-source?)) c (? . 33)) ((c def c (c (? . 19) q collapsible-contract-property?)) q (239261 . 3)) ((c form c (c (? . 67) q runtime-require)) q (448704 . 2)) ((c form c (c (? . 6) q all-defined-out)) q (6482 . 2)) ((c def c (c (? . 42) q assw)) q (95606 . 4)) ((c def c (c (? . 0) q impersonate-continuation-mark-key)) q (405058 . 13)) ((c def c (c (? . 6) q hash-values)) q (120862 . 4)) ((c def c (c (? . 9) q implementation?)) q (189669 . 4)) ((c def c (c (? . 0) q exn:break:terminate?)) c (? . 121)) ((c def c (c (? . 25) q pretty-print-newline)) q (371971 . 4)) ((c def c (c (? . 8) q drop-right)) q (101012 . 4)) ((c def c (c (? . 42) q foldr)) q (93501 . 5)) ((c def c (c (? . 0) q semaphore?)) q (274769 . 3)) ((c def c (c (? . 0) q hash-remove!)) q (119788 . 4)) ((c def c (c (? . 0) q thread)) q (271152 . 3)) ((c def c (c (? . 0) q memq)) q (95129 . 4)) ((c form c (c (? . 6) q struct/derived)) q (165368 . 5)) ((c def c (c (? . 1) q unsafe-flvector-length)) q (500298 . 3)) ((c def c (c (? . 19) q collapsible-leaf/c-contract-list)) c (? . 36)) ((c def c (c (? . 0) q eq-hash-code)) q (20963 . 3)) ((c form c (c (? . 64) q unsyntax)) q (285665 . 2)) ((c form c (c (? . 133) q struct/dc)) q (203403 . 27)) ((c def c (c (? . 1) q unsafe-stencil-vector-update)) q (501977 . 9)) ((c def c (c (? . 0) q eprintf)) q (366256 . 4)) ((c def c (c (? . 6) q sequence-generate)) q (133176 . 3)) ((c def c (c (? . 0) q real->double-flonum)) q (23134 . 3)) ((c form c (c (? . 9) q send+)) q (181553 . 5)) ((c def c (c (? . 0) q filesystem-change-evt-cancel)) q (448266 . 3)) ((c def c (c (? . 0) q make-ephemeron-hash)) q (116580 . 4)) ((c def c (c (? . 40) q contract-late-neg-projection)) q (236605 . 4)) ((c def c (c (? . 0) q expand-user-path)) q (440112 . 3)) ((c def c (c (? . 0) q cadaar)) q (97357 . 3)) ((c def c (c (? . 0) q syntax-span)) q (288160 . 3)) ((c form c (c (? . 9) q public-final*)) q (178512 . 2)) ((c def c (c (? . 0) q unquoted-printing-string-value)) q (254232 . 3)) ((c def c (c (? . 82) q positive-integer?)) q (33389 . 3)) ((c def c (c (? . 2) q dict-implements/c)) q (138063 . 3)) ((c def c (c (? . 8) q sixth)) q (98987 . 3)) ((c def c (c (? . 0) q bytes-open-converter)) q (68686 . 5)) ((c def c (c (? . 65) q force)) q (262150 . 3)) ((c form c (c (? . 6) q define-splicing-for-clause-syntax)) q (18962 . 2)) ((c def c (c (? . 6) q call-with-input-file)) q (324300 . 7)) ((c def c (c (? . 0) q regexp-match-positions/end)) q (85881 . 16)) ((c def c (c (? . 0) q exn?)) c (? . 47)) ((c def c (c (? . 1) q unsafe-fx>=)) q (493027 . 4)) ((c form c (c (? . 9) q augment)) q (178078 . 2)) ((c def c (c (? . 1) q unsafe-fxnot)) q (491807 . 3)) ((c form c (c (? . 76) q with-syntax*)) q (318877 . 5)) ((c def c (c (? . 76) q current-syntax-context)) q (317496 . 4)) ((c def c (c (? . 0) q asin)) q (25715 . 3)) ((c def c (c (? . 0) q semaphore-peek-evt?)) q (275301 . 3)) ((c def c (c (? . 0) q number->string)) q (29377 . 4)) ((c def c (c (? . 0) q thread-cell?)) q (277605 . 3)) ((c def c (c (? . 0) q custom-print-quotable-accessor)) q (375439 . 2)) ((c def c (c (? . 25) q pretty-print-depth)) q (370501 . 4)) ((c def c (c (? . 9) q interface->method-names)) q (189958 . 3)) ((c def c (c (? . 0) q prop:input-port)) q (329549 . 2)) ((c def c (c (? . 16) q extfl>)) q (42171 . 4)) ((c def c (c (? . 24) q prop:provide-transformer)) q (310555 . 2)) ((c def c (c (? . 13) q mutable-setalw)) q (147204 . 4)) ((c def c (c (? . 19) q collapsible-count-property-count)) c (? . 35)) ((c def c (c (? . 0) q odd?)) q (22778 . 3)) ((c def c (c (? . 0) q struct-info)) q (415994 . 3)) ((c def c (c (? . 1) q unsafe-fx*/wraparound)) q (492507 . 4)) ((c def c (c (? . 25) q tentative-pretty-print-port-cancel)) q (374042 . 3)) ((c def c (c (? . 0) q current-drive)) q (447493 . 2)) ((c def c (c (? . 102) q true)) q (21352 . 2)) ((c def c (c (? . 134) q bytes-append*)) q (70396 . 4)) ((c def c (c (? . 0) q car)) q (92157 . 3)) ((c def c (c (? . 0) q exn:srclocs-accessor)) q (260393 . 4)) ((c def c (c (? . 22) q sequence-count)) q (134365 . 4)) ((c def c (c (? . 0) q string-upcase)) q (49284 . 3)) ((c def c (c (? . 57) q contract-proc)) q (242439 . 6)) ((c def c (c (? . 0) q sha1-bytes)) q (379479 . 5)) ((c form c (c (? . 76) q define/with-syntax)) q (317421 . 4)) ((c def c (c (? . 0) q phantom-bytes?)) q (490803 . 3)) ((c def c (c (? . 23) q list*of)) q (202604 . 4)) ((c def c (c (? . 6) q make-exn:fail:contract:continuation)) c (? . 108)) ((c def c (c (? . 1) q unsafe-fltan)) q (494652 . 3)) ((c def c (c (? . 0) q list*)) q (92373 . 4)) ((c form c (c (? . 0) q quote-syntax)) q (19312 . 3)) ((c form c (c (? . 65) q delay/name)) q (262349 . 2)) ((c def c (c (? . 37) q udp-send-to*)) q (463624 . 13)) ((c form c (c (? . 26) q prompt-tag/c)) q (205503 . 8)) ((c def c (c (? . 0) q srcloc-span)) c (? . 59)) ((c def c (c (? . 0) q split-path)) q (440478 . 5)) ((c def c (c (? . 42) q remv*)) q (94225 . 4)) ((c def c (c (? . 0) q vector->pseudo-random-generator!)) q (28415 . 5)) ((c def c (c (? . 16) q make-extflvector)) q (44096 . 4)) ((c form c (c (? . 9) q public)) q (177843 . 2)) ((c def c (c (? . 0) q hash-copy)) q (122922 . 3)) ((c def c (c (? . 0) q exn:fail:network?)) c (? . 83)) ((c def c (c (? . 122) q prop:chaperone-unsafe-undefined)) q (516333 . 2)) ((c def c (c (? . 9) q equal<%>)) q (188356 . 2)) ((c def c (c (? . 6) q in-string)) q (125293 . 6)) ((c form c (c (? . 13) q define-custom-set-types)) q (156032 . 12)) ((c def c (c (? . 10) q vector-argmax)) q (110822 . 4)) ((c def c (c (? . 0) q null)) q (92249 . 2)) ((c form c (c (? . 31) q set)) q (267338 . 2)) ((c def c (c (? . 26) q continuation-mark-key/c)) q (205700 . 3)) ((c def c (c (? . 80) q date*->seconds)) q (483338 . 4)) ((c def c (c (? . 0) q ceiling)) q (24403 . 3)) ((c def c (c (? . 16) q extfl>=)) q (42334 . 4)) ((c form c (c (? . 9) q augment*)) q (178666 . 2)) ((c def c (c (? . 0) q port-display-handler)) q (368638 . 6)) ((c def c (c (? . 0) q regexp-match-peek-immediate)) q (82208 . 15)) ((c def c (c (? . 9) q object=?)) q (188980 . 4)) ((c def c (c (? . 0) q struct-type-make-predicate)) q (416797 . 3)) ((c form c (c (? . 6) q local-require)) q (5531 . 2)) ((c def c (c (? . 0) q current-library-collection-links)) q (518376 . 11)) ((c def c (c (? . 0) q current-locale)) q (319702 . 4)) ((c def c (c (? . 6) q in-values*-sequence)) q (131720 . 3)) ((c def c (c (? . 0) q write-char)) q (358316 . 4)) ((c def c (c (? . 0) q raise-result-error)) q (247779 . 13)) ((c def c (c (? . 24) q provide-transformer?)) q (310673 . 3)) ((c def c (c (? . 17) q get-preference)) q (456118 . 18)) ((c form c (c (? . 32) q redirect-generics)) q (170869 . 4)) ((c def c (c (? . 40) q flat-contract?)) q (236157 . 3)) ((c def c (c (? . 12) q sandbox-make-environment-variables)) q (425865 . 5)) ((c def c (c (? . 0) q internal-definition-context-add-scopes)) q (301630 . 5)) ((c def c (c (? . 1) q unsafe-cdr)) q (496541 . 3)) ((c def c (c (? . 17) q make-directory*)) q (453779 . 3)) ((c def c (c (? . 20) q tcp-addresses)) q (461773 . 7)) ((c def c (c (? . 0) q make-ephemeron)) q (489777 . 4)) ((c def c (c (? . 1) q unsafe-impersonate-vector)) q (515040 . 11)) ((c def c (c (? . 0) q string->list)) q (48042 . 3)) ((c def c (c (? . 0) q module->exports)) q (398279 . 7)) ((c def c (c (? . 16) q fx->extfl)) q (43818 . 3)) ((c def c (c (? . 13) q set-member?)) q (151547 . 4)) ((c form c (c (? . 9) q init-field)) q (177697 . 2)) ((c def c (c (? . 6) q make-exn:break)) c (? . 69)) ((c def c (c (? . 0) q semaphore-try-wait?)) q (275058 . 3)) ((c def c (c (? . 0) q open-input-bytes)) q (328312 . 4)) ((c def c (c (? . 11) q fxvector-ref)) q (40229 . 4)) ((c def c (c (? . 0) q regexp)) q (74416 . 6)) ((c form c (c (? . 6) q for/fold)) q (16132 . 6)) ((c form c (c (? . 48) q match-lambda**)) q (244720 . 2)) ((c def c (c (? . 122) q chaperone-struct-unsafe-undefined)) q (516257 . 3)) ((c def c (c (? . 0) q raise-arity-error*)) q (251618 . 13)) ((c def c (c (? . 37) q udp-send-ready-evt)) q (466947 . 3)) ((c def c (c (? . 0) q syntax?)) q (287709 . 3)) ((c def c (c (? . 23) q non-empty-listof)) q (202532 . 3)) ((c def c (c (? . 0) q rename-transformer-target)) q (298104 . 3)) ((c def c (c (? . 1) q unsafe-flexpt)) q (495069 . 4)) ((c def c (c (? . 135) q syntax-procedure-alias-property)) q (311173 . 8)) ((c def c (c (? . 8) q empty)) q (98557 . 2)) ((c form c (c (? . 41) q import)) q (193746 . 2)) ((c def c (c (? . 0) q make-pipe)) q (329246 . 6)) ((c def c (c (? . 14) q processor-count)) q (282451 . 2)) ((c def c (c (? . 0) q write)) q (365265 . 4)) ((c def c (c (? . 17) q display-to-file)) q (450186 . 11)) ((c def c (c (? . 1) q unsafe-fl<=)) q (493883 . 4)) ((c def c (c (? . 0) q read-byte-or-special)) q (355939 . 8)) ((c form c (c (? . 27) q letrec-syntax)) q (12302 . 2)) ((c def c (c (? . 0) q regexp-match-peek-positions)) q (81219 . 19)) ((c form c (c (? . 13) q for*/set)) q (149333 . 2)) ((c def c (c (? . 0) q module-predefined?)) q (398898 . 4)) ((c form c (c (? . 23) q ->d)) q (209874 . 34)) ((c def c (c (? . 0) q bytes?)) q (63514 . 3)) ((c def c (c (? . 15) q display-lines)) q (335704 . 7)) ((c def c (c (? . 0) q syntax-track-origin)) q (313363 . 7)) ((c def c (c (? . 82) q exact-ceiling)) q (33044 . 3)) ((c def c (c (? . 0) q primitive?)) q (162570 . 3)) ((c def c (c (? . 17) q other-permission-bits)) q (459978 . 2)) ((c def c (c (? . 57) q struct-type-property/c)) q (213078 . 3)) ((c def c (c (? . 43) q call-with-default-reading-parameterization)) q (364490 . 3)) ((c def c (c (? . 0) q current-error-port)) q (320476 . 4)) ((c def c (c (? . 0) q prop:expansion-contexts)) q (303549 . 2)) ((c def c (c (? . 16) q extfl->inexact)) q (43877 . 3)) ((c def c (c (? . 19) q impersonator-prop:collapsible)) q (240731 . 2)) ((c def c (c (? . 0) q load-extension)) q (387825 . 3)) ((c def c (c (? . 0) q vector->pseudo-random-generator)) q (28291 . 4)) ((c form c (c (? . 48) q match-let)) q (244758 . 2)) ((c def c (c (? . 0) q mpair?)) q (106230 . 3)) ((c def c (c (? . 0) q even?)) q (22724 . 3)) ((c def c (c (? . 6) q make-exn:fail:filesystem:exists)) c (? . 129)) ((c def c (c (? . 1) q unsafe-char<?)) q (496089 . 4)) ((c form c (c (? . 9) q define/augment)) q (179318 . 3)) ((c form c (c (? . 40) q contract-pos/neg-doubling)) q (223146 . 2)) ((c def c (c (? . 0) q hash-placeholder?)) q (105775 . 3)) ((c def c (c (? . 0) q struct:exn:fail:read)) c (? . 85)) ((c def c (c (? . 0) q impersonate-channel)) q (403748 . 13)) ((c def c (c (? . 0) q hash-eq?)) q (114625 . 3)) ((c def c (c (? . 1) q unsafe-box*-cas!)) q (497721 . 5)) ((c def c (c (? . 0) q sha256-bytes)) q (379875 . 5)) ((c def c (c (? . 0) q make-readtable)) q (374206 . 11)) ((c def c (c (? . 0) q file-stream-buffer-mode)) q (320957 . 6)) ((c def c (c (? . 0) q cdaar)) q (96629 . 3)) ((c form c (c (? . 40) q with-contract-continuation-mark)) q (223025 . 3)) ((c def c (c (? . 20) q tcp-connect)) q (460464 . 9)) ((c def c (c (? . 11) q fx*)) q (37864 . 3)) ((c def c (c (? . 26) q rename-contract)) q (237867 . 4)) ((c form c (c (? . 23) q flat-rec-contract)) q (205883 . 2)) ((c def c (c (? . 21) q instance-describe-variable!)) q (434695 . 7)) ((c form c (c (? . 53) q contract-first-order-okay-to-give-up?)) q (237972 . 2)) ((c def c (c (? . 0) q log-message)) q (477979 . 13)) ((c def c (c (? . 44) q flvector)) q (36272 . 3)) ((c def c (c (? . 1) q unsafe-list-ref)) q (496962 . 4)) ((c def c (c (? . 40) q coerce-chaperone-contract)) q (222377 . 4)) ((c def c (c (? . 0) q special-comment-value)) q (374976 . 3)) ((c def c (c (? . 24) q export)) c (? . 68)) ((c def c (c (? . 1) q unsafe-extflasin)) q (513301 . 3)) ((c def c (c (? . 6) q make-do-sequence)) q (132005 . 15)) ((c def c (c (? . 44) q flceiling)) q (34666 . 3)) ((c def c (c (? . 19) q collapsible-contract?)) q (238861 . 3)) ((c form c (c (? . 136) q define-syntax-parameter)) q (312088 . 2)) ((c def c (c (? . 57) q make-proj-contract)) q (241482 . 15)) ((c def c (c (? . 0) q current-evt-pseudo-random-generator)) q (274143 . 5)) ((c def c (c (? . 21) q linklet?)) q (428954 . 3)) ((c form c (c (? . 14) q place/context)) q (282412 . 2)) ((c form c (c (? . 6) q for/and)) q (15580 . 2)) ((c def c (c (? . 0) q current-security-guard)) q (413598 . 4)) ((c form c (c (? . 137) q filtered-out)) q (10819 . 2)) ((c def c (c (? . 44) q flasin)) q (34990 . 3)) ((c def c (c (? . 57) q contract-random-generate/choose)) q (243080 . 4)) ((c form c (c (? . 2) q gen:dict)) q (138339 . 2)) ((c def c (c (? . 0) q unbox*)) q (114012 . 3)) ((c def c (c (? . 23) q and/c)) q (200149 . 3)) ((c def c (c (? . 82) q nan?)) q (33284 . 3)) ((c def c (c (? . 17) q character-device-type-bits)) q (459507 . 2)) ((c def c (c (? . 15) q dup-output-port)) q (342409 . 4)) ((c def c (c (? . 0) q impersonate-vector*)) q (401580 . 15)) ((c def c (c (? . 15) q read-bytes-line-evt)) q (347595 . 5)) ((c def c (c (? . 27) q call/ec)) q (264758 . 3)) ((c def c (c (? . 0) q string->path-element)) q (437544 . 6)) ((c def c (c (? . 130) q hash-union!)) q (123497 . 11)) ((c def c (c (? . 1) q unsafe-extflvector-length)) q (513938 . 3)) ((c def c (c (? . 0) q thread-resume)) q (271579 . 4)) ((c def c (c (? . 13) q set-mutable?)) q (146639 . 3)) ((c def c (c (? . 10) q vector-copy)) q (110227 . 5)) ((c def c (c (? . 0) q port-counts-lines?)) q (321671 . 3)) ((c def c (c (? . 14) q place?)) q (280284 . 3)) ((c form c (c (? . 23) q contract-out)) q (213177 . 23)) ((c def c (c (? . 0) q complete-path?)) q (439480 . 3)) ((c def c (c (? . 6) q hash-empty?)) q (121443 . 3)) ((c def c (c (? . 66) q blame-original?)) q (224618 . 3)) ((c def c (c (? . 0) q chaperone-of?)) q (399286 . 4)) ((c def c (c (? . 0) q struct:exn:fail:contract:divide-by-zero)) c (? . 118)) ((c def c (c (? . 0) q path-element->string)) q (438091 . 3)) ((c def c (c (? . 0) q port-writes-special?)) q (361203 . 3)) ((c def c (c (? . 6) q in-inclusive-range)) q (124719 . 5)) ((c def c (c (? . 1) q unsafe-fxquotient)) q (491302 . 4)) ((c def c (c (? . 0) q current-write-relative-directory)) q (367913 . 11)) ((c form c (c (? . 9) q this%)) q (177621 . 2)) ((c def c (c (? . 82) q exact-round)) q (32910 . 3)) ((c def c (c (? . 1) q unsafe-cons-list)) q (496862 . 4)) ((c def c (c (? . 0) q struct:exn:fail:syntax:missing-module)) c (? . 52)) ((c form c (c (? . 27) q letrec)) q (12004 . 2)) ((c def c (c (? . 13) q subset?)) q (153612 . 4)) ((c def c (c (? . 66) q blame-add-context)) q (223841 . 9)) ((c def c (c (? . 0) q make-output-port)) q (331838 . 59)) ((c def c (c (? . 0) q module->imports)) q (398033 . 6)) ((c def c (c (? . 13) q set-equal?)) q (146363 . 3)) ((c form c (c (? . 136) q define-rename-transformer-parameter)) q (312196 . 2)) ((c form c (c (? . 6) q for*/vector)) q (16808 . 2)) ((c def c (c (? . 21) q recompile-linklet)) q (430226 . 28)) ((c def c (c (? . 8) q eighth)) q (99089 . 3)) ((c def c (c (? . 1) q unsafe-fxrshift)) q (491949 . 4)) ((c def c (c (? . 8) q split-at)) q (100548 . 4)) ((c def c (c (? . 6) q procedure-reduce-keyword-arity-mask)) q (160991 . 14)) ((c def c (c (? . 6) q in-hash-values)) q (126743 . 6)) ((c def c (c (? . 42) q remv)) q (93882 . 4)) ((c def c (c (? . 6) q make-exn:fail:syntax:unbound)) c (? . 138)) ((c def c (c (? . 6) q in-input-port-bytes)) q (125905 . 3)) ((c def c (c (? . 11) q fxremainder)) q (37997 . 4)) ((c def c (c (? . 0) q compiled-expression-recompile)) q (390474 . 3)) ((c def c (c (? . 0) q byte-regexp?)) q (74299 . 3)) ((c def c (c (? . 0) q substring)) q (47082 . 5)) ((c def c (c (? . 0) q make-weak-hashalw)) q (116138 . 4)) ((q def ((lib "racket/symbol.rkt") symbol->immutable-string)) q (74096 . 3)) ((c def c (c (? . 8) q indexes-where)) q (100225 . 4)) ((c def c (c (? . 0) q exn:fail:syntax:unbound?)) c (? . 138)) ((c def c (c (? . 0) q string-copy)) q (47261 . 3)) ((c def c (c (? . 12) q call-with-custodian-shutdown)) c (? . 139)) ((c def c (c (? . 6) q make-exn:fail:contract:non-fixnum-result)) c (? . 97)) ((c def c (c (? . 0) q bytes->path)) q (437264 . 4)) ((c def c (c (? . 6) q make-base-empty-namespace)) q (380179 . 2)) ((c form c (c (? . 41) q contracted)) q (193566 . 2)) ((c def c (c (? . 6) q call-with-output-file*)) q (325820 . 18)) ((c def c (c (? . 80) q date->julian/scaliger)) q (483991 . 3)) ((c def c (c (? . 19) q prop:collapsible-contract)) q (238803 . 2)) ((c def c (c (? . 0) q eval-jit-enabled)) q (391444 . 4)) ((c def c (c (? . 11) q fxvector)) q (39964 . 3)) ((c def c (c (? . 24) q make-provide-transformer)) q (309967 . 10)) ((c def c (c (? . 6) q make-exn:fail:filesystem:version)) c (? . 86)) ((c def c (c (? . 6) q in-cycle)) q (131508 . 3)) ((c form c (c (? . 13) q gen:set)) q (151532 . 2)) ((c def c (c (? . 44) q flatan)) q (35096 . 3)) ((c form c (c (? . 9) q override-final*)) q (178624 . 2)) ((c def c (c (? . 0) q identifier-remove-from-definition-context)) q (303255 . 7)) ((c def c (c (? . 0) q hash-clear)) q (120117 . 3)) ((c def c (c (? . 0) q open-output-string)) q (328690 . 3)) ((c def c (c (? . 23) q or/c)) q (199995 . 3)) ((c def c (c (? . 0) q current-seconds)) q (480810 . 2)) ((c form c (c (? . 6) q for/lists)) q (15831 . 7)) ((c def c (c (? . 11) q fxvector?)) q (39909 . 3)) ((c def c (c (? . 0) q struct:exn:fail:syntax:unbound)) c (? . 138)) ((c def c (c (? . 25) q pretty-print-handler)) q (370258 . 3)) ((c def c (c (? . 0) q current-get-interaction-evt)) q (389730 . 4)) ((c def c (c (? . 1) q unsafe-flmin)) q (494053 . 4)) ((c def c (c (? . 0) q make-ephemeron-hashalw)) q (116734 . 4)) ((c def c (c (? . 0) q subbytes)) q (64198 . 5)) ((c def c (c (? . 0) q identifier-prune-lexical-context)) q (291772 . 5)) ((c form c (c (? . 0) q unquote-splicing)) q (19288 . 2)) ((c def c (c (? . 9) q is-a?)) q (189493 . 4)) ((c def c (c (? . 0) q make-string)) q (46473 . 4)) ((c def c (c (? . 24) q export-orig-stx)) c (? . 68)) ((c form c (c (? . 9) q abstract)) q (178221 . 2)) ((q form ((lib "racket/help.rkt") help)) q (519363 . 6)) ((c def c (c (? . 0) q peek-bytes-avail!)) q (353665 . 14)) ((c def c (c (? . 40) q contract-custom-write-property-proc)) q (237617 . 7)) ((c def c (c (? . 1) q unsafe-set-box!)) q (497441 . 4)) ((c def c (c (? . 7) q stream-add-between)) q (136992 . 4)) ((c def c (c (? . 0) q string-ci=?)) q (48797 . 4)) ((c def c (c (? . 6) q in-weak-hash-values)) q (129507 . 3)) ((c def c (c (? . 6) q date*)) c (? . 63)) ((c def c (c (? . 0) q struct:exn:fail:filesystem)) c (? . 89)) ((c def c (c (? . 6) q sequence->stream)) q (133107 . 3)) ((c def c (c (? . 140) q syntax-local-require-introduce)) q (13954 . 3)) ((c def c (c (? . 66) q raise-blame-error)) q (223241 . 14)) ((c def c (c (? . 37) q udp-send-to)) q (462945 . 13)) ((c def c (c (? . 44) q flcos)) q (34886 . 3)) ((c def c (c (? . 11) q fixnum-for-every-system?)) q (39839 . 3)) ((c def c (c (? . 0) q call-in-nested-thread)) q (271386 . 4)) ((c def c (c (? . 0) q char<?)) q (71076 . 4)) ((c def c (c (? . 0) q current-preserved-thread-cell-values)) q (277933 . 4)) ((c def c (c (? . 11) q fxpopcount)) q (38579 . 3)) ((c def c (c (? . 44) q fl-)) q (33756 . 4)) ((c def c (c (? . 0) q make-immutable-hash)) q (117206 . 4)) ((c form c (c (? . 9) q define/public-final)) q (178970 . 3)) ((c def c (c (? . 11) q fx+)) q (37733 . 3)) ((c def c (c (? . 0) q bytes->string/locale)) q (65881 . 9)) ((c def c (c (? . 44) q fl+)) q (33701 . 3)) ((c form c (c (? . 41) q tag)) q (193855 . 3)) ((c def c (c (? . 0) q srcloc-line)) c (? . 59)) ((c def c (c (? . 9) q interface-extension?)) q (189760 . 4)) ((c def c (c (? . 1) q unsafe-extfl=)) q (512186 . 4)) ((c def c (c (? . 1) q unsafe-fxremainder)) q (491387 . 4)) ((c def c (c (? . 15) q dup-input-port)) q (342300 . 4)) ((c def c (c (? . 0) q datum-intern-literal)) q (291478 . 3)) ((c form c (c (? . 41) q open)) q (193491 . 2)) ((c def c (c (? . 31) q call/prompt)) q (265626 . 7)) ((c def c (c (? . 0) q special-comment?)) q (374914 . 3)) ((c def c (c (? . 0) q equal-always-secondary-hash-code)) q (20886 . 3)) ((c form c (c (? . 13) q for/weak-seteq)) q (150058 . 2)) ((c def c (c (? . 6) q in-immutable-hash-values)) q (128607 . 3)) ((c def c (c (? . 7) q stream-map)) q (136294 . 4)) ((c def c (c (? . 12) q default-language-readers)) q (426043 . 3)) ((c def c (c (? . 13) q set-intersect!)) q (152985 . 4)) ((c def c (c (? . 0) q delete-directory)) q (447744 . 3)) ((c def c (c (? . 0) q expand-to-top-form)) q (314724 . 4)) ((c def c (c (? . 0) q make-continuation-mark-key)) q (269800 . 4)) ((c form c (c (? . 27) q let*-values)) q (12117 . 2)) ((c def c (c (? . 0) q port-write-handler)) q (368421 . 6)) ((c def c (c (? . 0) q peek-bytes)) q (352450 . 5)) ((c def c (c (? . 0) q make-resolved-module-path)) q (391715 . 7)) ((c def c (c (? . 42) q remove)) q (93697 . 5)) ((c form c (c (? . 41) q unit)) q (191888 . 22)) ((c form c (c (? . 48) q match-lambda)) q (244649 . 2)) ((c def c (c (? . 0) q box)) q (113737 . 3)) ((c def c (c (? . 0) q memv)) q (95025 . 4)) ((c def c (c (? . 1) q unsafe-fllog)) q (494891 . 3)) ((c form c (c (? . 41) q compound-unit)) q (194161 . 12)) ((c def c (c (? . 1) q unsafe-extflatan)) q (513439 . 3)) ((c def c (c (? . 6) q with-input-from-file)) q (326768 . 7)) ((c def c (c (? . 17) q file->value)) q (449117 . 4)) ((c def c (c (? . 6) q in-list)) q (124939 . 3)) ((c def c (c (? . 0) q positive?)) q (22614 . 3)) ((c def c (c (? . 19) q collapsible-count-property)) c (? . 35)) ((c def c (c (? . 0) q raise-range-error)) q (249324 . 17)) ((c def c (c (? . 0) q make-hasheqv)) q (115712 . 4)) ((c def c (c (? . 5) q const*)) q (162880 . 3)) ((c form c (c (? . 9) q augride)) q (178115 . 2)) ((c def c (c (? . 0) q progress-evt?)) q (358169 . 6)) ((c def c (c (? . 73) q extract-struct-info)) q (173894 . 3)) ((c def c (c (? . 19) q struct:collapsible-ho/c)) c (? . 94)) ((c def c (c (? . 0) q string?)) q (46420 . 3)) ((c def c (c (? . 2) q dict-iterate-first)) q (139111 . 3)) ((c def c (c (? . 13) q set-eq?)) q (146536 . 3)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-key)) q (503291 . 4)) ((c def c (c (? . 8) q cons?)) q (98579 . 3)) ((c def c (c (? . 6) q make-exn:fail:unsupported)) c (? . 119)) ((c def c (c (? . 40) q contract-val-first-projection)) q (236820 . 4)) ((c def c (c (? . 0) q hash-remove)) q (119902 . 4)) ((c def c (c (? . 0) q prefab-key->struct-type)) q (173032 . 4)) ((c def c (c (? . 0) q caadar)) q (97157 . 3)) ((c def c (c (? . 17) q make-temporary-directory)) q (454526 . 6)) ((c form c (c (? . 141) q define-provide-syntax)) q (14035 . 3)) ((c def c (c (? . 6) q make-exn:fail:syntax:missing-module)) c (? . 52)) ((c def c (c (? . 16) q floating-point-bytes->extfl)) q (45577 . 9)) ((c def c (c (? . 39) q trace-call)) q (520877 . 5)) ((c def c (c (? . 6) q impersonate-procedure*)) q (399886 . 11)) ((c def c (c (? . 0) q exn:fail:syntax?)) c (? . 104)) ((c def c (c (? . 0) q srcloc?)) c (? . 59)) ((c def c (c (? . 0) q thread-rewind-receive)) q (272651 . 3)) ((c def c (c (? . 1) q unsafe-fxvector-ref)) q (500100 . 4)) ((c def c (c (? . 17) q symbolic-link-type-bits)) q (459341 . 2)) ((c def c (c (? . 0) q bytes-converter?)) q (70290 . 3)) ((c def c (c (? . 48) q legacy-match-expander?)) q (245551 . 3)) ((c def c (c (? . 0) q nack-guard-evt)) q (273537 . 3)) ((c def c (c (? . 0) q symbol-interned?)) q (73492 . 3)) ((c def c (c (? . 0) q hash-iterate-value)) q (122008 . 4)) ((c def c (c (? . 17) q group-permission-bits)) q (459831 . 2)) ((c def c (c (? . 0) q cdaaar)) q (97757 . 3)) ((c form c (c (? . 13) q for*/mutable-set)) q (149769 . 2)) ((c form c (c (? . 13) q for*/weak-setalw)) q (150392 . 2)) ((c def c (c (? . 42) q build-string)) q (48184 . 4)) ((c def c (c (? . 0) q stencil-vector-mask-width)) q (112527 . 2)) ((c form c (c (? . 6) q define-struct)) q (165206 . 6)) ((c def c (c (? . 0) q string-normalize-nfc)) q (49720 . 3)) ((c def c (c (? . 6) q exn:fail:user)) c (? . 125)) ((c def c (c (? . 0) q cdaadr)) q (97857 . 3)) ((c def c (c (? . 0) q struct:exn:fail:contract:variable)) c (? . 120)) ((c def c (c (? . 0) q alarm-evt)) q (273937 . 4)) ((c def c (c (? . 0) q compile-allow-set!-undefined)) q (390772 . 4)) ((c def c (c (? . 0) q read-cdot)) q (363963 . 4)) ((c def c (c (? . 0) q procedure-extract-target)) q (161889 . 3)) ((c form c (c (? . 9) q member-name-key)) q (180033 . 2)) ((c def c (c (? . 8) q first)) q (98682 . 3)) ((c def c (c (? . 0) q make-known-char-range-list)) q (72884 . 5)) ((c def c (c (? . 0) q remainder)) q (23609 . 4)) ((c def c (c (? . 0) q sync/timeout)) q (272822 . 4)) ((c def c (c (? . 1) q unsafe-flreal-part)) q (495372 . 5)) ((c def c (c (? . 15) q read-bytes-avail!-evt)) q (347074 . 4)) ((c def c (c (? . 6) q make-exn:fail:syntax)) c (? . 104)) ((c def c (c (? . 66) q blame-swapped?)) q (224680 . 3)) ((c def c (c (? . 3) q import?)) c (? . 28)) ((c def c (c (? . 0) q banner)) q (486486 . 2)) ((c def c (c (? . 0) q char-ci<=?)) q (71636 . 4)) ((c def c (c (? . 0) q newline)) q (358550 . 3)) ((c def c (c (? . 10) q vector-empty?)) q (109028 . 3)) ((c def c (c (? . 0) q complex?)) q (21810 . 3)) ((c def c (c (? . 9) q dynamic-send)) q (181163 . 9)) ((c def c (c (? . 1) q unsafe-string->immutable-string!)) q (499124 . 4)) ((c def c (c (? . 0) q char-alphabetic?)) q (71923 . 3)) ((c def c (c (? . 1) q unsafe-chaperone-vector)) q (515467 . 11)) ((c def c (c (? . 0) q port-print-handler)) q (368859 . 7)) ((c def c (c (? . 37) q udp-multicast-join-group!)) q (468686 . 7)) ((c def c (c (? . 8) q takef-right)) q (101225 . 4)) ((c def c (c (? . 37) q udp-multicast-set-ttl!)) q (469721 . 4)) ((c def c (c (? . 20) q tcp-accept/enable-break)) q (461292 . 3)) ((c def c (c (? . 0) q read-square-bracket-with-tag)) q (362805 . 4)) ((c def c (c (? . 17) q group-read-bit)) q (459872 . 2)) ((c form c (c (? . 9) q override*)) q (178552 . 2)) ((c form c (c (? . 142) q define-module-boundary-contract)) q (215617 . 20)) ((c def c (c (? . 6) q make-exn:fail:network:errno)) c (? . 95)) ((c form c (c (? . 93) q in-generator)) q (137605 . 5)) ((c form c (c (? . 13) q for/mutable-seteqv)) q (149651 . 2)) ((c def c (c (? . 0) q struct-type?)) q (172362 . 3)) ((c def c (c (? . 8) q remove-duplicates)) q (103242 . 7)) ((c def c (c (? . 66) q blame-add-missing-party)) q (225072 . 5)) ((c def c (c (? . 0) q weak-box?)) q (489722 . 3)) ((c def c (c (? . 0) q magnitude)) q (26212 . 3)) ((c def c (c (? . 13) q list->weak-setalw)) q (148821 . 4)) ((c def c (c (? . 1) q unsafe-mcdr)) q (496649 . 3)) ((c def c (c (? . 143) q make-parameter-rename-transformer)) q (312326 . 3)) ((c def c (c (? . 57) q contract-random-generate-fail)) q (243218 . 2)) ((c def c (c (? . 16) q extfl->exact)) q (43682 . 3)) ((c def c (c (? . 19) q collapsible-wrapper-property-checking-wrapper)) c (? . 124)) ((c def c (c (? . 0) q current-output-port)) q (320363 . 4)) ((c def c (c (? . 0) q string-ci<?)) q (48894 . 4)) ((c def c (c (? . 0) q path-convention-type)) q (438343 . 3)) ((c form c (c (? . 93) q infinite-generator)) q (137565 . 2)) ((c def c (c (? . 6) q in-lines)) q (126053 . 5)) ((c form c (c (? . 7) q for*/stream)) q (137141 . 2)) ((c def c (c (? . 82) q infinite?)) q (33334 . 3)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-first)) q (509144 . 3)) ((c def c (c (? . 6) q regexp-split)) q (88936 . 15)) ((c def c (c (? . 1) q unsafe-u16vector-set!)) q (501137 . 5)) ((c def c (c (? . 30) q call-with-break-parameterization)) q (270489 . 5)) ((c def c (c (? . 6) q in-directory)) q (130911 . 5)) ((c form c (c (? . 9) q define-serializable-class*)) q (188390 . 4)) ((c def c (c (? . 43) q path-string?)) q (437078 . 3)) ((c def c (c (? . 56) q futures-enabled?)) q (279371 . 2)) ((c def c (c (? . 19) q collapsible-leaf/c?)) c (? . 36)) ((c def c (c (? . 1) q unsafe-struct-ref)) q (502420 . 4)) ((c def c (c (? . 0) q equal?)) q (20104 . 4)) ((c def c (c (? . 0) q raise-type-error)) q (250732 . 10)) ((c def c (c (? . 6) q exn:fail:filesystem:exists)) c (? . 129)) ((c def c (c (? . 0) q wrap-evt)) q (273249 . 4)) ((c def c (c (? . 0) q current-compile-target-machine)) q (391034 . 5)) ((c def c (c (? . 3) q syntax-local-require-certifier)) q (309577 . 4))))
syntax
(if test-expr then-expr else-expr)
syntax
(lambda formals body ...+)
 
formals = id
        | (id ...)
        | (id ...+ . rest-id)
syntax
(init-rest id)
(init-rest)
syntax
(parameterize ([parameter-expr value-expr] ...)
  body ...+)
 
  parameter-expr : parameter?
procedure
(char->integer char) -> exact-integer?
  char : char?
procedure
(argmax proc lst) -> any
  proc : (-> any/c real?)
  lst : (and/c pair? list?)
procedure
(read [in]) -> any
  in : input-port? = (current-input-port)
procedure
(sort  lst                             
       less-than?                      
      [#:key extract-key               
       #:cache-keys? cache-keys?]) -> list?
  lst : list?
  less-than? : (any/c any/c . -> . any/c)
  extract-key : (any/c . -> . any/c) = (lambda (x) x)
  cache-keys? : boolean? = #f
struct
(struct color (red green blue alpha))
  red : (and/c natural-number/c (<=/c 255))
  green : (and/c natural-number/c (<=/c 255))
  blue : (and/c natural-number/c (<=/c 255))
  alpha : (and/c natural-number/c (<=/c 255))
struct
(struct data-source (connector args extensions)
    #:mutable)
  connector : (or/c 'postgresql 'mysql 'sqlite3 'odbc)
  args : list?
  extensions : (listof (list/c symbol? any/c))
parameter
(current-command-line-arguments) -> (vectorof string?)
(current-command-line-arguments argv) -> void?
  argv : (vectorof (and/c string? immutable?))
value
object% : class?

(something id thing-expr ...)
 
  thing-expr : number?
syntax
(module id module-path form ...)
syntax
(module* id module-path form ...)
(module* id #f form ...)
syntax
(module+ id form ...)
syntax
(#%module-begin form ...)
syntax
(#%printing-module-begin form ...)
syntax
(#%plain-module-begin form ...)
syntax
(#%declare declaration-keyword ...)
 
declaration-keyword = #:cross-phase-persistent
                    | #:empty-namespace
                    | #:require=define
                    | #:unsafe
                    | #:realm identifier
syntax
(require require-spec ...)
 
       require-spec = module-path
                    | (only-in require-spec id-maybe-renamed ...)
                    | (except-in require-spec id ...)
                    | (prefix-in prefix-id require-spec)
                    | (rename-in require-spec [orig-id bind-id] ...)
                    | (combine-in require-spec ...)
                    | (relative-in module-path require-spec ...)
                    | (only-meta-in phase-level require-spec ...)
                    | (only-space-in space require-spec ...)
                    | (for-syntax require-spec ...)
                    | (for-template require-spec ...)
                    | (for-label require-spec ...)
                    | (for-meta phase-level require-spec ...)
                    | (for-space space require-spec ...)
                    | derived-require-spec
                       
        module-path = root-module-path
                    | (submod root-module-path submod-path-element ...)
                    | (submod "." submod-path-element ...)
                    | (submod ".." submod-path-element ...)
                       
   root-module-path = (quote id)
                    | rel-string
                    | (lib rel-string ...+)
                    | id
                    | (file string)
                    | (planet id)
                    | (planet string)
                    | (planet rel-string
                              (user-string pkg-string vers)
                              rel-string ...)
                       
submod-path-element = id
                    | ".."
                       
   id-maybe-renamed = id
                    | [orig-id bind-id]
                       
        phase-level = exact-integer
                    | #f
                       
              space = id
                    | #f
                       
               vers = 
                    | nat
                    | nat minor-vers
                       
         minor-vers = nat
                    | (nat nat)
                    | (= nat)
                    | (+ nat)
                    | (- nat)

module-path
syntax
(only-in require-spec id-maybe-renamed ...)
syntax
(except-in require-spec id ...)
syntax
(prefix-in prefix-id require-spec)
syntax
(rename-in require-spec [orig-id bind-id] ...)
syntax
(combine-in require-spec ...)
syntax
(relative-in module-path require-spec ...)
syntax
(only-meta-in phase-level require-spec ...)
syntax
(only-space-in space require-spec ...)

(for-meta phase-level require-spec ...)

(for-syntax require-spec ...)

(for-template require-spec ...)

(for-label require-spec ...)

(for-space space require-spec ...)

derived-require-spec

(quote id)

rel-string
syntax
(lib rel-string ...+)

id
syntax
(file string)
syntax
(planet id)
(planet string)
(planet rel-string (user-string pkg-string vers)
        rel-string ...)
syntax
(submod root-module-path submod-path-element ...)
(submod "." submod-path-element ...)
(submod ".." submod-path-element ...)
syntax
(local-require require-spec ...)
syntax
(provide provide-spec ...)
 
provide-spec = id
             | (all-defined-out)
             | (all-from-out module-path ...)
             | (rename-out [orig-id export-id] ...)
             | (except-out provide-spec provide-spec ...)
             | (prefix-out prefix-id provide-spec)
             | (struct-out id)
             | (combine-out provide-spec ...)
             | (protect-out provide-spec ...)
             | (for-meta phase-level provide-spec ...)
             | (for-syntax provide-spec ...)
             | (for-template provide-spec ...)
             | (for-label provide-spec ...)
             | (for-space space provide-spec ...)
             | derived-provide-spec
                
 phase-level = exact-integer
             | #f
                
       space = id
             | #f

id
syntax
(all-defined-out)
syntax
(all-from-out module-path ...)
syntax
(rename-out [orig-id export-id] ...)
syntax
(except-out provide-spec provide-spec ...)
syntax
(prefix-out prefix-id provide-spec)
syntax
(struct-out id)
syntax
(combine-out provide-spec ...)
syntax
(protect-out provide-spec ...)

(for-meta phase-level provide-spec ...)

(for-syntax provide-spec ...)

(for-template provide-spec ...)

(for-label provide-spec ...)

(for-space space provide-spec ...)

derived-provide-spec
syntax
(for-meta phase-level require-spec ...)
syntax
(for-syntax require-spec ...)
syntax
(for-template require-spec ...)
syntax
(for-label require-spec ...)
syntax
(for-space space require-spec ...)
syntax
(#%require raw-require-spec ...)
 
    raw-require-spec = phaseless-spec
                     | (for-meta phase-level raw-require-spec ...)
                     | (for-syntax raw-require-spec ...)
                     | (for-template raw-require-spec ...)
                     | (for-label raw-require-spec ...)
                     | (just-meta phase-level raw-require-spec ...)
                     | (portal portal-id content)
                        
         phase-level = exact-integer
                     | #f
                        
      phaseless-spec = spaceless-spec
                     | (for-space space phaseless-spec ...)
                     | (just-space space spaceless-spec ...)
                        
               space = id
                     | #f
                        
      spaceless-spec = raw-module-path
                     | (only raw-module-path id ...)
                     | (prefix prefix-id raw-module-path)
                     | (all-except raw-module-path id ...)
                     | (prefix-all-except prefix-id
                                          raw-module-path id ...)
                     | (rename raw-module-path local-id exported-id)
                        
     raw-module-path = raw-root-module-path
                     | (submod raw-root-module-path id ...+)
                     | (submod "." id ...+)
                        
raw-root-module-path = (quote id)
                     | rel-string
                     | (lib rel-string ...)
                     | id
                     | (file string)
                     | (planet rel-string
                               (user-string pkg-string vers ...))
                     | literal-path
syntax
(#%provide raw-provide-spec ...)
 
raw-provide-spec = phaseless-spec
                 | (for-meta phase-level phaseless-spec ...)
                 | (for-syntax phaseless-spec ...)
                 | (for-label phaseless-spec ...)
                 | (protect raw-provide-spec ...)
                    
     phase-level = exact-integer
                 | #f
                    
  phaseless-spec = spaceless-spec
                 | (for-space space spaceless-spec ...)
                 | (protect phaseless-spec ...)
                    
           space = id
                 | #f
                    
  spaceless-spec = id
                 | (rename local-id export-id)
                 | (struct struct-id (field-id ...))
                 | (all-from raw-module-path)
                 | (all-from-except raw-module-path id ...)
                 | (all-defined)
                 | (all-defined-except id ...)
                 | (prefix-all-defined prefix-id)
                 | (prefix-all-defined-except prefix-id id ...)
                 | (protect spaceless-spec ...)
                 | (expand (id . datum))
                 | (expand (id . datum) orig-form)
syntax
(matching-identifiers-in regexp require-spec)
syntax
(subtract-in require-spec subtracted-spec ...)
syntax
(filtered-in proc-expr require-spec)
syntax
(path-up rel-string ...)
syntax
(multi-in subs ...+)
 
    subs = sub-path
         | (sub-path ...)
            
sub-path = rel-string
         | id
syntax
(matching-identifiers-out regexp provide-spec)
syntax
(filtered-out proc-expr provide-spec)
syntax
(quote datum)
syntax
(#%datum . datum)
syntax
(#%expression expr)
syntax
id
syntax
(#%top . id)
syntax
(#%variable-reference id)
(#%variable-reference (#%top . id))
(#%variable-reference)
syntax
(proc-expr arg ...)
syntax
(#%app proc-expr arg ...)

arg-expr

keyword arg-expr
syntax
(#%plain-app proc-expr arg-expr ...)
(#%plain-app)
syntax
(lambda kw-formals body ...+)
syntax
(λ kw-formals body ...+)
 
kw-formals = (arg ...)
           | (arg ...+ . rest-id)
           | rest-id
              
       arg = id
           | [id default-expr]
           | keyword id
           | keyword [id default-expr]

(id ...)

(id ...+ . rest-id)

rest-id

(arg ...)

id

[id default-expr]

keyword id

keyword [id default-expr]

(arg ...+ . rest-id)
syntax
(case-lambda [formals body ...+] ...)
 
formals = (id ...)
        | (id ...+ . rest-id)
        | rest-id
syntax
(#%plain-lambda formals body ...+)
syntax
(let ([id val-expr] ...) body ...+)
(let proc-id ([id init-expr] ...) body ...+)
syntax
(let* ([id val-expr] ...) body ...+)
syntax
(letrec ([id val-expr] ...) body ...+)
syntax
(let-values ([(id ...) val-expr] ...) body ...+)
syntax
(let*-values ([(id ...) val-expr] ...) body ...+)
syntax
(letrec-values ([(id ...) val-expr] ...) body ...+)
syntax
(let-syntax ([id trans-expr] ...) body ...+)
syntax
(letrec-syntax ([id trans-expr] ...) body ...+)
syntax
(let-syntaxes ([(id ...) trans-expr] ...) body ...+)
syntax
(letrec-syntaxes ([(id ...) trans-expr] ...) body ...+)
syntax
(letrec-syntaxes+values ([(trans-id ...) trans-expr] ...)
                        ([(val-id ...) val-expr] ...)
   body ...+)
syntax
(local [definition ...] body ...+)
syntax
(shared ([id expr] ...) body ...+)
syntax
(if test-expr then-expr else-expr)
syntax
(cond cond-clause ...)
 
cond-clause = [test-expr then-body ...+]
            | [else then-body ...+]
            | [test-expr => proc-expr]
            | [test-expr]

[test-expr then-body ...+]

[test-expr => proc-expr]

[test-expr]
syntax
else
syntax
=>
syntax
(and expr ...)
syntax
(or expr ...)
syntax
(case val-expr case-clause ...)
 
case-clause = [(datum ...) then-body ...+]
            | [else then-body ...+]
syntax
(define id expr)
(define (head args) body ...+)
 
head = id
     | (head args)
        
args = arg ...
     | arg ... . rest-id
        
 arg = arg-id
     | [arg-id default-expr]
     | keyword arg-id
     | keyword [arg-id default-expr]
syntax
(define-values (id ...) expr)
syntax
(define-syntax id expr)
(define-syntax (head args) body ...+)
syntax
(define-syntaxes (id ...) expr)
syntax
(define-for-syntax id expr)
(define-for-syntax (head args) body ...+)
syntax
(define-values-for-syntax (id ...) expr)
syntax
(define-require-syntax id proc-expr)
(define-require-syntax (id args ...) body ...+)
procedure
(syntax-local-require-introduce stx) -> syntax?
  stx : syntax?
syntax
(define-provide-syntax id proc-expr)
(define-provide-syntax (id args ...) body ...+)
procedure
(syntax-local-provide-introduce stx) -> syntax?
  stx : syntax?
syntax
(begin form ...)
(begin expr ...+)
syntax
(begin0 expr ...+)
syntax
(begin-for-syntax form ...)
syntax
(when test-expr body ...+)
syntax
(unless test-expr body ...+)
syntax
(set! id expr)
syntax
(set!-values (id ...) expr)
syntax
(for (for-clause ...) body-or-break ... body)
 
   for-clause = [id seq-expr]
              | [(id ...) seq-expr]
              | #:when guard-expr
              | #:unless guard-expr
              | #:do [do-body ...]
              | break-clause
              | #:splice (splicing-id . form)
                 
 break-clause = #:break guard-expr
              | #:final guard-expr
                 
body-or-break = body
              | break-clause
 
  seq-expr : sequence?
syntax
(for/list (for-clause ...) body-or-break ... body)
syntax
(for/vector maybe-length (for-clause ...) body-or-break ... body)
 
maybe-length = 
             | #:length length-expr
             | #:length length-expr #:fill fill-expr
 
  length-expr : exact-nonnegative-integer?
syntax
(for/hash (for-clause ...) body-or-break ... body)
syntax
(for/hasheq (for-clause ...) body-or-break ... body)
syntax
(for/hasheqv (for-clause ...) body-or-break ... body)
syntax
(for/hashalw (for-clause ...) body-or-break ... body)
syntax
(for/and (for-clause ...) body-or-break ... body)
syntax
(for/or (for-clause ...) body-or-break ... body)
syntax
(for/sum (for-clause ...) body-or-break ... body)
syntax
(for/product (for-clause ...) body-or-break ... body)
syntax
(for/lists (id ... maybe-result)
           (for-clause ...)
  body-or-break ... body)
 
maybe-result = 
             | #:result result-expr
syntax
(for/first (for-clause ...) body-or-break ... body)
syntax
(for/last (for-clause ...) body-or-break ... body)
syntax
(for/fold ([accum-id init-expr] ... maybe-result) (for-clause ...)
  body-or-break ... body)
 
maybe-result = 
             | #:result result-expr
syntax
(for/foldr ([accum-id init-expr] ... accum-option ...)
           (for-clause ...)
  body-or-break ... body)
 
accum-option = #:result result-expr
             | #:delay
             | #:delay-as delayed-id
             | #:delay-with delayer-id
syntax
(for* (for-clause ...) body-or-break ... body)
syntax
(for*/list (for-clause ...) body-or-break ... body)
syntax
(for*/lists (id ... maybe-result) (for-clause ...)
  body-or-break ... body)
syntax
(for*/vector maybe-length (for-clause ...) body-or-break ... body)
syntax
(for*/hash (for-clause ...) body-or-break ... body)
syntax
(for*/hasheq (for-clause ...) body-or-break ... body)
syntax
(for*/hasheqv (for-clause ...) body-or-break ... body)
syntax
(for*/hashalw (for-clause ...) body-or-break ... body)
syntax
(for*/and (for-clause ...) body-or-break ... body)
syntax
(for*/or (for-clause ...) body-or-break ... body)
syntax
(for*/sum (for-clause ...) body-or-break ... body)
syntax
(for*/product (for-clause ...) body-or-break ... body)
syntax
(for*/first (for-clause ...) body-or-break ... body)
syntax
(for*/last (for-clause ...) body-or-break ... body)
syntax
(for*/fold ([accum-id init-expr] ... maybe-result) (for-clause ...)
  body-or-break ... body)
syntax
(for*/foldr ([accum-id init-expr] ... accum-option ...)
            (for-clause ...)
  body-or-break ... body)
syntax
(for/fold/derived orig-datum
  ([accum-id init-expr] ... maybe-result) (for-clause ...)
  body-or-break ... body)
syntax
(for*/fold/derived orig-datum
  ([accum-id init-expr] ... maybe-result) (for-clause ...)
  body-or-break ... body)
syntax
(for/foldr/derived orig-datum
  ([accum-id init-expr] ... accum-option ...) (for-clause ...)
  body-or-break ... body)
syntax
(for*/foldr/derived orig-datum
  ([accum-id init-expr] ... accum-option ...) (for-clause ...)
  body-or-break ... body)
syntax
(define-sequence-syntax id
  expr-transform-expr
  clause-transform-expr)
 
  expr-transform-expr : (or/c (-> identifier?)
                              (syntax? . -> . syntax?))
  clause-transform-expr : (syntax? . -> . syntax?)
syntax
(:do-in ([(outer-id ...) outer-expr] ...)
        outer-check
        ([loop-id loop-expr] ...)
        pos-guard
        ([(inner-id ...) inner-expr] ...)
        pre-guard
        post-guard
        (loop-arg ...))
procedure
(for-clause-syntax-protect stx) -> syntax?
  stx : syntax?
syntax
(define-splicing-for-clause-syntax id proc-expr)
syntax
(do ([id init-expr step-expr-maybe] ...)
    (stop?-expr finish-expr ...)
  expr ...)
 
step-expr-maybe = 
                | step-expr
syntax
(with-continuation-mark key-expr val-expr result-expr)
syntax
(quasiquote datum)
syntax
unquote
syntax
unquote-splicing
syntax
(quote-syntax datum)
(quote-syntax datum #:local)
syntax
(#%top-interaction . form)
syntax
(block defn-or-expr ...)
syntax
(#%stratified-body defn-or-expr ...)
syntax
(begin-encourage-inline form ...)
syntax
(define-inline id expr)
(define-inline (head args) body ...+)
 
head = id
     | (head args)
        
args = arg ...
     | arg ... . rest-id
        
 arg = arg-id
     | [arg-id default-expr]
     | keyword arg-id
     | keyword [arg-id default-expr]
syntax
(lazy-require [module-path (fun-import ...)] ...)
 
fun-import = fun-id
           | (orig-fun-id fun-id)
syntax
(lazy-require-syntax [module-path (macro-import ...)] ...)
 
macro-import = macro-id
             | (orig-macro-id macro-id)
procedure
(equal? v1 v2) -> boolean?
  v1 : any/c
  v2 : any/c
procedure
(equal-always? v1 v2) -> boolean?
  v1 : any/c
  v2 : any/c
procedure
(eqv? v1 v2) -> boolean?
  v1 : any/c
  v2 : any/c
procedure
(eq? v1 v2) -> boolean?
  v1 : any/c
  v2 : any/c
procedure
(equal?/recur v1 v2 recur-proc) -> boolean?
  v1 : any/c
  v2 : any/c
  recur-proc : (any/c any/c -> any/c)
procedure
(equal-always?/recur v1 v2 recur-proc) -> boolean?
  v1 : any/c
  v2 : any/c
  recur-proc : (any/c any/c -> any/c)
procedure
(equal-hash-code v) -> fixnum?
  v : any/c
procedure
(equal-secondary-hash-code v) -> fixnum?
  v : any/c
procedure
(equal-always-hash-code v) -> fixnum?
  v : any/c
procedure
(equal-always-secondary-hash-code v) -> fixnum?
  v : any/c
procedure
(eq-hash-code v) -> fixnum?
  v : any/c
procedure
(eqv-hash-code v) -> fixnum?
  v : any/c
value
gen:equal+hash : any/c
value
gen:equal-mode+hash : any/c
value
prop:equal+hash : struct-type-property?
procedure
(boolean? v) -> boolean?
  v : any/c
procedure
(not v) -> boolean?
  v : any/c
procedure
(immutable? v) -> boolean?
  v : any/c
value
true : boolean?
value
false : boolean?
procedure
(symbol=? a b) -> boolean?
  a : symbol?
  b : symbol?
procedure
(boolean=? a b) -> boolean?
  a : boolean?
  b : boolean?
procedure
(false? v) -> boolean?
  v : any/c
syntax
(nand expr ...)
syntax
(nor expr ...)
syntax
(implies expr1 expr2)
procedure
(xor b1 b2) -> any
  b1 : any/c
  b2 : any/c
procedure
(number? v) -> boolean?
  v : any/c
procedure
(complex? v) -> boolean?
  v : any/c
procedure
(real? v) -> boolean?
  v : any/c
procedure
(rational? v) -> boolean?
  v : any/c
procedure
(integer? v) -> boolean?
  v : any/c
procedure
(exact-integer? v) -> boolean?
  v : any/c
procedure
(exact-nonnegative-integer? v) -> boolean?
  v : any/c
procedure
(exact-positive-integer? v) -> boolean?
  v : any/c
procedure
(inexact-real? v) -> boolean?
  v : any/c
procedure
(fixnum? v) -> boolean?
  v : any/c
procedure
(flonum? v) -> boolean?
  v : any/c
procedure
(double-flonum? v) -> boolean?
  v : any/c
procedure
(single-flonum? v) -> boolean?
  v : any/c
procedure
(single-flonum-available?) -> boolean?
procedure
(zero? z) -> boolean?
  z : number?
procedure
(positive? x) -> boolean?
  x : real?
procedure
(negative? x) -> boolean?
  x : real?
procedure
(even? n) -> boolean?
  n : integer?
procedure
(odd? n) -> boolean?
  n : integer?
procedure
(exact? z) -> boolean?
  z : number?
procedure
(inexact? z) -> boolean?
  z : number?
procedure
(inexact->exact z) -> exact?
  z : number?
procedure
(exact->inexact z) -> inexact?
  z : number?
procedure
(real->single-flonum x) -> single-flonum?
  x : real?
procedure
(real->double-flonum x) -> flonum?
  x : real?
procedure
(+ z ...) -> number?
  z : number?
procedure
(- z) -> number?
  z : number?
(- z w ...+) -> number?
  z : number?
  w : number?
procedure
(* z ...) -> number?
  z : number?
procedure
(/ z) -> number?
  z : number?
(/ z w ...+) -> number?
  z : number?
  w : number?
procedure
(quotient n m) -> integer?
  n : integer?
  m : integer?
procedure
(remainder n m) -> integer?
  n : integer?
  m : integer?
procedure
(quotient/remainder n m) -> integer? integer?
  n : integer?
  m : integer?
procedure
(modulo n m) -> integer?
  n : integer?
  m : integer?
procedure
(add1 z) -> number?
  z : number?
procedure
(sub1 z) -> number?
  z : number?
procedure
(abs x) -> number?
  x : real?
procedure
(max x ...+) -> real?
  x : real?
procedure
(min x ...+) -> real?
  x : real?
procedure
(gcd n ...) -> rational?
  n : rational?
procedure
(lcm n ...) -> rational?
  n : rational?
procedure
(round x) -> (or/c integer? +inf.0 -inf.0 +nan.0)
  x : real?
procedure
(floor x) -> (or/c integer? +inf.0 -inf.0 +nan.0)
  x : real?
procedure
(ceiling x) -> (or/c integer? +inf.0 -inf.0 +nan.0)
  x : real?
procedure
(truncate x) -> (or/c integer? +inf.0 -inf.0 +nan.0)
  x : real?
procedure
(numerator q) -> integer?
  q : rational?
procedure
(denominator q) -> (and/c integer? positive?)
  q : rational?
procedure
(rationalize x tolerance) -> real?
  x : real?
  tolerance : real?
procedure
(= z w ...) -> boolean?
  z : number?
  w : number?
procedure
(< x y ...) -> boolean?
  x : real?
  y : real?
procedure
(<= x y ...) -> boolean?
  x : real?
  y : real?
procedure
(> x y ...) -> boolean?
  x : real?
  y : real?
procedure
(>= x y ...) -> boolean?
  x : real?
  y : real?
procedure
(sqrt z) -> number?
  z : number?
procedure
(integer-sqrt n) -> complex?
  n : integer?
procedure
(integer-sqrt/remainder n) -> complex? integer?
  n : integer?
procedure
(expt z w) -> number?
  z : number?
  w : number?
procedure
(exp z) -> number?
  z : number?
procedure
(log z [b]) -> number?
  z : number?
  b : number? = (exp 1)
procedure
(sin z) -> number?
  z : number?
procedure
(cos z) -> number?
  z : number?
procedure
(tan z) -> number?
  z : number?
procedure
(asin z) -> number?
  z : number?
procedure
(acos z) -> number?
  z : number?
procedure
(atan z) -> number?
  z : number?
(atan y x) -> number?
  y : real?
  x : real?
procedure
(make-rectangular x y) -> number?
  x : real?
  y : real?
procedure
(make-polar magnitude angle) -> number?
  magnitude : real?
  angle : real?
procedure
(real-part z) -> real?
  z : number?
procedure
(imag-part z) -> real?
  z : number?
procedure
(magnitude z) -> (and/c real? (not/c negative?))
  z : number?
procedure
(angle z) -> real?
  z : number?
procedure
(bitwise-ior n ...) -> exact-integer?
  n : exact-integer?
procedure
(bitwise-and n ...) -> exact-integer?
  n : exact-integer?
procedure
(bitwise-xor n ...) -> exact-integer?
  n : exact-integer?
procedure
(bitwise-not n) -> exact-integer?
  n : exact-integer?
procedure
(bitwise-bit-set? n m) -> boolean?
  n : exact-integer?
  m : exact-nonnegative-integer?
procedure
(bitwise-bit-field n start end) -> exact-integer?
  n : exact-integer?
  start : exact-nonnegative-integer?
  end : (and/c exact-nonnegative-integer?
               (>=/c start))
procedure
(arithmetic-shift n m) -> exact-integer?
  n : exact-integer?
  m : exact-integer?
procedure
(integer-length n) -> exact-integer?
  n : exact-integer?
procedure
(random k [rand-gen]) -> exact-nonnegative-integer?
  k : (integer-in 1 4294967087)
  rand-gen : pseudo-random-generator?
           = (current-pseudo-random-generator)
(random min max [rand-gen]) -> exact-nonnegative-integer?
  min : exact-integer?
  max : (integer-in (+ 1 min) (+ 4294967087 min))
  rand-gen : pseudo-random-generator?
           = (current-pseudo-random-generator)
(random [rand-gen]) -> (and/c real? inexact? (>/c 0) (</c 1))
  rand-gen : pseudo-random-generator?
           = (current-pseudo-random-generator)
procedure
(random-seed k) -> void?
  k : (integer-in 0 (sub1 (expt 2 31)))
procedure
(make-pseudo-random-generator) -> pseudo-random-generator?
procedure
(pseudo-random-generator? v) -> boolean?
  v : any/c
parameter
(current-pseudo-random-generator) -> pseudo-random-generator?
(current-pseudo-random-generator rand-gen) -> void?
  rand-gen : pseudo-random-generator?
procedure
(pseudo-random-generator->vector rand-gen)
 -> pseudo-random-generator-vector?
  rand-gen : pseudo-random-generator?
procedure
(vector->pseudo-random-generator vec)
 -> pseudo-random-generator?
  vec : pseudo-random-generator-vector?
procedure
(vector->pseudo-random-generator! rand-gen     
                                  vec)     -> void?
  rand-gen : pseudo-random-generator?
  vec : pseudo-random-generator-vector?
procedure
(pseudo-random-generator-vector? v) -> boolean?
  v : any/c
procedure
(crypto-random-bytes n) -> bytes?
  n : exact-positive-integer?
procedure
(random-ref seq [rand-gen]) -> any/c
  seq : sequence?
  rand-gen : pseudo-random-generator?
           = (current-pseudo-random-generator)
procedure
(random-sample  seq                               
                n                                 
               [rand-gen                          
                #:replacement? replacement?]) -> (listof any/c)
  seq : sequence?
  n : exact-positive-integer?
  rand-gen : pseudo-random-generator?
           = (current-pseudo-random-generator)
  replacement? : any/c = #t
procedure
(number->string z [radix]) -> string?
  z : number?
  radix : (or/c 2 8 10 16) = 10
procedure
(string->number  s             
                [radix         
                 convert-mode  
                 decimal-mode  
                 single-mode]) 
 -> (or/c number? #f string? extflonum?)
  s : string?
  radix : (integer-in 2 16) = 10
  convert-mode : (or/c 'number-or-false 'read)
               = 'number-or-false
  decimal-mode : (or/c 'decimal-as-inexact 'decimal-as-exact)
               = (if (read-decimal-as-inexact)
                     'decimal-as-inexact
                     'decimal-as-exact)
  single-mode : (or/c 'single 'double)
              = (if (read-single-flonum)
                    'single
                    'double)
procedure
(real->decimal-string n [decimal-digits]) -> string?
  n : rational?
  decimal-digits : exact-nonnegative-integer? = 2
procedure
(integer-bytes->integer  bstr            
                         signed?         
                        [big-endian?     
                         start           
                         end])       -> exact-integer?
  bstr : bytes?
  signed? : any/c
  big-endian? : any/c = (system-big-endian?)
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(integer->integer-bytes  n               
                         size-n          
                         signed?         
                        [big-endian?     
                         dest-bstr       
                         start])     -> bytes?
  n : exact-integer?
  size-n : (or/c 1 2 4 8)
  signed? : any/c
  big-endian? : any/c = (system-big-endian?)
  dest-bstr : (and/c bytes? (not/c immutable?))
            = (make-bytes size-n)
  start : exact-nonnegative-integer? = 0
procedure
(floating-point-bytes->real  bstr            
                            [big-endian?     
                             start           
                             end])       -> flonum?
  bstr : bytes?
  big-endian? : any/c = (system-big-endian?)
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(real->floating-point-bytes  x               
                             size-n          
                            [big-endian?     
                             dest-bstr       
                             start])     -> bytes?
  x : real?
  size-n : (or/c 4 8)
  big-endian? : any/c = (system-big-endian?)
  dest-bstr : (and/c bytes? (not/c immutable?))
            = (make-bytes size-n)
  start : exact-nonnegative-integer? = 0
procedure
(system-big-endian?) -> boolean?
value
pi : flonum?
value
pi.f : (or/c single-flonum? flonum?)
procedure
(degrees->radians x) -> real?
  x : real?
procedure
(radians->degrees x) -> real?
  x : real?
procedure
(sqr z) -> number?
  z : number?
procedure
(sgn x) -> (or/c (=/c -1) (=/c 0) (=/c 1) +nan.0 +nan.f)
  x : real?
procedure
(conjugate z) -> number?
  z : number?
procedure
(sinh z) -> number?
  z : number?
procedure
(cosh z) -> number?
  z : number?
procedure
(tanh z) -> number?
  z : number?
procedure
(exact-round x) -> exact-integer?
  x : rational?
procedure
(exact-floor x) -> exact-integer?
  x : rational?
procedure
(exact-ceiling x) -> exact-integer?
  x : rational?
procedure
(exact-truncate x) -> exact-integer?
  x : rational?
procedure
(order-of-magnitude r) -> (and/c exact? integer?)
  r : (and/c real? positive?)
procedure
(nan? x) -> boolean?
  x : real?
procedure
(infinite? x) -> boolean?
  x : real?
procedure
(positive-integer? x) -> boolean?
  x : any/c
procedure
(negative-integer? x) -> boolean?
  x : any/c
procedure
(nonpositive-integer? x) -> boolean?
  x : any/c
procedure
(nonnegative-integer? x) -> boolean?
  x : any/c
procedure
(natural? x) -> boolean?
  x : any/c
procedure
(fl+ a ...) -> flonum?
  a : flonum?
procedure
(fl- a b ...) -> flonum?
  a : flonum?
  b : flonum?
procedure
(fl* a ...) -> flonum?
  a : flonum?
procedure
(fl/ a b ...) -> flonum?
  a : flonum?
  b : flonum?
procedure
(flabs a) -> flonum?
  a : flonum?
procedure
(fl= a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(fl< a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(fl> a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(fl<= a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(fl>= a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(flmin a b ...) -> flonum?
  a : flonum?
  b : flonum?
procedure
(flmax a b ...) -> flonum?
  a : flonum?
  b : flonum?
procedure
(flround a) -> flonum?
  a : flonum?
procedure
(flfloor a) -> flonum?
  a : flonum?
procedure
(flceiling a) -> flonum?
  a : flonum?
procedure
(fltruncate a) -> flonum?
  a : flonum?
procedure
(flsingle a) -> flonum?
  a : flonum?
procedure
(flsin a) -> flonum?
  a : flonum?
procedure
(flcos a) -> flonum?
  a : flonum?
procedure
(fltan a) -> flonum?
  a : flonum?
procedure
(flasin a) -> flonum?
  a : flonum?
procedure
(flacos a) -> flonum?
  a : flonum?
procedure
(flatan a) -> flonum?
  a : flonum?
procedure
(fllog a) -> flonum?
  a : flonum?
procedure
(flexp a) -> flonum?
  a : flonum?
procedure
(flsqrt a) -> flonum?
  a : flonum?
procedure
(flexpt a b) -> flonum?
  a : flonum?
  b : flonum?
procedure
(->fl a) -> flonum?
  a : exact-integer?
procedure
(fl->exact-integer a) -> exact-integer?
  a : flonum?
procedure
(make-flrectangular a b)
 -> (and/c complex?
           (lambda (c) (flonum? (real-part c)))
           (lambda (c) (flonum? (imag-part c))))
  a : flonum?
  b : flonum?
procedure
(flreal-part a) -> flonum?
  a : (and/c complex?
             (lambda (c) (flonum? (real-part c)))
             (lambda (c) (flonum? (imag-part c))))
procedure
(flimag-part a) -> flonum?
  a : (and/c complex?
             (lambda (c) (flonum? (real-part c)))
             (lambda (c) (flonum? (imag-part c))))
procedure
(flrandom rand-gen) -> (and flonum? (>/c 0) (</c 1))
  rand-gen : pseudo-random-generator?
procedure
(flvector? v) -> boolean?
  v : any/c
procedure
(flvector x ...) -> flvector?
  x : flonum?
procedure
(make-flvector size [x]) -> flvector?
  size : exact-nonnegative-integer?
  x : flonum? = 0.0
procedure
(flvector-length vec) -> exact-nonnegative-integer?
  vec : flvector?
procedure
(flvector-ref vec pos) -> flonum?
  vec : flvector?
  pos : exact-nonnegative-integer?
procedure
(flvector-set! vec pos x) -> flonum?
  vec : flvector?
  pos : exact-nonnegative-integer?
  x : flonum?
procedure
(flvector-copy vec [start end]) -> flvector?
  vec : flvector?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length v)
procedure
(in-flvector vec [start stop step]) -> sequence?
  vec : flvector?
  start : exact-nonnegative-integer? = 0
  stop : (or/c exact-integer? #f) = #f
  step : (and/c exact-integer? (not/c zero?)) = 1
syntax
(for/flvector maybe-length (for-clause ...) body ...)
syntax
(for*/flvector maybe-length (for-clause ...) body ...)
 
maybe-length = 
             | #:length length-expr
             | #:length length-expr #:fill fill-expr
 
  length-expr : exact-nonnegative-integer?
  fill-expr : flonum?
procedure
(shared-flvector x ...) -> flvector?
  x : flonum?
procedure
(make-shared-flvector size [x]) -> flvector?
  size : exact-nonnegative-integer?
  x : flonum? = 0.0
procedure
(fx+ a ...) -> fixnum?
  a : fixnum?
procedure
(fx- a b ...) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fx* a ...) -> fixnum?
  a : fixnum?
procedure
(fxquotient a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fxremainder a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fxmodulo a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fxabs a) -> fixnum?
  a : fixnum?
procedure
(fxand a ...) -> fixnum?
  a : fixnum?
procedure
(fxior a ...) -> fixnum?
  a : fixnum?
procedure
(fxxor a ...) -> fixnum?
  a : fixnum?
procedure
(fxnot a) -> fixnum?
  a : fixnum?
procedure
(fxlshift a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fxrshift a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fxpopcount a) -> fixnum?
  a : (and/c fixnum? (not/c negative?))
procedure
(fxpopcount32 a) -> fixnum?
  a : (and/c fixnum? (integer-in 0 #xFFFFFFFF))
procedure
(fxpopcount16 a) -> fixnum?
  a : (and/c fixnum? (integer-in 0 #xFFFF))
procedure
(fx+/wraparound a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fx-/wraparound a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fx*/wraparound a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fxlshift/wraparound a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fx= a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(fx< a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(fx> a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(fx<= a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(fx>= a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(fxmin a b ...) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fxmax a b ...) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(fx->fl a) -> flonum?
  a : fixnum?
procedure
(fl->fx fl) -> fixnum?
  fl : flonum?
procedure
(fixnum-for-every-system? v) -> boolean?
  v : any/c
procedure
(fxvector? v) -> boolean?
  v : any/c
procedure
(fxvector x ...) -> fxvector?
  x : fixnum?
procedure
(make-fxvector size [x]) -> fxvector?
  size : exact-nonnegative-integer?
  x : fixnum? = 0
procedure
(fxvector-length vec) -> exact-nonnegative-integer?
  vec : fxvector?
procedure
(fxvector-ref vec pos) -> fixnum?
  vec : fxvector?
  pos : exact-nonnegative-integer?
procedure
(fxvector-set! vec pos x) -> fixnum?
  vec : fxvector?
  pos : exact-nonnegative-integer?
  x : fixnum?
procedure
(fxvector-copy vec [start end]) -> fxvector?
  vec : fxvector?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length v)
procedure
(in-fxvector vec [start stop step]) -> sequence?
  vec : fxvector?
  start : exact-nonnegative-integer? = 0
  stop : (or/c exact-integer? #f) = #f
  step : (and/c exact-integer? (not/c zero?)) = 1
syntax
(for/fxvector maybe-length (for-clause ...) body ...)
syntax
(for*/fxvector maybe-length (for-clause ...) body ...)
 
maybe-length = 
             | #:length length-expr
             | #:length length-expr #:fill fill-expr
 
  length-expr : exact-nonnegative-integer?
  fill-expr : fixnum?
procedure
(shared-fxvector x ...) -> fxvector?
  x : fixnum?
procedure
(make-shared-fxvector size [x]) -> fxvector?
  size : exact-nonnegative-integer?
  x : fixnum? = 0
procedure
(most-positive-fixnum) -> fixnum?
procedure
(most-negative-fixnum) -> fixnum?
procedure
(extflonum? v) -> boolean?
  v : any/c
procedure
(extflonum-available?) -> boolean?
procedure
(extfl+ a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(extfl- a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(extfl* a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(extfl/ a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(extflabs a) -> extflonum?
  a : extflonum?
procedure
(extfl= a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(extfl< a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(extfl> a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(extfl<= a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(extfl>= a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(extflmin a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(extflmax a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(extflround a) -> extflonum?
  a : extflonum?
procedure
(extflfloor a) -> extflonum?
  a : extflonum?
procedure
(extflceiling a) -> extflonum?
  a : extflonum?
procedure
(extfltruncate a) -> extflonum?
  a : extflonum?
procedure
(extflsin a) -> extflonum?
  a : extflonum?
procedure
(extflcos a) -> extflonum?
  a : extflonum?
procedure
(extfltan a) -> extflonum?
  a : extflonum?
procedure
(extflasin a) -> extflonum?
  a : extflonum?
procedure
(extflacos a) -> extflonum?
  a : extflonum?
procedure
(extflatan a) -> extflonum?
  a : extflonum?
procedure
(extfllog a) -> extflonum?
  a : extflonum?
procedure
(extflexp a) -> extflonum?
  a : extflonum?
procedure
(extflsqrt a) -> extflonum?
  a : extflonum?
procedure
(extflexpt a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(->extfl a) -> extflonum?
  a : exact-integer?
procedure
(extfl->exact-integer a) -> exact-integer?
  a : extflonum?
procedure
(real->extfl a) -> extflonum?
  a : real?
procedure
(extfl->exact a) -> (and/c real? exact?)
  a : extflonum?
procedure
(extfl->fx a) -> fixnum?
  a : extflonum?
procedure
(fx->extfl a) -> extflonum?
  a : fixnum?
procedure
(extfl->inexact a) -> flonum?
  a : extflonum?
value
pi.t : extflonum?
procedure
(extflvector? v) -> boolean?
  v : any/c
procedure
(extflvector x ...) -> extflvector?
  x : extflonum?
procedure
(make-extflvector size [x]) -> extflvector?
  size : exact-nonnegative-integer?
  x : extflonum? = 0.0t0
procedure
(extflvector-length vec) -> exact-nonnegative-integer?
  vec : extflvector?
procedure
(extflvector-ref vec pos) -> extflonum?
  vec : extflvector?
  pos : exact-nonnegative-integer?
procedure
(extflvector-set! vec pos x) -> extflonum?
  vec : extflvector?
  pos : exact-nonnegative-integer?
  x : extflonum?
procedure
(extflvector-copy vec [start end]) -> extflvector?
  vec : extflvector?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length v)
procedure
(in-extflvector vec [start stop step]) -> sequence?
  vec : extflvector?
  start : exact-nonnegative-integer? = 0
  stop : (or/c exact-integer? #f) = #f
  step : (and/c exact-integer? (not/c zero?)) = 1
syntax
(for/extflvector maybe-length (for-clause ...) body ...)
syntax
(for*/extflvector maybe-length (for-clause ...) body ...)
 
maybe-length = 
             | #:length length-expr
             | #:length length-expr #:fill fill-expr
 
  length-expr : exact-nonnegative-integer?
  fill-expr : extflonum?
procedure
(shared-extflvector x ...) -> extflvector?
  x : extflonum?
procedure
(make-shared-extflvector size [x]) -> extflvector?
  size : exact-nonnegative-integer?
  x : extflonum? = 0.0t0
procedure
(floating-point-bytes->extfl  bstr            
                             [big-endian?     
                              start           
                              end])       -> extflonum?
  bstr : bytes?
  big-endian? : any/c = (system-big-endian?)
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(extfl->floating-point-bytes  x               
                             [big-endian?     
                              dest-bstr       
                              start])     -> bytes?
  x : extflonum?
  big-endian? : any/c = (system-big-endian?)
  dest-bstr : (and/c bytes? (not/c immutable?))
            = (make-bytes 10)
  start : exact-nonnegative-integer? = 0
procedure
(string? v) -> boolean?
  v : any/c
procedure
(make-string k [char]) -> string?
  k : exact-nonnegative-integer?
  char : char? = #\nul
procedure
(string char ...) -> string?
  char : char?
procedure
(string->immutable-string str) -> (and/c string? immutable?)
  str : string?
procedure
(string-length str) -> exact-nonnegative-integer?
  str : string?
procedure
(string-ref str k) -> char?
  str : string?
  k : exact-nonnegative-integer?
procedure
(string-set! str k char) -> void?
  str : (and/c string? (not/c immutable?))
  k : exact-nonnegative-integer?
  char : char?
procedure
(substring str start [end]) -> string?
  str : string?
  start : exact-nonnegative-integer?
  end : exact-nonnegative-integer? = (string-length str)
procedure
(string-copy str) -> string?
  str : string?
procedure
(string-copy!  dest           
               dest-start     
               src            
              [src-start      
               src-end])  -> void?
  dest : (and/c string? (not/c immutable?))
  dest-start : exact-nonnegative-integer?
  src : string?
  src-start : exact-nonnegative-integer? = 0
  src-end : exact-nonnegative-integer? = (string-length src)
procedure
(string-fill! dest char) -> void?
  dest : (and/c string? (not/c immutable?))
  char : char?
procedure
(string-append str ...) -> string?
  str : string?
procedure
(string-append-immutable str ...) -> (and/c string? immutable?)
  str : string?
procedure
(string->list str) -> (listof char?)
  str : string?
procedure
(list->string lst) -> string?
  lst : (listof char?)
procedure
(build-string n proc) -> string?
  n : exact-nonnegative-integer?
  proc : (exact-nonnegative-integer? . -> . char?)
procedure
(string=? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string<? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string<=? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string>? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string>=? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-ci=? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-ci<? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-ci<=? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-ci>? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-ci>=? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-upcase str) -> string?
  str : string?
procedure
(string-downcase string) -> string?
  string : string?
procedure
(string-titlecase string) -> string?
  string : string?
procedure
(string-foldcase string) -> string?
  string : string?
procedure
(string-normalize-nfd string) -> string?
  string : string?
procedure
(string-normalize-nfkd string) -> string?
  string : string?
procedure
(string-normalize-nfc string) -> string?
  string : string?
procedure
(string-normalize-nfkc string) -> string?
  string : string?
procedure
(string-locale=? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-locale<? str1 str2 ...+) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-locale>? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-locale-ci=? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-locale-ci<? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-locale-ci>? str1 str2 ...) -> boolean?
  str1 : string?
  str2 : string?
procedure
(string-locale-upcase string) -> string?
  string : string?
procedure
(string-locale-downcase string) -> string?
  string : string?
procedure
(string-grapheme-span str start [end]) -> exact-nonnegative-integer?
  str : string?
  start : exact-nonnegative-integer?
  end : exact-nonnegative-integer? = (string-length str)
procedure
(string-grapheme-count str start [end])
 -> exact-nonnegative-integer?
  str : string?
  start : exact-nonnegative-integer?
  end : exact-nonnegative-integer? = (string-length str)
procedure
(string-append* str ... strs) -> string?
  str : string?
  strs : (listof string?)
procedure
(string-join  strs                            
             [sep                             
              #:before-first before-first     
              #:before-last before-last       
              #:after-last after-last])   -> string?
  strs : (listof string?)
  sep : string? = " "
  before-first : string? = ""
  before-last : string? = sep
  after-last : string? = ""
procedure
(string-normalize-spaces  str                     
                         [sep                     
                          space                   
                          #:trim? trim?           
                          #:repeat? repeat?]) -> string?
  str : string?
  sep : (or/c string? regexp?) = #px"\\s+"
  space : string? = " "
  trim? : any/c = #t
  repeat? : any/c = #f
procedure
(string-replace str from to [#:all? all?]) -> string?
  str : string?
  from : (or/c string? regexp?)
  to : string?
  all? : any/c = #t
procedure
(string-split  str                     
              [sep                     
               #:trim? trim?           
               #:repeat? repeat?]) -> (listof string?)
  str : string?
  sep : (or/c string? regexp?) = #px"\\s+"
  trim? : any/c = #t
  repeat? : any/c = #f
procedure
(string-trim  str                     
             [sep                     
              #:left? left?           
              #:right? right?         
              #:repeat? repeat?]) -> string?
  str : string?
  sep : (or/c string? regexp?) = #px"\\s+"
  left? : any/c = #t
  right? : any/c = #t
  repeat? : any/c = #f
procedure
(non-empty-string? x) -> boolean?
  x : any/c
procedure
(string-contains? s contained) -> boolean?
  s : string?
  contained : string?
procedure
(string-prefix? s prefix) -> boolean?
  s : string?
  prefix : string?
procedure
(string-suffix? s suffix) -> boolean?
  s : string?
  suffix : string?
procedure
(~a  v                                         
     ...                                       
    [#:separator separator                     
     #:width width                             
     #:max-width max-width                     
     #:min-width min-width                     
     #:limit-marker limit-marker               
     #:limit-prefix? limit-prefix?             
     #:align align                             
     #:pad-string pad-string                   
     #:left-pad-string left-pad-string         
     #:right-pad-string right-pad-string]) -> string?
  v : any/c
  separator : string? = ""
  width : (or/c exact-nonnegative-integer? #f) = #f
  max-width : (or/c exact-nonnegative-integer? +inf.0)
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0)
  limit-marker : string? = ""
  limit-prefix? : boolean? = #f
  align : (or/c 'left 'center 'right) = 'left
  pad-string : non-empty-string? = " "
  left-pad-string : non-empty-string? = pad-string
  right-pad-string : non-empty-string? = pad-string
procedure
(~v  v                                         
     ...                                       
    [#:separator separator                     
     #:width width                             
     #:max-width max-width                     
     #:min-width min-width                     
     #:limit-marker limit-marker               
     #:limit-prefix? limit-prefix?             
     #:align align                             
     #:pad-string pad-string                   
     #:left-pad-string left-pad-string         
     #:right-pad-string right-pad-string]) -> string?
  v : any/c
  separator : string? = " "
  width : (or/c exact-nonnegative-integer? #f) = #f
  max-width : (or/c exact-nonnegative-integer? +inf.0)
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0)
  limit-marker : string? = "..."
  limit-prefix? : boolean? = #f
  align : (or/c 'left 'center 'right) = 'left
  pad-string : non-empty-string? = " "
  left-pad-string : non-empty-string? = pad-string
  right-pad-string : non-empty-string? = pad-string
procedure
(~s  v                                         
     ...                                       
    [#:separator separator                     
     #:width width                             
     #:max-width max-width                     
     #:min-width min-width                     
     #:limit-marker limit-marker               
     #:limit-prefix? limit-prefix?             
     #:align align                             
     #:pad-string pad-string                   
     #:left-pad-string left-pad-string         
     #:right-pad-string right-pad-string]) -> string?
  v : any/c
  separator : string? = " "
  width : (or/c exact-nonnegative-integer? #f) = #f
  max-width : (or/c exact-nonnegative-integer? +inf.0)
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0)
  limit-marker : string? = "..."
  limit-prefix? : boolean? = #f
  align : (or/c 'left 'center 'right) = 'left
  pad-string : non-empty-string? = " "
  left-pad-string : non-empty-string? = pad-string
  right-pad-string : non-empty-string? = pad-string
procedure
(~e  v                                         
     ...                                       
    [#:separator separator                     
     #:width width                             
     #:max-width max-width                     
     #:min-width min-width                     
     #:limit-marker limit-marker               
     #:limit-prefix? limit-prefix?             
     #:align align                             
     #:pad-string pad-string                   
     #:left-pad-string left-pad-string         
     #:right-pad-string right-pad-string]) -> string?
  v : any/c
  separator : string? = " "
  width : (or/c exact-nonnegative-integer? #f) = #f
  max-width : (or/c exact-nonnegative-integer? +inf.0)
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0)
  limit-marker : string? = "..."
  limit-prefix? : boolean? = #f
  align : (or/c 'left 'center 'right) = 'left
  pad-string : non-empty-string? = " "
  left-pad-string : non-empty-string? = pad-string
  right-pad-string : non-empty-string? = pad-string
procedure
(~r  x                                     
    [#:sign sign                           
     #:base base                           
     #:precision precision                 
     #:notation notation                   
     #:format-exponent format-exponent     
     #:min-width min-width                 
     #:pad-string pad-string               
     #:groups groups                       
     #:group-sep group-sep                 
     #:decimal-sep decimal-sep])       -> string?
  x : rational?
  sign : (or/c #f '+ '++ 'parens
               (let ([ind (or/c string? (list/c string? string?))])
                 (list/c ind ind ind)))
       = #f
  base : (or/c (integer-in 2 36) (list/c 'up (integer-in 2 36)))
       = 10
  precision : (or/c exact-nonnegative-integer?              = 6
                    (list/c '= exact-nonnegative-integer?))
  notation : (or/c 'positional 'exponential
                   (-> rational? (or/c 'positional 'exponential)))
           = 'positional
  format-exponent : (or/c #f string? (-> exact-integer? string?))
                  = #f
  min-width : exact-positive-integer? = 1
  pad-string : non-empty-string? = " "
  groups : (non-empty-listof exact-positive-integer?) = '(3)
  group-sep : string? = ""
  decimal-sep : string? = "."
procedure
(~.a  v                                         
      ...                                       
     [#:separator separator                     
      #:width width                             
      #:max-width max-width                     
      #:min-width min-width                     
      #:limit-marker limit-marker               
      #:limit-prefix? limit-prefix?             
      #:align align                             
      #:pad-string pad-string                   
      #:left-pad-string left-pad-string         
      #:right-pad-string right-pad-string]) -> string?
  v : any/c
  separator : string? = ""
  width : (or/c exact-nonnegative-integer? #f) = #f
  max-width : (or/c exact-nonnegative-integer? +inf.0)
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0)
  limit-marker : string? = ""
  limit-prefix? : boolean? = #f
  align : (or/c 'left 'center 'right) = 'left
  pad-string : non-empty-string? = " "
  left-pad-string : non-empty-string? = pad-string
  right-pad-string : non-empty-string? = pad-string
procedure
(~.v  v                                         
      ...                                       
     [#:separator separator                     
      #:width width                             
      #:max-width max-width                     
      #:min-width min-width                     
      #:limit-marker limit-marker               
      #:limit-prefix? limit-prefix?             
      #:align align                             
      #:pad-string pad-string                   
      #:left-pad-string left-pad-string         
      #:right-pad-string right-pad-string]) -> string?
  v : any/c
  separator : string? = " "
  width : (or/c exact-nonnegative-integer? #f) = #f
  max-width : (or/c exact-nonnegative-integer? +inf.0)
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0)
  limit-marker : string? = "..."
  limit-prefix? : boolean? = #f
  align : (or/c 'left 'center 'right) = 'left
  pad-string : non-empty-string? = " "
  left-pad-string : non-empty-string? = pad-string
  right-pad-string : non-empty-string? = pad-string
procedure
(~.s  v                                         
      ...                                       
     [#:separator separator                     
      #:width width                             
      #:max-width max-width                     
      #:min-width min-width                     
      #:limit-marker limit-marker               
      #:limit-prefix? limit-prefix?             
      #:align align                             
      #:pad-string pad-string                   
      #:left-pad-string left-pad-string         
      #:right-pad-string right-pad-string]) -> string?
  v : any/c
  separator : string? = " "
  width : (or/c exact-nonnegative-integer? #f) = #f
  max-width : (or/c exact-nonnegative-integer? +inf.0)
            = (or width +inf.0)
  min-width : exact-nonnegative-integer? = (or width 0)
  limit-marker : string? = "..."
  limit-prefix? : boolean? = #f
  align : (or/c 'left 'center 'right) = 'left
  pad-string : non-empty-string? = " "
  left-pad-string : non-empty-string? = pad-string
  right-pad-string : non-empty-string? = pad-string
procedure
(bytes? v) -> boolean?
  v : any/c
procedure
(make-bytes k [b]) -> bytes?
  k : exact-nonnegative-integer?
  b : byte? = 0
procedure
(bytes b ...) -> bytes?
  b : byte?
procedure
(bytes->immutable-bytes bstr) -> (and/c bytes? immutable?)
  bstr : bytes?
procedure
(byte? v) -> boolean?
  v : any/c
procedure
(bytes-length bstr) -> exact-nonnegative-integer?
  bstr : bytes?
procedure
(bytes-ref bstr k) -> byte?
  bstr : bytes?
  k : exact-nonnegative-integer?
procedure
(bytes-set! bstr k b) -> void?
  bstr : (and/c bytes? (not/c immutable?))
  k : exact-nonnegative-integer?
  b : byte?
procedure
(subbytes bstr start [end]) -> bytes?
  bstr : bytes?
  start : exact-nonnegative-integer?
  end : exact-nonnegative-integer? = (bytes-length str)
procedure
(bytes-copy bstr) -> bytes?
  bstr : bytes?
procedure
(bytes-copy!  dest           
              dest-start     
              src            
             [src-start      
              src-end])  -> void?
  dest : (and/c bytes? (not/c immutable?))
  dest-start : exact-nonnegative-integer?
  src : bytes?
  src-start : exact-nonnegative-integer? = 0
  src-end : exact-nonnegative-integer? = (bytes-length src)
procedure
(bytes-fill! dest b) -> void?
  dest : (and/c bytes? (not/c immutable?))
  b : byte?
procedure
(bytes-append bstr ...) -> bytes?
  bstr : bytes?
procedure
(bytes->list bstr) -> (listof byte?)
  bstr : bytes?
procedure
(list->bytes lst) -> bytes?
  lst : (listof byte?)
procedure
(make-shared-bytes k [b]) -> bytes?
  k : exact-nonnegative-integer?
  b : byte? = 0
procedure
(shared-bytes b ...) -> bytes?
  b : byte?
procedure
(bytes=? bstr1 bstr2 ...) -> boolean?
  bstr1 : bytes?
  bstr2 : bytes?
procedure
(bytes<? bstr1 bstr2 ...) -> boolean?
  bstr1 : bytes?
  bstr2 : bytes?
procedure
(bytes>? bstr1 bstr2 ...) -> boolean?
  bstr1 : bytes?
  bstr2 : bytes?
procedure
(bytes->string/utf-8 bstr [err-char start end]) -> string?
  bstr : bytes?
  err-char : (or/c #f char?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(bytes->string/locale  bstr         
                      [err-char     
                       start        
                       end])    -> string?
  bstr : bytes?
  err-char : (or/c #f char?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(bytes->string/latin-1  bstr         
                       [err-char     
                        start        
                        end])    -> string?
  bstr : bytes?
  err-char : (or/c #f char?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(string->bytes/utf-8 str [err-byte start end]) -> bytes?
  str : string?
  err-byte : (or/c #f byte?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (string-length str)
procedure
(string->bytes/locale str [err-byte start end]) -> bytes?
  str : string?
  err-byte : (or/c #f byte?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (string-length str)
procedure
(string->bytes/latin-1  str          
                       [err-byte     
                        start        
                        end])    -> bytes?
  str : string?
  err-byte : (or/c #f byte?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (string-length str)
procedure
(string-utf-8-length str [start end]) -> exact-nonnegative-integer?
  str : string?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (string-length str)
procedure
(bytes-utf-8-length bstr [err-char start end])
 -> (or/c exact-nonnegative-integer? #f)
  bstr : bytes?
  err-char : (or/c #f char?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(bytes-utf-8-ref bstr [skip err-char start end]) -> (or/c char? #f)
  bstr : bytes?
  skip : exact-nonnegative-integer? = 0
  err-char : (or/c #f char?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(bytes-utf-8-index  bstr     
                    skip     
                   [err-char 
                    start    
                    end])    
 -> (or/c exact-nonnegative-integer? #f)
  bstr : bytes?
  skip : exact-nonnegative-integer?
  err-char : (or/c #f char?) = #f
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(bytes-open-converter from-name to-name)
 -> (or/c bytes-converter? #f)
  from-name : string?
  to-name : string?
procedure
(bytes-close-converter converter) -> void
  converter : bytes-converter?
procedure
(bytes-convert  converter      
                src-bstr       
               [src-start-pos  
                src-end-pos    
                dest-bstr      
                dest-start-pos 
                dest-end-pos]) 
 -> (or/c bytes? exact-nonnegative-integer?)
    exact-nonnegative-integer?
    (or/c 'complete 'continues 'aborts 'error)
  converter : bytes-converter?
  src-bstr : bytes?
  src-start-pos : exact-nonnegative-integer? = 0
  src-end-pos : exact-nonnegative-integer?
              = (bytes-length src-bstr)
  dest-bstr : (or/c bytes? #f) = #f
  dest-start-pos : exact-nonnegative-integer? = 0
  dest-end-pos : (or/c exact-nonnegative-integer? #f)
               = (and dest-bstr
                      (bytes-length dest-bstr))
procedure
(bytes-convert-end  converter      
                   [dest-bstr      
                    dest-start-pos 
                    dest-end-pos]) 
 -> (or/c bytes? exact-nonnegative-integer?)
    (or/c 'complete 'continues)
  converter : bytes-converter?
  dest-bstr : (or/c bytes? #f) = #f
  dest-start-pos : exact-nonnegative-integer? = 0
  dest-end-pos : (or/c exact-nonnegative-integer? #f)
               = (and dest-bstr
                      (bytes-length dest-bstr))
procedure
(bytes-converter? v) -> boolean?
  v : any/c
procedure
(locale-string-encoding) -> any
procedure
(bytes-append* str ... strs) -> bytes?
  str : bytes?
  strs : (listof bytes?)
procedure
(bytes-join strs sep) -> bytes?
  strs : (listof bytes?)
  sep : bytes?
procedure
(char? v) -> boolean?
  v : any/c
procedure
(char->integer char) -> exact-integer?
  char : char?
procedure
(integer->char k) -> char?
  k : (and/c exact-integer?
             (or/c (integer-in 0 #xD7FF)
                   (integer-in #xE000 #x10FFFF)))
procedure
(char-utf-8-length char) -> (integer-in 1 6)
  char : char?
procedure
(char=? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char<? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char<=? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char>? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char>=? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char-ci=? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char-ci<? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char-ci<=? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char-ci>? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char-ci>=? char1 char2 ...) -> boolean?
  char1 : char?
  char2 : char?
procedure
(char-alphabetic? char) -> boolean?
  char : char?
procedure
(char-lower-case? char) -> boolean?
  char : char?
procedure
(char-upper-case? char) -> boolean?
  char : char?
procedure
(char-title-case? char) -> boolean?
  char : char?
procedure
(char-numeric? char) -> boolean?
  char : char?
procedure
(char-symbolic? char) -> boolean?
  char : char?
procedure
(char-punctuation? char) -> boolean?
  char : char?
procedure
(char-graphic? char) -> boolean?
  char : char?
procedure
(char-whitespace? char) -> boolean?
  char : char?
procedure
(char-blank? char) -> boolean?
  char : char?
procedure
(char-iso-control? char) -> boolean?
  char : char?
procedure
(char-extended-pictographic? char) -> boolean?
  char : char?
procedure
(char-general-category char) -> symbol?
  char : char?
procedure
(char-grapheme-break-property char) -> ?
  char : char?
procedure
(make-known-char-range-list)
 -> (listof (list/c exact-nonnegative-integer?
                    exact-nonnegative-integer?
                    boolean?))
procedure
(char-upcase char) -> char?
  char : char?
procedure
(char-downcase char) -> char?
  char : char?
procedure
(char-titlecase char) -> char?
  char : char?
procedure
(char-foldcase char) -> char?
  char : char?
procedure
(char-grapheme-step char state) -> boolean? fixnum?
  char : char?
  state : fixnum?
procedure
(symbol? v) -> boolean?
  v : any/c
procedure
(symbol-interned? sym) -> boolean?
  sym : symbol?
procedure
(symbol-unreadable? sym) -> boolean?
  sym : symbol?
procedure
(symbol->string sym) -> string?
  sym : symbol?
procedure
(string->symbol str) -> symbol?
  str : string?
procedure
(string->uninterned-symbol str) -> symbol?
  str : string?
procedure
(string->unreadable-symbol str) -> symbol?
  str : string?
procedure
(gensym [base]) -> symbol?
  base : (or/c string? symbol?) = "g"
procedure
(symbol<? a-sym b-sym ...) -> boolean?
  a-sym : symbol?
  b-sym : symbol?
procedure
(symbol->immutable-string sym) -> (and/c string? immutable?)
  sym : symbol?
procedure
(regexp? v) -> boolean?
  v : any/c
procedure
(pregexp? v) -> boolean?
  v : any/c
procedure
(byte-regexp? v) -> boolean?
  v : any/c
procedure
(byte-pregexp? v) -> boolean?
  v : any/c
procedure
(regexp str) -> regexp?
  str : string?
(regexp str handler) -> any
  str : string?
  handler : (or/c #f (string? -> any))
procedure
(pregexp str) -> pregexp?
  str : string?
(pregexp str handler) -> any
  str : string?
  handler : (or/c #f (string? -> any))
procedure
(byte-regexp bstr) -> byte-regexp?
  bstr : bytes?
(byte-regexp bstr handler) -> any
  bstr : bytes?
  handler : (or/c #f (bytes? -> any))
procedure
(byte-pregexp bstr) -> byte-pregexp?
  bstr : bytes?
(byte-pregexp bstr handler) -> any
  bstr : bytes?
  handler : (or/c #f (bytes? -> any))
procedure
(regexp-quote str [case-sensitive?]) -> string?
  str : string?
  case-sensitive? : any/c = #t
(regexp-quote bstr [case-sensitive?]) -> bytes?
  bstr : bytes?
  case-sensitive? : any/c = #t
procedure
(regexp-max-lookbehind pattern) -> exact-nonnegative-integer?
  pattern : (or/c regexp? byte-regexp?)
procedure
(regexp-match  pattern        
               input          
              [start-pos      
               end-pos        
               output-port    
               input-prefix]) 
 -> (if (and (or (string? pattern) (regexp? pattern))
             (or (string? input) (path? input)))
        (or/c #f (cons/c string? (listof (or/c string? #f))))
        (or/c #f (cons/c bytes?  (listof (or/c bytes?  #f)))))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? path? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  output-port : (or/c output-port? #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-match*  pattern                     
                input                       
               [start-pos                   
                end-pos                     
                input-prefix                
                #:match-select match-select 
                #:gap-select? gap-select])  
 -> (if (and (or (string? pattern) (regexp? pattern))
             (or (string? input) (path? input)))
        (listof (or/c string? (listof (or/c #f string?))))
        (listof (or/c bytes? (listof (or/c #f bytes?)))))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? path? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  input-prefix : bytes? = #""
  match-select : (or/c (list? . -> . (or/c any/c list?)) = car
                       #f)
  gap-select : any/c = #f
procedure
(regexp-try-match  pattern        
                   input          
                  [start-pos      
                   end-pos        
                   output-port    
                   input-prefix]) 
 -> (or/c #f (cons/c bytes? (listof (or/c bytes? #f))))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : input-port?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  output-port : (or/c output-port? #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-match-positions  pattern        
                         input          
                        [start-pos      
                         end-pos        
                         output-port    
                         input-prefix]) 
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-integer?
                                        exact-integer?)
                                #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? path? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  output-port : (or/c output-port? #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-match-positions*  pattern                       
                          input                         
                         [start-pos                     
                          end-pos                       
                          input-prefix                  
                          #:match-select match-select]) 
 -> (or/c (listof (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?))
          (listof (listof (or/c #f (cons/c exact-nonnegative-integer?
                                           exact-nonnegative-integer?)))))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? path? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  input-prefix : bytes? = #""
  match-select : (list? . -> . (or/c any/c list?)) = car
procedure
(regexp-match?  pattern            
                input              
               [start-pos          
                end-pos            
                output-port        
                input-prefix]) -> boolean?
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? path? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  output-port : (or/c output-port? #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-match-exact? pattern input) -> boolean?
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? path?)
procedure
(regexp-match-peek  pattern        
                    input          
                   [start-pos      
                    end-pos        
                    progress       
                    input-prefix]) 
 -> (or/c (cons/c bytes? (listof (or/c bytes? #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : input-port?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  progress : (or/c evt #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-match-peek-positions  pattern        
                              input          
                             [start-pos      
                              end-pos        
                              progress       
                              input-prefix]) 
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : input-port?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  progress : (or/c evt #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-match-peek-immediate  pattern        
                              input          
                             [start-pos      
                              end-pos        
                              progress       
                              input-prefix]) 
 -> (or/c (cons/c bytes? (listof (or/c bytes? #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : input-port?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  progress : (or/c evt #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-match-peek-positions-immediate  pattern        
                                        input          
                                       [start-pos      
                                        end-pos        
                                        progress       
                                        input-prefix]) 
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : input-port?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  progress : (or/c evt #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-match-peek-positions*  pattern                       
                               input                         
                              [start-pos                     
                               end-pos                       
                               input-prefix                  
                               #:match-select match-select]) 
 -> (or/c (listof (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?))
          (listof (listof (or/c #f (cons/c exact-nonnegative-integer?
                                           exact-nonnegative-integer?)))))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : input-port?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  input-prefix : bytes? = #""
  match-select : (list? . -> . (or/c any/c list?)) = car
procedure
(regexp-match/end  pattern      
                   input        
                  [start-pos    
                   end-pos      
                   output-port  
                   input-prefix 
                   count])      
 -> (if (and (or (string? pattern) (regexp? pattern))
             (or/c (string? input) (path? input)))
        (or/c #f (cons/c string? (listof (or/c string? #f))))
        (or/c #f (cons/c bytes?  (listof (or/c bytes?  #f)))))
    (or/c #f bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? path? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  output-port : (or/c output-port? #f) = #f
  input-prefix : bytes? = #""
  count : exact-nonnegative-integer? = 1
procedure
(regexp-match-positions/end  pattern      
                             input        
                            [start-pos    
                             end-pos      
                             input-prefix 
                             count])      
 -> (listof (cons/c exact-nonnegative-integer?
                    exact-nonnegative-integer?))
    (or/c #f bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? path? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  input-prefix : bytes? = #""
  count : exact-nonnegative-integer? = 1
procedure
(regexp-match-peek-positions/end  pattern      
                                  input        
                                 [start-pos    
                                  end-pos      
                                  progress     
                                  input-prefix 
                                  count])      
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
    (or/c #f bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : input-port?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  progress : (or/c evt #f) = #f
  input-prefix : bytes? = #""
  count : exact-nonnegative-integer? = 1
procedure
(regexp-match-peek-positions-immediate/end  pattern      
                                            input        
                                           [start-pos    
                                            end-pos      
                                            progress     
                                            input-prefix 
                                            count])      
 -> (or/c (cons/c (cons/c exact-nonnegative-integer?
                          exact-nonnegative-integer?)
                  (listof (or/c (cons/c exact-nonnegative-integer?
                                        exact-nonnegative-integer?)
                                #f)))
          #f)
    (or/c #f bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : input-port?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  progress : (or/c evt #f) = #f
  input-prefix : bytes? = #""
  count : exact-nonnegative-integer? = 1
procedure
(regexp-split  pattern        
               input          
              [start-pos      
               end-pos        
               input-prefix]) 
 -> (if (and (or (string? pattern) (regexp? pattern))
             (string? input))
        (cons/c string? (listof string?))
        (cons/c bytes? (listof bytes?)))
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes? input-port?)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-replace  pattern        
                 input          
                 insert         
                [input-prefix]) 
 -> (if (and (or (string? pattern) (regexp? pattern))
             (string? input))
        string?
        bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes?)
  insert : (or/c string? bytes?
                 ((string?) () #:rest (listof string?) . ->* . string?)
                 ((bytes?) () #:rest (listof bytes?) . ->* . bytes?))
  input-prefix : bytes? = #""
procedure
(regexp-replace*  pattern            
                  input              
                  insert             
                 [start-pos          
                  end-pos            
                  input-prefix]) -> (or/c string? bytes?)
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  input : (or/c string? bytes?)
  insert : (or/c string? bytes?
                 ((string?) () #:rest (listof string?) . ->* . string?)
                 ((bytes?) () #:rest (listof bytes?) . ->* . bytes?))
  start-pos : exact-nonnegative-integer? = 0
  end-pos : (or/c exact-nonnegative-integer? #f) = #f
  input-prefix : bytes? = #""
procedure
(regexp-replaces input replacements) -> (or/c string? bytes?)
  input : (or/c string? bytes?)
  replacements : (listof
                  (list/c (or/c string? bytes? regexp? byte-regexp?)
                          (or/c string? bytes?
                              ((string?) () #:rest (listof string?) . ->* . string?)
                              ((bytes?) () #:rest (listof bytes?) . ->* . bytes?))))
procedure
(regexp-replace-quote str) -> string?
  str : string?
(regexp-replace-quote bstr) -> bytes?
  bstr : bytes?
procedure
(keyword? v) -> boolean?
  v : any/c
procedure
(keyword->string keyword) -> string?
  keyword : keyword?
procedure
(string->keyword str) -> keyword?
  str : string?
procedure
(keyword<? a-keyword b-keyword ...) -> boolean?
  a-keyword : keyword?
  b-keyword : keyword?
procedure
(keyword->immutable-string sym) -> (and/c string? immutable?)
  sym : keyword?
procedure
(pair? v) -> boolean?
  v : any/c
procedure
(null? v) -> boolean?
  v : any/c
procedure
(cons a d) -> pair?
  a : any/c
  d : any/c
procedure
(car p) -> any/c
  p : pair?
procedure
(cdr p) -> any/c
  p : pair?
value
null : null?
procedure
(list? v) -> boolean?
  v : any/c
procedure
(list v ...) -> list?
  v : any/c
procedure
(list* v ... tail) -> any/c
  v : any/c
  tail : any/c
procedure
(build-list n proc) -> list?
  n : exact-nonnegative-integer?
  proc : (exact-nonnegative-integer? . -> . any)
procedure
(length lst) -> exact-nonnegative-integer?
  lst : list?
procedure
(list-ref lst pos) -> any/c
  lst : pair?
  pos : exact-nonnegative-integer?
procedure
(list-tail lst pos) -> any/c
  lst : any/c
  pos : exact-nonnegative-integer?
procedure
(append lst ...) -> list?
  lst : list?
(append lst ... v) -> any/c
  lst : list?
  v : any/c
procedure
(reverse lst) -> list?
  lst : list?
procedure
(map proc lst ...+) -> list?
  proc : procedure?
  lst : list?
procedure
(andmap proc lst ...+) -> any
  proc : procedure?
  lst : list?
procedure
(ormap proc lst ...+) -> any
  proc : procedure?
  lst : list?
procedure
(for-each proc lst ...+) -> void?
  proc : procedure?
  lst : list?
procedure
(foldl proc init lst ...+) -> any/c
  proc : procedure?
  init : any/c
  lst : list?
procedure
(foldr proc init lst ...+) -> any/c
  proc : procedure?
  init : any/c
  lst : list?
procedure
(filter pred lst) -> list?
  pred : procedure?
  lst : list?
procedure
(remove v lst [proc]) -> list?
  v : any/c
  lst : list?
  proc : procedure? = equal?
procedure
(remq v lst) -> list?
  v : any/c
  lst : list?
procedure
(remv v lst) -> list?
  v : any/c
  lst : list?
procedure
(remw v lst) -> list?
  v : any/c
  lst : list?
procedure
(remove* v-lst lst [proc]) -> list?
  v-lst : list?
  lst : list?
  proc : procedure? = equal?
procedure
(remq* v-lst lst) -> list?
  v-lst : list?
  lst : list?
procedure
(remv* v-lst lst) -> list?
  v-lst : list?
  lst : list?
procedure
(remw* v-lst lst) -> list?
  v-lst : list?
  lst : list?
procedure
(sort  lst                             
       less-than?                      
      [#:key extract-key               
       #:cache-keys? cache-keys?]) -> list?
  lst : list?
  less-than? : (any/c any/c . -> . any/c)
  extract-key : (any/c . -> . any/c) = (lambda (x) x)
  cache-keys? : boolean? = #f
procedure
(member v lst [is-equal?]) -> (or/c #f list? any/c)
  v : any/c
  lst : (or/c list? any/c)
  is-equal? : (any/c any/c -> any/c) = equal?
procedure
(memw v lst) -> (or/c #f list? any/c)
  v : any/c
  lst : (or/c list? any/c)
procedure
(memv v lst) -> (or/c #f list? any/c)
  v : any/c
  lst : (or/c list? any/c)
procedure
(memq v lst) -> (or/c #f list? any/c)
  v : any/c
  lst : (or/c list? any/c)
procedure
(memf proc lst) -> (or/c #f list? any/c)
  proc : procedure?
  lst : (or/c list? any/c)
procedure
(findf proc lst) -> any/c
  proc : procedure?
  lst : list?
procedure
(assoc v lst [is-equal?]) -> (or/c pair? #f)
  v : any/c
  lst : (or/c (listof pair?) any/c)
  is-equal? : (any/c any/c -> any/c) = equal?
procedure
(assw v lst) -> (or/c pair? #f)
  v : any/c
  lst : (or/c (listof pair?) any/c)
procedure
(assv v lst) -> (or/c pair? #f)
  v : any/c
  lst : (or/c (listof pair?) any/c)
procedure
(assq v lst) -> (or/c pair? #f)
  v : any/c
  lst : (or/c (listof pair?) any/c)
procedure
(assf proc lst) -> (or/c pair? #f)
  proc : procedure?
  lst : (or/c (listof pair?) any/c)
procedure
(caar v) -> any/c
  v : (cons/c pair? any/c)
procedure
(cadr v) -> any/c
  v : (cons/c any/c pair?)
procedure
(cdar v) -> any/c
  v : (cons/c pair? any/c)
procedure
(cddr v) -> any/c
  v : (cons/c any/c pair?)
procedure
(caaar v) -> any/c
  v : (cons/c (cons/c pair? any/c) any/c)
procedure
(caadr v) -> any/c
  v : (cons/c any/c (cons/c pair? any/c))
procedure
(cadar v) -> any/c
  v : (cons/c (cons/c any/c pair?) any/c)
procedure
(caddr v) -> any/c
  v : (cons/c any/c (cons/c any/c pair?))
procedure
(cdaar v) -> any/c
  v : (cons/c (cons/c pair? any/c) any/c)
procedure
(cdadr v) -> any/c
  v : (cons/c any/c (cons/c pair? any/c))
procedure
(cddar v) -> any/c
  v : (cons/c (cons/c any/c pair?) any/c)
procedure
(cdddr v) -> any/c
  v : (cons/c any/c (cons/c any/c pair?))
procedure
(caaaar v) -> any/c
  v : (cons/c (cons/c (cons/c pair? any/c) any/c) any/c)
procedure
(caaadr v) -> any/c
  v : (cons/c any/c (cons/c (cons/c pair? any/c) any/c))
procedure
(caadar v) -> any/c
  v : (cons/c (cons/c any/c (cons/c pair? any/c)) any/c)
procedure
(caaddr v) -> any/c
  v : (cons/c any/c (cons/c any/c (cons/c pair? any/c)))
procedure
(cadaar v) -> any/c
  v : (cons/c (cons/c (cons/c any/c pair?) any/c) any/c)
procedure
(cadadr v) -> any/c
  v : (cons/c any/c (cons/c (cons/c any/c pair?) any/c))
procedure
(caddar v) -> any/c
  v : (cons/c (cons/c any/c (cons/c any/c pair?)) any/c)
procedure
(cadddr v) -> any/c
  v : (cons/c any/c (cons/c any/c (cons/c any/c pair?)))
procedure
(cdaaar v) -> any/c
  v : (cons/c (cons/c (cons/c pair? any/c) any/c) any/c)
procedure
(cdaadr v) -> any/c
  v : (cons/c any/c (cons/c (cons/c pair? any/c) any/c))
procedure
(cdadar v) -> any/c
  v : (cons/c (cons/c any/c (cons/c pair? any/c)) any/c)
procedure
(cdaddr v) -> any/c
  v : (cons/c any/c (cons/c any/c (cons/c pair? any/c)))
procedure
(cddaar v) -> any/c
  v : (cons/c (cons/c (cons/c any/c pair?) any/c) any/c)
procedure
(cddadr v) -> any/c
  v : (cons/c any/c (cons/c (cons/c any/c pair?) any/c))
procedure
(cdddar v) -> any/c
  v : (cons/c (cons/c any/c (cons/c any/c pair?)) any/c)
procedure
(cddddr v) -> any/c
  v : (cons/c any/c (cons/c any/c (cons/c any/c pair?)))
value
empty : null?
procedure
(cons? v) -> boolean?
  v : any/c
procedure
(empty? v) -> boolean?
  v : any/c
procedure
(first lst) -> any/c
  lst : list?
procedure
(rest lst) -> list?
  lst : list?
procedure
(second lst) -> any
  lst : list?
procedure
(third lst) -> any
  lst : list?
procedure
(fourth lst) -> any
  lst : list?
procedure
(fifth lst) -> any
  lst : list?
procedure
(sixth lst) -> any
  lst : list?
procedure
(seventh lst) -> any
  lst : list?
procedure
(eighth lst) -> any
  lst : list?
procedure
(ninth lst) -> any
  lst : list?
procedure
(tenth lst) -> any
  lst : list?
procedure
(last lst) -> any
  lst : list?
procedure
(last-pair p) -> pair?
  p : pair?
procedure
(make-list k v) -> list?
  k : exact-nonnegative-integer?
  v : any/c
procedure
(list-update lst pos updater) -> list?
  lst : list?
  pos : (and/c (>=/c 0) (</c (length lst)))
  updater : (-> any/c any/c)
procedure
(list-set lst pos value) -> list?
  lst : list?
  pos : (and/c (>=/c 0) (</c (length lst)))
  value : any/c
procedure
(index-of lst v [is-equal?]) -> (or/c exact-nonnegative-integer? #f)
  lst : list?
  v : any/c
  is-equal? : (any/c any/c . -> . any/c) = equal?
procedure
(index-where lst proc) -> (or/c exact-nonnegative-integer? #f)
  lst : list?
  proc : (any/c . -> . any/c)
procedure
(indexes-of lst v [is-equal?])
 -> (listof exact-nonnegative-integer?)
  lst : list?
  v : any/c
  is-equal? : (any/c any/c . -> . any/c) = equal?
procedure
(indexes-where lst proc) -> (listof exact-nonnegative-integer?)
  lst : list?
  proc : (any/c . -> . any/c)
procedure
(take lst pos) -> list?
  lst : any/c
  pos : exact-nonnegative-integer?
procedure
(drop lst pos) -> any/c
  lst : any/c
  pos : exact-nonnegative-integer?
procedure
(split-at lst pos) -> list? any/c
  lst : any/c
  pos : exact-nonnegative-integer?
procedure
(takef lst pred) -> list?
  lst : any/c
  pred : procedure?
procedure
(dropf lst pred) -> any/c
  lst : any/c
  pred : procedure?
procedure
(splitf-at lst pred) -> list? any/c
  lst : any/c
  pred : procedure?
procedure
(take-right lst pos) -> any/c
  lst : any/c
  pos : exact-nonnegative-integer?
procedure
(drop-right lst pos) -> list?
  lst : any/c
  pos : exact-nonnegative-integer?
procedure
(split-at-right lst pos) -> list? any/c
  lst : any/c
  pos : exact-nonnegative-integer?
procedure
(takef-right lst pred) -> any/c
  lst : any/c
  pred : procedure?
procedure
(dropf-right lst pred) -> list?
  lst : any/c
  pred : procedure?
procedure
(splitf-at-right lst pred) -> list? any/c
  lst : any/c
  pred : procedure?
procedure
(list-prefix? l r [same?]) -> boolean?
  l : list?
  r : list?
  same? : (any/c any/c . -> . any/c) = equal?
procedure
(take-common-prefix l r [same?]) -> list?
  l : list?
  r : list?
  same? : (any/c any/c . -> . any/c) = equal?
procedure
(drop-common-prefix l r [same?]) -> list? list?
  l : list?
  r : list?
  same? : (any/c any/c . -> . any/c) = equal?
procedure
(split-common-prefix l r [same?]) -> list? list? list?
  l : list?
  r : list?
  same? : (any/c any/c . -> . any/c) = equal?
procedure
(add-between  lst                             
              v                               
             [#:before-first before-first     
              #:before-last before-last       
              #:after-last after-last         
              #:splice? splice?])         -> list?
  lst : list?
  v : any/c
  before-first : list? = '()
  before-last : any/c = v
  after-last : list? = '()
  splice? : any/c = #f
procedure
(append* lst ... lsts) -> list?
  lst : list?
  lsts : (listof list?)
(append* lst ... lsts) -> any/c
  lst : list?
  lsts : list?
procedure
(flatten v) -> list?
  v : any/c
procedure
(check-duplicates  lst                            
                  [same?                          
                   #:key extract-key              
                   #:default failure-result]) -> any
  lst : list?
  same? : (any/c any/c . -> . any/c) = equal?
  extract-key : (-> any/c any/c) = (lambda (x) x)
  failure-result : failure-result/c = (lambda () #f)
procedure
(remove-duplicates  lst                     
                   [same?                   
                    #:key extract-key]) -> list?
  lst : list?
  same? : (any/c any/c . -> . any/c) = equal?
  extract-key : (any/c . -> . any/c) = (lambda (x) x)
procedure
(filter-map proc lst ...+) -> list?
  proc : procedure?
  lst : list?
procedure
(count proc lst ...+) -> exact-nonnegative-integer?
  proc : procedure?
  lst : list?
procedure
(partition pred lst) -> list? list?
  pred : procedure?
  lst : list?
procedure
(range end) -> list?
  end : real?
(range start end [step]) -> list?
  start : real?
  end : real?
  step : real? = 1
procedure
(inclusive-range start end [step]) -> list?
  start : real?
  end : real?
  step : real? = 1
procedure
(append-map proc lst ...+) -> list?
  proc : procedure?
  lst : list?
procedure
(filter-not pred lst) -> list?
  pred : (any/c . -> . any/c)
  lst : list?
procedure
(shuffle lst) -> list?
  lst : list?
procedure
(combinations lst) -> list?
  lst : list?
(combinations lst size) -> list?
  lst : list?
  size : exact-nonnegative-integer?
procedure
(in-combinations lst) -> sequence?
  lst : list?
(in-combinations lst size) -> sequence?
  lst : list?
  size : exact-nonnegative-integer?
procedure
(permutations lst) -> list?
  lst : list?
procedure
(in-permutations lst) -> sequence?
  lst : list?
procedure
(argmin proc lst) -> any/c
  proc : (-> any/c real?)
  lst : (and/c pair? list?)
procedure
(argmax proc lst) -> any/c
  proc : (-> any/c real?)
  lst : (and/c pair? list?)
procedure
(group-by key lst [same?]) -> (listof list?)
  key : (-> any/c any/c)
  lst : list?
  same? : (any/c any/c . -> . any/c) = equal?
procedure
(cartesian-product lst ...) -> (listof list?)
  lst : list?
procedure
(remf pred lst) -> list?
  pred : procedure?
  lst : list?
procedure
(remf* pred lst) -> list?
  pred : procedure?
  lst : list?
procedure
(make-reader-graph v) -> any/c
  v : any/c
procedure
(placeholder? v) -> boolean?
  v : any/c
procedure
(make-placeholder v) -> placeholder?
  v : any/c
procedure
(placeholder-set! ph datum) -> void?
  ph : placeholder?
  datum : any/c
procedure
(placeholder-get ph) -> any/c
  ph : placeholder?
procedure
(hash-placeholder? v) -> boolean?
  v : any/c
procedure
(make-hash-placeholder assocs) -> hash-placeholder?
  assocs : (listof pair?)
procedure
(make-hasheq-placeholder assocs) -> hash-placeholder?
  assocs : (listof pair?)
procedure
(make-hasheqv-placeholder assocs) -> hash-placeholder?
  assocs : (listof pair?)
procedure
(make-hashalw-placeholder assocs) -> hash-placeholder?
  assocs : (listof pair?)
procedure
(mpair? v) -> boolean?
  v : any/c
procedure
(mcons a d) -> mpair?
  a : any/c
  d : any/c
procedure
(mcar p) -> any/c
  p : mpair?
procedure
(mcdr p) -> any/c
  p : mpair?
procedure
(set-mcar! p v) -> void?
  p : mpair?
  v : any/c
procedure
(set-mcdr! p v) -> void?
  p : mpair?
  v : any/c
procedure
(vector? v) -> boolean?
  v : any/c
procedure
(make-vector size [v]) -> vector?
  size : exact-nonnegative-integer?
  v : any/c = 0
procedure
(vector v ...) -> vector?
  v : any/c
procedure
(vector-immutable v ...) -> (and/c vector?
                                   immutable?)
  v : any/c
procedure
(vector-length vec) -> exact-nonnegative-integer?
  vec : vector?
procedure
(vector-ref vec pos) -> any/c
  vec : vector?
  pos : exact-nonnegative-integer?
procedure
(vector-set! vec pos v) -> void?
  vec : (and/c vector? (not/c immutable?))
  pos : exact-nonnegative-integer?
  v : any/c
procedure
(vector*-length vec) -> exact-nonnegative-integer?
  vec : (and/c vector? (not/c impersonator?))
procedure
(vector*-ref vec pos) -> any/c
  vec : (and/c vector? (not/c impersonator?))
  pos : exact-nonnegative-integer?
procedure
(vector*-set! vec pos v) -> void?
  vec : (and/c vector? (not/c immutable?)  (not/c impersonator?))
  pos : exact-nonnegative-integer?
  v : any/c
procedure
(vector-cas! vec pos old-v new-v) -> boolean?
  vec : (and/c vector? (not/c immutable?) (not/c impersonator?))
  pos : exact-nonnegative-integer?
  old-v : any/c
  new-v : any/c
procedure
(vector->list vec) -> list?
  vec : vector?
procedure
(list->vector lst) -> vector?
  lst : list?
procedure
(vector->immutable-vector vec) -> (and/c vector? immutable?)
  vec : vector?
procedure
(vector-fill! vec v) -> void?
  vec : (and/c vector? (not/c immutable?))
  v : any/c
procedure
(vector-copy!  dest           
               dest-start     
               src            
              [src-start      
               src-end])  -> void?
  dest : (and/c vector? (not/c immutable?))
  dest-start : exact-nonnegative-integer?
  src : vector?
  src-start : exact-nonnegative-integer? = 0
  src-end : exact-nonnegative-integer? = (vector-length src)
procedure
(vector->values vec [start-pos end-pos]) -> any
  vec : vector?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (vector-length vec)
procedure
(build-vector n proc) -> vector?
  n : exact-nonnegative-integer?
  proc : (exact-nonnegative-integer? . -> . any/c)
procedure
(vector-empty? v) -> boolean?
  v : vector?
procedure
(vector-set*! vec pos v ... ...) -> void?
  vec : (and/c vector? (not/c immutable?))
  pos : exact-nonnegative-integer?
  v : any/c
procedure
(vector-map proc vec ...+) -> vector?
  proc : procedure?
  vec : vector?
procedure
(vector-map! proc vec ...+) -> vector?
  proc : procedure?
  vec : (and/c vector? (not/c immutable?))
procedure
(vector-append vec ...) -> vector?
  vec : vector?
procedure
(vector-take vec pos) -> vector?
  vec : vector?
  pos : exact-nonnegative-integer?
procedure
(vector-take-right vec pos) -> vector?
  vec : vector?
  pos : exact-nonnegative-integer?
procedure
(vector-drop vec pos) -> vector?
  vec : vector?
  pos : exact-nonnegative-integer?
procedure
(vector-drop-right vec pos) -> vector?
  vec : vector?
  pos : exact-nonnegative-integer?
procedure
(vector-split-at vec pos) -> vector? vector?
  vec : vector?
  pos : exact-nonnegative-integer?
procedure
(vector-split-at-right vec pos) -> vector? vector?
  vec : vector?
  pos : exact-nonnegative-integer?
procedure
(vector-copy vec [start end]) -> vector?
  vec : vector?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length v)
procedure
(vector-filter pred vec) -> vector?
  pred : procedure?
  vec : vector?
procedure
(vector-filter-not pred vec) -> vector?
  pred : procedure?
  vec : vector?
procedure
(vector-count proc vec ...+) -> exact-nonnegative-integer?
  proc : procedure?
  vec : vector?
procedure
(vector-argmin proc vec) -> any/c
  proc : (-> any/c real?)
  vec : vector?
procedure
(vector-argmax proc vec) -> any/c
  proc : (-> any/c real?)
  vec : vector?
procedure
(vector-member v vec) -> (or/c natural-number/c #f)
  v : any/c
  vec : vector?
procedure
(vector-memv v vec) -> (or/c natural-number/c #f)
  v : any/c
  vec : vector?
procedure
(vector-memq v vec) -> (or/c natural-number/c #f)
  v : any/c
  vec : vector?
procedure
(vector-sort  vec                             
              less-than?                      
             [start                           
              end                             
              #:key key                       
              #:cache-keys? cache-keys?]) -> vector?
  vec : vector?
  less-than? : (any/c any/c . -> . any/c)
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length vec)
  key : (any/c . -> . any/c) = (λ (x) x)
  cache-keys? : boolean? = #f
procedure
(vector-sort!  vec                             
               less-than?                      
              [start                           
               end                             
               #:key key                       
               #:cache-keys? cache-keys?]) -> void?
  vec : (and/c vector? (not/c immutable?))
  less-than? : (any/c any/c . -> . any/c)
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length vec)
  key : (any/c . -> . any/c) = (λ (x) x)
  cache-keys? : boolean? = #f
procedure
(stencil-vector? v) -> boolean?
  v : any/c
procedure
(stencil-vector-mask-width) -> exact-nonnegative-integer?
procedure
(stencil-vector mask v ...) -> stencil-vector?
  mask : (integer-in 0 (sub1 (expt 2 (stencil-vector-mask-width))))
  v : any/c
procedure
(stencil-vector-mask vec)
 -> (integer-in 0 (sub1 (expt 2 (stencil-vector-mask-width))))
  vec : stencil-vector?
procedure
(stencil-vector-length vec)
 -> (integer-in 0 (sub1 (stencil-vector-mask-width)))
  vec : stencil-vector?
procedure
(stencil-vector-ref vec pos) -> any/c
  vec : stencil-vector?
  pos : exact-nonnegative-integer?
procedure
(stencil-vector-set! vec pos v) -> avoid?
  vec : stencil-vector?
  pos : exact-nonnegative-integer?
  v : any/c
procedure
(stencil-vector-update vec             
                       remove-mask     
                       add-mask        
                       v ...)      -> stencil-vector?
  vec : stencil-vector?
  remove-mask : (integer-in 0 (sub1 (expt 2 (stencil-vector-mask-width))))
  add-mask : (integer-in 0 (sub1 (expt 2 (stencil-vector-mask-width))))
  v : any/c
procedure
(box? v) -> boolean?
  v : any/c
procedure
(box v) -> box?
  v : any/c
procedure
(box-immutable v) -> (and/c box? immutable?)
  v : any/c
procedure
(unbox box) -> any/c
  box : box?
procedure
(set-box! box v) -> void?
  box : (and/c box? (not/c immutable?))
  v : any/c
procedure
(unbox* box) -> any/c
  box : (and box? (not/c impersonator?))
procedure
(set-box*! box v) -> void?
  box : (and/c box? (not/c immutable?) (not/c impersonator?))
  v : any/c
procedure
(box-cas! box old new) -> boolean?
  box : (and/c box? (not/c immutable?) (not/c impersonator?))
  old : any/c
  new : any/c
procedure
(hash? v) -> boolean?
  v : any/c
procedure
(hash-equal? hash) -> boolean?
  hash : hash?
procedure
(hash-equal-always? hash) -> boolean?
  hash : hash?
procedure
(hash-eqv? hash) -> boolean?
  hash : hash?
procedure
(hash-eq? hash) -> boolean?
  hash : hash?
procedure
(hash-strong? hash) -> boolean?
  hash : hash?
procedure
(hash-weak? hash) -> boolean?
  hash : hash?
procedure
(hash-ephemeron? hash) -> boolean?
  hash : hash?
procedure
(hash key val ... ...)
 -> (and/c hash? hash-equal? immutable? hash-strong?)
  key : any/c
  val : any/c
procedure
(hashalw key val ... ...)
 -> (and/c hash? hash-equal-always? immutable? hash-strong?)
  key : any/c
  val : any/c
procedure
(hasheq key val ... ...)
 -> (and/c hash? hash-eq? immutable? hash-strong?)
  key : any/c
  val : any/c
procedure
(hasheqv key val ... ...)
 -> (and/c hash? hash-eqv? immutable? hash-strong?)
  key : any/c
  val : any/c
procedure
(make-hash [assocs])
 -> (and/c hash? hash-equal? (not/c immutable?) hash-strong?)
  assocs : (listof pair?) = null
procedure
(make-hashalw [assocs])
 -> (and/c hash? hash-equal-always? (not/c immutable?) hash-strong?)
  assocs : (listof pair?) = null
procedure
(make-hasheqv [assocs])
 -> (and/c hash? hash-eqv? (not/c immutable?) hash-strong?)
  assocs : (listof pair?) = null
procedure
(make-hasheq [assocs])
 -> (and/c hash? hash-eq? (not/c immutable?) hash-strong?)
  assocs : (listof pair?) = null
procedure
(make-weak-hash [assocs])
 -> (and/c hash? hash-equal? (not/c immutable?) hash-weak?)
  assocs : (listof pair?) = null
procedure
(make-weak-hashalw [assocs])
 -> (and/c hash? hash-equal-always? (not/c immutable?) hash-weak?)
  assocs : (listof pair?) = null
procedure
(make-weak-hasheqv [assocs])
 -> (and/c hash? hash-eqv? (not/c immutable?) hash-weak?)
  assocs : (listof pair?) = null
procedure
(make-weak-hasheq [assocs])
 -> (and/c hash? hash-eq? (not/c immutable?) hash-weak?)
  assocs : (listof pair?) = null
procedure
(make-ephemeron-hash [assocs])
 -> (and/c hash? hash-equal? (not/c immutable?) hash-ephemeron?)
  assocs : (listof pair?) = null
procedure
(make-ephemeron-hashalw [assocs])
 -> (and/c hash? hash-equal-always? (not/c immutable?) hash-ephemeron?)
  assocs : (listof pair?) = null
procedure
(make-ephemeron-hasheqv [assocs])
 -> (and/c hash? hash-eqv? (not/c immutable?) hash-ephemeron?)
  assocs : (listof pair?) = null
procedure
(make-ephemeron-hasheq [assocs])
 -> (and/c hash? hash-eq? (not/c immutable?) hash-ephemeron?)
  assocs : (listof pair?) = null
procedure
(make-immutable-hash [assocs])
 -> (and/c hash? hash-equal? immutable? hash-strong?)
  assocs : (listof pair?) = null
procedure
(make-immutable-hashalw [assocs])
 -> (and/c hash? hash-equal-always? immutable? hash-strong?)
  assocs : (listof pair?) = null
procedure
(make-immutable-hasheqv [assocs])
 -> (and/c hash? hash-eqv? immutable? hash-strong?)
  assocs : (listof pair?) = null
procedure
(make-immutable-hasheq [assocs])
 -> (and/c hash? hash-eq? immutable? hash-strong?)
  assocs : (listof pair?) = null
procedure
(hash-set! hash key v) -> void?
  hash : (and/c hash? (not/c immutable?))
  key : any/c
  v : any/c
procedure
(hash-set*! hash key v ... ...) -> void?
  hash : (and/c hash? (not/c immutable?))
  key : any/c
  v : any/c
procedure
(hash-set hash key v) -> (and/c hash? immutable?)
  hash : (and/c hash? immutable?)
  key : any/c
  v : any/c
procedure
(hash-set* hash key v ... ...) -> (and/c hash? immutable?)
  hash : (and/c hash? immutable?)
  key : any/c
  v : any/c
procedure
(hash-ref hash key [failure-result]) -> any
  hash : hash?
  key : any/c
  failure-result : failure-result/c
                 = (lambda ()
                     (raise (make-exn:fail:contract ....)))
procedure
(hash-ref-key hash key [failure-result]) -> any
  hash : hash?
  key : any/c
  failure-result : failure-result/c
                 = (lambda ()
                     (raise (make-exn:fail:contract ....)))
procedure
(hash-ref! hash key to-set) -> any
  hash : hash?
  key : any/c
  to-set : failure-result/c
procedure
(hash-has-key? hash key) -> boolean?
  hash : hash?
  key : any/c
procedure
(hash-update!  hash                 
               key                  
               updater              
              [failure-result]) -> void?
  hash : (and/c hash? (not/c immutable?))
  key : any/c
  updater : (any/c . -> . any/c)
  failure-result : failure-result/c
                 = (lambda ()
                     (raise (make-exn:fail:contract ....)))
procedure
(hash-update hash key updater [failure-result])
 -> (and/c hash? immutable?)
  hash : (and/c hash? immutable?)
  key : any/c
  updater : (any/c . -> . any/c)
  failure-result : failure-result/c
                 = (lambda ()
                     (raise (make-exn:fail:contract ....)))
procedure
(hash-remove! hash key) -> void?
  hash : (and/c hash? (not/c immutable?))
  key : any/c
procedure
(hash-remove hash key) -> (and/c hash? immutable?)
  hash : (and/c hash? immutable?)
  key : any/c
procedure
(hash-clear! hash) -> void?
  hash : (and/c hash? (not/c immutable?))
procedure
(hash-clear hash) -> (and/c hash? immutable?)
  hash : (and/c hash? immutable?)
procedure
(hash-copy-clear hash [#:kind kind]) -> hash?
  hash : hash?
  kind : (or/c #f 'immutable 'mutable 'weak 'ephemeron) = #f
procedure
(hash-map hash proc [try-order?]) -> (listof any/c)
  hash : hash?
  proc : (any/c any/c . -> . any/c)
  try-order? : any/c = #f
procedure
(hash-map/copy hash proc [#:kind kind]) -> hash?
  hash : hash?
  proc : (any/c any/c . -> . (values any/c any/c))
  kind : (or/c #f 'immutable 'mutable 'weak 'ephemeron) = #f
procedure
(hash-keys hash [try-order?]) -> (listof any/c)
  hash : hash?
  try-order? : any/c = #f
procedure
(hash-values hash [try-order?]) -> (listof any/c)
  hash : hash?
  try-order? : any/c = #f
procedure
(hash->list hash [try-order?]) -> (listof (cons/c any/c any/c))
  hash : hash?
  try-order? : any/c = #f
procedure
(hash-keys-subset? hash1 hash2) -> boolean?
  hash1 : hash?
  hash2 : hash?
procedure
(hash-for-each hash proc [try-order?]) -> void?
  hash : hash?
  proc : (any/c any/c . -> . any)
  try-order? : any/c = #f
procedure
(hash-count hash) -> exact-nonnegative-integer?
  hash : hash?
procedure
(hash-empty? hash) -> boolean?
  hash : hash?
procedure
(hash-iterate-first hash)
 -> (or/c #f exact-nonnegative-integer?)
  hash : hash?
procedure
(hash-iterate-next hash pos)
 -> (or/c #f exact-nonnegative-integer?)
  hash : hash?
  pos : exact-nonnegative-integer?
procedure
(hash-iterate-key hash pos) -> any/c
  hash : hash?
  pos : exact-nonnegative-integer?
procedure
(hash-iterate-key hash pos bad-index-v) -> any/c
  hash : hash?
  pos : exact-nonnegative-integer?
  bad-index-v : any/c
procedure
(hash-iterate-value hash pos) -> any
  hash : hash?
  pos : exact-nonnegative-integer?
procedure
(hash-iterate-value hash pos bad-index-v) -> any
  hash : hash?
  pos : exact-nonnegative-integer?
  bad-index-v : any/c
procedure
(hash-iterate-pair hash pos) -> (cons any/c any/c)
  hash : hash?
  pos : exact-nonnegative-integer?
procedure
(hash-iterate-pair hash pos bad-index-v) -> (cons any/c any/c)
  hash : hash?
  pos : exact-nonnegative-integer?
  bad-index-v : any/c
procedure
(hash-iterate-key+value hash pos) -> any/c any/c
  hash : hash?
  pos : exact-nonnegative-integer?
procedure
(hash-iterate-key+value hash             
                        pos              
                        bad-index-v) -> any/c any/c
  hash : hash?
  pos : exact-nonnegative-integer?
  bad-index-v : any/c
procedure
(hash-copy hash) -> (and/c hash? (not/c immutable?))
  hash : hash?
procedure
(hash-union  h0                          
             h ...                       
            [#:combine combine           
             #:combine/key combine/key]) 
 -> (and/c hash? immutable?)
  h0 : (and/c hash? immutable?)
  h : hash?
  combine : (-> any/c any/c any/c)
          = (lambda _ (error 'hash-union ....))
  combine/key : (-> any/c any/c any/c any/c)
              = (lambda (k a b) (combine a b))
procedure
(hash-union!  h0                              
              h ...                           
             [#:combine combine               
              #:combine/key combine/key]) -> void?
  h0 : (and/c hash? (not/c immutable?))
  h : hash?
  combine : (-> any/c any/c any/c)
          = (lambda _ (error 'hash-union ....))
  combine/key : (-> any/c any/c any/c any/c)
              = (lambda (k a b) (combine a b))
procedure
(hash-intersect  h0                          
                 h ...                       
                [#:combine combine           
                 #:combine/key combine/key]) 
 -> (and/c hash? immutable?)
  h0 : (and/c hash? immutable?)
  h : hash?
  combine : (-> any/c any/c any/c)
          = (lambda _ (error 'hash-intersect ...))
  combine/key : (-> any/c any/c any/c any/c)
              = (lambda (k a b) (combine a b))
procedure
(sequence? v) -> boolean?
  v : any/c
procedure
(in-range end) -> stream?
  end : real?
(in-range start end [step]) -> stream?
  start : real?
  end : real?
  step : real? = 1
procedure
(in-inclusive-range start end [step]) -> stream?
  start : real?
  end : real?
  step : real? = 1
procedure
(in-naturals [start]) -> stream?
  start : exact-nonnegative-integer? = 0
procedure
(in-list lst) -> stream?
  lst : list?
procedure
(in-mlist mlst) -> sequence?
  mlst : mlist?
procedure
(in-vector vec [start stop step]) -> sequence?
  vec : vector?
  start : exact-nonnegative-integer? = 0
  stop : (or/c exact-integer? #f) = #f
  step : (and/c exact-integer? (not/c zero?)) = 1
procedure
(in-string str [start stop step]) -> sequence?
  str : string?
  start : exact-nonnegative-integer? = 0
  stop : (or/c exact-integer? #f) = #f
  step : (and/c exact-integer? (not/c zero?)) = 1
procedure
(in-bytes bstr [start stop step]) -> sequence?
  bstr : bytes?
  start : exact-nonnegative-integer? = 0
  stop : (or/c exact-integer? #f) = #f
  step : (and/c exact-integer? (not/c zero?)) = 1
procedure
(in-port [r in]) -> sequence?
  r : (input-port? . -> . any/c) = read
  in : input-port? = (current-input-port)
procedure
(in-input-port-bytes in) -> sequence?
  in : input-port?
procedure
(in-input-port-chars in) -> sequence?
  in : input-port?
procedure
(in-lines [in mode]) -> sequence?
  in : input-port? = (current-input-port)
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
       = 'any
procedure
(in-bytes-lines [in mode]) -> sequence?
  in : input-port? = (current-input-port)
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
       = 'any
procedure
(in-hash hash) -> sequence?
  hash : hash?
(in-hash hash bad-index-v) -> sequence?
  hash : hash?
  bad-index-v : any/c
procedure
(in-hash-keys hash) -> sequence?
  hash : hash?
(in-hash-keys hash bad-index-v) -> sequence?
  hash : hash?
  bad-index-v : any/c
procedure
(in-hash-values hash) -> sequence?
  hash : hash?
(in-hash-values hash bad-index-v) -> sequence?
  hash : hash?
  bad-index-v : any/c
procedure
(in-hash-pairs hash) -> sequence?
  hash : hash?
(in-hash-pairs hash bad-index-v) -> sequence?
  hash : hash?
  bad-index-v : any/c
procedure
(in-mutable-hash hash) -> sequence?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
procedure
(in-mutable-hash hash bad-index-v) -> sequence?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  bad-index-v : any/c
procedure
(in-mutable-hash-keys hash) -> sequence?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
procedure
(in-mutable-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  bad-index-v : any/c
procedure
(in-mutable-hash-values hash) -> sequence?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
procedure
(in-mutable-hash-values hash bad-index-v) -> sequence?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  bad-index-v : any/c
procedure
(in-mutable-hash-pairs hash) -> sequence?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
procedure
(in-mutable-hash-pairs hash bad-index-v) -> sequence?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  bad-index-v : any/c
procedure
(in-immutable-hash hash) -> sequence?
  hash : (and/c hash? immutable?)
procedure
(in-immutable-hash hash bad-index-v) -> sequence?
  hash : (and/c hash? immutable?)
  bad-index-v : any/c
procedure
(in-immutable-hash-keys hash) -> sequence?
  hash : (and/c hash? immutable?)
procedure
(in-immutable-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? immutable?)
  bad-index-v : any/c
procedure
(in-immutable-hash-values hash) -> sequence?
  hash : (and/c hash? immutable?)
procedure
(in-immutable-hash-values hash bad-index-v) -> sequence?
  hash : (and/c hash? immutable?)
  bad-index-v : any/c
procedure
(in-immutable-hash-pairs hash) -> sequence?
  hash : (and/c hash? immutable?)
procedure
(in-immutable-hash-pairs hash bad-index-v) -> sequence?
  hash : (and/c hash? immutable?)
  bad-index-v : any/c
procedure
(in-weak-hash hash) -> sequence?
  hash : (and/c hash? hash-weak?)
procedure
(in-weak-hash hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-weak?)
  bad-index-v : any/c
procedure
(in-weak-hash-keys hash) -> sequence?
  hash : (and/c hash? hash-weak?)
procedure
(in-weak-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-weak?)
  bad-index-v : any/c
procedure
(in-weak-hash-values hash) -> sequence?
  hash : (and/c hash? hash-weak?)
procedure
(in-weak-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-weak?)
  bad-index-v : any/c
procedure
(in-weak-hash-pairs hash) -> sequence?
  hash : (and/c hash? hash-weak?)
procedure
(in-weak-hash-pairs hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-weak?)
  bad-index-v : any/c
procedure
(in-ephemeron-hash hash) -> sequence?
  hash : (and/c hash? hash-ephemeron?)
procedure
(in-ephemeron-hash hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-ephemeron?)
  bad-index-v : any/c
procedure
(in-ephemeron-hash-keys hash) -> sequence?
  hash : (and/c hash? hash-ephemeron?)
procedure
(in-ephemeron-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-ephemeron?)
  bad-index-v : any/c
procedure
(in-ephemeron-hash-values hash) -> sequence?
  hash : (and/c hash? hash-ephemeron?)
procedure
(in-ephemeron-hash-keys hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-ephemeron?)
  bad-index-v : any/c
procedure
(in-ephemeron-hash-pairs hash) -> sequence?
  hash : (and/c hash? hash-ephemeron?)
procedure
(in-ephemeron-hash-pairs hash bad-index-v) -> sequence?
  hash : (and/c hash? hash-ephemeron?)
  bad-index-v : any/c
procedure
(in-directory [dir use-dir?]) -> sequence?
  dir : (or/c #f path-string?) = #f
  use-dir? : ((and/c path? complete-path?) . -> . any/c)
           = (lambda (dir-path) #t)
procedure
(in-producer producer) -> sequence?
  producer : procedure?
(in-producer producer stop arg ...) -> sequence?
  producer : procedure?
  stop : any/c
  arg : any/c
procedure
(in-value v) -> sequence?
  v : any/c
procedure
(in-indexed seq) -> sequence?
  seq : sequence?
procedure
(in-sequences seq ...) -> sequence?
  seq : sequence?
procedure
(in-cycle seq ...) -> sequence?
  seq : sequence?
procedure
(in-parallel seq ...) -> sequence?
  seq : sequence?
procedure
(in-values-sequence seq) -> sequence?
  seq : sequence?
procedure
(in-values*-sequence seq) -> sequence?
  seq : sequence?
procedure
(stop-before seq pred) -> sequence?
  seq : sequence?
  pred : (any/c . -> . any)
procedure
(stop-after seq pred) -> sequence?
  seq : sequence?
  pred : (any/c . -> . any)
procedure
(make-do-sequence thunk) -> sequence?
  thunk : (or/c (-> (values (any/c . -> . any)
                            (any/c . -> . any/c)
                            any/c
                            (or/c (any/c . -> . any/c) #f)
                            (or/c (() () #:rest list? . ->* . any/c) #f)
                            (or/c ((any/c) () #:rest list? . ->* . any/c) #f)))
                (-> (values (any/c . -> . any)
                            (or/c (any/c . -> . any/c) #f)
                            (any/c . -> . any/c)
                            any/c
                            (or/c (any/c . -> . any/c) #f)
                            (or/c (() () #:rest list? . ->* . any/c) #f)
                            (or/c ((any/c) () #:rest list? . ->* . any/c) #f))))
value
prop:sequence : struct-type-property?
procedure
(sequence->stream seq) -> stream?
  seq : sequence?
procedure
(sequence-generate seq) -> (-> boolean?) (-> any)
  seq : sequence?
procedure
(sequence-generate* seq)
 -> (or/c list? #f)
    (-> (values (or/c list? #f) procedure?))
  seq : sequence?
value
empty-sequence : sequence?
procedure
(sequence->list s) -> list?
  s : sequence?
procedure
(sequence-length s) -> exact-nonnegative-integer?
  s : sequence?
procedure
(sequence-ref s i) -> any
  s : sequence?
  i : exact-nonnegative-integer?
procedure
(sequence-tail s i) -> sequence?
  s : sequence?
  i : exact-nonnegative-integer?
procedure
(sequence-append s ...) -> sequence?
  s : sequence?
procedure
(sequence-map f s) -> sequence?
  f : procedure?
  s : sequence?
procedure
(sequence-andmap f s) -> boolean?
  f : (-> any/c ... boolean?)
  s : sequence?
procedure
(sequence-ormap f s) -> boolean?
  f : (-> any/c ... boolean?)
  s : sequence?
procedure
(sequence-for-each f s) -> void?
  f : (-> any/c ... any)
  s : sequence?
procedure
(sequence-fold f i s) -> any/c
  f : (-> any/c any/c ... any/c)
  i : any/c
  s : sequence?
procedure
(sequence-count f s) -> exact-nonnegative-integer?
  f : procedure?
  s : sequence?
procedure
(sequence-filter f s) -> sequence?
  f : (-> any/c ... boolean?)
  s : sequence?
procedure
(sequence-add-between s e) -> sequence?
  s : sequence?
  e : any/c
procedure
(sequence/c [#:min-count min-count]     
             elem/c ...)            -> contract?
  min-count : (or/c #f exact-nonnegative-integer?) = #f
  elem/c : contract?
procedure
(in-syntax stx) -> sequence?
  stx : syntax?
procedure
(in-slice length seq) -> sequence?
  length : exact-positive-integer?
  seq : sequence?
procedure
(stream? v) -> boolean?
  v : any/c
procedure
(stream-empty? s) -> boolean?
  s : stream?
procedure
(stream-first s) -> any
  s : (and/c stream? (not/c stream-empty?))
procedure
(stream-rest s) -> stream?
  s : (and/c stream? (not/c stream-empty?))
syntax
(stream-cons first-expr rest-expr)
(stream-cons #:eager first-expr rest-expr)
(stream-cons first-expr #:eager rest-expr)
(stream-cons #:eager first-expr #:eager rest-expr)
syntax
(stream-lazy stream-expr)
(stream-lazy #:who who-expr stream-expr)
procedure
(stream-force s) -> stream?
  s : stream?
syntax
(stream e ...)
syntax
(stream* e ... tail)
procedure
(in-stream s) -> sequence?
  s : stream?
value
empty-stream : stream?
procedure
(stream->list s) -> list?
  s : stream?
procedure
(stream-length s) -> exact-nonnegative-integer?
  s : stream?
procedure
(stream-ref s i) -> any
  s : stream?
  i : exact-nonnegative-integer?
procedure
(stream-tail s i) -> stream?
  s : stream?
  i : exact-nonnegative-integer?
procedure
(stream-take s i) -> stream?
  s : stream?
  i : exact-nonnegative-integer?
procedure
(stream-append s ...) -> stream?
  s : stream?
procedure
(stream-map f s) -> stream?
  f : procedure?
  s : stream?
procedure
(stream-andmap f s) -> boolean?
  f : (-> any/c ... boolean?)
  s : stream?
procedure
(stream-ormap f s) -> boolean?
  f : (-> any/c ... boolean?)
  s : stream?
procedure
(stream-for-each f s) -> void?
  f : (-> any/c ... any)
  s : stream?
procedure
(stream-fold f i s) -> any/c
  f : (-> any/c any/c ... any/c)
  i : any/c
  s : stream?
procedure
(stream-count f s) -> exact-nonnegative-integer?
  f : procedure?
  s : stream?
procedure
(stream-filter f s) -> stream?
  f : (-> any/c ... boolean?)
  s : stream?
procedure
(stream-add-between s e) -> stream?
  s : stream?
  e : any/c
syntax
(for/stream (for-clause ...) body-or-break ... body)
syntax
(for*/stream (for-clause ...) body-or-break ... body)
value
gen:stream : any/c
value
prop:stream : struct-type-property?
procedure
(stream/c c) -> contract?
  c : contract?
procedure
(generator? v) -> boolean?
  v : any/c
syntax
(generator formals body ...+)
 
formals = (id ...)
        | (id ...+ . rest-id)
        | rest-id
procedure
(yield v ...) -> any
  v : any/c
syntax
(infinite-generator body ...+)
syntax
(in-generator maybe-arity body ...+)
 
maybe-arity = 
            | #:arity arity-k
procedure
(generator-state g) -> symbol?
  g : generator?
procedure
(sequence->generator s) -> (-> any)
  s : sequence?
procedure
(sequence->repeated-generator s) -> (-> any)
  s : sequence?
procedure
(dict? v) -> boolean?
  v : any/c
procedure
(dict-implements? d sym ...) -> boolean?
  d : dict?
  sym : symbol?
procedure
(dict-implements/c sym ...) -> flat-contract?
  sym : symbol?
procedure
(dict-mutable? d) -> boolean?
  d : dict?
procedure
(dict-can-remove-keys? d) -> boolean?
  d : dict?
procedure
(dict-can-functional-set? d) -> boolean?
  d : dict?
syntax
gen:dict
value
prop:dict : struct-type-property?
procedure
(dict-ref dict key [failure-result]) -> any
  dict : dict?
  key : any/c
  failure-result : failure-result/c
                 = (lambda () (raise (make-exn:fail ....)))
procedure
(dict-set! dict key v) -> void?
  dict : (and/c dict? (not/c immutable?))
  key : any/c
  v : any/c
procedure
(dict-set dict key v) -> (and/c dict? immutable?)
  dict : (and/c dict? immutable?)
  key : any/c
  v : any/c
procedure
(dict-remove! dict key) -> void?
  dict : (and/c dict? (not/c immutable?))
  key : any/c
procedure
(dict-remove dict key) -> (and/c dict? immutable?)
  dict : (and/c dict? immutable?)
  key : any/c
procedure
(dict-iterate-first dict) -> any/c
  dict : dict?
procedure
(dict-iterate-next dict pos) -> any/c
  dict : dict?
  pos : any/c
procedure
(dict-iterate-key dict pos) -> any
  dict : dict?
  pos : any/c
procedure
(dict-iterate-value dict pos) -> any
  dict : dict?
  pos : any/c
procedure
(dict-has-key? dict key) -> boolean?
  dict : dict?
  key : any/c
procedure
(dict-set*! dict key v ... ...) -> void?
  dict : (and/c dict? (not/c immutable?))
  key : any/c
  v : any/c
procedure
(dict-set* dict key v ... ...) -> (and/c dict? immutable?)
  dict : (and/c dict? immutable?)
  key : any/c
  v : any/c
procedure
(dict-ref! dict key to-set) -> any
  dict : dict?
  key : any/c
  to-set : any/c
procedure
(dict-update!  dict                 
               key                  
               updater              
              [failure-result]) -> void?
  dict : (and/c dict? (not/c immutable?))
  key : any/c
  updater : (any/c . -> . any/c)
  failure-result : failure-result/c
                 = (lambda () (raise (make-exn:fail ....)))
procedure
(dict-update dict key updater [failure-result])
 -> (and/c dict? immutable?)
  dict : dict?
  key : any/c
  updater : (any/c . -> . any/c)
  failure-result : failure-result/c
                 = (lambda () (raise (make-exn:fail ....)))
procedure
(dict-map dict proc) -> (listof any/c)
  dict : dict?
  proc : (any/c any/c . -> . any/c)
procedure
(dict-map/copy dict proc) -> dict?
  dict : dict?
  proc : (any/c any/c . -> . (values any/c any/c))
procedure
(dict-for-each dict proc) -> void?
  dict : dict?
  proc : (any/c any/c . -> . any)
procedure
(dict-empty? dict) -> boolean?
  dict : dict?
procedure
(dict-count dict) -> exact-nonnegative-integer?
  dict : dict?
procedure
(dict-copy dict) -> dict?
  dict : dict?
procedure
(dict-clear dict) -> dict?
  dict : dict?
procedure
(dict-clear! dict) -> void?
  dict : dict?
procedure
(dict-keys dict) -> list?
  dict : dict?
procedure
(dict-values dict) -> list?
  dict : dict?
procedure
(dict->list dict) -> list?
  dict : dict?
procedure
(in-dict dict) -> sequence?
  dict : dict?
procedure
(in-dict-keys dict) -> sequence?
  dict : dict?
procedure
(in-dict-values dict) -> sequence?
  dict : dict?
procedure
(in-dict-pairs dict) -> sequence?
  dict : dict?
value
prop:dict/contract : struct-type-property?
procedure
(dict-key-contract d) -> contract?
  d : dict?
procedure
(dict-value-contract d) -> contract?
  d : dict?
procedure
(dict-iter-contract d) -> contract?
  d : dict?
syntax
(define-custom-hash-types name
                          optional-predicate
                          comparison-expr
                          optional-hash-functions)
 
     optional-predicate = 
                        | #:key? predicate-expr
                           
optional-hash-functions = 
                        | hash1-expr
                        | hash1-expr hash2-expr
procedure
(make-custom-hash-types  eql?            
                        [hash1           
                         hash2           
                         #:key? key?     
                         #:name name     
                         #:for who]) -> (any/c . -> . boolean?)
                                        (any/c . -> . boolean?)
                                        (any/c . -> . boolean?)
                                        (any/c . -> . boolean?)
                                        (->* [] [dict?] dict?)
                                        (->* [] [dict?] dict?)
                                        (->* [] [dict?] dict?)
  eql? : (or/c (any/c any/c . -> . any/c)
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  key? : (any/c . -> . boolean?) = (const #true)
  name : symbol? = 'custom-hash
  who : symbol? = 'make-custom-hash-types
procedure
(make-custom-hash  eql?              
                  [hash1             
                   hash2             
                   #:key? key?]) -> dict?
  eql? : (or/c (any/c any/c . -> . any/c)
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  key? : (any/c . -> . boolean?) = (λ (x) #true)
procedure
(make-weak-custom-hash  eql?              
                       [hash1             
                        hash2             
                        #:key? key?]) -> dict?
  eql? : (or/c (any/c any/c . -> . any/c)
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  key? : (any/c . -> . boolean?) = (λ (x) #true)
procedure
(make-immutable-custom-hash  eql?              
                            [hash1             
                             hash2             
                             #:key? key?]) -> dict?
  eql? : (or/c (any/c any/c . -> . any/c)
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  key? : (any/c . -> . boolean?) = (λ (x) #true)
procedure
(keyword-apply/dict proc                   
                    kw-dict                
                    pos-arg ...            
                    pos-args               
                    #:<kw> kw-arg ...) -> any
  proc : procedure?
  kw-dict : dict?
  pos-arg : any/c
  pos-args : (listof any/c)
  kw-arg : any/c
procedure
(set-equal? x) -> boolean?
  x : any/c
procedure
(set-equal-always? x) -> boolean?
  x : any/c
procedure
(set-eqv? x) -> boolean?
  x : any/c
procedure
(set-eq? x) -> boolean?
  x : any/c
procedure
(set? x) -> boolean?
  x : any/c
procedure
(set-mutable? x) -> boolean?
  x : any/c
procedure
(set-weak? x) -> boolean?
  x : any/c
procedure
(set v ...) -> (and/c generic-set? set-equal? set?)
  v : any/c
procedure
(setalw v ...) -> (and/c generic-set? set-equal-always? set?)
  v : any/c
procedure
(seteqv v ...) -> (and/c generic-set? set-eqv? set?)
  v : any/c
procedure
(seteq v ...) -> (and/c generic-set? set-eq? set?)
  v : any/c
procedure
(mutable-set v ...)
 -> (and/c generic-set? set-equal? set-mutable?)
  v : any/c
procedure
(mutable-setalw v ...)
 -> (and/c generic-set? set-equal-always? set-mutable?)
  v : any/c
procedure
(mutable-seteqv v ...)
 -> (and/c generic-set? set-eqv? set-mutable?)
  v : any/c
procedure
(mutable-seteq v ...)
 -> (and/c generic-set? set-eq? set-mutable?)
  v : any/c
procedure
(weak-set v ...) -> (and/c generic-set? set-equal? set-weak?)
  v : any/c
procedure
(weak-setalw v ...)
 -> (and/c generic-set? set-equal-always? set-weak?)
  v : any/c
procedure
(weak-seteqv v ...) -> (and/c generic-set? set-eqv? set-weak?)
  v : any/c
procedure
(weak-seteq v ...) -> (and/c generic-set? set-eq? set-weak?)
  v : any/c
procedure
(list->set lst) -> (and/c generic-set? set-equal? set?)
  lst : list?
procedure
(list->setalw lst)
 -> (and/c generic-set? set-equal-always? set?)
  lst : list?
procedure
(list->seteqv lst) -> (and/c generic-set? set-eqv? set?)
  lst : list?
procedure
(list->seteq lst) -> (and/c generic-set? set-eq? set?)
  lst : list?
procedure
(list->mutable-set lst)
 -> (and/c generic-set? set-equal? set-mutable?)
  lst : list?
procedure
(list->mutable-setalw lst)
 -> (and/c generic-set? set-equal-always? set-mutable?)
  lst : list?
procedure
(list->mutable-seteqv lst)
 -> (and/c generic-set? set-eqv? set-mutable?)
  lst : list?
procedure
(list->mutable-seteq lst)
 -> (and/c generic-set? set-eq? set-mutable?)
  lst : list?
procedure
(list->weak-set lst)
 -> (and/c generic-set? set-equal? set-weak?)
  lst : list?
procedure
(list->weak-setalw lst)
 -> (and/c generic-set? set-equal-always? set-weak?)
  lst : list?
procedure
(list->weak-seteqv lst)
 -> (and/c generic-set? set-eqv? set-weak?)
  lst : list?
procedure
(list->weak-seteq lst) -> (and/c generic-set? set-eq? set-weak?)
  lst : list?
syntax
(for/set (for-clause ...) body ...+)
syntax
(for/seteq (for-clause ...) body ...+)
syntax
(for/seteqv (for-clause ...) body ...+)
syntax
(for/setalw (for-clause ...) body ...+)
syntax
(for*/set (for-clause ...) body ...+)
syntax
(for*/seteq (for-clause ...) body ...+)
syntax
(for*/seteqv (for-clause ...) body ...+)
syntax
(for*/setalw (for-clause ...) body ...+)
syntax
(for/mutable-set (for-clause ...) body ...+)
syntax
(for/mutable-seteq (for-clause ...) body ...+)
syntax
(for/mutable-seteqv (for-clause ...) body ...+)
syntax
(for/mutable-setalw (for-clause ...) body ...+)
syntax
(for*/mutable-set (for-clause ...) body ...+)
syntax
(for*/mutable-seteq (for-clause ...) body ...+)
syntax
(for*/mutable-seteqv (for-clause ...) body ...+)
syntax
(for*/mutable-setalw (for-clause ...) body ...+)
syntax
(for/weak-set (for-clause ...) body ...+)
syntax
(for/weak-seteq (for-clause ...) body ...+)
syntax
(for/weak-seteqv (for-clause ...) body ...+)
syntax
(for/weak-setalw (for-clause ...) body ...+)
syntax
(for*/weak-set (for-clause ...) body ...+)
syntax
(for*/weak-seteq (for-clause ...) body ...+)
syntax
(for*/weak-seteqv (for-clause ...) body ...+)
syntax
(for*/weak-setalw (for-clause ...) body ...+)
procedure
(in-immutable-set st) -> sequence?
  st : set?
procedure
(in-mutable-set st) -> sequence?
  st : set-mutable?
procedure
(in-weak-set st) -> sequence?
  st : set-weak?
procedure
(generic-set? v) -> boolean?
  v : any/c
procedure
(set-implements? st sym ...) -> boolean?
  st : generic-set?
  sym : symbol?
procedure
(set-implements/c sym ...) -> flat-contract?
  sym : symbol?
procedure
(set/c  elem/c                          
       [#:cmp cmp                       
        #:kind kind                     
        #:lazy? lazy?                   
        #:equal-key/c equal-key/c]) -> contract?
  elem/c : chaperone-contract?
  cmp : (or/c 'dont-care 'equal 'equal-always 'eqv 'eq)
      = 'dont-care
  kind : (or/c 'dont-care 'immutable 'mutable 'weak 'mutable-or-weak)
       = 'immutable
  lazy? : any/c = (not (and (equal? kind 'immutable)
                            (flat-contract? elem/c)))
  equal-key/c : contract? = any/c
syntax
gen:set
procedure
(set-member? st v) -> boolean?
  st : generic-set?
  v : any/c
procedure
(set-add st v) -> generic-set?
  st : generic-set?
  v : any/c
procedure
(set-add! st v) -> void?
  st : generic-set?
  v : any/c
procedure
(set-remove st v) -> generic-set?
  st : generic-set?
  v : any/c
procedure
(set-remove! st v) -> void?
  st : generic-set?
  v : any/c
procedure
(set-empty? st) -> boolean?
  st : generic-set?
procedure
(set-count st) -> exact-nonnegative-integer?
  st : generic-set?
procedure
(set-first st) -> any/c
  st : (and/c generic-set? (not/c set-empty?))
procedure
(set-rest st) -> generic-set?
  st : (and/c generic-set? (not/c set-empty?))
procedure
(set->stream st) -> stream?
  st : generic-set?
procedure
(set-copy st) -> generic-set?
  st : generic-set?
procedure
(set-copy-clear st) -> (and/c generic-set? set-empty?)
  st : generic-set?
procedure
(set-clear st) -> (and/c generic-set? set-empty?)
  st : generic-set?
procedure
(set-clear! st) -> void?
  st : generic-set?
procedure
(set-union st0 st ...) -> generic-set?
  st0 : generic-set?
  st : generic-set?
procedure
(set-union! st0 st ...) -> void?
  st0 : generic-set?
  st : generic-set?
procedure
(set-intersect st0 st ...) -> generic-set?
  st0 : generic-set?
  st : generic-set?
procedure
(set-intersect! st0 st ...) -> void?
  st0 : generic-set?
  st : generic-set?
procedure
(set-subtract st0 st ...) -> generic-set?
  st0 : generic-set?
  st : generic-set?
procedure
(set-subtract! st0 st ...) -> void?
  st0 : generic-set?
  st : generic-set?
procedure
(set-symmetric-difference st0 st ...) -> generic-set?
  st0 : generic-set?
  st : generic-set?
procedure
(set-symmetric-difference! st0 st ...) -> void?
  st0 : generic-set?
  st : generic-set?
procedure
(set=? st st2) -> boolean?
  st : generic-set?
  st2 : generic-set?
procedure
(subset? st st2) -> boolean?
  st : generic-set?
  st2 : generic-set?
procedure
(proper-subset? st st2) -> boolean?
  st : generic-set?
  st2 : generic-set?
procedure
(set->list st) -> list?
  st : generic-set?
procedure
(set-map st proc) -> (listof any/c)
  st : generic-set?
  proc : (any/c . -> . any/c)
procedure
(set-for-each st proc) -> void?
  st : generic-set?
  proc : (any/c . -> . any)
procedure
(in-set st) -> sequence?
  st : generic-set?
procedure
(impersonate-hash-set  st              
                       inject-proc     
                       add-proc        
                       shrink-proc     
                       extract-proc    
                      [clear-proc      
                       equal-key-proc] 
                       prop            
                       prop-val ...    
                       ...)            
 -> (and/c (or/c set-mutable? set-weak?) impersonator?)
  st : (or/c set-mutable? set-weak?)
  inject-proc : (or/c #f (-> set? any/c any/c))
  add-proc : (or/c #f (-> set? any/c any/c))
  shrink-proc : (or/c #f (-> set? any/c any/c))
  extract-proc : (or/c #f (-> set? any/c any/c))
  clear-proc : (or/c #f (-> set? any)) = #f
  equal-key-proc : (or/c #f (-> set? any/c any/c)) = #f
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-hash-set  st              
                     inject-proc     
                     add-proc        
                     shrink-proc     
                     extract-proc    
                    [clear-proc      
                     equal-key-proc] 
                     prop            
                     prop-val ...    
                     ...)            
 -> (and/c (or/c set? set-mutable? set-weak?) chaperone?)
  st : (or/c set? set-mutable? set-weak?)
  inject-proc : (or/c #f (-> set? any/c any/c))
  add-proc : (or/c #f (-> set? any/c any/c))
  shrink-proc : (or/c #f (-> set? any/c any/c))
  extract-proc : (or/c #f (-> set? any/c any/c))
  clear-proc : (or/c #f (-> set? any)) = #f
  equal-key-proc : (or/c #f (-> set? any/c any/c)) = #f
  prop : impersonator-property?
  prop-val : any/c
syntax
(define-custom-set-types name
                         optional-predicate
                         comparison-expr
                         optional-hash-functions)
 
     optional-predicate = 
                        | #:elem? predicate-expr
                           
optional-hash-functions = 
                        | hash1-expr
                        | hash1-expr hash2-expr
procedure
(make-custom-set-types  eql?          
                       [hash1         
                        hash2         
                        #:elem? elem? 
                        #:name name   
                        #:for who])   
 -> (any/c . -> . boolean?)
    (any/c . -> . boolean?)
    (any/c . -> . boolean?)
    (any/c . -> . boolean?)
    (->* [] [stream?] generic-set?)
    (->* [] [stream?] generic-set?)
    (->* [] [stream?] generic-set?)
  eql? : (or/c (any/c any/c . -> . any/c)
               (any/c any/c (any/c any/c . -> . any/c) . -> . any/c))
  hash1 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  hash2 : (or/c (any/c . -> . exact-integer?)
                (any/c (any/c . -> . exact-integer?) . -> . exact-integer?))
        = (const 1)
  elem? : (any/c . -> . boolean?) = (const #true)
  name : symbol? = 'custom-set
  who : symbol? = 'make-custom-set-types
procedure
(procedure? v) -> boolean?
  v : any/c
procedure
(apply proc v ... lst #:<kw> kw-arg ...) -> any
  proc : procedure?
  v : any/c
  lst : list?
  kw-arg : any/c
procedure
(compose proc ...) -> procedure?
  proc : procedure?
procedure
(compose1 proc ...) -> procedure?
  proc : procedure?
procedure
(procedure-rename proc name [realm]) -> procedure?
  proc : procedure?
  name : symbol?
  realm : symbol? = 'racket
procedure
(procedure-realm proc) -> symbol?
  proc : procedure?
procedure
(procedure->method proc) -> procedure?
  proc : procedure?
procedure
(procedure-closure-contents-eq? proc1      
                                proc2) -> boolean?
  proc1 : procedure?
  proc2 : procedure?
procedure
(keyword-apply proc                   
               kw-lst                 
               kw-val-lst             
               v ...                  
               lst                    
               #:<kw> kw-arg ...) -> any
  proc : procedure?
  kw-lst : (listof keyword?)
  kw-val-lst : list?
  v : any/c
  lst : list?
  kw-arg : any/c
procedure
(procedure-arity proc) -> normalized-arity?
  proc : procedure?
procedure
(procedure-arity? v) -> boolean?
  v : any/c
procedure
(procedure-arity-mask proc) -> exact-integer?
  proc : procedure?
procedure
(procedure-arity-includes? proc k [kws-ok?]) -> boolean?
  proc : procedure?
  k : exact-nonnegative-integer?
  kws-ok? : any/c = #f
procedure
(procedure-reduce-arity  proc        
                         arity       
                        [name        
                         realm]) -> procedure?
  proc : procedure?
  arity : procedure-arity?
  name : (or/c symbol? #f) = #f
  realm : symbol? = 'racket
procedure
(procedure-reduce-arity-mask  proc        
                              mask        
                             [name        
                              realm]) -> procedure?
  proc : procedure?
  mask : exact-integer?
  name : (or/c symbol? #f) = #f
  realm : symbol? = 'racket
procedure
(procedure-keywords proc) -> (listof keyword?)
                             (or/c (listof keyword?) #f)
  proc : procedure?
procedure
(procedure-result-arity proc) -> (or/c #f procedure-arity?)
  proc : procedure?
procedure
(make-keyword-procedure proc [plain-proc]) -> procedure?
  proc : (((listof keyword?) list?) () #:rest list? . ->* . any)
  plain-proc : procedure?
             = (lambda args (apply proc null null args))
procedure
(procedure-reduce-keyword-arity  proc             
                                 arity            
                                 required-kws     
                                 allowed-kws      
                                [name             
                                 realm])      -> procedure?
  proc : procedure?
  arity : procedure-arity?
  required-kws : (listof keyword?)
  allowed-kws : (or/c (listof keyword?)
                      #f)
  name : (or/c symbol? #f) = #f
  realm : symbol? = 'racket
procedure
(procedure-reduce-keyword-arity-mask  proc             
                                      mask             
                                      required-kws     
                                      allowed-kws      
                                     [name             
                                      realm])      -> procedure?
  proc : procedure?
  mask : exact-integer?
  required-kws : (listof keyword?)
  allowed-kws : (or/c (listof keyword?)
                       #f)
  name : (or/c symbol? #f) = #f
  realm : symbol? = 'racket
struct
(struct arity-at-least (value)
    #:extra-constructor-name make-arity-at-least)
  value : exact-nonnegative-integer?
value
prop:procedure : struct-type-property?
procedure
(procedure-struct-type? type) -> boolean?
  type : struct-type?
procedure
(procedure-extract-target proc) -> (or/c #f procedure?)
  proc : procedure?
value
prop:arity-string : struct-type-property?
value
prop:checked-procedure : struct-type-property?
procedure
(checked-procedure-check-and-extract type     
                                     v        
                                     proc     
                                     v1       
                                     v2)  -> any/c
  type : struct-type?
  v : any/c
  proc : (any/c any/c any/c . -> . any/c)
  v1 : any/c
  v2 : any/c
procedure
(procedure-specialize proc) -> procedure?
  proc : procedure?
procedure
(primitive? v) -> boolean?
  v : any/c
procedure
(primitive-closure? v) -> boolean
  v : any/c
procedure
(primitive-result-arity prim) -> procedure-arity?
  prim : primitive?
procedure
(identity v) -> any/c
  v : any/c
procedure
(const v) -> procedure?
  v : any/c
procedure
(const* v ...) -> procedure?
  v : any/c
syntax
(thunk  body ...+)
syntax
(thunk* body ...+)
procedure
(negate proc) -> procedure?
  proc : procedure?
procedure
((conjoin f ...) x ...) -> any
  f : procedure?
  x : any/c
procedure
((disjoin f ...) x ...) -> any
  f : procedure?
  x : any/c
procedure
(curry proc) -> procedure?
  proc : procedure?
(curry proc v ...+) -> any
  proc : procedure?
  v : any/c
procedure
(curryr proc) -> procedure?
  proc : procedure?
(curryr proc v ...+) -> any
  proc : procedure?
  v : any/c
procedure
(normalized-arity? arity) -> boolean?
  arity : any/c
procedure
(normalize-arity arity)
 -> (and/c normalized-arity? (lambda (x) (arity=? x arity)))
  arity : procedure-arity?
procedure
(arity=? a b) -> boolean?
  a : procedure-arity?
  b : procedure-arity?
procedure
(arity-includes? a b) -> boolean?
  a : procedure-arity?
  b : procedure-arity?
procedure
(void? v) -> boolean?
  v : any/c
procedure
(void v ...) -> void?
  v : any/c
value
undefined : any/c
syntax
(struct id maybe-super (field ...)
        struct-option ...)
 
  maybe-super = 
              | super-id
                 
        field = field-id
              | [field-id field-option ...]
                 
struct-option = #:mutable
              | #:super super-expr
              | #:inspector inspector-expr
              | #:auto-value auto-expr
              | #:guard guard-expr
              | #:property prop-expr val-expr
              | #:transparent
              | #:prefab
              | #:sealed
              | #:authentic
              | #:name name-id
              | #:extra-name name-id
              | #:constructor-name constructor-id
              | #:extra-constructor-name constructor-id
              | #:reflection-name symbol-expr
              | #:methods gen:name-id method-defs
              | #:omit-define-syntaxes
              | #:omit-define-values
                 
 field-option = #:mutable
              | #:auto
                 
  method-defs = (definition ...)
syntax
(struct-field-index field-id)
syntax
(define-struct id-maybe-super (field ...)
               struct-option ...)
 
id-maybe-super = id
               | (id super-id)
syntax
(struct/derived (id . rest-form)
id (field ...) struct-option ...)
(struct/derived (id . rest-form)
id super-id (field ...) struct-option ...)
syntax
(define-struct/derived (id . rest-form)
  id-maybe-super (field ...) struct-option ...)
procedure
(make-struct-type  name               
                   super-type         
                   init-field-cnt     
                   auto-field-cnt     
                  [auto-v             
                   props              
                   inspector          
                   proc-spec          
                   immutables         
                   guard              
                   constructor-name]) 
 -> struct-type?
    struct-constructor-procedure?
    struct-predicate-procedure?
    struct-accessor-procedure?
    struct-mutator-procedure?
  name : symbol?
  super-type : (or/c struct-type? #f)
  init-field-cnt : exact-nonnegative-integer?
  auto-field-cnt : exact-nonnegative-integer?
  auto-v : any/c = #f
  props : (listof (cons/c struct-type-property? = null
                          any/c))
  inspector : (or/c inspector? #f 'prefab) = (current-inspector)
  proc-spec : (or/c procedure?                 = #f
                    exact-nonnegative-integer?
                    #f)
  immutables : (listof exact-nonnegative-integer?) = null
  guard : (or/c procedure? #f) = #f
  constructor-name : (or/c symbol? #f) = #f
procedure
(make-struct-field-accessor  accessor-proc        
                             field-pos            
                            [field/proc-name      
                             arg-contract-str     
                             realm])          -> procedure?
  accessor-proc : struct-accessor-procedure?
  field-pos : exact-nonnegative-integer?
  field/proc-name : (or/c symbol? #f)
                  = (symbol->string (format "field~a" field-pos))
  arg-contract-str : (or/c string? symbol? #f) = #f
  realm : symbol? = 'racket
procedure
(make-struct-field-mutator  mutator-proc         
                            field-pos            
                           [field/proc-name      
                            arg-contract-str     
                            realm])          -> procedure?
  mutator-proc : struct-mutator-procedure?
  field-pos : exact-nonnegative-integer?
  field/proc-name : (or/c symbol? #f)
                  = (symbol->string (format "field~a" field-pos))
  arg-contract-str : (or/c string? symbol? #f) = #f
  realm : symbol? = 'racket
value
prop:sealed : struct-type-property?
procedure
(make-struct-type-property  name             
                           [guard            
                            supers           
                            can-impersonate? 
                            accessor-name    
                            contract-str     
                            realm])          
 -> struct-type-property?
    (any/c . -> . boolean?)
    procedure?
  name : symbol?
  guard : (or/c procedure? #f 'can-impersonate) = #f
  supers : (listof (cons/c struct-type-property?  = null
                           (any/c . -> . any/c)))
  can-impersonate? : any/c = #f
  accessor-name : (or/c symbol? #f) = #f
  contract-str : (or/c string? symbol? #f) = #f
  realm : symbol? = 'racket
procedure
(struct-type-property? v) -> boolean?
  v : any/c
procedure
(struct-type-property-accessor-procedure? v) -> boolean?
  v : any/c
procedure
(struct-type-property-predicate-procedure?  v          
                                           [prop]) -> boolean?
  v : any/c
  prop : (or/c struct-type-property? #f) = #f
syntax
(define-generics id
  generics-opt ...
  [method-id . kw-formals*] ...
  generics-opt ...)
 
generics-opt = #:defaults ([default-pred? default-impl ...] ...)
             | #:fast-defaults ([fast-pred? fast-impl ...] ...)
             | #:fallbacks [fallback-impl ...]
             | #:defined-predicate defined-pred-id
             | #:defined-table defined-table-id
             | #:derive-property prop-expr prop-value-expr
             | #:requires [required-method-id ...]
                
 kw-formals* = (arg* ...)
             | (arg* ...+ . rest-id)
             | rest-id
                
        arg* = arg-id
             | [arg-id]
             | keyword arg-id
             | keyword [arg-id]
procedure
(raise-support-error name v) -> none/c
  name : symbol?
  v : any/c
struct
(struct exn:fail:support exn:fail ()
    #:transparent)
syntax
(define/generic local-id method-id)
syntax
(generic-instance/c gen-id [method-id method-ctc] ...)
 
  method-ctc : contract?
syntax
(impersonate-generics gen-id val-expr
  [method-id method-proc-expr] ...
  maybe-properties)
 
maybe-properties = 
                 | #:properties props-expr
 
  method-proc-expr : (any/c . -> . any/c)
  props-expr : (list/c impersonator-property? any/c ... ...)
syntax
(chaperone-generics gen-id val-expr
  [method-id method-proc-expr] ...
  maybe-properties)
syntax
(redirect-generics mode gen-id val-expr
   [method-id method-proc-expr] ...
   maybe-properties)
syntax
(make-struct-type-property/generic
  name-expr
  maybe-guard-expr
  maybe-supers-expr
  maybe-can-impersonate?-expr
  property-option
  ...)
 
           maybe-guard-expr = 
                            | guard-expr
                               
          maybe-supers-expr = 
                            | supers-expr
                               
maybe-can-impersonate?-expr = 
                            | can-impersonate?-expr
                               
            property-option = #:property prop-expr val-expr
                            | #:methods gen:name-id method-defs
                               
                method-defs = (definition ...)
 
  name-expr : symbol?
  guard-expr : (or/c procedure? #f 'can-impersonate)
  supers-expr : (listof (cons/c struct-type-property? (-> any/c any/c)))
  can-impersonate?-expr : any/c
  prop-expr : struct-type-property?
  val-expr : any/c
syntax
(make-generic-struct-type-property
   gen:name-id
   method-def
   ...)
syntax
(struct-copy id struct-expr fld-id ...)
 
fld-id = [field-id expr]
       | [field-id #:parent parent-id expr]
procedure
(struct->vector v [opaque-v]) -> vector?
  v : any/c
  opaque-v : any/c = '...
procedure
(struct? v) -> any
  v : any/c
procedure
(struct-type? v) -> boolean?
  v : any/c
procedure
(struct-constructor-procedure? v) -> boolean?
  v : any/c
procedure
(struct-predicate-procedure? v) -> boolean?
  v : any/c
procedure
(struct-accessor-procedure? v) -> boolean?
  v : any/c
procedure
(struct-mutator-procedure? v) -> boolean?
  v : any/c
procedure
(prefab-struct-key v) -> (or/c #f symbol? list?)
  v : any/c
procedure
(make-prefab-struct key v ...) -> struct?
  key : prefab-key?
  v : any/c
procedure
(prefab-struct-type-key+field-count type)
 -> (or/c #f (cons/c prefab-key? (integer-in 0 32768)))
  type : struct-type?
procedure
(prefab-key->struct-type key field-count) -> struct-type?
  key : prefab-key?
  field-count : (integer-in 0 32768)
procedure
(prefab-key? v) -> boolean?
  v : any/c
procedure
(make-constructor-style-printer get-constructor 
                                get-contents)   
 -> (-> any/c output-port? (or/c #t #f 0 1) void?)
  get-constructor : (-> any/c (or/c symbol? string?))
  get-contents : (-> any/c sequence?)
procedure
(struct->list v [#:on-opaque on-opaque]) -> (or/c list? #f)
  v : any/c
  on-opaque : (or/c 'error 'return-false 'skip) = 'error
procedure
(struct-info? v) -> boolean?
  v : any/c
procedure
(checked-struct-info? v) -> boolean?
  v : any/c
procedure
(make-struct-info thunk) -> struct-info?
  thunk : (-> (and/c struct-info? list?))
procedure
(extract-struct-info v) -> (and/c struct-info? list?)
  v : struct-info?
value
struct:struct-info : struct-type?
value
prop:struct-info : struct-type-property?
value
prop:struct-auto-info : struct-type-property?
procedure
(struct-auto-info? v) -> boolean?
  v : any/c
procedure
(struct-auto-info-lists sai)
 -> (list/c (listof identifier?) (listof identifier?))
  sai : struct-auto-info?
value
prop:struct-field-info : struct-type-property?
procedure
(struct-field-info? v) -> boolean?
  v : any/c
procedure
(struct-field-info-list sfi) -> (listof symbol?)
  sfi : struct-field-info?
syntax
(interface (super-interface-expr ...) name-clause ...)
 
name-clause = id
            | (id contract-expr)
syntax
(interface* (super-interface-expr ...)
            ([property-expr val-expr] ...)
  name-clause ...)
 
name-clause = id
            | (id contract-expr)
value
object% : class?
syntax
(class* superclass-expr (interface-expr ...)
  class-clause
  ...)
 
     class-clause = (inspect inspector-expr)
                  | (init init-decl ...)
                  | (init-field init-decl ...)
                  | (field field-decl ...)
                  | (inherit-field maybe-renamed ...)
                  | (init-rest id)
                  | (init-rest)
                  | (public maybe-renamed ...)
                  | (pubment maybe-renamed ...)
                  | (public-final maybe-renamed ...)
                  | (override maybe-renamed ...)
                  | (overment maybe-renamed ...)
                  | (override-final maybe-renamed ...)
                  | (augment maybe-renamed ...)
                  | (augride maybe-renamed ...)
                  | (augment-final maybe-renamed ...)
                  | (private id ...)
                  | (abstract id ...)
                  | (inherit maybe-renamed ...)
                  | (inherit/super maybe-renamed ...)
                  | (inherit/inner maybe-renamed ...)
                  | (rename-super renamed ...)
                  | (rename-inner renamed ...)
                  | method-definition
                  | definition
                  | expr
                  | (begin class-clause ...)
                     
        init-decl = id
                  | (renamed)
                  | (maybe-renamed default-value-expr)
                     
       field-decl = (maybe-renamed default-value-expr)
                     
    maybe-renamed = id
                  | renamed
                     
          renamed = (internal-id external-id)
                     
method-definition = (define-values (id) method-procedure)
                     
 method-procedure = (lambda kw-formals expr ...+)
                  | (case-lambda (formals expr ...+) ...)
                  | (#%plain-lambda formals expr ...+)
                  | (let-values ([(id) method-procedure] ...)
                      method-procedure)
                  | (letrec-values ([(id) method-procedure] ...)
                      method-procedure)
                  | (let-values ([(id) method-procedure] ...+)
                      id)
                  | (letrec-values ([(id) method-procedure] ...+)
                      id)
                  | (chaperone-procedure method-procedure wrapper-proc
                                         other-arg-expr ...)
syntax
(class superclass-expr class-clause ...)
syntax
this
syntax
this%
syntax
(inspect inspector-expr)
syntax
(init init-decl ...)
syntax
(init-field init-decl ...)
syntax
(field field-decl ...)
syntax
(inherit-field maybe-renamed ...)
syntax
(init-rest id)
(init-rest)
syntax
(public maybe-renamed ...)
syntax
(pubment maybe-renamed ...)
syntax
(public-final maybe-renamed ...)
syntax
(override maybe-renamed ...)
syntax
(overment maybe-renamed ...)
syntax
(override-final maybe-renamed ...)
syntax
(augment maybe-renamed ...)
syntax
(augride maybe-renamed ...)
syntax
(augment-final maybe-renamed ...)
syntax
(private id ...)
syntax
(abstract id ...)
syntax
(inherit maybe-renamed ...)
syntax
(inherit/super maybe-renamed ...)
syntax
(inherit/inner maybe-renamed ...)
syntax
(rename-super renamed ...)
syntax
(rename-inner renamed ...)
syntax
(public* (id expr) ...)
syntax
(pubment* (id expr) ...)
syntax
(public-final* (id expr) ...)
syntax
(override* (id expr) ...)
syntax
(overment* (id expr) ...)
syntax
(override-final* (id expr) ...)
syntax
(augment* (id expr) ...)
syntax
(augride* (id expr) ...)
syntax
(augment-final* (id expr) ...)
syntax
(private* (id expr) ...)
syntax
(define/public id expr)
(define/public (id . formals) body ...+)
syntax
(define/pubment id expr)
(define/pubment (id . formals) body ...+)
syntax
(define/public-final id expr)
(define/public-final (id . formals) body ...+)
syntax
(define/override id expr)
(define/override (id . formals) body ...+)
syntax
(define/overment id expr)
(define/overment (id . formals) body ...+)
syntax
(define/override-final id expr)
(define/override-final (id . formals) body ...+)
syntax
(define/augment id expr)
(define/augment (id . formals) body ...+)
syntax
(define/augride id expr)
(define/augride (id . formals) body ...+)
syntax
(define/augment-final id expr)
(define/augment-final (id . formals) body ...+)
syntax
(define/private id expr)
(define/private (id . formals) body ...+)
syntax
(class/derived original-datum
  (name-id super-expr (interface-expr ...) deserialize-id-expr)
  class-clause
  ...)
syntax
(super id arg ...)
(super id arg ... . arg-list-expr)
syntax
(inner default-expr id arg ...)
(inner default-expr id arg ... . arg-list-expr)
syntax
(define-local-member-name id ...)
syntax
(define-member-name id key-expr)
syntax
(member-name-key identifier)
procedure
(generate-member-key) -> member-name-key?
procedure
(member-name-key? v) -> boolean?
  v : any/c
procedure
(member-name-key=? a-key b-key) -> boolean?
  a-key : member-name-key?
  b-key : member-name-key?
procedure
(member-name-key-hash-code a-key) -> integer?
  a-key : member-name-key?
procedure
(make-object class init-v ...) -> object?
  class : class?
  init-v : any/c
syntax
(new class-expr (id by-name-expr) ...)
syntax
(instantiate class-expr (by-pos-expr ...) (id by-name-expr) ...)
syntax
super-make-object
syntax
(super-instantiate (by-pos-expr ...) (id by-expr ...) ...)
syntax
(super-new (id by-name-expr ...) ...)

(method-id arg ... . arg-list-expr)
syntax
(send obj-expr method-id arg ...)
(send obj-expr method-id arg ... . arg-list-expr)
syntax
(send/apply obj-expr method-id arg ... arg-list-expr)
syntax
(send/keyword-apply obj-expr method-id
                    keyword-list-expr value-list-expr
                    arg ... arg-list-expr)
procedure
(dynamic-send obj                    
              method-name            
              v ...                  
              #:<kw> kw-arg ...) -> any
  obj : object?
  method-name : symbol?
  v : any/c
  kw-arg : any/c
syntax
(send* obj-expr msg ...+)
 
msg = (method-id arg ...)
    | (method-id arg ... . arg-list-expr)
syntax
(send+ obj-expr msg ...)
 
msg = (method-id arg ...)
    | (method-id arg ... . arg-list-expr)
syntax
(with-method ([id (obj-expr method-id)] ...)
  body ...+)
syntax
(get-field id obj-expr)
procedure
(dynamic-get-field field-name obj) -> any/c
  field-name : symbol?
  obj : object?
syntax
(set-field! id obj-expr expr)
procedure
(dynamic-set-field! field-name obj v) -> void?
  field-name : symbol?
  obj : object?
  v : any/c
syntax
(field-bound? id obj-expr)
syntax
(class-field-accessor class-expr field-id)
syntax
(class-field-mutator class-expr field-id)
syntax
(generic class-or-interface-expr id)
syntax
(send-generic obj-expr generic-expr arg ...)
(send-generic obj-expr generic-expr arg ... . arg-list-expr)
procedure
(make-generic type method-name) -> generic?
  type : (or/c class? interface?)
  method-name : symbol?
syntax
(mixin (interface-expr ...) (interface-expr ...)
  class-clause ...)
syntax
(trait trait-clause ...)
 
trait-clause = (public maybe-renamed ...)
             | (pubment maybe-renamed ...)
             | (public-final maybe-renamed ...)
             | (override maybe-renamed ...)
             | (overment maybe-renamed ...)
             | (override-final maybe-renamed ...)
             | (augment maybe-renamed ...)
             | (augride maybe-renamed ...)
             | (augment-final maybe-renamed ...)
             | (inherit maybe-renamed ...)
             | (inherit/super maybe-renamed ...)
             | (inherit/inner maybe-renamed ...)
             | method-definition
             | (field field-declaration ...)
             | (inherit-field maybe-renamed ...)
procedure
(trait? v) -> boolean?
  v : any/c
procedure
(trait->mixin tr) -> (class? . -> . class?)
  tr : trait?
procedure
(trait-sum tr ...+) -> trait?
  tr : trait?
syntax
(trait-exclude trait-expr id)
syntax
(trait-exclude-field trait-expr id)
syntax
(trait-alias trait-expr id new-id)
syntax
(trait-rename trait-expr id new-id)
syntax
(trait-rename-field trait-expr id new-id)
syntax
(class/c maybe-opaque member-spec ...)
 
maybe-opaque = 
             | #:opaque
             | #:opaque #:ignore-local-member-names
                
 member-spec = method-spec
             | (field field-spec ...)
             | (init field-spec ...)
             | (init-field field-spec ...)
             | (inherit method-spec ...)
             | (inherit-field field-spec ...)
             | (super method-spec ...)
             | (inner method-spec ...)
             | (override method-spec ...)
             | (augment method-spec ...)
             | (augride method-spec ...)
             | (absent absent-spec ...)
                
 method-spec = method-id
             | (method-id method-contract-expr)
                
  field-spec = field-id
             | (field-id contract-expr)
                
 absent-spec = method-id
             | (field field-id ...)
syntax
(absent absent-spec ...)
syntax
(->m dom ... range)
syntax
(->*m (mandatory-dom ...) (optional-dom ...) rest range)
syntax
(case->m (-> dom ... rest range) ...)
syntax
(->dm (mandatory-dependent-dom ...)
      (optional-dependent-dom ...)
      dependent-rest
      pre-cond
      dep-range)
syntax
(object/c member-spec ...)
 
member-spec = method-spec
            | (field field-spec ...)
               
method-spec = method-id
            | (method-id method-contract)
               
 field-spec = field-id
            | (field-id contract-expr)
procedure
(instanceof/c class-contract) -> contract?
  class-contract : contract?
procedure
(dynamic-object/c method-names         
                  method-contracts     
                  field-names          
                  field-contracts) -> contract?
  method-names : (listof symbol?)
  method-contracts : (listof contract?)
  field-names : (listof symbol?)
  field-contracts : (listof contract?)
syntax
(object-contract member-spec ...)
 
            member-spec = (method-id method-contract)
                        | (field field-id contract-expr)
                           
        method-contract = (-> dom ... range)
                        | (->* (mandatory-dom ...)
                               (optional-dom ...)
                               rest
                               range)
                        | (->d (mandatory-dependent-dom ...)
                               (optional-dependent-dom ...)
                               dependent-rest
                               pre-cond
                               dep-range)
                           
                    dom = dom-expr
                        | keyword dom-expr
                           
                  range = range-expr
                        | (values range-expr ...)
                        | any
                           
          mandatory-dom = dom-expr
                        | keyword dom-expr
                           
           optional-dom = dom-expr
                        | keyword dom-expr
                           
                   rest = 
                        | #:rest rest-expr
                           
mandatory-dependent-dom = [id dom-expr]
                        | keyword [id dom-expr]
                           
 optional-dependent-dom = [id dom-expr]
                        | keyword [id dom-expr]
                           
         dependent-rest = 
                        | #:rest id rest-expr
                           
               pre-cond = 
                        | #:pre-cond boolean-expr
                           
              dep-range = any
                        | [id range-expr] post-cond
                        | (values [id range-expr] ...) post-cond
                           
              post-cond = 
                        | #:post-cond boolean-expr
value
mixin-contract : contract?
procedure
(make-mixin-contract type ...) -> contract?
  type : (or/c class? interface?)
procedure
(is-a?/c type) -> flat-contract?
  type : (or/c class? interface?)
procedure
(implementation?/c interface) -> flat-contract?
  interface : interface?
procedure
(subclass?/c class) -> flat-contract?
  class : class?
interface
equal<%> : interface?
syntax
(define-serializable-class* class-id superclass-expr
                                     (interface-expr ...)
  class-clause ...)
syntax
(define-serializable-class class-id superclass-expr
  class-clause ...)
interface
externalizable<%> : interface?
value
printable<%> : interface?
value
writable<%> : interface?
procedure
(object? v) -> boolean?
  v : any/c
procedure
(class? v) -> boolean?
  v : any/c
procedure
(interface? v) -> boolean?
  v : any/c
procedure
(generic? v) -> boolean?
  v : any/c
procedure
(object=? a b) -> boolean?
  a : object?
  b : object?
procedure
(object-or-false=? a b) -> boolean?
  a : (or/c object? #f)
  b : (or/c object? #f)
procedure
(object=-hash-code o) -> fixnum?
  o : object?
procedure
(object->vector object [opaque-v]) -> vector?
  object : object?
  opaque-v : any/c = #f
procedure
(class->interface class) -> interface?
  class : class?
procedure
(object-interface object) -> interface?
  object : object?
procedure
(is-a? v type) -> boolean?
  v : any/c
  type : (or/c interface? class?)
procedure
(subclass? v cls) -> boolean?
  v : any/c
  cls : class?
procedure
(implementation? v intf) -> boolean?
  v : any/c
  intf : interface?
procedure
(interface-extension? v intf) -> boolean?
  v : any/c
  intf : interface?
procedure
(method-in-interface? sym intf) -> boolean?
  sym : symbol?
  intf : interface?
procedure
(interface->method-names intf) -> (listof symbol?)
  intf : interface?
procedure
(object-method-arity-includes? object     
                               sym        
                               cnt)   -> boolean?
  object : object?
  sym : symbol?
  cnt : exact-nonnegative-integer?
procedure
(field-names object) -> (listof symbol?)
  object : object?
procedure
(object-info object) -> (or/c class? #f) boolean?
  object : object?
procedure
(class-info class)
 -> symbol?
    exact-nonnegative-integer?
    (listof symbol?)
    (any/c exact-nonnegative-integer? . -> . any/c)
    (any/c exact-nonnegative-integer? any/c . -> . any/c)
    (or/c class? #f)
    boolean?
  class : class?
struct
(struct exn:fail:object exn:fail ()
    #:extra-constructor-name make-exn:fail:object)
procedure
(class-seal class                
            key                  
            unsealed-inits       
            unsealed-fields      
            unsealed-methods     
            inst-proc            
            member-proc)     -> class?
  class : class?
  key : symbol?
  unsealed-inits : (listof symbol?)
  unsealed-fields : (listof symbol?)
  unsealed-methods : (listof symbol?)
  inst-proc : (-> class? any)
  member-proc : (-> class? (listof symbol?) any)
procedure
(class-unseal class key wrong-key-proc) -> class?
  class : class?
  key : symbol?
  wrong-key-proc : (-> class? any)
syntax
(surrogate use-wrapper-proc method-spec ...)
 
use-wrapper-proc = #:use-wrapper-proc
                 | 
                    
     method-spec = (augment default-expr method-id arg-spec ...)
                 | (override method-id arg-spec ...)
                    
        arg-spec = (id ...)
                 | id
syntax
(unit
  (import tagged-sig-spec ...)
  (export tagged-sig-spec ...)
  init-depends-decl
  unit-body-expr-or-defn
  ...)
 
  tagged-sig-spec = sig-spec
                  | (tag id sig-spec)
                     
         sig-spec = sig-id
                  | (prefix id sig-spec)
                  | (rename sig-spec (id id) ...)
                  | (only sig-spec id ...)
                  | (except sig-spec id ...)
                     
init-depends-decl = 
                  | (init-depend tagged-sig-id ...)
                     
    tagged-sig-id = sig-id
                  | (tag id sig-id)
syntax
(define-signature sig-id extension-decl
  (sig-elem ...))
 
extension-decl = 
               | extends sig-id
                  
      sig-elem = id
               | (define-syntaxes (id ...) expr)
               | (define-values (id ...) expr)
               | (define-values-for-export (id ...) expr)
               | (contracted [id contract] ...)
               | (open sig-spec)
               | (struct id (field ...) struct-option ...)
               | (sig-form-id . datum)
                  
         field = id
               | [id #:mutable]
                  
 struct-option = #:mutable
               | #:constructor-name constructor-id
               | #:extra-constructor-name constructor-id
               | #:omit-constructor
               | #:omit-define-syntaxes
               | #:omit-define-values
syntax
(open sig-spec)
syntax
(define-values-for-export (id ...) expr)
syntax
(contracted [id contract] ...)
syntax
(only sig-spec id ...)
syntax
(except sig-spec id ...)
syntax
(rename sig-spec (id id) ...)
syntax
(prefix id sig-spec)
syntax
(import tagged-sig-spec ...)
syntax
(export tagged-sig-spec ...)
syntax
(link linkage-decl ...)
syntax
(tag id sig-spec)
(tag id sig-id)
syntax
(init-depend tagged-sig-id ...)
syntax
extends
syntax
(invoke-unit unit-expr)
(invoke-unit unit-expr (import tagged-sig-spec ...))
syntax
(define-values/invoke-unit unit-expr
  (import tagged-sig-spec ...)
  (export tagged-sig-spec ...))
syntax
(compound-unit
  (import link-binding ...)
  (export tagged-link-id ...)
  (link linkage-decl ...))
 
  link-binding = (link-id : tagged-sig-id)
                  
tagged-link-id = (tag id link-id)
               | link-id
                  
  linkage-decl = ((link-binding ...) unit-expr tagged-link-id ...)
syntax
(define-unit unit-id
  (import tagged-sig-spec ...)
  (export tagged-sig-spec ...)
  init-depends-decl
  unit-body-expr-or-defn
  ...)
syntax
(compound-unit/infer
  (import tagged-infer-link-import ...)
  (export tagged-infer-link-export ...)
  (link infer-linkage-decl ...))
 
tagged-infer-link-import = tagged-sig-id
                         | (link-id : tagged-sig-id)
                            
tagged-infer-link-export = (tag id infer-link-export)
                         | infer-link-export
                            
       infer-link-export = link-id
                         | sig-id
                            
      infer-linkage-decl = ((link-binding ...) unit-id
                                               tagged-link-id ...)
                         | unit-id
syntax
(define-compound-unit id
  (import link-binding ...)
  (export tagged-link-id ...)
  (link linkage-decl ...))
syntax
(define-compound-unit/infer id
  (import link-binding ...)
  (export tagged-infer-link-export ...)
  (link infer-linkage-decl ...))
syntax
(define-unit-binding unit-id
  unit-expr
  (import tagged-sig-spec ...+)
  (export tagged-sig-spec ...+)
  init-depends-decl)
syntax
(invoke-unit/infer unit-spec)
 
unit-spec = unit-id
          | (link link-unit-id ...)
syntax
(define-values/invoke-unit/infer maybe-exports unit-spec)
 
maybe-exports = 
              | (export tagged-sig-spec ...)
                 
    unit-spec = unit-id
              | (link link-unit-id ...)
syntax
(unit-from-context tagged-sig-spec)
syntax
(define-unit-from-context id tagged-sig-spec)
syntax
(unit/new-import-export
  (import tagged-sig-spec ...)
  (export tagged-sig-spec ...)
  init-depends-decl
  ((tagged-sig-spec ...) unit-expr tagged-sig-spec))
syntax
(define-unit/new-import-export unit-id
  (import tagged-sig-spec ...)
  (export tagged-sig-spec ...)
  init-depends-decl
  ((tagged-sig-spec ...) unit-expr tagged-sig-spec))
syntax
(unit/s
  (import tagged-sig-spec ...)
  (export tagged-sig-spec ...)
  init-depends-decl
  unit-id)
syntax
(define-unit/s name-id
  (import tagged-sig-spec ...)
  (export tagged-sig-spec ...)
  init-depends-decl
  unit-id)
syntax
(define-signature-form sig-form-id expr)
(define-signature-form (sig-form-id id) body ...+)
(define-signature-form (sig-form-id id intro-id) body ...+)
syntax
(struct/ctc id ([field contract-expr] ...) struct-option ...)
 
        field = id
              | [id #:mutable]
                 
struct-option = #:mutable
              | #:omit-constructor
              | #:omit-define-syntaxes
              | #:omit-define-values
procedure
(unit? v) -> boolean?
  v : any/c
syntax
(provide-signature-elements sig-spec ...)
syntax
(unit/c
  (import sig-block ...)
  (export sig-block ...)
  init-depends-decl
  optional-body-ctc)
 
        sig-block = (tagged-sig-id [id contract] ...)
                  | tagged-sig-id
                     
init-depends-decl = 
                  | (init-depend tagged-sig-id ...)
                     
optional-body-ctc = 
                  | contract
                  | (values contract ...)
syntax
(define-unit/contract unit-id
  (import sig-spec-block ...)
  (export sig-spec-block ...)
  init-depends-decl
  optional-body-ctc
  unit-body-expr-or-defn
  ...)
 
   sig-spec-block = (tagged-sig-spec [id contract] ...)
                  | tagged-sig-spec
                     
optional-body-ctc = 
                  | #:invoke/contract contract
                  | #:invoke/contract (values contract ...)
procedure
(unit-static-signatures unit-identifier 
                        err-syntax)     
 -> (list/c (cons/c (or/c symbol? #f)
                    identifier?))
    (list/c (cons/c (or/c symbol? #f)
                    identifier?))
  unit-identifier : identifier?
  err-syntax : syntax?
procedure
(signature-members sig-identifier     
                   err-syntax)    -> (or/c identifier? #f)
                                     (listof identifier?)
                                     (listof identifier?)
                                     (listof identifier?)
  sig-identifier : identifier?
  err-syntax : syntax?
procedure
(unit-static-init-dependencies unit-identifier 
                               err-syntax)     
 -> (list/c (cons/c (or/c symbol? #f)
                    identifier?))
  unit-identifier : identifier?
  err-syntax : syntax?
procedure
(flat-contract-with-explanation  get-explanation 
                                [#:name name])   
 -> flat-contract?
  get-explanation : (-> any/c (or/c boolean? (-> blame? any)))
  name : any/c = (object-name get-explanation)
procedure
(flat-named-contract  name              
                      flat-contract     
                     [generator])   -> flat-contract?
  name : any/c
  flat-contract : flat-contract?
  generator : (or/c #f (-> exact-nonnegative-integer? (-> any/c)))
            = #f
value
any/c : flat-contract?
value
none/c : flat-contract?
procedure
(or/c contract ...) -> contract?
  contract : contract?
procedure
(first-or/c contract ...) -> contract?
  contract : contract?
procedure
(and/c contract ...) -> contract?
  contract : contract?
procedure
(not/c flat-contract) -> flat-contract?
  flat-contract : flat-contract?
procedure
(=/c z) -> flat-contract?
  z : real?
procedure
(</c n) -> flat-contract?
  n : real?
procedure
(>/c n) -> flat-contract?
  n : real?
procedure
(<=/c n) -> flat-contract?
  n : real?
procedure
(>=/c n) -> flat-contract?
  n : real?
procedure
(between/c n m) -> flat-contract?
  n : real?
  m : real?
procedure
(real-in n m) -> flat-contract?
  n : real?
  m : real?
procedure
(integer-in j k) -> flat-contract?
  j : (or/c exact-integer? #f)
  k : (or/c exact-integer? #f)
procedure
(char-in a b) -> flat-contract?
  a : char?
  b : char?
value
natural-number/c : flat-contract?
procedure
(string-len/c len) -> flat-contract?
  len : real?
value
false/c : flat-contract?
value
printable/c : flat-contract?
procedure
(one-of/c v ...+) -> flat-contract?
  v : any/c
procedure
(symbols sym ...+) -> flat-contract?
  sym : symbol?
procedure
(vectorof  c                         
          [#:immutable immutable     
           #:flat? flat?             
           #:eager eager])       -> contract?
  c : contract?
  immutable : (or/c #t #f 'dont-care) = 'dont-care
  flat? : boolean? = #f
  eager : (or/c #t #f exact-nonnegative-integer?) = #t
procedure
(vector-immutableof c) -> contract?
  c : contract?
procedure
(vector/c  c                         
           ...                       
          [#:immutable immutable     
           #:flat? flat?])       -> contract?
  c : contract?
  immutable : (or/c #t #f 'dont-care) = 'dont-care
  flat? : boolean? = #f
procedure
(vector-immutable/c c ...) -> contract?
  c : contract?
procedure
(box/c  in-c                      
       [c                         
        #:immutable immutable     
        #:flat? flat?])       -> contract?
  in-c : contract?
  c : contract? = in-c
  immutable : (or/c #t #f 'dont-care) = 'dont-care
  flat? : boolean? = #f
procedure
(box-immutable/c c) -> contract?
  c : contract?
procedure
(listof c) -> list-contract?
  c : contract?
procedure
(non-empty-listof c) -> list-contract?
  c : contract?
procedure
(list*of ele-c [last-c]) -> contract?
  ele-c : contract?
  last-c : contract? = ele-c
procedure
(cons/c car-c cdr-c) -> contract?
  car-c : contract?
  cdr-c : contract?
syntax
(cons/dc [car-id contract-expr] [cdr-id (car-id) contract-expr] cons/dc-option)
(cons/dc [car-id (cdr-id) contract-expr] [cdr-id contract-expr] cons/dc-option)
 
cons/dc-option = 
               | #:flat
               | #:chaperone
               | #:impersonator
procedure
(list/c c ...) -> list-contract?
  c : contract?
procedure
(*list/c prefix suffix ...) -> list-contract?
  prefix : contract?
  suffix : contract?
procedure
(syntax/c c) -> flat-contract?
  c : flat-contract?
syntax
(struct/c struct-id contract-expr ...)
syntax
(struct/dc struct-id field-spec ... maybe-inv)
 
         field-spec = [field-name maybe-lazy contract-expr]
                    | [field-name (dep-field-name ...)
                                  maybe-lazy
                                  maybe-contract-type
                                  maybe-dep-state
                                  contract-expr]
                       
         field-name = field-id
                    | (#:selector selector-id)
                    | (field-id #:parent struct-id)
                       
         maybe-lazy = 
                    | #:lazy
                       
maybe-contract-type = 
                    | #:flat
                    | #:chaperone
                    | #:impersonator
                       
    maybe-dep-state = 
                    | #:depends-on-state
                       
          maybe-inv = 
                    | #:inv (dep-field-name ...) invariant-expr
procedure
(parameter/c  in                                  
             [out                                 
              #:impersonator? impersonator?]) -> contract?
  in : contract?
  out : contract? = in
  impersonator? : any/c = #t
procedure
(procedure-arity-includes/c n) -> flat-contract?
  n : exact-nonnegative-integer?
procedure
(hash/c  key                       
         val                       
        [#:immutable immutable     
         #:flat? flat?])       -> contract?
  key : chaperone-contract?
  val : contract?
  immutable : (or/c #t #f 'dont-care) = 'dont-care
  flat? : boolean? = #f
syntax
(hash/dc [key-id key-contract-expr] [value-id (key-id) value-contract-expr]
         hash/dc-option)
 
hash/dc-option = 
               | #:immutable immutable?-expr hash/dc-option
               | #:kind kind-expr hash/dc-option
procedure
(channel/c val) -> contract?
  val : contract?
syntax
(prompt-tag/c contract ... maybe-call/cc)
 
maybe-call/cc = 
              | #:call/cc contract
              | #:call/cc (values contract ...)
 
  contract : contract?
procedure
(continuation-mark-key/c contract) -> contract?
  contract : contract?
procedure
(evt/c contract ...) -> chaperone-contract?
  contract : chaperone-contract?
syntax
(flat-rec-contract id flat-contract-expr ...)
syntax
(flat-murec-contract ([id flat-contract-expr ...] ...) body ...+)
syntax
any
procedure
(promise/c c) -> contract?
  c : contract?
procedure
(flat-contract predicate) -> flat-contract?
  predicate : (-> any/c any/c)
procedure
(flat-contract-predicate v) -> (-> any/c any/c)
  v : flat-contract?
procedure
(property/c accessor ctc [#:name name]) -> flat-contract?
  accessor : (-> any/c any/c)
  ctc : flat-contract?
  name : any/c = (object-name accessor)
procedure
(suggest/c c field message) -> contract?
  c : contract?
  field : string?
  message : string?
syntax
(-> dom ... range)
(-> dom ... ellipsis dom-expr ... range)
 
     dom = dom-expr
         | keyword dom-expr
            
   range = range-expr
         | (values range-expr ...)
         | any
            
ellipsis = ...
syntax
(->* (mandatory-dom ...) optional-doms rest pre range post)
 
mandatory-dom = dom-expr
              | keyword dom-expr
                 
optional-doms = 
              | (optional-dom ...)
                 
 optional-dom = dom-expr
              | keyword dom-expr
                 
         rest = 
              | #:rest rest-expr
                 
          pre = 
              | #:pre pre-cond-expr
              | #:pre/desc pre-cond-expr
                 
        range = range-expr
              | (values range-expr ...)
              | any
                 
         post = 
              | #:post post-cond-expr
              | #:post/desc post-cond-expr
syntax
(->i maybe-chaperone
     (mandatory-dependent-dom ...)
     dependent-rest
     pre-condition
     param-value
     dependent-range
     post-condition)
(->i maybe-chaperone
     (mandatory-dependent-dom ...)
     (optional-dependent-dom ...)
     dependent-rest
     pre-condition
     param-value
     dependent-range
     post-condition)
 
        maybe-chaperone = #:chaperone
                        | 
                           
mandatory-dependent-dom = id+ctc
                        | keyword id+ctc
                           
 optional-dependent-dom = id+ctc
                        | keyword id+ctc
                           
         dependent-rest = 
                        | #:rest id+ctc
                           
          pre-condition = 
                        | #:pre (id ...)
                          boolean-expr pre-condition
                        | #:pre/desc (id ...)
                          expr pre-condition
                        | #:pre/name (id ...)
                          string boolean-expr pre-condition
                           
            param-value = 
                        | #:param (id ...)
                          param-expr val-expr param-value
                           
        dependent-range = any
                        | id+ctc
                        | un+ctc
                        | (values id+ctc ...)
                        | (values un+ctc ...)
                           
         post-condition = 
                        | #:post (id ...)
                          boolean-expr post-condition
                        | #:post/desc (id ...)
                          expr post-condition
                        | #:post/name (id ...)
                          string boolean-expr post-condition
                           
                 id+ctc = [id contract-expr]
                        | [id (id ...) contract-expr]
                           
                 un+ctc = [_ contract-expr]
                        | [_ (id ...) contract-expr]
syntax
(->d (mandatory-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
(->d (mandatory-dependent-dom ...)
     (optional-dependent-dom ...)
     dependent-rest
     pre-condition
     dependent-range
     post-condition)
 
mandatory-dependent-dom = [id dom-expr]
                        | keyword [id dom-expr]
                           
 optional-dependent-dom = [id dom-expr]
                        | keyword [id dom-expr]
                           
         dependent-rest = 
                        | #:rest id rest-expr
                           
          pre-condition = 
                        | #:pre boolean-expr
                        | #:pre-cond boolean-expr
                           
        dependent-range = any
                        | [_ range-expr]
                        | (values [_ range-expr] ...)
                        | [id range-expr]
                        | (values [id range-expr] ...)
                           
         post-condition = 
                        | #:post-cond boolean-expr
syntax
(case-> (-> dom-expr ... rest range) ...)
 
 rest = 
      | #:rest rest-expr
         
range = range-expr
      | (values range-expr ...)
      | any
procedure
(dynamic->*                                                            
            [#:mandatory-domain-contracts mandatory-domain-contracts   
             #:optional-domain-contracts optional-domain-contracts     
             #:mandatory-keywords mandatory-keywords                   
             #:mandatory-keyword-contracts mandatory-keyword-contracts 
             #:optional-keywords optional-keywords                     
             #:optional-keyword-contracts optional-keyword-contracts   
             #:rest-contract rest-contract]                            
             #:range-contracts range-contracts)                        
 -> contract?
  mandatory-domain-contracts : (listof contract?) = '()
  optional-domain-contracts : (listof contract?) = '()
  mandatory-keywords : (listof keyword?) = '()
  mandatory-keyword-contracts : (listof contract?) = '()
  optional-keywords : (listof keyword?) = '()
  optional-keyword-contracts : (listof contract?) = '()
  rest-contract : (or/c #f contract?) = #f
  range-contracts : (or/c #f (listof contract?))
syntax
(unconstrained-domain-> range-expr ...)
value
predicate/c : contract?
value
the-unsupplied-arg : unsupplied-arg?
procedure
(unsupplied-arg? v) -> boolean?
  v : any/c
syntax
(parametric->/c (x ...) c)
procedure
(new-∀/c [name]) -> contract?
  name : (or/c symbol? #f) = #f
procedure
(new-∃/c [name]) -> contract?
  name : (or/c symbol? #f) = #f
syntax
(contract-struct id (field-id ...))

(id/dc field-spec ...)
 
field-spec = [field-id contract-expr]
           | [field-id (field-id ...) contract-expr]
syntax
(define-contract-struct id (field-id ...))
procedure
(struct-type-property/c value-contract) -> contract?
  value-contract : contract?
syntax
(contract-out unprotected-submodule contract-out-item ...)
 
unprotected-submodule = 
                      | #:unprotected-submodule submodule-name
                         
    contract-out-item = (struct id/ignored ((id contract-expr) ...)
                          struct-option)
                      | (rename orig-id id contract-expr)
                      | (id contract-expr)
                      | #:∃ poly-variables
                      | #:exists poly-variables
                      | #:∀ poly-variables
                      | #:forall poly-variables
                         
       poly-variables = id
                      | (id ...)
                         
           id/ignored = id
                      | (id ignored-id)
                         
        struct-option = 
                      | #:omit-constructor
syntax
(recontract-out id ...)
syntax
(provide/contract unprotected-submodule contract-out-item ...)
syntax
(struct-guard/c contract-expr ...)
syntax
(with-contract blame-id (wc-export ...) free-var-list ... body ...+)
(with-contract blame-id results-spec free-var-list ... body ...+)
 
    wc-export = (id contract-expr)
                 
  result-spec = #:result contract-expr
              | #:results (contract-expr ...)
                 
free-var-list = 
              | #:freevar id contract-expr
              | #:freevars ([id contract-expr] ...)
syntax
(define/contract id contract-expr free-var-list init-value-expr)
(define/contract (head args) contract-expr free-var-list body ...+)
syntax
(struct/contract struct-id ([field contract-expr] ...)
                        struct-option ...)
(struct/contract struct-id super-struct-id
                        ([field contract-expr] ...)
                        struct-option ...)
syntax
(define-struct/contract struct-id ([field contract-expr] ...)
                        struct-option ...)
(define-struct/contract (struct-id super-struct-id)
                        ([field contract-expr] ...)
                        struct-option ...)
syntax
(invariant-assertion invariant-expr expr)
syntax
current-contract-region
syntax
(define-module-boundary-contract id
  orig-id
  contract-expr
  pos-blame-party
  source-loc
  name-for-blame
  context-limit)
 
pos-blame-party = 
                | #:pos-source pos-source-expr
                   
     source-loc = 
                | #:srcloc srcloc-expr
                   
 name-for-blame = 
                | #:name-for-blame blame-id
                   
  context-limit = 
                | #:context-limit limit-expr
syntax
(contract contract-expr to-protect-expr
          positive-blame-expr negative-blame-expr)
(contract contract-expr to-protect-expr
          positive-blame-expr negative-blame-expr
          #:context-limit limit-expr)
(contract contract-expr to-protect-expr
          positive-blame-expr negative-blame-expr
          value-name-expr source-location-expr)
procedure
(make-contract                                                              
               [#:name name                                                 
                #:first-order first-order                                   
                #:late-neg-projection late-neg-proj                         
                #:collapsible-late-neg-projection collapsible-late-neg-proj 
                #:val-first-projection val-first-proj                       
                #:projection proj                                           
                #:stronger stronger                                         
                #:equivalent equivalent                                     
                #:list-contract? is-list-contract?])                        
 -> contract?
  name : any/c = 'anonymous-contract
  first-order : (-> any/c any/c) = (λ (x) #t)
  late-neg-proj : (or/c #f (-> blame? (-> any/c any/c any/c)))
                = #f
  collapsible-late-neg-proj : (or/c #f (-> blame? (values (-> any/c any/c any/c) collapsible-contract?)))
                            = #f
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c))))
                 = #f
  proj : (-> blame? (-> any/c any/c))
       = (λ (b)
           (λ (x)
             (if (first-order x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e")
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f
  is-list-contract? : boolean? = #f
procedure
(make-chaperone-contract                                                              
                         [#:name name                                                 
                          #:first-order first-order                                   
                          #:late-neg-projection late-neg-proj                         
                          #:collapsible-late-neg-projection collapsible-late-neg-proj 
                          #:val-first-projection val-first-proj                       
                          #:projection proj                                           
                          #:stronger stronger                                         
                          #:equivalent equivalent                                     
                          #:list-contract? is-list-contract?])                        
 -> chaperone-contract?
  name : any/c = 'anonymous-chaperone-contract
  first-order : (-> any/c any/c) = (λ (x) #t)
  late-neg-proj : (or/c #f (-> blame? (-> any/c any/c any/c)))
                = #f
  collapsible-late-neg-proj : (or/c #f (-> blame? (values (-> any/c any/c any/c) collapsible-contract?)))
                            = #f
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c))))
                 = #f
  proj : (-> blame? (-> any/c any/c))
       = (λ (b)
           (λ (x)
             (if (first-order x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e")
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f
  is-list-contract? : boolean? = #f
procedure
(make-flat-contract                                                              
                    [#:name name                                                 
                     #:first-order first-order                                   
                     #:late-neg-projection late-neg-proj                         
                     #:collapsible-late-neg-projection collapsible-late-neg-proj 
                     #:val-first-projection val-first-proj                       
                     #:projection proj                                           
                     #:stronger stronger                                         
                     #:equivalent equivalent                                     
                     #:list-contract? is-list-contract?])                        
 -> flat-contract?
  name : any/c = 'anonymous-flat-contract
  first-order : (-> any/c any/c) = (λ (x) #t)
  late-neg-proj : (or/c #f (-> blame? (-> any/c any/c any/c)))
                = #f
  collapsible-late-neg-proj : (or/c #f (-> blame? (values (-> any/c any/c any/c) collapsible-contract?)))
                            = #f
  val-first-proj : (or/c #f (-> blame? (-> any/c (-> any/c any/c))))
                 = #f
  proj : (-> blame? (-> any/c any/c))
       = (λ (b)
           (λ (x)
             (if (first-order x)
               x
               (raise-blame-error
                b x
                '(expected: "~a" given: "~e")
                name x))))
  stronger : (or/c #f (-> contract? contract? boolean?)) = #f
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f
  is-list-contract? : boolean? = #f
procedure
(build-compound-type-name c/s ...) -> any
  c/s : any/c
procedure
(coerce-contract id v) -> contract?
  id : symbol?
  v : any/c
procedure
(coerce-contracts id vs) -> (listof contract?)
  id : symbol?
  vs : (listof any/c)
procedure
(coerce-chaperone-contract id v) -> chaperone-contract?
  id : symbol?
  v : any/c
procedure
(coerce-chaperone-contracts id vs)
 -> (listof chaperone-contract?)
  id : symbol?
  vs : (listof any/c)
procedure
(coerce-flat-contract id v) -> flat-contract?
  id : symbol?
  v : any/c
procedure
(coerce-flat-contracts id v) -> (listof flat-contract?)
  id : symbol?
  v : (listof any/c)
procedure
(coerce-contract/f v) -> (or/c contract? #f)
  v : any/c
parameter
(skip-projection-wrapper?) -> boolean?
(skip-projection-wrapper? wrap?) -> void?
  wrap? : boolean?
 = #f
syntax
(with-contract-continuation-mark blame body ...)
(with-contract-continuation-mark blame+neg-party body ...)
syntax
(contract-pos/neg-doubling e1 e2)
procedure
(blame? v) -> boolean?
  v : any/c
procedure
(raise-blame-error b                                 
                   #:missing-party missing-party     
                   v                                 
                   fmt                               
                   v-fmt ...)                    -> none/c
  b : blame?
  missing-party : #f
  v : any/c
  fmt : (or/c string?
              (listof (or/c string?
                            'given 'given:
                            'expected 'expected:)))
  v-fmt : any/c
procedure
(blame-add-context  blame                     
                    context                   
                   [#:important important     
                    #:swap? swap?])       -> blame?
  blame : blame?
  context : (or/c string? #f)
  important : (or/c string? #f) = #f
  swap? : boolean? = #f
procedure
(blame-context blame) -> (listof string?)
  blame : blame?
procedure
(blame-positive b) -> any/c
  b : blame?
procedure
(blame-negative b) -> any/c
  b : blame?
procedure
(blame-contract b) -> any/c
  b : blame?
procedure
(blame-value b) -> any/c
  b : blame?
procedure
(blame-source b) -> srcloc?
  b : blame?
procedure
(blame-swap b) -> blame?
  b : blame?
procedure
(blame-original? b) -> boolean?
  b : blame?
procedure
(blame-swapped? b) -> boolean?
  b : blame?
procedure
(blame-replace-negative b neg) -> blame?
  b : blame?
  neg : any/c
procedure
(blame-replaced-negative? b) -> boolean?
  b : blame?
procedure
(blame-update b pos neg) -> blame?
  b : blame?
  pos : any/c
  neg : any/c
procedure
(blame-missing-party? b) -> boolean?
  b : blame?
procedure
(blame-add-missing-party b missing-party)
 -> (and/c blame? (not/c blame-missing-party?))
  b : (and/c blame? blame-missing-party?)
  missing-party : any/c
struct
(struct exn:fail:contract:blame exn:fail:contract (object)
    #:extra-constructor-name make-exn:fail:contract:blame)
  object : blame?
parameter
(current-blame-format) -> (-> blame? any/c string? string?)
(current-blame-format proc) -> void?
  proc : (-> blame? any/c string? string?)
value
prop:contract : struct-type-property?
value
prop:chaperone-contract : struct-type-property?
value
prop:flat-contract : struct-type-property?
value
prop:contracted : struct-type-property?
value
impersonator-prop:contracted : impersonator-property?
value
prop:blame : struct-type-property?
value
impersonator-prop:blame : impersonator-property?
procedure
(build-flat-contract-property                                                              
                              [#:name get-name                                             
                               #:first-order get-first-order                               
                               #:late-neg-projection late-neg-proj                         
                               #:collapsible-late-neg-projection collapsible-late-neg-proj 
                               #:val-first-projection val-first-proj                       
                               #:projection get-projection                                 
                               #:stronger stronger                                         
                               #:equivalent equivalent                                     
                               #:generate generate                                         
                               #:list-contract? is-list-contract?])                        
 -> flat-contract-property?
  get-name : (-> contract? any/c)
           = (λ (c) 'anonymous-flat-contract)
  get-first-order : (-> contract? (-> any/c boolean?))
                  = (λ (c) (λ (x) #t))
  late-neg-proj : (or/c #f (-> contract? (-> blame? (-> any/c any/c any/c))))
                = #f
  collapsible-late-neg-proj : (or/c #f (-> contract? (-> blame? (values (-> any/c any/c any/c) collapsible-contract?))))
                            = #f
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c))))
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c)))
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e")
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f
  generate : (->i ([c contract?])
                  [generator
                   (c)
                   (-> exact-nonnegative-integer?
                       (or/c (-> (or/c contract-random-generate-fail? c))
                             #f))])
           = (λ (c) (λ (fuel) #f))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f)
procedure
(build-chaperone-contract-property                                                              
                                   [#:name get-name                                             
                                    #:first-order get-first-order                               
                                    #:late-neg-projection late-neg-proj                         
                                    #:collapsible-late-neg-projection collapsible-late-neg-proj 
                                    #:val-first-projection val-first-proj                       
                                    #:projection get-projection                                 
                                    #:stronger stronger                                         
                                    #:equivalent equivalent                                     
                                    #:generate generate                                         
                                    #:exercise exercise                                         
                                    #:list-contract? is-list-contract?])                        
 -> chaperone-contract-property?
  get-name : (-> contract? any/c)
           = (λ (c) 'anonymous-chaperone-contract)
  get-first-order : (-> contract? (-> any/c boolean?))
                  = (λ (c) (λ (x) #t))
  late-neg-proj : (or/c #f (-> contract? (-> blame? (-> any/c any/c any/c))))
                = #f
  collapsible-late-neg-proj : (or/c #f (-> contract? (-> blame? (values (-> any/c any/c any/c) collapsible-contract?))))
                            = #f
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c))))
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c)))
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e")
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f
  generate : (->i ([c contract?])
                  [generator
                   (c)
                   (-> exact-nonnegative-integer?
                       (or/c (-> (or/c contract-random-generate-fail? c))
                             #f))])
           = (λ (c) (λ (fuel) #f))
  exercise : (->i ([c contract?])
                  [result
                   (c)
                   (-> exact-nonnegative-integer?
                       (values
                        (-> c void?)
                        (listof contract?)))])
           = (λ (c) (λ (fuel) (values void '())))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f)
procedure
(build-contract-property                                                              
                         [#:name get-name                                             
                          #:first-order get-first-order                               
                          #:late-neg-projection late-neg-proj                         
                          #:collapsible-late-neg-projection collapsible-late-neg-proj 
                          #:val-first-projection val-first-proj                       
                          #:projection get-projection                                 
                          #:stronger stronger                                         
                          #:equivalent equivalent                                     
                          #:generate generate                                         
                          #:exercise exercise                                         
                          #:list-contract? is-list-contract?])                        
 -> contract-property?
  get-name : (-> contract? any/c) = (λ (c) 'anonymous-contract)
  get-first-order : (-> contract? (-> any/c boolean?))
                  = (λ (c) (λ (x) #t))
  late-neg-proj : (or/c #f (-> contract? (-> blame? (-> any/c any/c any/c))))
                = #f
  collapsible-late-neg-proj : (or/c #f (-> contract? (-> blame? (values (-> any/c any/c any/c) collapsible-contract?))))
                            = #f
  val-first-proj : (or/c #f (-> contract? blame? (-> any/c (-> any/c any/c))))
                 = #f
  get-projection : (-> contract? (-> blame? (-> any/c any/c)))
                 = (λ (c)
                     (λ (b)
                       (λ (x)
                         (if ((get-first-order c) x)
                             x
                             (raise-blame-error
                              b x '(expected: "~a" given: "~e")
                              (get-name c) x)))))
  stronger : (or/c (-> contract? contract? boolean?) #f) = #f
  equivalent : (or/c #f (-> contract? contract? boolean?)) = #f
  generate : (->i ([c contract?])
                  [generator
                   (c)
                   (-> exact-nonnegative-integer?
                       (or/c (-> (or/c contract-random-generate-fail? c))
                             #f))])
           = (λ (c) (λ (fuel) #f))
  exercise : (->i ([c contract?])
                  [result
                   (c)
                   (-> exact-nonnegative-integer?
                       (values
                        (-> c void?)
                        (listof contract?)))])
           = (λ (c) (λ (fuel) (values void '())))
  is-list-contract? : (-> contract? boolean?) = (λ (c) #f)
procedure
(contract-property? v) -> boolean?
  v : any/c
procedure
(chaperone-contract-property? v) -> boolean?
  v : any/c
procedure
(flat-contract-property? v) -> boolean?
  v : any/c
syntax
(define/final-prop header body ...)
 
header = main-id
       | (main-id id ...)
       | (main-id id ... . id)
syntax
(define/subexpression-pos-prop header body ...)
 
header = main-id
       | (main-id id ...)
       | (main-id id ... . id)
procedure
(contract-stronger? c1 c2) -> boolean?
  c1 : contract?
  c2 : contract?
procedure
(contract-equivalent? c1 c2) -> boolean?
  c1 : contract?
  c2 : contract?
procedure
(contract-first-order-passes? contract v) -> boolean?
  contract : contract?
  v : any/c
procedure
(contract-first-order c) -> (-> any/c boolean?)
  c : contract?
procedure
(contract? v) -> boolean?
  v : any/c
procedure
(chaperone-contract? v) -> boolean?
  v : any/c
procedure
(impersonator-contract? v) -> boolean?
  v : any/c
procedure
(flat-contract? v) -> boolean?
  v : any/c
procedure
(list-contract? v) -> boolean?
  v : any/c
procedure
(contract-name c) -> any/c
  c : contract?
procedure
(value-contract v) -> (or/c contract? #f)
  v : has-contract?
procedure
(has-contract? v) -> boolean?
  v : any/c
procedure
(value-blame v) -> (or/c blame? #f)
  v : has-blame?
procedure
(has-blame? v) -> boolean?
  v : any/c
procedure
(contract-late-neg-projection c)
 -> (-> blame? (-> any/c (or/c #f any/c) any/c))
  c : contract?
procedure
(contract-projection c) -> (-> blame? (-> any/c any/c))
  c : contract?
procedure
(contract-val-first-projection c)
 -> (-> blame? (-> any/c (-> any/c any/c)))
  c : contract?
procedure
(make-none/c sexp-name) -> contract?
  sexp-name : any/c
syntax
(recursive-contract contract-expr recursive-contract-option ...)
(recursive-contract contract-expr type recursive-contract-option ...)
 
recursive-contract-option = #:list-contract?
                          | #:extra-delay
                             
                     type = #:impersonator
                          | #:chaperone
                          | #:flat
syntax
(opt/c contract-expr maybe-name)
 
maybe-name = 
           | #:error-name id
syntax
(define-opt/c (id id ...) expr)
value
contract-continuation-mark-key : continuation-mark-key?
procedure
(contract-custom-write-property-proc c         
                                     p         
                                     mode) -> void?
  c : contract?
  p : output-port?
  mode : (or/c #f #t 0 1)
procedure
(rename-contract contract name) -> contract?
  contract : contract?
  name : any/c
syntax
(contract-first-order-okay-to-give-up?)
syntax
(contract-first-order-try-less-hard e)
procedure
(if/c predicate then-contract else-contract) -> contract?
  predicate : (-> any/c any/c)
  then-contract : contract?
  else-contract : contract?
value
failure-result/c : contract?
procedure
(get/build-val-first-projection c)
 -> (-> blame? (-> any/c (-> any/c any/c)))
  c : contract?
procedure
(get/build-late-neg-projection c)
 -> (-> blame? (-> any/c any/c any/c))
  c : contract?
procedure
(get/build-collapsible-late-neg-projection c)
 -> (-> blame? (values (-> any/c any/c any/c) collapsible-contract?))
  c : contract?
value
collapsible-contract-continuation-mark-key
 : continuation-mark-key?
syntax
(with-collapsible-contract-continuation-mark body ...)
value
prop:collapsible-contract : struct-type-property?
procedure
(collapsible-contract? v) -> boolean?
  v : any/c
procedure
(merge new-cc new-neg old-cc old-neg) -> collapsible-contract?
  new-cc : collapsible-contract?
  new-neg : any/c
  old-cc : collapsible-contract?
  old-neg : any/c
procedure
(collapsible-guard cc val neg-party) -> any/c
  cc : collapsible-contract?
  val : any/c
  neg-party : any/c
procedure
(collapsible-contract-property? v) -> boolean?
  v : any/c
procedure
(build-collapsible-contract-property                                          
                                     [#:try-merge try-merge                   
                                      #:collapsible-guard collapsible-guard]) 
 -> collapsible-contract-property?
  try-merge : (or/c #f                                    = #f
                    (-> collapsible-contract?
                        any/c
                        collapsible-contract?
                        any/c
                        (or/c #f collapsible-contract?)))
  collapsible-guard : (-> collapsible-contract? any/c any/c any/c)
                    = (λ (cc v neg)
                        (error
                         "internal error: contract does not support `collapsible-guard`" cc))
struct
(struct collapsible-ho/c (latest-blame missing-party latest-ctc))
  latest-blame : blame?
  missing-party : any/c
  latest-ctc : contract?
struct
(struct collapsible-leaf/c (proj-list
                            contract-list
                            blame-list
                            missing-party-list))
  proj-list : (listof (-> any/c any/c any/c))
  contract-list : (listof contract?)
  blame-list : (listof blame?)
  missing-party-list : (listof any/c)
value
impersonator-prop:collapsible : impersonator-property?
procedure
(has-impersonator-prop:collapsible? v) -> boolean?
  v : any/c
procedure
(get-impersonator-prop:collapsible v) -> collapsible-property?
  v : any/c
struct
(struct collapsible-property (c-c neg-party ref))
  c-c : collapsible-contract?
  neg-party : any/c
  ref : (or/c #f impersonator?)
struct
(struct collapsible-count-property collapsible-property (count
                                                         prev))
  count : natural-number/c
  prev : (or/c collapsible-count-property? any/c)
struct
(struct collapsible-wrapper-property collapsible-property
        (checking-wrapper)
  checking-wrapper : impersonator?
procedure
(make-proj-contract name proj first-order) -> contract?
  name : any/c
  proj : (or/c (-> any/c
                   any/c
                   (list/c any/c any/c)
                   contact?
                   (-> any/c any/c))
               (-> any/c
                   any/c
                   (list/c any/c any/c)
                   contact?
                   boolean?
                   (-> any/c any/c)))
  first-order : (-> any/c boolean?)
procedure
(raise-contract-error val          
                      src          
                      pos          
                      name         
                      fmt          
                      arg ...) -> any/c
  val : any/c
  src : any/c
  pos : any/c
  name : any/c
  fmt : string?
  arg : any/c
procedure
(contract-proc c)
 -> (->* (symbol? symbol? (or/c syntax? (list/c any/c any/c)))
         (boolean?)
         (-> any/c any))
  c : contract?
procedure
(contract-random-generate ctc [fuel fail]) -> any/c
  ctc : contract?
  fuel : 5 = exact-nonnegative-integer?
  fail : (or/c #f (-> any) (-> boolean? any)) = #f
procedure
(contract-exercise [#:fuel fuel              
                    #:shuffle? shuffle?]     
                    val ...+)            -> void?
  fuel : exact-nonnegative-integer? = 10
  shuffle? : any/c = #f
  val : any/c
procedure
(contract-random-generate/choose c fuel) -> (or/c #f (-> c))
  c : contract?
  fuel : exact-nonnegative-integer?
value
contract-random-generate-fail : contract-random-generate-fail?
procedure
(contract-random-generate-fail? v) -> boolean?
  v : any/c
procedure
(contract-random-generate-env? v) -> boolean?
  v : any/c
procedure
(contract-random-generate-stash env c v) -> void?
  env : contract-random-generate-env?
  c : contract?
  v : c
procedure
(contract-random-generate-get-current-environment)
 -> contract-random-generate-env?
syntax
(match val-expr clause ...)
 
clause = [pat body ...+]
       | [pat (=> id) body ...+]
       | [pat #:when cond-expr body ...+]
syntax
(match* (val-expr ...+) clause* ...)
 
clause* = [(pat ...+) body ...+]
        | [(pat ...+) (=> id) body ...+]
        | [(pat ...+) #:when cond-expr body ...+]
syntax
(match/values expr clause* clause* ...)
syntax
(define/match (head args)
  match*-clause ...)
 
         head = id
              | (head args)
                 
         args = arg ...
              | arg ... . rest-id
                 
          arg = arg-id
              | [arg-id default-expr]
              | keyword arg-id
              | keyword [arg-id default-expr]
                 
match*-clause = [(pat ...+) body ...+]
              | [(pat ...+) (=> id) body ...+]
              | [(pat ...+) #:when cond-expr body ...+]
syntax
(match-lambda clause ...)
syntax
(match-lambda* clause ...)
syntax
(match-lambda** clause* ...)
syntax
(match-let ([pat expr] ...) body ...+)
syntax
(match-let* ([pat expr] ...) body ...+)
syntax
(match-let-values ([(pat ...) expr] ...) body ...+)
syntax
(match-let*-values ([(pat ...) expr] ...) body ...+)
syntax
(match-letrec ([pat expr] ...) body ...+)
syntax
(match-letrec-values ([(pat ...) expr] ...) body ...+)
syntax
(match-define pat expr)
syntax
(match-define-values (pat pats ...) expr)
procedure
(exn:misc:match? v) -> boolean?
  v : any/c
syntax
(failure-cont)
syntax
(define-match-expander id proc-expr)
(define-match-expander id proc-expr proc-expr)
value
prop:match-expander : struct-type-property?
value
prop:legacy-match-expander : struct-type-property?
procedure
(match-expander? v) -> boolean?
  v : any/c
procedure
(legacy-match-expander? v) -> boolean?
  v : any/c
procedure
(syntax-local-match-introduce stx) -> syntax?
  stx : syntax?
parameter
(match-equality-test) -> (any/c any/c . -> . any)
(match-equality-test comp-proc) -> void?
  comp-proc : (any/c any/c . -> . any)
syntax
(match/derived val-expr original-datum clause ...)
syntax
(match*/derived (val-expr ...) original-datum clause* ...)
syntax
(== val comparator)
(== val)
syntax
(struct* struct-id ([field pat] ...))
procedure
(values v ...) -> any
  v : any/c
procedure
(call-with-values generator receiver) -> any
  generator : (-> any)
  receiver : procedure?
procedure
(raise v [barrier?]) -> any
  v : any/c
  barrier? : any/c = #t
procedure
(error message-sym) -> any
  message-sym : symbol?
(error message-str v ...) -> any
  message-str : string?
  v : any/c
(error who-sym format-str v ...) -> any
  who-sym : symbol?
  format-str : string?
  v : any/c
procedure
(raise-user-error message-sym) -> any
  message-sym : symbol?
(raise-user-error message-str v ...) -> any
  message-str : string?
  v : any/c
(raise-user-error who-sym format-str v ...) -> any
  who-sym : symbol?
  format-str : string?
  v : any/c
procedure
(raise-argument-error name expected v) -> any
  name : symbol?
  expected : string?
  v : any/c
(raise-argument-error name         
                      expected     
                      bad-pos      
                      v ...)   -> any
  name : symbol?
  expected : string?
  bad-pos : exact-nonnegative-integer?
  v : any/c
procedure
(raise-argument-error* name realm expected v) -> any
  name : symbol?
  realm : symbol?
  expected : string?
  v : any/c
(raise-argument-error* name         
                       realm        
                       expected     
                       bad-pos      
                       v ...)   -> any
  name : symbol?
  realm : symbol?
  expected : string?
  bad-pos : exact-nonnegative-integer?
  v : any/c
procedure
(raise-result-error name expected v) -> any
  name : symbol?
  expected : string?
  v : any/c
(raise-result-error name         
                    expected     
                    bad-pos      
                    v ...)   -> any
  name : symbol?
  expected : string?
  bad-pos : exact-nonnegative-integer?
  v : any/c
procedure
(raise-result-error* name realm expected v) -> any
  name : symbol?
  realm : symbol?
  expected : string?
  v : any/c
(raise-result-error* name         
                     realm        
                     expected     
                     bad-pos      
                     v ...)   -> any
  name : symbol?
  realm : symbol?
  expected : string?
  bad-pos : exact-nonnegative-integer?
  v : any/c
procedure
(raise-arguments-error name        
                       message     
                       field       
                       v ...       
                       ...)    -> any
  name : symbol?
  message : string?
  field : string?
  v : any/c
procedure
(raise-arguments-error* name        
                        realm       
                        message     
                        field       
                        v ...       
                        ...)    -> any
  name : symbol?
  realm : symbol?
  message : string?
  field : string?
  v : any/c
procedure
(raise-range-error  name                  
                    type-description      
                    index-prefix          
                    index                 
                    in-value              
                    lower-bound           
                    upper-bound           
                   [alt-lower-bound]) -> any
  name : symbol?
  type-description : string?
  index-prefix : string?
  index : exact-integer?
  in-value : any/c
  lower-bound : exact-integer?
  upper-bound : exact-integer?
  alt-lower-bound : (or/c #f exact-integer?) = #f
procedure
(raise-range-error*  name                  
                     realm                 
                     type-description      
                     index-prefix          
                     index                 
                     in-value              
                     lower-bound           
                     upper-bound           
                    [alt-lower-bound]) -> any
  name : symbol?
  realm : symbol?
  type-description : string?
  index-prefix : string?
  index : exact-integer?
  in-value : any/c
  lower-bound : exact-integer?
  upper-bound : exact-integer?
  alt-lower-bound : (or/c #f exact-integer?) = #f
procedure
(raise-type-error name expected v) -> any
  name : symbol?
  expected : string?
  v : any/c
(raise-type-error name expected bad-pos v ...) -> any
  name : symbol?
  expected : string?
  bad-pos : exact-nonnegative-integer?
  v : any/c
procedure
(raise-mismatch-error name        
                      message     
                      v ...+      
                      ...+)   -> any
  name : symbol?
  message : string?
  v : any/c
procedure
(raise-arity-error name arity-v arg-v ...) -> any
  name : (or/c symbol? procedure?)
  arity-v : (or/c exact-nonnegative-integer?
                  arity-at-least?
                  (listof
                   (or/c exact-nonnegative-integer?
                         arity-at-least?)))
  arg-v : any/c
procedure
(raise-arity-error* name           
                    realm          
                    arity-v        
                    arg-v ...) -> any
  name : (or/c symbol? procedure?)
  realm : symbol?
  arity-v : (or/c exact-nonnegative-integer?
                  arity-at-least?
                  (listof
                   (or/c exact-nonnegative-integer?
                         arity-at-least?)))
  arg-v : any/c
procedure
(raise-arity-mask-error name mask arg-v ...) -> any
  name : (or/c symbol? procedure?)
  mask : exact-integer?
  arg-v : any/c
procedure
(raise-arity-mask-error* name           
                         realm          
                         mask           
                         arg-v ...) -> any
  name : (or/c symbol? procedure?)
  realm : symbol?
  mask : exact-integer?
  arg-v : any/c
procedure
(raise-result-arity-error name              
                          arity-v           
                          detail-str        
                          result-v ...) -> any
  name : (or/c symbol? #f)
  arity-v : exact-nonnegative-integer?
  detail-str : (or/c string? #f)
  result-v : any/c
procedure
(raise-result-arity-error* name              
                           realm             
                           arity-v           
                           detail-str        
                           result-v ...) -> any
  name : (or/c symbol? #f)
  realm : symbol?
  arity-v : exact-nonnegative-integer?
  detail-str : (or/c string? #f)
  result-v : any/c
procedure
(raise-syntax-error  name               
                     message            
                    [expr               
                     sub-expr           
                     extra-sources      
                     message-suffix     
                     #:exn exn])    -> any
  name : (or/c symbol? #f)
  message : string?
  expr : any/c = #f
  sub-expr : any/c = #f
  extra-sources : (listof syntax?) = null
  message-suffix : string? = ""
  exn : (-> string?                = exn:fail:syntax
            continuation-mark-set?
            (listof syntax?)
            exn:fail:syntax?)
procedure
(unquoted-printing-string? v) -> boolean?
  v : any/c
procedure
(unquoted-printing-string s) -> unquoted-printing-string?
  s : string?
procedure
(unquoted-printing-string-value ups) -> string?
  ups : unquoted-printing-string?
procedure
(call-with-exception-handler f thunk) -> any
  f : (any/c . -> . any)
  thunk : (-> any)
parameter
(uncaught-exception-handler) -> (any/c . -> . any)
(uncaught-exception-handler f) -> void?
  f : (any/c . -> . any)
syntax
(with-handlers ([pred-expr handler-expr] ...)
  body ...+)
syntax
(with-handlers* ([pred-expr handler-expr] ...)
  body ...+)
parameter
(error-escape-handler) -> (-> any)
(error-escape-handler proc) -> void?
  proc : (-> any)
parameter
(error-display-handler) -> (string? any/c . -> . any)
(error-display-handler proc) -> void?
  proc : (string? any/c . -> . any)
parameter
(error-print-width) -> (and/c exact-integer? (>=/c 3))
(error-print-width width) -> void?
  width : (and/c exact-integer? (>=/c 3))
parameter
(error-print-context-length) -> exact-nonnegative-integer?
(error-print-context-length cnt) -> void?
  cnt : exact-nonnegative-integer?
parameter
(error-print-source-location) -> boolean?
(error-print-source-location include?) -> void?
  include? : any/c
parameter
(error-value->string-handler)
 -> (any/c exact-nonnegative-integer?
           . -> .
           string?)
(error-value->string-handler proc) -> void?
  proc : (any/c exact-nonnegative-integer?
                . -> .
                string?)
parameter
(error-syntax->string-handler)
 -> (any/c (or/c exact-nonnegative-integer? #f)
          . -> .
          string?)
(error-syntax->string-handler proc) -> void?
  proc : (any/c (or/c exact-nonnegative-integer? #f)
               . -> .
               string?)
struct
(struct exn (message continuation-marks)
    #:extra-constructor-name make-exn
    #:transparent)
  message : string?
  continuation-marks : continuation-mark-set?
struct
(struct exn:fail exn ()
    #:extra-constructor-name make-exn:fail
    #:transparent)
struct
(struct exn:fail:contract exn:fail ()
    #:extra-constructor-name make-exn:fail:contract
    #:transparent)
struct
(struct exn:fail:contract:arity exn:fail:contract ()
    #:extra-constructor-name make-exn:fail:contract:arity
    #:transparent)
struct
(struct exn:fail:contract:divide-by-zero exn:fail:contract ()
    #:extra-constructor-name
    make-exn:fail:contract:divide-by-zero
    #:transparent)
struct
(struct exn:fail:contract:non-fixnum-result exn:fail:contract ()
    #:extra-constructor-name
    make-exn:fail:contract:non-fixnum-result
    #:transparent)
struct
(struct exn:fail:contract:continuation exn:fail:contract ()
    #:extra-constructor-name make-exn:fail:contract:continuation
    #:transparent)
struct
(struct exn:fail:contract:variable exn:fail:contract (id)
    #:extra-constructor-name make-exn:fail:contract:variable
    #:transparent)
  id : symbol?
struct
(struct exn:fail:syntax exn:fail (exprs)
    #:extra-constructor-name make-exn:fail:syntax
    #:transparent)
  exprs : (listof syntax?)
struct
(struct exn:fail:syntax:unbound exn:fail:syntax ()
    #:extra-constructor-name make-exn:fail:syntax:unbound
    #:transparent)
struct
(struct exn:fail:syntax:missing-module exn:fail:syntax (path)
    #:extra-constructor-name make-exn:fail:syntax:missing-module
    #:transparent)
  path : module-path?
struct
(struct exn:fail:read exn:fail (srclocs)
    #:extra-constructor-name make-exn:fail:read
    #:transparent)
  srclocs : (listof srcloc?)
struct
(struct exn:fail:read:eof exn:fail:read ()
    #:extra-constructor-name make-exn:fail:read:eof
    #:transparent)
struct
(struct exn:fail:read:non-char exn:fail:read ()
    #:extra-constructor-name make-exn:fail:read:non-char
    #:transparent)
struct
(struct exn:fail:filesystem exn:fail ()
    #:extra-constructor-name make-exn:fail:filesystem
    #:transparent)
struct
(struct exn:fail:filesystem:exists exn:fail:filesystem ()
    #:extra-constructor-name make-exn:fail:filesystem:exists
    #:transparent)
struct
(struct exn:fail:filesystem:version exn:fail:filesystem ()
    #:extra-constructor-name make-exn:fail:filesystem:version
    #:transparent)
struct
(struct exn:fail:filesystem:errno exn:fail:filesystem (errno)
    #:extra-constructor-name make-exn:fail:filesystem:errno
    #:transparent)
  errno : (cons/c exact-integer? (or/c 'posix 'windows 'gai))
struct
(struct exn:fail:filesystem:missing-module exn:fail:filesystem
        (path)
    #:extra-constructor-name
    make-exn:fail:filesystem:missing-module
    #:transparent)
  path : module-path?
struct
(struct exn:fail:network exn:fail ()
    #:extra-constructor-name make-exn:fail:network
    #:transparent)
struct
(struct exn:fail:network:errno exn:fail:network (errno)
    #:extra-constructor-name make-exn:fail:network:errno
    #:transparent)
  errno : (cons/c exact-integer? (or/c 'posix 'windows 'gai))
struct
(struct exn:fail:out-of-memory exn:fail ()
    #:extra-constructor-name make-exn:fail:out-of-memory
    #:transparent)
struct
(struct exn:fail:unsupported exn:fail ()
    #:extra-constructor-name make-exn:fail:unsupported
    #:transparent)
struct
(struct exn:fail:user exn:fail ()
    #:extra-constructor-name make-exn:fail:user
    #:transparent)
struct
(struct exn:break exn (continuation)
    #:extra-constructor-name make-exn:break
    #:transparent)
  continuation : continuation?
struct
(struct exn:break:hang-up exn:break ()
    #:extra-constructor-name make-exn:break:hang-up
    #:transparent)
struct
(struct exn:break:terminate exn:break ()
    #:extra-constructor-name make-exn:break:terminate
    #:transparent)
value
prop:exn:srclocs : struct-type-property?
procedure
(exn:srclocs? v) -> boolean?
  v : any/c
procedure
(exn:srclocs-accessor v)
 -> (exn:srclocs? . -> . (listof srcloc))
  v : exn:srclocs?
struct
(struct srcloc (source line column position span)
    #:extra-constructor-name make-srcloc
    #:transparent)
  source : any/c
  line : (or/c exact-positive-integer? #f)
  column : (or/c exact-nonnegative-integer? #f)
  position : (or/c exact-positive-integer? #f)
  span : (or/c exact-nonnegative-integer? #f)
procedure
(srcloc->string srcloc) -> (or/c string? #f)
  srcloc : srcloc?
value
prop:exn:missing-module : struct-type-property?
procedure
(exn:missing-module? v) -> boolean?
  v : any/c
procedure
(exn:missing-module-accessor v)
 -> (exn:missing-module? . -> . module-path?)
  v : exn:srclocs?
procedure
(exn->string exn) -> string?
  exn : (or/c exn? any/c)
procedure
(error-message->adjusted-string name               
                                name-realm         
                                message            
                                message-realm) -> string?
  name : (or/c symbol? #f)
  name-realm : symbol?
  message : string?
  message-realm : symbol?
procedure
(error-contract->adjusted-string contract-str        
                                 contract-realm) -> string?
  contract-str : string?
  contract-realm : symbol?
parameter
(current-error-message-adjuster)
 -> (symbol? . -> . (or/c procedure? #f))
(current-error-message-adjuster proc) -> void?
  proc : (symbol? . -> . (or/c procedure? #f))
value
error-message-adjuster-key : symbol?
procedure
(promise? v) -> boolean?
  v : any/c
syntax
(delay body ...+)
syntax
(lazy body ...+)
procedure
(force v) -> any
  v : any/c
procedure
(promise-forced? promise) -> boolean?
  promise : promise?
procedure
(promise-running? promise) -> boolean?
  promise : promise?
syntax
(delay/name body ...+)
procedure
(promise/name? promise) -> boolean?
  promise : any/c
syntax
(delay/strict body ...+)
syntax
(delay/sync body ...+)
syntax
(delay/thread body/option ...+)
 
body/option = body
            | #:group thread-group-expr
syntax
(delay/idle body/option ...+)
 
body/option = body
            | #:wait-for wait-evt-expr
            | #:work-while while-evt-expr
            | #:tick tick-secs-expr
            | #:use use-ratio-expr
syntax
(for/list/concurrent maybe-group (for-clause ...)
  body-or-break ... body)
 
maybe-group = 
            | #:group thread-group-expr
 
  thread-group-expr : thread-group?
syntax
(for*/list/concurrent maybe-group (for-clause ...)
  body-or-break ... body)
procedure
(call-with-continuation-prompt  proc           
                               [prompt-tag     
                                handler]       
                                arg ...)   -> any
  proc : procedure?
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
  handler : (or/c procedure? #f) = #f
  arg : any/c
procedure
(abort-current-continuation prompt-tag     
                            v ...)     -> any
  prompt-tag : any/c
  v : any/c
procedure
(make-continuation-prompt-tag) -> continuation-prompt-tag?
(make-continuation-prompt-tag name) -> continuation-prompt-tag?
  name : symbol?
procedure
(default-continuation-prompt-tag) -> continuation-prompt-tag?
procedure
(call-with-current-continuation  proc             
                                [prompt-tag]) -> any
  proc : (continuation? . -> . any)
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(call/cc proc [prompt-tag]) -> any
  proc : (continuation? . -> . any)
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(call-with-composable-continuation  proc             
                                   [prompt-tag]) -> any
  proc : (continuation? . -> . any)
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(call-with-escape-continuation proc) -> any
  proc : (continuation? . -> . any)
procedure
(call/ec proc) -> any
  proc : (continuation? . -> . any)
procedure
(call-in-continuation k proc) -> any
  k : continuation?
  proc : (-> any)
syntax
(let/cc k body ...+)
syntax
(let/ec k body ...+)
procedure
(call-with-continuation-barrier thunk) -> any
  thunk : (-> any)
procedure
(continuation-prompt-available?  prompt-tag     
                                [cont])     -> any
  prompt-tag : continuation-prompt-tag?
  cont : continuation? = (call/cc values)
procedure
(continuation? v) -> boolean?
  v : any/c
procedure
(continuation-prompt-tag? v) -> boolean?
  v : any/c
procedure
(dynamic-wind pre-thunk       
              value-thunk     
              post-thunk) -> any
  pre-thunk : (-> any)
  value-thunk : (-> any)
  post-thunk : (-> any)
procedure
(call/prompt proc [prompt-tag handler] arg ...) -> any
  proc : procedure?
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
  handler : (or/c procedure? #f) = #f
  arg : any/c
procedure
(abort/cc prompt-tag v ...) -> any
  prompt-tag : any/c
  v : any/c
procedure
(call/comp proc [prompt-tag]) -> any
  proc : (continuation? . -> . any)
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(abort v ...) -> any
  v : any/c
syntax
(% expr)
(% expr handler-expr)
(% expr handler-expr #:tag tag-expr)
procedure
(fcontrol v #:tag prompt-tag) -> any
  v : any/c
  prompt-tag : (default-continuation-prompt-tag)
syntax
(prompt expr ...+)
syntax
(control id expr ...+)
syntax
(prompt-at prompt-tag-expr expr ...+)
syntax
(control-at prompt-tag-expr id expr ...+)
syntax
(reset expr ...+)
syntax
(shift id expr ...+)
syntax
(reset-at prompt-tag-expr expr ...+)
syntax
(shift-at prompt-tag-expr identifier expr ...+)
syntax
(prompt0 expr ...+)
syntax
(reset0 expr ...+)
syntax
(control0 id expr ...+)
syntax
(shift0 id expr ...+)
syntax
(prompt0-at prompt-tag-expr expr ...+)
syntax
(reset0-at prompt-tag-expr expr ...+)
syntax
(control0-at prompt-tag-expr id expr ...+)
syntax
(shift0-at prompt-tag-expr id expr ...+)
procedure
(spawn proc) -> any
  proc : ((any/c . -> . any) . -> . any)
procedure
(splitter proc) -> any
  proc : (((-> any) . -> . any)
          ((continuation? . -> . any) . -> . any)
          . -> . any)
procedure
(new-prompt) -> any
syntax
(set prompt-expr expr ...+)
syntax
(cupto prompt-expr id expr ...+)
procedure
(continuation-marks cont [prompt-tag]) -> continuation-mark-set?
  cont : (or/c continuation? thread? #f)
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(current-continuation-marks [prompt-tag])
 -> continuation-mark-set?
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(continuation-mark-set->list  mark-set         
                              key-v            
                             [prompt-tag]) -> list?
  mark-set : (or/c continuation-mark-set? #f)
  key-v : any/c
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(continuation-mark-set->list*  mark-set         
                               key-list         
                              [none-v           
                               prompt-tag]) -> (listof vector?)
  mark-set : (or/c continuation-mark-set? #f)
  key-list : (listof any/c)
  none-v : any/c = #f
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(continuation-mark-set->iterator  mark-set     
                                  key-list     
                                 [none-v       
                                  prompt-tag]) 
 -> (-> (values (or/c vector? #f) procedure?))
  mark-set : (or/c continuation-mark-set? #f)
  key-list : (listof any/c)
  none-v : any/c = #f
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(continuation-mark-set-first  mark-set         
                              key-v            
                             [none-v           
                              prompt-tag]) -> any
  mark-set : (or/c continuation-mark-set? #f)
  key-v : any/c
  none-v : any/c = #f
  prompt-tag : continuation-prompt-tag?
             = (default-continuation-prompt-tag)
procedure
(call-with-immediate-continuation-mark  key-v           
                                        proc            
                                       [default-v]) -> any
  key-v : any/c
  proc : (any/c . -> . any)
  default-v : any/c = #f
procedure
(make-continuation-mark-key) -> continuation-mark-key?
(make-continuation-mark-key sym) -> continuation-mark-key?
  sym : symbol?
procedure
(continuation-mark-key? v) -> boolean?
  v : any/c
procedure
(continuation-mark-set? v) -> boolean?
  v : any/c
procedure
(continuation-mark-set->context  mark-set      
                                [realms?]) -> list?
  mark-set : continuation-mark-set?
  realms? : any/c = #f
procedure
(break-enabled) -> boolean?
(break-enabled on?) -> void?
  on? : any/c
syntax
(parameterize-break boolean-expr body ...+)
procedure
(current-break-parameterization) -> break-parameterization?
procedure
(call-with-break-parameterization break-param     
                                  thunk)      -> any
  break-param : break-parameterization?
  thunk : (-> any)
procedure
(break-parameterization? v) -> boolean?
  v : any/c
procedure
(exit [v]) -> any
  v : any/c = #t
parameter
(exit-handler) -> (any/c . -> . any)
(exit-handler proc) -> void?
  proc : (any/c . -> . any)
parameter
(executable-yield-handler) -> (byte? . -> . any)
(executable-yield-handler proc) -> void?
  proc : (byte? . -> . any)
procedure
(assert-unreachable) -> none/c
syntax
(with-assert-unreachable
  body ...+)
procedure
(thread thunk) -> thread?
  thunk : (-> any)
procedure
(thread? v) -> thread?
  v : any/c
procedure
(current-thread) -> thread?
procedure
(thread/suspend-to-kill thunk) -> thread?
  thunk : (-> any)
procedure
(call-in-nested-thread thunk [cust]) -> any
  thunk : (-> any)
  cust : custodian? = (current-custodian)
procedure
(thread-suspend thd) -> void?
  thd : thread?
procedure
(thread-resume thd [benefactor]) -> void?
  thd : thread?
  benefactor : (or/c thread? custodian? #f) = #f
procedure
(kill-thread thd) -> void?
  thd : thread?
procedure
(break-thread thd [kind]) -> void?
  thd : thread?
  kind : (or/c #f 'hang-up 'terminate) = #f
procedure
(sleep [secs]) -> void?
  secs : (>=/c 0) = 0
procedure
(thread-running? thd) -> any
  thd : thread?
procedure
(thread-dead? thd) -> any
  thd : thread?
procedure
(thread-wait thd) -> void?
  thd : thread?
procedure
(thread-dead-evt thd) -> evt?
  thd : thread?
procedure
(thread-resume-evt thd) -> evt?
  thd : thread?
procedure
(thread-suspend-evt thd) -> evt?
  thd : thread?
procedure
(thread-send thd v [fail-thunk]) -> any
  thd : thread?
  v : any/c
  fail-thunk : (or/c (-> any) #f)
             = (lambda () (raise-mismatch-error ....))
procedure
(thread-receive) -> any/c
procedure
(thread-try-receive) -> any/c
procedure
(thread-receive-evt) -> evt?
procedure
(thread-rewind-receive lst) -> void?
  lst : list?
procedure
(evt? v) -> boolean?
  v : any/c
procedure
(sync evt ...) -> any
  evt : evt?
procedure
(sync/timeout timeout evt ...) -> any
  timeout : (or/c #f (and/c real? (not/c negative?)) (-> any))
  evt : evt?
procedure
(sync/enable-break evt ...) -> any
  evt : evt?
procedure
(sync/timeout/enable-break timeout evt ...) -> any
  timeout : (or/c #f (and/c real? (not/c negative?)) (-> any))
  evt : evt?
procedure
(choice-evt evt ...) -> evt?
  evt : evt?
procedure
(wrap-evt evt wrap) -> evt?
  evt : evt?
  wrap : (any/c ... . -> . any)
procedure
(handle-evt evt handle) -> handle-evt?
  evt : evt?
  handle : (any/c ... . -> . any)
procedure
(guard-evt maker) -> evt?
  maker : (-> (or/c evt? any/c))
procedure
(nack-guard-evt maker) -> evt?
  maker : (evt? . -> . (or/c evt? any/c))
procedure
(poll-guard-evt maker) -> evt?
  maker : (boolean? . -> . (or/c evt? any/c))
procedure
(replace-evt evt maker) -> evt?
  evt : evt?
  maker : (any/c ... . -> . (or/c evt? any/c))
value
always-evt : evt?
value
never-evt : evt?
procedure
(system-idle-evt) -> evt?
procedure
(alarm-evt msecs [monotonic?]) -> evt?
  msecs : real?
  monotonic? : any/c = #f
procedure
(handle-evt? evt) -> boolean?
  evt : evt?
value
prop:evt : struct-type-property?
parameter
(current-evt-pseudo-random-generator)
 -> pseudo-random-generator?
(current-evt-pseudo-random-generator generator) -> void?
  generator : pseudo-random-generator?
procedure
(channel? v) -> boolean?
  v : any/c
procedure
(make-channel) -> channel?
procedure
(channel-get ch) -> any
  ch : channel?
procedure
(channel-try-get ch) -> any
  ch : channel?
procedure
(channel-put ch v) -> void?
  ch : channel?
  v : any/c
procedure
(channel-put-evt ch v) -> channel-put-evt?
  ch : channel?
  v : any/c
procedure
(channel-put-evt? v) -> boolean?
  v : any/c
procedure
(semaphore? v) -> boolean?
  v : any/c
procedure
(make-semaphore [init]) -> semaphore?
  init : exact-nonnegative-integer? = 0
procedure
(semaphore-post sema) -> void?
  sema : semaphore?
procedure
(semaphore-wait sema) -> void?
  sema : semaphore?
procedure
(semaphore-try-wait? sema) -> boolean?
  sema : semaphore?
procedure
(semaphore-wait/enable-break sema) -> void?
  sema : semaphore?
procedure
(semaphore-peek-evt sema) -> semaphore-peek-evt?
  sema : semaphore?
procedure
(semaphore-peek-evt? v) -> boolean?
  v : any/c
procedure
(call-with-semaphore  sema                
                      proc                
                     [try-fail-thunk]     
                      arg ...)        -> any
  sema : semaphore?
  proc : procedure?
  try-fail-thunk : (or/c (-> any) #f) = #f
  arg : any/c
procedure
(call-with-semaphore/enable-break  sema                
                                   proc                
                                  [try-fail-thunk]     
                                   arg ...)        -> any
  sema : semaphore?
  proc : procedure?
  try-fail-thunk : (or/c (-> any) #f) = #f
  arg : any/c
procedure
(async-channel? v) -> boolean?
  v : any/c
procedure
(make-async-channel [limit]) -> async-channel?
  limit : (or/c exact-positive-integer? #f) = #f
procedure
(async-channel-get ach) -> any/c
  ach : async-channel?
procedure
(async-channel-try-get ach) -> any/c
  ach : async-channel?
procedure
(async-channel-put ach v) -> void?
  ach : async-channel?
  v : any/c
procedure
(async-channel-put-evt ach v) -> evt?
  ach : async-channel?
  v : any/c
procedure
(async-channel/c c) -> contract?
  c : contract?
procedure
(impersonate-async-channel channel      
                           get-proc     
                           put-proc     
                           prop         
                           prop-val ... 
                           ...)         
 -> (and/c async-channel? impersonator?)
  channel : async-channel?
  get-proc : (any/c . -> . any/c)
  put-proc : (any/c . -> . any/c)
  prop : impersonator-property?
  prop-val : any
procedure
(chaperone-async-channel channel      
                         get-proc     
                         put-proc     
                         prop         
                         prop-val ... 
                         ...)         
 -> (and/c async-channel? chaperone?)
  channel : async-channel?
  get-proc : (any/c . -> . any/c)
  put-proc : (any/c . -> . any/c)
  prop : impersonator-property?
  prop-val : any
procedure
(thread-cell? v) -> boolean?
  v : any/c
procedure
(make-thread-cell v [preserved?]) -> thread-cell?
  v : any/c
  preserved? : any/c = #f
procedure
(thread-cell-ref cell) -> any
  cell : thread-cell?
procedure
(thread-cell-set! cell v) -> any
  cell : thread-cell?
  v : any/c
procedure
(current-preserved-thread-cell-values) -> thread-cell-values?
(current-preserved-thread-cell-values thread-cell-vals) -> void?
  thread-cell-vals : thread-cell-values?
procedure
(thread-cell-values? v) -> boolean?
  v : any/c
procedure
(make-parameter v [guard name]) -> parameter?
  v : any/c
  guard : (or/c (any/c . -> . any) #f) = #f
  name : symbol? = 'parameter-procedure
syntax
(parameterize ([parameter-expr value-expr] ...)
  body ...+)
 
  parameter-expr : parameter?
syntax
(parameterize* ((parameter-expr value-expr) ...)
  body ...+)
procedure
(make-derived-parameter parameter     
                        guard         
                        wrap)     -> parameter?
  parameter : parameter?
  guard : (any/c . -> . any)
  wrap : (any/c . -> . any)
procedure
(parameter? v) -> boolean?
  v : any/c
procedure
(parameter-procedure=? a b) -> boolean?
  a : parameter?
  b : parameter?
procedure
(current-parameterization) -> parameterization?
procedure
(call-with-parameterization parameterization     
                            thunk)           -> any
  parameterization : parameterization?
  thunk : (-> any)
procedure
(parameterization? v) -> boolean?
  v : any/c
procedure
(future thunk) -> future?
  thunk : (-> any)
procedure
(touch f) -> any
  f : future?
procedure
(futures-enabled?) -> boolean?
procedure
(current-future) -> (or/c #f future?)
procedure
(future? v) -> boolean?
  v : any/c
procedure
(would-be-future thunk) -> future?
  thunk : (-> any)
procedure
(processor-count) -> exact-positive-integer?
syntax
(for/async (for-clause ...) body-or-break ... body)
syntax
(for*/async (for-clause ...) body-or-break ... body)
procedure
(make-fsemaphore init) -> fsemaphore?
  init : exact-nonnegative-integer?
procedure
(fsemaphore? v) -> boolean?
  v : any/c
procedure
(fsemaphore-post fsema) -> void?
  fsema : fsemaphore?
procedure
(fsemaphore-wait fsema) -> void?
  fsema : fsemaphore?
procedure
(fsemaphore-try-wait? fsema) -> boolean?
  fsema : fsemaphore?
procedure
(fsemaphore-count fsema) -> exact-nonnegative-integer?
  fsema : fsemaphore?
procedure
(place-enabled?) -> boolean?
procedure
(place? v) -> boolean?
  v : any/c
procedure
(place-channel? v) -> boolean?
  v : any/c
procedure
(dynamic-place  module-path         
                start-name          
               [#:at location       
                #:named named]) -> place?
  module-path : (or/c module-path? path?)
  start-name : symbol?
  location : (or/c #f place-location?) = #f
  named : any/c = #f
procedure
(dynamic-place*  module-path     
                 start-name      
                [#:in in         
                 #:out out       
                 #:err err]) -> place?
                                (or/c output-port? #f)
                                (or/c input-port? #f)
                                (or/c input-port? #f)
  module-path : (or/c module-path? path?)
  start-name : symbol?
  in : (or/c input-port? #f) = #f
  out : (or/c output-port? #f) = (current-output-port)
  err : (or/c output-port? #f) = (current-error-port)
procedure
(place-wait p) -> exact-integer?
  p : place?
procedure
(place-dead-evt p) -> evt?
  p : place?
procedure
(place-kill p) -> void?
  p : place?
procedure
(place-break p [kind]) -> void?
  p : place?
  kind : (or/c #f 'hang-up 'terminate) = #f
procedure
(place-channel) -> place-channel? place-channel?
procedure
(place-channel-put pch v) -> void
  pch : place-channel?
  v : place-message-allowed?
procedure
(place-channel-get pch) -> place-message-allowed?
  pch : place-channel?
procedure
(place-channel-put/get pch v) -> any/c
  pch : place-channel?
  v : any/c
procedure
(place-message-allowed? v) -> boolean?
  v : any/c
value
prop:place-location : struct-type-property?
procedure
(place-location? v) -> boolean?
  v : any/c
syntax
(place id body ...+)
syntax
(place* maybe-port ...
        id
        body ...+)
 
maybe-port = 
           | #:in in-expr
           | #:out out-expr
           | #:err err-expr
syntax
(place/context id body ...+)
procedure
(processor-count) -> exact-positive-integer?
procedure
(engine proc) -> engine?
  proc : ((any/c . -> . void?) . -> . any/c)
procedure
(engine? v) -> any
  v : any/c
procedure
(engine-run until engine) -> boolean?
  until : (or/c evt? real?)
  engine : engine?
procedure
(engine-result engine) -> any
  engine : engine?
procedure
(engine-kill engine) -> void?
  engine : engine?
procedure
(memory-order-acquire) -> void?
procedure
(memory-order-release) -> void?
syntax
(syntax-case stx-expr (literal-id ...)
  clause ...)
 
      clause = [pattern result-expr]
             | [pattern fender-expr result-expr]
                
     pattern = np-pattern
             | (pattern ...)
             | (pattern ...+ . np-pattern)
             | (pattern ... pattern ellipsis pattern ... . np-pattern)
                
  np-pattern = _
             | id
             | #(pattern ...)
             | #(pattern ... pattern ellipsis pattern ...)
             | #&pattern
             | #s(key-datum pattern ...)
             | #s(key-datum pattern ... pattern ellipsis pattern ...)
             | (ellipsis stat-pattern)
             | const
                
stat-pattern = id
             | (stat-pattern ...)
             | (stat-pattern ...+ . stat-pattern)
             | #(stat-pattern ...)
             | #&stat-pattern
             | #s(key-datum stat-pattern ...)
             | const
                
    ellipsis = ...

_

id

(pattern ...)

(pattern ...+ . np-pattern)

(pattern ... pattern ellipsis pattern ...)

(pattern ... pattern ellipsis pattern ... . np-pattern)

#(pattern ...)

#(pattern ... pattern ellipsis pattern ...)

#&pattern

#s(key-datum pattern ...)

#s(key-datum pattern ... pattern ellipsis pattern ...)

(ellipsis stat-pattern)

const
syntax
(syntax-case* stx-expr (literal-id ...) id-compare-expr
  clause ...)
syntax
(with-syntax ([pattern stx-expr] ...)
  body ...+)
syntax
(syntax template)
 
     template = id
              | (head-template ...)
              | (head-template ...+ . template)
              | #(head-template ...)
              | #&template
              | #s(key-datum head-template ...)
              | (~? template template)
              | (ellipsis stat-template)
              | const
                 
head-template = template
              | head-template ellipsis ...+
              | (~@ . template)
              | (~? head-template head-template)
              | (~? head-template)
                 
stat-template = like template, but without ..., ~?, and ~@
                 
     ellipsis = ...

id

(head-template ...)

(head-template ... . template)

#(head-template ...)

#&template

#s(key-datum head-template ...)

(~? template1 template2)

(ellipsis stat-template)

const

template

head-template ellipsis ...+
syntax
(~@ . template)
syntax
(~? head-template1 head-template2)

(~? head-template)
syntax
(quasisyntax template)
syntax
(unsyntax expr)
syntax
(unsyntax-splicing expr)
syntax
(syntax/loc loc-expr template)
 
  loc-expr : (or/c #f srcloc? syntax?
                   (list/c any/c
                           (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f)
                           (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f))
                   (vector/c any/c
                             (or/c exact-positive-integer? #f)
                             (or/c exact-nonnegative-integer? #f)
                             (or/c exact-positive-integer? #f)
                             (or/c exact-nonnegative-integer? #f)))
syntax
(quasisyntax/loc loc-expr template)
 
  loc-expr : (or/c #f srcloc? syntax?
                   (list/c any/c
                           (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f)
                           (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f))
                   (vector/c any/c
                             (or/c exact-positive-integer? #f)
                             (or/c exact-nonnegative-integer? #f)
                             (or/c exact-positive-integer? #f)
                             (or/c exact-nonnegative-integer? #f)))
syntax
(quote-syntax/prune id)
syntax
(syntax-rules (literal-id ...)
  [(id . pattern) template] ...)
syntax
(syntax-id-rules (literal-id ...)
  [pattern template] ...)
syntax
(define-syntax-rule (id . pattern) template)
syntax
...
syntax
_
syntax
~?
syntax
~@
procedure
(syntax-pattern-variable? v) -> boolean?
  v : any/c
procedure
(syntax? v) -> boolean?
  v : any/c
procedure
(identifier? v) -> boolean?
  v : any/c
procedure
(syntax-source stx) -> any/c
  stx : syntax?
procedure
(syntax-line stx) -> (or/c exact-positive-integer? #f)
  stx : syntax?
procedure
(syntax-column stx) -> (or/c exact-nonnegative-integer? #f)
  stx : syntax?
procedure
(syntax-position stx) -> (or/c exact-positive-integer? #f)
  stx : syntax?
procedure
(syntax-span stx) -> (or/c exact-nonnegative-integer? #f)
  stx : syntax?
procedure
(syntax-original? stx) -> boolean?
  stx : syntax?
procedure
(syntax-source-module stx [source?])
 -> (or/c module-path-index? symbol? path? resolved-module-path? #f)
  stx : syntax?
  source? : any/c = #f
procedure
(syntax-e stx) -> any/c
  stx : syntax?
procedure
(syntax->list stx) -> (or/c list? #f)
  stx : syntax?
procedure
(syntax->datum stx) -> any/c
  stx : syntax?
procedure
(datum->syntax ctxt v [srcloc prop ignored]) -> syntax?
  ctxt : (or/c syntax? #f)
  v : any/c
  srcloc : (or/c #f
                 syntax?
                 srcloc?
                 (list/c any/c
                         (or/c exact-positive-integer? #f)
                         (or/c exact-nonnegative-integer? #f)
                         (or/c exact-positive-integer? #f)
                         (or/c exact-nonnegative-integer? #f))
                 (vector/c any/c
                          (or/c exact-positive-integer? #f)
                          (or/c exact-nonnegative-integer? #f)
                          (or/c exact-positive-integer? #f)
                          (or/c exact-nonnegative-integer? #f)))
         = #f
  prop : (or/c syntax? #f) = #f
  ignored : (or/c syntax? #f) = #f
procedure
(syntax-binding-set? v) -> boolean?
  v : any/c
procedure
(syntax-binding-set) -> syntax-binding-set?
procedure
(syntax-binding-set->syntax binding-set     
                            datum)      -> syntax?
  binding-set : syntax-binding-set?
  datum : any/c
procedure
(syntax-binding-set-extend                                                
                            binding-set                                   
                            symbol                                        
                            phase                                         
                            mpi                                           
                           [#:source-symbol source-symbol                 
                            #:source-phase source-phase                   
                            #:nominal-module nominal-mpi                  
                            #:nominal-phase nominal-phase                 
                            #:nominal-symbol nominal-symbol               
                            #:nominal-require-phase nominal-require-phase 
                            #:inspector inspector])                       
 -> syntax-binding-set?
  binding-set : syntax-binding-set?
  symbol : symbol?
  phase : (or/c exact-integer? #f)
  mpi : module-path-index?
  source-symbol : symbol? = symbol
  source-phase : (or/c exact-integer? #f) = phase
  nominal-mpi : module-path-index? = mpi
  nominal-phase : (or/c exact-integer? #f) = source-phase
  nominal-symbol : symbol? = source-symbol
  nominal-require-phase : (or/c exact-integer? #f) = 0
  inspector : (or/c inspector? #f) = #f
procedure
(datum-intern-literal v) -> any/c
  v : any/c
procedure
(syntax-shift-phase-level stx shift) -> syntax?
  stx : syntax?
  shift : (or/c exact-integer? #f)
procedure
(generate-temporaries stx-pair) -> (listof identifier?)
  stx-pair : (or syntax? list?)
procedure
(identifier-prune-lexical-context  id-stx     
                                  [syms]) -> identifier?
  id-stx : identifier?
  syms : (listof symbol?) = (list (syntax-e id-stx))
procedure
(identifier-prune-to-source-module id-stx) -> identifier?
  id-stx : identifier?
procedure
(syntax-recertify new-stx       
                  old-stx       
                  inspector     
                  key)      -> syntax?
  new-stx : syntax?
  old-stx : syntax?
  inspector : inspector?
  key : any/c
procedure
(syntax-debug-info stx [phase all-bindings?]) -> hash?
  stx : syntax?
  phase : (or/c exact-integer? #f) = (syntax-local-phase-level)
  all-bindings? : any/c = #f
procedure
(syntax-srcloc stx) -> (or/c #f srcloc?)
  stx : syntax?
procedure
(bound-identifier=? a-id b-id [phase-level]) -> boolean?
  a-id : syntax?
  b-id : syntax?
  phase-level : (or/c exact-integer? #f)
              = (syntax-local-phase-level)
procedure
(free-identifier=?  a-id                
                    b-id                
                   [a-phase-level       
                    b-phase-level]) -> boolean?
  a-id : identifier?
  b-id : identifier?
  a-phase-level : (or/c exact-integer? #f)
                = (syntax-local-phase-level)
  b-phase-level : (or/c exact-integer? #f) = a-phase-level
procedure
(free-transformer-identifier=? a-id b-id) -> boolean?
  a-id : identifier?
  b-id : identifier?
procedure
(free-template-identifier=? a-id b-id) -> boolean?
  a-id : identifier?
  b-id : identifier?
procedure
(free-label-identifier=? a-id b-id) -> boolean?
  a-id : identifier?
  b-id : identifier?
procedure
(check-duplicate-identifier ids) -> (or/c identifier? #f)
  ids : (listof identifier?)
procedure
(identifier-binding  id-stx            
                    [phase-level       
                     top-level-symbol? 
                     exact-scopes?])   
 -> (or/c 'lexical
          #f
          (list/c module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  phase+space-shift?
                  phase+space?)
          (list/c symbol?))
  id-stx : identifier?
  phase-level : (or/c exact-integer? #f)
              = (syntax-local-phase-level)
  top-level-symbol? : any/c = #f
  exact-scopes? : any/c = #f
procedure
(identifier-transformer-binding  id-stx           
                                [rt-phase-level]) 
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  phase+space-shift?
                  phase+space?))
  id-stx : identifier?
  rt-phase-level : (or/c exact-integer? #f)
                 = (syntax-local-phase-level)
procedure
(identifier-template-binding id-stx)
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  phase+space?
                  phase+space-shift?
                  phase+space?))
  id-stx : identifier?
procedure
(identifier-label-binding id-stx)
 -> (or/c 'lexical
          #f
          (listof module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  phase+space-shift?
                  phase+space?))
  id-stx : identifier?
procedure
(identifier-distinct-binding  id-stx        
                              wrt-id-stx    
                             [phase-level]) 
 -> (or/c 'lexical
          #f
          (list/c module-path-index?
                  symbol?
                  module-path-index?
                  symbol?
                  exact-nonnegative-integer?
                  phase+space-shift?
                  phase+space?)
          (list/c symbol?))
  id-stx : identifier?
  wrt-id-stx : identifier?
  phase-level : (or/c exact-integer? #f)
              = (syntax-local-phase-level)
procedure
(identifier-binding-symbol  id-stx            
                           [phase-level]) -> symbol?
  id-stx : identifier?
  phase-level : (or/c exact-integer? #f)
              = (syntax-local-phase-level)
procedure
(identifier-binding-portal-syntax  id-stx        
                                  [phase-level]) 
 -> (or/c #f syntax?)
  id-stx : identifier?
  phase-level : (or/c exact-integer? #f)
              = (syntax-local-phase-level)
procedure
(syntax-bound-symbols  stx                 
                      [phase-level         
                       exact-scopes?]) -> (listof symbol?)
  stx : stx?
  phase-level : (or/c exact-integer? #f)
              = (syntax-local-phase-level)
  exact-scopes? : any/c = #f
procedure
(syntax-bound-phases stx) -> (listof (or/c exact-integer? #f))
  stx : stx?
procedure
(set!-transformer? v) -> boolean?
  v : any/c
procedure
(make-set!-transformer proc) -> set!-transformer?
  proc : (syntax? . -> . syntax?)
procedure
(set!-transformer-procedure transformer)
 -> (syntax? . -> . syntax?)
  transformer : set!-transformer?
value
prop:set!-transformer : struct-type-property?
procedure
(rename-transformer? v) -> boolean?
  v : any/c
procedure
(make-rename-transformer id-stx) -> rename-transformer?
  id-stx : syntax?
procedure
(rename-transformer-target transformer) -> identifier?
  transformer : rename-transformer?
value
prop:rename-transformer : struct-type-property?
procedure
(local-expand  stx              
               context-v        
               stop-ids         
              [intdef-ctx]) -> syntax?
  stx : any/c
  context-v : (or/c 'expression 'top-level 'module 'module-begin list?)
  stop-ids : (or/c (listof identifier?) empty #f)
  intdef-ctx : (or/c internal-definition-context?           = #f
                     #f
                     (listof internal-definition-context?))
procedure
(syntax-local-expand-expression  stx            
                                [opaque-only?]) 
 -> (if opaque-only? #f syntax?) syntax?
  stx : any/c
  opaque-only? : any/c = #f
procedure
(local-transformer-expand  stx              
                           context-v        
                           stop-ids         
                          [intdef-ctx]) -> syntax?
  stx : any/c
  context-v : (or/c 'expression 'top-level list?)
  stop-ids : (or/c (listof identifier?) #f)
  intdef-ctx : (or/c internal-definition-context?           = #f
                     #f
                     (listof internal-definition-context?))
procedure
(local-expand/capture-lifts  stx            
                             context-v      
                             stop-ids       
                            [intdef-ctx     
                             lift-ctx]) -> syntax?
  stx : any/c
  context-v : (or/c 'expression 'top-level 'module 'module-begin list?)
  stop-ids : (or/c (listof identifier?) #f)
  intdef-ctx : (or/c internal-definition-context?           = #f
                     #f
                     (listof internal-definition-context?))
  lift-ctx : any/c = (gensym 'lifts)
procedure
(local-transformer-expand/capture-lifts  stx            
                                         context-v      
                                         stop-ids       
                                        [intdef-ctx     
                                         lift-ctx]) -> syntax?
  stx : any/c
  context-v : (or/c 'expression 'top-level list?)
  stop-ids : (or/c (listof identifier?) #f)
  intdef-ctx : (or/c internal-definition-context?           = #f
                     #f
                     (listof internal-definition-context?))
  lift-ctx : any/c = (gensym 'lifts)
procedure
(syntax-local-apply-transformer transformer     
                                binding-id      
                                context-v       
                                intdef-ctx      
                                v ...)      -> any
  transformer : procedure?
  binding-id : (or/c identifier? #f)
  context-v : (or/c 'expression 'top-level 'module 'module-begin list?)
  intdef-ctx : (or/c internal-definition-context? #f)
  v : any/c
procedure
(internal-definition-context? v) -> boolean?
  v : any/c
procedure
(syntax-local-make-definition-context [parent-ctx   
                                       add-scope?]) 
 -> internal-definition-context?
  parent-ctx : (or/c internal-definition-context? #f) = #f
  add-scope? : any/c = #t
procedure
(internal-definition-context-add-scopes intdef-ctx     
                                        stx)       -> syntax?
  intdef-ctx : internal-definition-context?
  stx : syntax?
procedure
(internal-definition-context-splice-binding-identifier            
                                                       intdef-ctx 
                                                       id)        
 -> syntax?
  intdef-ctx : internal-definition-context?
  id : identifier?
procedure
(syntax-local-bind-syntaxes  id-list             
                             expr                
                             intdef-ctx          
                            [extra-intdef-ctxs]) 
 -> (listof identifier?)
  id-list : (listof identifier?)
  expr : (or/c syntax? #f)
  intdef-ctx : internal-definition-context?
  extra-intdef-ctxs : (or/c internal-definition-context?
                            (listof internal-definition-context?))
                    = '()
procedure
(internal-definition-context-binding-identifiers intdef-ctx)
 -> (listof identifier?)
  intdef-ctx : internal-definition-context?
procedure
(internal-definition-context-introduce  intdef-ctx     
                                        stx            
                                       [mode])     -> syntax?
  intdef-ctx : internal-definition-context?
  stx : syntax?
  mode : (or/c 'flip 'add 'remove) = 'flip
procedure
(internal-definition-context-seal intdef-ctx) -> void?
  intdef-ctx : internal-definition-context?
procedure
(identifier-remove-from-definition-context id-stx      
                                           intdef-ctx) 
 -> identifier?
  id-stx : identifier?
  intdef-ctx : (or/c internal-definition-context?
                     (listof internal-definition-context?))
value
prop:expansion-contexts : struct-type-property?
procedure
(syntax-local-value  id-stx            
                    [failure-thunk     
                     intdef-ctx])  -> any
  id-stx : identifier?
  failure-thunk : (or/c (-> any) #f) = #f
  intdef-ctx : (or/c internal-definition-context?           = #f
                     #f
                     (listof internal-definition-context?))
procedure
(syntax-local-value/immediate  id-stx            
                              [failure-thunk     
                               intdef-ctx])  -> any
  id-stx : syntax?
  failure-thunk : (or/c (-> any) #f) = #f
  intdef-ctx : (or/c internal-definition-context?           = #f
                     #f
                     (listof internal-definition-context?))
procedure
(syntax-local-lift-expression stx) -> identifier?
  stx : syntax?
procedure
(syntax-local-lift-values-expression n stx)
 -> (listof identifier?)
  n : exact-nonnegative-integer?
  stx : syntax?
procedure
(syntax-local-lift-context) -> any/c
procedure
(syntax-local-lift-module stx) -> void?
  stx : syntax?
procedure
(syntax-local-lift-module-end-declaration stx) -> void?
  stx : syntax?
procedure
(syntax-local-lift-require raw-require-spec     
                           stx                  
                           new-scope?)      -> syntax?
  raw-require-spec : any/c
  stx : syntax?
  new-scope? : #t
procedure
(syntax-local-lift-provide raw-provide-spec-stx) -> void?
  raw-provide-spec-stx : syntax?
procedure
(syntax-local-name) -> any/c
procedure
(syntax-local-context)
 -> (or/c 'expression 'top-level 'module 'module-begin list?)
procedure
(syntax-local-phase-level) -> exact-integer?
procedure
(syntax-local-module-exports mod-path)
 -> (listof (cons/c phase+space? (listof symbol?)))
  mod-path : (or/c module-path?
                   (syntax/c module-path?))
procedure
(syntax-local-submodules) -> (listof symbol?)
procedure
(syntax-local-module-interned-scope-symbols)
 -> (listof symbol?)
procedure
(syntax-local-get-shadower  id-stx                
                           [only-generated?]) -> identifier?
  id-stx : identifier?
  only-generated? : any/c = #f
procedure
(syntax-local-make-delta-introducer id-stx) -> procedure?
  id-stx : identifier?
procedure
(syntax-local-certifier [active?])
 -> ((syntax?) (any/c (or/c procedure? #f))
     . ->* . syntax?)
  active? : boolean? = #f
procedure
(syntax-transforming?) -> boolean?
procedure
(syntax-transforming-with-lifts?) -> boolean?
procedure
(syntax-transforming-module-expression?) -> boolean?
procedure
(syntax-local-identifier-as-binding  id-stx           
                                    [intdef-ctx]) -> identifier?
  id-stx : identifier?
  intdef-ctx : (or/c internal-definition-context? #f) = #f
procedure
(syntax-local-introduce stx) -> syntax?
  stx : syntax?
procedure
(make-syntax-introducer [as-use-site?])
 -> ((syntax?) ((or/c 'flip 'add 'remove)) . ->* . syntax?)
  as-use-site? : any/c = #f
procedure
(make-interned-syntax-introducer key)
 -> ((syntax?) ((or/c 'flip 'add 'remove)) . ->* . syntax?)
  key : (and/c symbol? symbol-interned?)
procedure
(make-syntax-delta-introducer  ext-stx       
                               base-stx      
                              [phase-level]) 
 -> ((syntax?) ((or/c 'flip 'add 'remove)) . ->* . syntax?)
  ext-stx : identifier?
  base-stx : (or/c syntax? #f)
  phase-level : (or/c #f exact-integer?)
              = (syntax-local-phase-level)
procedure
(syntax-local-transforming-module-provides?) -> boolean?
procedure
(syntax-local-module-defined-identifiers)
 -> (and/c hash? immutable?)
procedure
(syntax-local-module-required-identifiers mod-path 
                                          shift)   
 -> (or/c (listof (cons/c phase+space?
                          (listof identifier?)))
          #f)
  mod-path : (or/c module-path? #f)
  shift : (or/c #t phase+space-shift?)
value
prop:liberal-define-context : struct-type-property?
procedure
(liberal-define-context? v) -> boolean?
  v : any/c
procedure
(expand-import require-spec)
 -> (listof import?) (listof import-source?)
  require-spec : syntax?
procedure
(make-require-transformer proc) -> require-transformer?
  proc : (syntax? . -> . (values
                          (listof import?)
                          (listof import-source?)))
value
prop:require-transformer : struct-type-property?
procedure
(require-transformer? v) -> boolean?
  v : any/c
struct
(struct import (local-id
                src-sym
                src-mod-path
                mode
                req-mode
                orig-mode
                orig-stx)
    #:extra-constructor-name make-import)
  local-id : identifier?
  src-sym : symbol?
  src-mod-path : (or/c module-path?
                       (syntax/c module-path?))
  mode : phase+space?
  req-mode : phase+space-shift?
  orig-mode : phase+space?
  orig-stx : syntax?
struct
(struct import-source (mod-path-stx mode)
    #:extra-constructor-name make-import-source)
  mod-path-stx : (syntax/c module-path?)
  mode : phase+space-shift?
parameter
(current-require-module-path) -> (or/c #f module-path-index?)
(current-require-module-path module-path) -> void?
  module-path : (or/c #f module-path-index?)
procedure
(convert-relative-module-path module-path)
 -> (or/c module-path?
          (syntax/c module-path?))
  module-path : (or/c module-path?
                      (syntax/c module-path?))
procedure
(syntax-local-require-certifier)
 -> ((syntax?) (or/c #f (syntax? . -> . syntax?))
     . ->* . syntax?)
procedure
(expand-export provide-spec modes) -> (listof export?)
  provide-spec : syntax?
  modes : (listof phase+space?)
procedure
(pre-expand-export provide-spec modes) -> syntax?
  provide-spec : syntax?
  modes : (listof phase+space?)
procedure
(make-provide-transformer proc) -> provide-transformer?
  proc : (syntax? (listof phase+space?)
          . -> . (listof export?))
(make-provide-transformer proc pre-proc)
 -> (and/c provide-transformer? provide-pre-transformer?)
  proc : (syntax? (listof phase+space?)
          . -> . (listof export?))
  pre-proc : (syntax? (listof phase+space?)
              . -> . syntax?)
procedure
(make-provide-pre-transformer pre-proc)
 -> provide-pre-transformer?
  pre-proc : (syntax? (listof phase+space?)
              . -> . syntax?)
value
prop:provide-transformer : struct-type-property?
value
prop:provide-pre-transformer : struct-type-property?
procedure
(provide-transformer? v) -> boolean?
  v : any/c
procedure
(provide-pre-transformer? v) -> boolean?
  v : any/c
struct
(struct export (local-id out-sym mode protect? orig-stx)
    #:extra-constructor-name make-export)
  local-id : identifier?
  out-sym : symbol?
  mode : phase+space?
  protect? : any/c
  orig-stx : syntax?
procedure
(syntax-local-provide-certifier)
 -> ((syntax?) (or/c #f (syntax? . -> . syntax?))
     . ->* . syntax?)
procedure
(syntax-procedure-alias-property stx)
 -> (or/c #f
          (letrec ([val? (recursive-contract
                          (or/c (cons/c identifier? identifier?)
                                (cons/c val? val?)))])
            val?))
  stx : syntax?
procedure
(syntax-procedure-converted-arguments-property stx)
 -> (or/c #f
          (letrec ([val? (recursive-contract
                          (or/c (cons/c identifier? identifier?)
                                (cons/c val? val?)))])
            val?))
  stx : syntax?
procedure
(portal-syntax? v) -> boolean?
  v : any/c
procedure
(make-portal-syntax stx) -> portal-syntax?
  stx : syntax?
procedure
(portal-syntax-content portal) -> syntax?
  portal : portal-syntax?
syntax
(define-syntax-parameter id expr)
syntax
(syntax-parameterize ([id expr] ...) body-expr ...+)
syntax
(define-rename-transformer-parameter id expr)
procedure
(syntax-parameter-value id-stx) -> any
  id-stx : syntax?
procedure
(make-parameter-rename-transformer id-stx) -> any
  id-stx : syntax?
syntax
splicing-let
syntax
splicing-letrec
syntax
splicing-let-values
syntax
splicing-letrec-values
syntax
splicing-let-syntax
syntax
splicing-letrec-syntax
syntax
splicing-let-syntaxes
syntax
splicing-letrec-syntaxes
syntax
splicing-letrec-syntaxes+values
syntax
splicing-local
syntax
splicing-parameterize
syntax
splicing-syntax-parameterize
procedure
(syntax-property stx key v [preserved?]) -> syntax?
  stx : syntax?
  key : (if preserved? (and/c symbol? symbol-interned?) any/c)
  v : any/c
  preserved? : any/c = (eq? key 'paren-shape)
(syntax-property stx key) -> any
  stx : syntax?
  key : any/c
procedure
(syntax-property-remove stx key) -> syntax?
  stx : syntax?
  key : any/c
procedure
(syntax-property-preserved? stx key) -> boolean?
  stx : syntax?
  key : (and/c symbol? symbol-interned?)
procedure
(syntax-property-symbol-keys stx) -> list?
  stx : syntax?
procedure
(syntax-track-origin new-stx      
                     orig-stx     
                     id-stx)  -> any
  new-stx : syntax?
  orig-stx : syntax?
  id-stx : identifier?
procedure
(syntax-tainted? stx) -> boolean?
  stx : syntax?
procedure
(syntax-arm stx [inspector use-mode?]) -> syntax?
  stx : syntax?
  inspector : (or/c inspector? #f) = #f
  use-mode? : any/c = #f
procedure
(syntax-protect stx) -> syntax?
  stx : syntax?
procedure
(syntax-disarm stx inspector) -> syntax?
  stx : syntax?
  inspector : (or/c inspector? #f)
procedure
(syntax-rearm stx from-stx [use-mode?]) -> syntax?
  stx : syntax?
  from-stx : syntax?
  use-mode? : any/c = #f
procedure
(syntax-taint stx) -> syntax?
  stx : syntax?
procedure
(expand top-level-form [insp]) -> syntax?
  top-level-form : any/c
  insp : inspector? = (current-code-inspector)
procedure
(expand-syntax stx [insp]) -> syntax?
  stx : syntax?
  insp : inspector? = (current-code-inspector)
procedure
(expand-once top-level-form [insp]) -> syntax?
  top-level-form : any/c
  insp : inspector? = (current-code-inspector)
procedure
(expand-syntax-once stx [insp]) -> syntax?
  stx : syntax?
  insp : inspector? = (current-code-inspector)
procedure
(expand-to-top-form top-level-form [insp]) -> syntax?
  top-level-form : any/c
  insp : inspector? = (current-code-inspector)
procedure
(expand-syntax-to-top-form stx [insp]) -> syntax?
  stx : syntax?
  insp : inspector? = (current-code-inspector)
procedure
(syntax-serialize                                                    
                   stx                                               
                   #:preserve-property-keys preserve-property-keys   
                  [#:provides-namespace provides-namespace           
                   #:base-module-path-index base-module-path-index]) 
 -> any/c
  stx : syntax?
  preserve-property-keys : (listof symbol?)
  provides-namespace : (or/c namespace? #f)
                     = (current-namespace)
  base-module-path-index : (or/c module-path-index? #f) = #f
procedure
(syntax-deserialize                                                    
                     v                                                 
                    [#:base-module-path-index base-module-path-index]) 
 -> syntax?
  v : any/c
  base-module-path-index : (or/c module-path-index? #f) = #f
syntax
(include path-spec)
 
path-spec = string
          | (file string)
          | (lib string ...+)
syntax
(include-at/relative-to context source path-spec)
syntax
(include/reader path-spec reader-expr)
syntax
(include-at/relative-to/reader context source path-spec reader-expr)
procedure
(format-id  lctx                               
            fmt                                
            v ...                              
           [#:source src                       
            #:props props                      
            #:cert ignored                     
            #:subs? subs?                      
            #:subs-intro subs-introducer]) -> identifier?
  lctx : (or/c syntax? #f)
  fmt : string?
  v : (or/c string? symbol? keyword? char? number?
            (syntax/c (or/c string? symbol? keyword? char? number?)))
  src : (or/c syntax? #f) = #f
  props : (or/c syntax? #f) = #f
  ignored : (or/c syntax? #f) = #f
  subs? : boolean? = #f
  subs-introducer : (-> syntax? syntax?)
                  = (if (syntax-transforming?) syntax-local-introduce values)
procedure
(format-symbol fmt v ...) -> symbol?
  fmt : string?
  v : (or/c string? symbol? keyword? char? number?
            (syntax/c (or/c string? symbol? keyword? char? number?)))
syntax
(define/with-syntax pattern stx-expr)
 
  stx-expr : syntax?
parameter
(current-syntax-context) -> (or/c syntax? false/c)
(current-syntax-context stx) -> void?
  stx : (or/c syntax? false/c)
procedure
(wrong-syntax stx format-string v ...) -> any
  stx : syntax?
  format-string : string?
  v : any/c
parameter
(current-recorded-disappeared-uses)
 -> (or/c (listof identifier?) false/c)
(current-recorded-disappeared-uses ids) -> void?
  ids : (or/c (listof identifier?) false/c)
syntax
(with-disappeared-uses body-expr ... stx-expr)
 
  stx-expr : syntax?
procedure
(syntax-local-value/record id predicate) -> any/c
  id : identifier?
  predicate : (-> any/c boolean?)
procedure
(record-disappeared-uses id [intro?]) -> void?
  id : (or/c identifier? (listof identifier?))
  intro? : boolean? = (syntax-transforming?)
procedure
(generate-temporary [name-base]) -> identifier?
  name-base : any/c = 'g
procedure
(internal-definition-context-apply intdef-ctx     
                                   stx)       -> syntax?
  intdef-ctx : internal-definition-context?
  stx : syntax?
procedure
(syntax-local-eval stx [intdef-ctx]) -> any
  stx : any/c
  intdef-ctx : (or/c internal-definition-context?
                     #f
                     (listof internal-definition-context?))
             = '()
syntax
(with-syntax* ([pattern stx-expr] ...)
  body ...+)
 
  stx-expr : syntax?
procedure
(phase? v) -> boolean?
  v : any/c
procedure
(space? v) -> boolean?
  v : any/c
procedure
(phase+space? v) -> boolean?
  v : any/c
procedure
(phase+space phase space) -> phase+space?
  phase : phase?
  space : space?
procedure
(phase+space-phase p+s) -> phase?
  p+s : phase+space?
procedure
(phase+space-space p+s) -> phase?
  p+s : phase+space?
procedure
(phase+space-shift? v) -> boolean?
  v : any/c
procedure
(phase+space+ p+s shift) -> phase+space?
  p+s : phase+space?
  shift : phase+space-shift?
procedure
(phase+space-shift+ shift additional-shift) -> phase+space-shift?
  shift : phase+space?
  additional-shift : phase+space-shift?
parameter
(current-locale) -> (or/c string? #f)
(current-locale locale) -> void?
  locale : (or/c string? #f)
procedure
(input-port? v) -> boolean?
  v : any/c
procedure
(output-port? v) -> boolean?
  v : any/c
procedure
(port? v) -> boolean?
  v : any/c
procedure
(close-input-port in) -> void?
  in : input-port?
procedure
(close-output-port out) -> void?
  out : output-port?
procedure
(port-closed? port) -> boolean?
  port : port?
procedure
(port-closed-evt port) -> evt?
  port : port?
parameter
(current-input-port) -> input-port?
(current-input-port in) -> void?
  in : input-port?
parameter
(current-output-port) -> output-port?
(current-output-port out) -> void?
  out : output-port?
parameter
(current-error-port) -> output-port?
(current-error-port out) -> void?
  out : output-port?
procedure
(file-stream-port? v) -> boolean?
  v : any/c
procedure
(terminal-port? v) -> boolean?
  v : any/c
procedure
(port-waiting-peer? port) -> boolean?
  port : port?
value
eof : eof-object?
procedure
(eof-object? v) -> boolean?
  v : any/c
procedure
(flush-output [out]) -> void?
  out : output-port? = (current-output-port)
procedure
(file-stream-buffer-mode port) -> (or/c 'none 'line 'block #f)
  port : port?
(file-stream-buffer-mode port mode) -> void?
  port : port?
  mode : (or/c 'none 'line 'block)
procedure
(file-position port) -> exact-nonnegative-integer?
  port : port?
(file-position port pos) -> void?
  port : port?
  pos : (or/c exact-nonnegative-integer? eof-object?)
procedure
(file-position* port) -> (or/c exact-nonnegative-integer? #f)
  port : port?
procedure
(file-truncate port size) -> void?
  port : (and/c output-port? file-stream-port?)
  size : exact-nonnegative-integer?
procedure
(port-count-lines! port) -> void?
  port : port?
procedure
(port-counts-lines? port) -> boolean?
  port : port?
procedure
(port-next-location port)
 -> (or/c exact-positive-integer? #f)
    (or/c exact-nonnegative-integer? #f)
    (or/c exact-positive-integer? #f)
  port : port?
procedure
(set-port-next-location! port          
                         line          
                         column        
                         position) -> void?
  port : port?
  line : (or/c exact-positive-integer? #f)
  column : (or/c exact-nonnegative-integer? #f)
  position : (or/c exact-positive-integer? #f)
parameter
(port-count-lines-enabled) -> boolean?
(port-count-lines-enabled on?) -> void?
  on? : any/c
procedure
(open-input-file  path                            
                 [#:mode mode-flag                
                  #:for-module? for-module?]) -> input-port?
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
  for-module? : any/c = #f
procedure
(open-output-file  path                                         
                  [#:mode mode-flag                             
                   #:exists exists-flag                         
                   #:permissions permissions]                   
                   #:replace-permissions? replace-permissions?) 
 -> output-port?
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
  exists-flag : (or/c 'error 'append 'update 'can-update
                      'replace 'truncate
                      'must-truncate 'truncate/replace)
              = 'error
  permissions : (integer-in 0 65535) = #o666
  replace-permissions? : #f
procedure
(open-input-output-file                                               
                         path                                         
                        [#:mode mode-flag                             
                         #:exists exists-flag                         
                         #:permissions permissions]                   
                         #:replace-permissions? replace-permissions?) 
 -> input-port? output-port?
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
  exists-flag : (or/c 'error 'append 'update 'can-update
                      'replace 'truncate
                      'must-truncate 'truncate/replace)
              = 'error
  permissions : (integer-in 0 65535) = #o666
  replace-permissions? : #f
procedure
(call-with-input-file  path                   
                       proc                   
                      [#:mode mode-flag]) -> any
  path : path-string?
  proc : (input-port? . -> . any)
  mode-flag : (or/c 'binary 'text) = 'binary
procedure
(call-with-output-file                                               
                        path                                         
                        proc                                         
                       [#:mode mode-flag                             
                        #:exists exists-flag                         
                        #:permissions permissions]                   
                        #:replace-permissions? replace-permissions?) 
 -> any
  path : path-string?
  proc : (output-port? . -> . any)
  mode-flag : (or/c 'binary 'text) = 'binary
  exists-flag : (or/c 'error 'append 'update 'can-update
                      'replace 'truncate
                      'must-truncate 'truncate/replace)
              = 'error
  permissions : (integer-in 0 65535) = #o666
  replace-permissions? : #f
procedure
(call-with-input-file*  path                   
                        proc                   
                       [#:mode mode-flag]) -> any
  path : path-string?
  proc : (input-port? . -> . any)
  mode-flag : (or/c 'binary 'text) = 'binary
procedure
(call-with-output-file*                                               
                         path                                         
                         proc                                         
                        [#:mode mode-flag                             
                         #:exists exists-flag                         
                         #:permissions permissions]                   
                         #:replace-permissions? replace-permissions?) 
 -> any
  path : path-string?
  proc : (output-port? . -> . any)
  mode-flag : (or/c 'binary 'text) = 'binary
  exists-flag : (or/c 'error 'append 'update 'can-update
                      'replace 'truncate
                      'must-truncate 'truncate/replace)
              = 'error
  permissions : (integer-in 0 65535) = #o666
  replace-permissions? : #f
procedure
(with-input-from-file  path                   
                       thunk                  
                      [#:mode mode-flag]) -> any
  path : path-string?
  thunk : (-> any)
  mode-flag : (or/c 'binary 'text) = 'binary
procedure
(with-output-to-file                                               
                      path                                         
                      thunk                                        
                     [#:mode mode-flag                             
                      #:exists exists-flag                         
                      #:permissions permissions]                   
                      #:replace-permissions? replace-permissions?) 
 -> any
  path : path-string?
  thunk : (-> any)
  mode-flag : (or/c 'binary 'text) = 'binary
  exists-flag : (or/c 'error 'append 'update 'can-update
                      'replace 'truncate
                      'must-truncate 'truncate/replace)
              = 'error
  permissions : (integer-in 0 65535) = #o666
  replace-permissions? : #f
procedure
(port-try-file-lock? port mode) -> boolean?
  port : file-stream-port?
  mode : (or/c 'shared 'exclusive)
procedure
(port-file-unlock port) -> void?
  port : file-stream-port?
procedure
(port-file-identity port) -> exact-positive-integer?
  port : file-stream-port?
procedure
(string-port? p) -> boolean?
  p : port?
procedure
(open-input-bytes bstr [name]) -> (and/c input-port? string-port?)
  bstr : bytes?
  name : any/c = 'string
procedure
(open-input-string str [name]) -> (and/c input-port? string-port?)
  str : string?
  name : any/c = 'string
procedure
(open-output-bytes [name]) -> (and/c output-port? string-port?)
  name : any/c = 'string
procedure
(open-output-string [name]) -> (and/c output-port? string-port?)
  name : any/c = 'string
procedure
(get-output-bytes  out           
                  [reset?        
                   start-pos     
                   end-pos]) -> bytes?
  out : (and/c output-port? string-port?)
  reset? : any/c = #f
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = #f
procedure
(get-output-string out) -> string?
  out : (and/c output-port? string-port?)
procedure
(make-pipe [limit input-name output-name])
 -> input-port? output-port?
  limit : exact-positive-integer? = #f
  input-name : any/c = 'pipe
  output-name : any/c = 'pipe
procedure
(pipe-content-length pipe-port) -> exact-nonnegative-integer?
  pipe-port : port?
value
prop:input-port : struct-type-property?
value
prop:output-port : struct-type-property?
procedure
(make-input-port  name                 
                  read-in              
                  peek                 
                  close                
                 [get-progress-evt     
                  commit               
                  get-location         
                  count-lines!         
                  init-position        
                  buffer-mode])    -> input-port?
  name : any/c
  read-in : (or/c
             (bytes?
              . -> . (or/c exact-nonnegative-integer?
                           eof-object?
                           procedure?
                           evt?))
             input-port?)
  peek : (or/c
          (bytes? exact-nonnegative-integer? (or/c evt? #f)
                  . -> . (or/c exact-nonnegative-integer?
                               eof-object?
                               procedure?
                               evt?
                               #f))
          input-port?
          #f)
  close : (-> any)
  get-progress-evt : (or/c (-> evt?) #f) = #f
  commit : (or/c (exact-positive-integer? evt? evt? . -> . any)
                 #f)
         = #f
  get-location : (or/c
                  (->
                   (values (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f)
                           (or/c exact-positive-integer? #f)))
                  #f)
               = #f
  count-lines! : (-> any) = void
  init-position : (or/c exact-positive-integer?
                        port?
                        #f
                        (-> (or/c exact-positive-integer? #f)))
                = 1
  buffer-mode : (or/c (case-> ((or/c 'block 'none) . -> . any)
                              (-> (or/c 'block 'none #f)))
                      #f)
              = #f
procedure
(make-output-port  name                      
                   evt                       
                   write-out                 
                   close                     
                  [write-out-special         
                   get-write-evt             
                   get-write-special-evt     
                   get-location              
                   count-lines!              
                   init-position             
                   buffer-mode])         -> output-port?
  name : any/c
  evt : evt?
  write-out : (or/c
               (bytes? exact-nonnegative-integer?
                       exact-nonnegative-integer?
                       boolean?
                       boolean?
                       . -> .
                       (or/c exact-nonnegative-integer?
                             #f
                             evt?))
               output-port?)
  close : (-> any)
  write-out-special : (or/c (any/c boolean? boolean? = #f
                                   . -> .
                                   (or/c any/c
                                         #f
                                         evt?))
                            output-port?
                            #f)
  get-write-evt : (or/c                               = #f
                   (bytes? exact-nonnegative-integer?
                           exact-nonnegative-integer?
                           . -> .
                           evt?)
                   #f)
  get-write-special-evt : (or/c                = #f
                           (any/c . -> . evt?)
                           #f)
  get-location : (or/c
                  (->
                   (values (or/c exact-positive-integer? #f)
                           (or/c exact-nonnegative-integer? #f)
                           (or/c exact-positive-integer? #f)))
                  #f)
               = #f
  count-lines! : (-> any) = void
  init-position : (or/c exact-positive-integer?
                        port?
                        #f
                        (-> (or/c exact-positive-integer? #f)))
                = 1
  buffer-mode : (or/c (case->
                       ((or/c 'block 'line 'none) . -> . any)
                       (-> (or/c 'block 'line 'none #f)))
                      #f)
              = #f
procedure
(port->list [r in]) -> (listof any/c)
  r : (input-port? . -> . any/c) = read
  in : input-port? = (current-input-port)
procedure
(port->string [in #:close? close?]) -> string?
  in : input-port? = (current-input-port)
  close? : any/c = #f
procedure
(port->bytes [in #:close? close?]) -> bytes?
  in : input-port? = (current-input-port)
  close? : any/c = #f
procedure
(port->lines [in                        
              #:line-mode line-mode     
              #:close? close?])     -> (listof string?)
  in : input-port? = (current-input-port)
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
            = 'any
  close? : any/c = #f
procedure
(port->bytes-lines [in                        
                    #:line-mode line-mode     
                    #:close? close?])     -> (listof bytes?)
  in : input-port? = (current-input-port)
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
            = 'any
  close? : any/c = #f
procedure
(display-lines  lst                         
               [out                         
                #:separator separator]) -> void?
  lst : list?
  out : output-port? = (current-output-port)
  separator : any/c = #"\n"
procedure
(call-with-output-string proc) -> string?
  proc : (output-port? . -> . any)
procedure
(call-with-output-bytes proc) -> bytes?
  proc : (output-port? . -> . any)
procedure
(with-output-to-string proc) -> string?
  proc : (-> any)
procedure
(with-output-to-bytes proc) -> bytes?
  proc : (-> any)
procedure
(call-with-input-string str proc) -> any
  str : string?
  proc : (input-port? . -> . any)
procedure
(call-with-input-bytes bstr proc) -> any
  bstr : bytes?
  proc : (input-port? . -> . any)
procedure
(with-input-from-string str proc) -> any
  str : string?
  proc : (-> any)
procedure
(with-input-from-bytes bstr proc) -> any
  bstr : bytes?
  proc : (-> any)
procedure
(input-port-append  close-at-eof?     
                    in ...            
                   [#:name name]) -> input-port?
  close-at-eof? : any/c
  in : input-port?
  name : any/c = (map object-name in)
procedure
(make-input-port/read-to-peek  name              
                               read-in           
                               fast-peek         
                               close             
                              [get-location      
                               count-lines!      
                               init-position     
                               buffer-mode       
                               buffering?        
                               on-consumed]) -> input-port?
  name : any/c
  read-in : (bytes?
             . -> . (or/c exact-nonnegative-integer?
                          eof-object?
                          procedure?
                          evt?))
  fast-peek : (or/c #f
                    (bytes? exact-nonnegative-integer?
                     (bytes? exact-nonnegative-integer?
                      . -> . (or/c exact-nonnegative-integer?
                                   eof-object?
                                   procedure?
                                   evt?
                                   #f))
                     . -> . (or/c exact-nonnegative-integer?
                                  eof-object?
                                  procedure?
                                  evt?
                                  #f)))
  close : (-> any)
  get-location : (or/c                                   = #f
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  count-lines! : (-> any) = void
  init-position : exact-positive-integer? = 1
  buffer-mode : (or/c (case-> ((or/c 'block 'none) . -> . any)
                              (-> (or/c 'block 'none #f)))
                      #f)
              = #f
  buffering? : any/c = #f
  on-consumed : (or/c ((or/c exact-nonnegative-integer? eof-object?
                             procedure? evt?)
                       . -> . any)
                      #f)
              = #f
procedure
(make-limited-input-port  in                
                          limit             
                         [close-orig?]) -> input-port?
  in : input-port?
  limit : exact-nonnegative-integer?
  close-orig? : any/c = #t
procedure
(make-pipe-with-specials [limit          
                          in-name        
                          out-name]) -> input-port? output-port?
  limit : exact-nonnegative-integer? = #f
  in-name : any/c = 'pipe
  out-name : any/c = 'pipe
procedure
(combine-output a-out b-out) -> output-port?
  a-out : output-port?
  b-out : output-port?
procedure
(merge-input a-in b-in [buffer-limit]) -> input-port?
  a-in : input-port?
  b-in : input-port?
  buffer-limit : (or/c exact-nonnegative-integer? #f) = 4096
procedure
(open-output-nowhere [name special-ok?]) -> output-port?
  name : any/c = 'nowhere
  special-ok? : any/c = #t
procedure
(peeking-input-port  in                              
                    [name                            
                     skip                            
                     #:init-position init-position]) 
 -> input-port?
  in : input-port?
  name : any/c = (object-name in)
  skip : exact-nonnegative-integer? = 0
  init-position : exact-positive-integer? = 1
procedure
(reencode-input-port  in                    
                      encoding              
                     [error-bytes           
                      close?                
                      name                  
                      convert-newlines?     
                      enc-error])       -> input-port?
  in : input-port?
  encoding : string?
  error-bytes : (or/c #f bytes?) = #f
  close? : any/c = #f
  name : any/c = (object-name in)
  convert-newlines? : any/c = #f
  enc-error : (string? input-port? . -> . any)
            = (lambda (msg port) (error ...))
procedure
(reencode-output-port  out               
                       encoding          
                      [error-bytes       
                       close?            
                       name              
                       newline-bytes     
                       enc-error])   -> output-port?
  out : output-port?
  encoding : string?
  error-bytes : (or/c #f bytes?) = #f
  close? : any/c = #f
  name : any/c = (object-name out)
  newline-bytes : (or/c #f bytes?) = #f
  enc-error : (string? output-port? . -> . any)
            = (lambda (msg port) (error ...))
procedure
(dup-input-port in [close?]) -> input-port?
  in : input-port?
  close? : any/c = #f
procedure
(dup-output-port out [close?]) -> output-port?
  out : output-port?
  close? : any/c = #f
procedure
(relocate-input-port  in               
                      line             
                      column           
                      position         
                     [close?]          
                      #:name name) -> input-port?
  in : input-port?
  line : (or/c exact-positive-integer? #f)
  column : (or/c exact-nonnegative-integer? #f)
  position : exact-positive-integer?
  close? : any/c = #t
  name : (object-name in)
procedure
(relocate-output-port  out              
                       line             
                       column           
                       position         
                      [close?]          
                       #:name name) -> output-port?
  out : output-port?
  line : (or/c exact-positive-integer? #f)
  column : (or/c exact-nonnegative-integer? #f)
  position : exact-positive-integer?
  close? : any/c = #t
  name : (object-name out)
procedure
(transplant-input-port  in                
                        get-location      
                        init-pos          
                       [close?            
                        count-lines!]     
                        #:name name)  -> input-port?
  in : input-port?
  get-location : (or/c
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  init-pos : exact-positive-integer?
  close? : any/c = #t
  count-lines! : (-> any) = void
  name : (object-name in)
procedure
(transplant-output-port  out               
                         get-location      
                         init-pos          
                        [close?            
                         count-lines!]     
                         #:name name)  -> output-port?
  out : output-port?
  get-location : (or/c
                  (->
                   (values
                    (or/c exact-positive-integer? #f)
                    (or/c exact-nonnegative-integer? #f)
                    (or/c exact-positive-integer? #f)))
                  #f)
  init-pos : exact-positive-integer?
  close? : any/c = #t
  count-lines! : (-> any) = void
  name : (object-name out)
procedure
(filter-read-input-port  in            
                         read-wrap     
                         peek-wrap     
                        [close?])  -> input-port?
  in : input-port?
  read-wrap : (bytes? (or/c exact-nonnegative-integer?
                            eof-object?
                            procedure?
                            evt?)
                      . -> .
                      (or/c exact-nonnegative-integer?
                            eof-object?
                            procedure?
                            evt?))
  peek-wrap : (bytes? exact-nonnegative-integer? (or/c evt? #f)
                      (or/c exact-nonnegative-integer?
                       eof-object?
                       procedure?
                       evt?
                       #f)
               . -> . (or/c exact-nonnegative-integer?
                       eof-object?
                       procedure?
                       evt?
                       #f))
  close? : any/c = #t
procedure
(special-filter-input-port in proc [close?]) -> input-port?
  in : input-port?
  proc : (procedure? bytes? . -> . (or/c exact-nonnegative-integer?
                                         eof-object?
                                         procedure?
                                         evt?))
  close? : any/c = #t
procedure
(eof-evt in) -> evt?
  in : input-port?
procedure
(read-bytes-evt k in) -> evt?
  k : exact-nonnegative-integer?
  in : input-port?
procedure
(read-bytes!-evt bstr in) -> evt?
  bstr : (and/c bytes? (not/c immutable?))
  in : input-port?
procedure
(read-bytes-avail!-evt bstr in) -> evt?
  bstr : (and/c bytes? (not/c immutable?))
  in : input-port?
procedure
(read-string-evt k in) -> evt?
  k : exact-nonnegative-integer?
  in : input-port?
procedure
(read-string!-evt str in) -> evt?
  str : (and/c string? (not/c immutable?))
  in : input-port?
procedure
(read-line-evt in [mode]) -> evt?
  in : input-port?
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
       = 'linefeed
procedure
(read-bytes-line-evt in [mode]) -> evt?
  in : input-port?
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
       = 'linefeed
procedure
(peek-bytes-evt k skip progress-evt in) -> evt?
  k : exact-nonnegative-integer?
  skip : exact-nonnegative-integer?
  progress-evt : (or/c progress-evt? #f)
  in : input-port?
(peek-bytes!-evt bstr skip progress-evt in) -> evt?
  bstr : (and/c bytes? (not/c immutable?))
  skip : exact-nonnegative-integer?
  progress-evt : (or/c progress-evt? #f)
  in : input-port?
(peek-bytes-avail!-evt bstr             
                       skip             
                       progress-evt     
                       in)          -> evt?
  bstr : (and/c bytes? (not/c immutable?))
  skip : exact-nonnegative-integer?
  progress-evt : (or/c progress-evt? #f)
  in : input-port?
(peek-string-evt k skip progress-evt in) -> evt?
  k : exact-nonnegative-integer?
  skip : exact-nonnegative-integer?
  progress-evt : (or/c progress-evt? #f)
  in : input-port?
(peek-string!-evt str skip progress-evt in) -> evt?
  str : (and/c string? (not/c immutable?))
  skip : exact-nonnegative-integer?
  progress-evt : (or/c progress-evt? #f)
  in : input-port?
procedure
(regexp-match-evt pattern in) -> any
  pattern : (or/c string? bytes? regexp? byte-regexp?)
  in : input-port?
procedure
(convert-stream from-encoding     
                in                
                to-encoding       
                out)          -> void?
  from-encoding : string?
  in : input-port?
  to-encoding : string?
  out : output-port?
procedure
(copy-port in out ...+) -> void?
  in : input-port?
  out : output-port?
procedure
(read-char [in]) -> (or/c char? eof-object?)
  in : input-port? = (current-input-port)
procedure
(read-byte [in]) -> (or/c byte? eof-object?)
  in : input-port? = (current-input-port)
procedure
(read-line [in mode]) -> (or/c string? eof-object?)
  in : input-port? = (current-input-port)
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
       = 'linefeed
procedure
(read-bytes-line [in mode]) -> (or/c bytes? eof-object?)
  in : input-port? = (current-input-port)
  mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
       = 'linefeed
procedure
(read-string amt [in]) -> (or/c string? eof-object?)
  amt : exact-nonnegative-integer?
  in : input-port? = (current-input-port)
procedure
(read-bytes amt [in]) -> (or/c bytes? eof-object?)
  amt : exact-nonnegative-integer?
  in : input-port? = (current-input-port)
procedure
(read-string! str [in start-pos end-pos])
 -> (or/c exact-nonnegative-integer? eof-object?)
  str : (and/c string? (not/c immutable?))
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (string-length str)
procedure
(read-bytes! bstr [in start-pos end-pos])
 -> (or/c exact-nonnegative-integer? eof-object?)
  bstr : bytes?
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(read-bytes-avail! bstr [in start-pos end-pos])
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : bytes?
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(read-bytes-avail!*  bstr      
                    [in        
                     start-pos 
                     end-pos]) 
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : bytes?
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(read-bytes-avail!/enable-break  bstr      
                                [in        
                                 start-pos 
                                 end-pos]) 
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : bytes?
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(peek-string amt skip-bytes-amt [in]) -> (or/c string? eof-object?)
  amt : exact-nonnegative-integer?
  skip-bytes-amt : exact-nonnegative-integer?
  in : input-port? = (current-input-port)
procedure
(peek-bytes amt skip-bytes-amt [in]) -> (or/c bytes? eof-object?)
  amt : exact-nonnegative-integer?
  skip-bytes-amt : exact-nonnegative-integer?
  in : input-port? = (current-input-port)
procedure
(peek-string!  str            
               skip-bytes-amt 
              [in             
               start-pos      
               end-pos])      
 -> (or/c exact-nonnegative-integer? eof-object?)
  str : (and/c string? (not/c immutable?))
  skip-bytes-amt : exact-nonnegative-integer?
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (string-length str)
procedure
(peek-bytes!  bstr           
              skip-bytes-amt 
             [in             
              start-pos      
              end-pos])      
 -> (or/c exact-nonnegative-integer? eof-object?)
  bstr : (and/c bytes? (not/c immutable?))
  skip-bytes-amt : exact-nonnegative-integer?
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(peek-bytes-avail!  bstr           
                    skip-bytes-amt 
                   [progress       
                    in             
                    start-pos      
                    end-pos])      
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : (and/c bytes? (not/c immutable?))
  skip-bytes-amt : exact-nonnegative-integer?
  progress : (or/c progress-evt? #f) = #f
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(peek-bytes-avail!*  bstr           
                     skip-bytes-amt 
                    [progress       
                     in             
                     start-pos      
                     end-pos])      
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : (and/c bytes? (not/c immutable?))
  skip-bytes-amt : exact-nonnegative-integer?
  progress : (or/c progress-evt? #f) = #f
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(peek-bytes-avail!/enable-break  bstr           
                                 skip-bytes-amt 
                                [progress       
                                 in             
                                 start-pos      
                                 end-pos])      
 -> (or/c exact-nonnegative-integer? eof-object? procedure?)
  bstr : (and/c bytes? (not/c immutable?))
  skip-bytes-amt : exact-nonnegative-integer?
  progress : (or/c progress-evt? #f) = #f
  in : input-port? = (current-input-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(read-char-or-special [in            
                       special-wrap  
                       source-name]) 
 -> (or/c char? eof-object? any/c)
  in : input-port? = (current-input-port)
  special-wrap : (or/c (any/c -> any/c) #f) = #f
  source-name : any/c = #f
procedure
(read-byte-or-special [in            
                       special-wrap  
                       source-name]) 
 -> (or/c byte? eof-object? any/c)
  in : input-port? = (current-input-port)
  special-wrap : (or/c (any/c -> any/c) #f) = #f
  source-name : any/c = #f
procedure
(peek-char [in skip-bytes-amt]) -> (or/c char? eof-object?)
  in : input-port? = (current-input-port)
  skip-bytes-amt : exact-nonnegative-integer? = 0
procedure
(peek-byte [in skip-bytes-amt]) -> (or/c byte? eof-object?)
  in : input-port? = (current-input-port)
  skip-bytes-amt : exact-nonnegative-integer? = 0
procedure
(peek-char-or-special [in             
                       skip-bytes-amt 
                       special-wrap   
                       source-name])  
 -> (or/c char? eof-object? any/c)
  in : input-port? = (current-input-port)
  skip-bytes-amt : exact-nonnegative-integer? = 0
  special-wrap : (or/c (any/c -> any/c) #f 'special) = #f
  source-name : any/c = #f
procedure
(peek-byte-or-special [in             
                       skip-bytes-amt 
                       progress       
                       special-wrap   
                       source-name])  
 -> (or/c byte? eof-object? any/c)
  in : input-port? = (current-input-port)
  skip-bytes-amt : exact-nonnegative-integer? = 0
  progress : (or/c progress-evt? #f) = #f
  special-wrap : (or/c (any/c -> any/c) #f 'special) = #f
  source-name : any/c = #f
procedure
(port-progress-evt [in]) -> progress-evt?
  in : (and/c input-port? port-provides-progress-evts?)
     = (current-input-port)
procedure
(port-provides-progress-evts? in) -> boolean
  in : input-port?
procedure
(port-commit-peeked amt progress evt [in]) -> boolean?
  amt : exact-nonnegative-integer?
  progress : progress-evt?
  evt : evt?
  in : input-port? = (current-input-port)
procedure
(byte-ready? [in]) -> boolean?
  in : input-port? = (current-input-port)
procedure
(char-ready? [in]) -> boolean?
  in : input-port? = (current-input-port)
procedure
(progress-evt? v) -> boolean?
  v : any/c
(progress-evt? evt in) -> boolean?
  evt : progress-evt?
  in : input-port?
procedure
(write-char char [out]) -> void?
  char : char?
  out : output-port? = (current-output-port)
procedure
(write-byte byte [out]) -> void?
  byte : byte?
  out : output-port? = (current-output-port)
procedure
(newline [out]) -> void?
  out : output-port? = (current-output-port)
procedure
(write-string str [out start-pos end-pos])
 -> exact-nonnegative-integer?
  str : string?
  out : output-port? = (current-output-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (string-length str)
procedure
(write-bytes bstr [out start-pos end-pos])
 -> exact-nonnegative-integer?
  bstr : bytes?
  out : output-port? = (current-output-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(write-bytes-avail  bstr          
                   [out           
                    start-pos     
                    end-pos]) -> exact-nonnegative-integer?
  bstr : bytes?
  out : output-port? = (current-output-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(write-bytes-avail*  bstr      
                    [out       
                     start-pos 
                     end-pos]) 
 -> (or/c exact-nonnegative-integer? #f)
  bstr : bytes?
  out : output-port? = (current-output-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(write-bytes-avail/enable-break  bstr      
                                [out       
                                 start-pos 
                                 end-pos]) 
 -> exact-nonnegative-integer?
  bstr : bytes?
  out : output-port? = (current-output-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(write-special v [out]) -> boolean?
  v : any/c
  out : output-port? = (current-output-port)
procedure
(write-special-avail* v [out]) -> boolean?
  v : any/c
  out : output-port? = (current-output-port)
procedure
(write-bytes-avail-evt  bstr          
                       [out           
                        start-pos     
                        end-pos]) -> evt?
  bstr : bytes?
  out : output-port? = (current-output-port)
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(write-special-evt v [out]) -> evt?
  v : any/c
  out : output-port? = (current-output-port)
procedure
(port-writes-atomic? out) -> boolean?
  out : output-port?
procedure
(port-writes-special? out) -> boolean?
  out : output-port?
procedure
(read [in]) -> any
  in : input-port? = (current-input-port)
procedure
(read-syntax [source-name in]) -> (or/c syntax? eof-object?)
  source-name : any/c = (object-name (current-input-port))
  in : input-port? = (current-input-port)
procedure
(read/recursive [in start readtable graph?]) -> any
  in : input-port? = (current-input-port)
  start : (or/c char? #f) = #f
  readtable : (or/c readtable? #f) = (current-readtable)
  graph? : any/c = #t
procedure
(read-syntax/recursive [source-name     
                        in              
                        start           
                        readtable       
                        graph?])    -> any
  source-name : any/c = (object-name in)
  in : input-port? = (current-input-port)
  start : (or/c char? #f) = #f
  readtable : (or/c readtable? #f) = (current-readtable)
  graph? : any/c = #t
procedure
(read-language [in fail-thunk])
 -> (or/c (any/c any/c . -> . any) #f)
  in : input-port? = (current-input-port)
  fail-thunk : (-> any) = (lambda () (error ...))
parameter
(read-case-sensitive) -> boolean?
(read-case-sensitive on?) -> void?
  on? : any/c
parameter
(read-square-bracket-as-paren) -> boolean?
(read-square-bracket-as-paren on?) -> void?
  on? : any/c
parameter
(read-curly-brace-as-paren) -> boolean?
(read-curly-brace-as-paren on?) -> void?
  on? : any/c
parameter
(read-square-bracket-with-tag) -> boolean?
(read-square-bracket-with-tag on?) -> void?
  on? : any/c
parameter
(read-curly-brace-with-tag) -> boolean?
(read-curly-brace-with-tag on?) -> void?
  on? : any/c
parameter
(read-accept-box) -> boolean?
(read-accept-box on?) -> void?
  on? : any/c
parameter
(read-accept-compiled) -> boolean?
(read-accept-compiled on?) -> void?
  on? : any/c
parameter
(read-accept-bar-quote) -> boolean?
(read-accept-bar-quote on?) -> void?
  on? : any/c
parameter
(read-accept-graph) -> boolean?
(read-accept-graph on?) -> void?
  on? : any/c
parameter
(read-syntax-accept-graph) -> boolean?
(read-syntax-accept-graph on?) -> void?
  on? : any/c
parameter
(read-decimal-as-inexact) -> boolean?
(read-decimal-as-inexact on?) -> void?
  on? : any/c
parameter
(read-single-flonum) -> boolean?
(read-single-flonum on?) -> void?
  on? : any/c
parameter
(read-accept-dot) -> boolean?
(read-accept-dot on?) -> void?
  on? : any/c
parameter
(read-accept-infix-dot) -> boolean?
(read-accept-infix-dot on?) -> void?
  on? : any/c
parameter
(read-cdot) -> boolean?
(read-cdot on?) -> void?
  on? : any/c
parameter
(read-accept-quasiquote) -> boolean?
(read-accept-quasiquote on?) -> void?
  on? : any/c
parameter
(read-accept-reader) -> boolean?
(read-accept-reader on?) -> void?
  on? : any/c
parameter
(read-accept-lang) -> boolean?
(read-accept-lang on?) -> void?
  on? : any/c
parameter
(current-readtable) -> (or/c readtable? #f)
(current-readtable readtable) -> void?
  readtable : (or/c readtable? #f)
procedure
(call-with-default-reading-parameterization thunk) -> any
  thunk : (-> any)
parameter
(current-reader-guard) -> (any/c . -> . any)
(current-reader-guard proc) -> void?
  proc : (any/c . -> . any)
parameter
(read-on-demand-source)
 -> (or/c #f #t (and/c path? complete-path?))
(read-on-demand-source mode) -> void?
  mode : (or/c #f #t (and/c path? complete-path?))
procedure
(port-read-handler in) -> (case->
                           (input-port? . -> . any)
                           (input-port?  any/c . -> . any))
  in : input-port?
(port-read-handler in proc) -> void?
  in : input-port?
  proc : (case->
          (input-port? . -> . any)
          (input-port? any/c . -> . any))
procedure
(write datum [out]) -> void?
  datum : any/c
  out : output-port? = (current-output-port)
procedure
(display datum [out]) -> void?
  datum : any/c
  out : output-port? = (current-output-port)
procedure
(print datum [out quote-depth]) -> void?
  datum : any/c
  out : output-port? = (current-output-port)
  quote-depth : (or/c 0 1) = 0
procedure
(writeln datum [out]) -> void?
  datum : any/c
  out : output-port? = (current-output-port)
procedure
(displayln datum [out]) -> void?
  datum : any/c
  out : output-port? = (current-output-port)
procedure
(println datum [out quote-depth]) -> void?
  datum : any/c
  out : output-port? = (current-output-port)
  quote-depth : (or/c 0 1) = 0
procedure
(fprintf out form v ...) -> void?
  out : output-port?
  form : string?
  v : any/c
procedure
(printf form v ...) -> void?
  form : string?
  v : any/c
procedure
(eprintf form v ...) -> void?
  form : string?
  v : any/c
procedure
(format form v ...) -> string?
  form : string?
  v : any/c
parameter
(print-pair-curly-braces) -> boolean?
(print-pair-curly-braces on?) -> void?
  on? : any/c
parameter
(print-mpair-curly-braces) -> boolean?
(print-mpair-curly-braces on?) -> void?
  on? : any/c
parameter
(print-unreadable) -> boolean?
(print-unreadable on?) -> void?
  on? : any/c
parameter
(print-graph) -> boolean?
(print-graph on?) -> void?
  on? : any/c
parameter
(print-struct) -> boolean?
(print-struct on?) -> void?
  on? : any/c
parameter
(print-box) -> boolean?
(print-box on?) -> void?
  on? : any/c
parameter
(print-vector-length) -> boolean?
(print-vector-length on?) -> void?
  on? : any/c
parameter
(print-hash-table) -> boolean?
(print-hash-table on?) -> void?
  on? : any/c
parameter
(print-boolean-long-form) -> boolean?
(print-boolean-long-form on?) -> void?
  on? : any/c
parameter
(print-reader-abbreviations) -> boolean?
(print-reader-abbreviations on?) -> void?
  on? : any/c
parameter
(print-as-expression) -> boolean?
(print-as-expression on?) -> void?
  on? : any/c
parameter
(print-syntax-width)
 -> (or/c +inf.0 0 (and/c exact-integer? (>/c 3)))
(print-syntax-width width) -> void?
  width : (or/c +inf.0 0 (and/c exact-integer? (>/c 3)))
parameter
(print-value-columns)
 -> (or/c +inf.0 (and/c exact-integer? (>/c 5)))
(print-value-columns columns) -> void?
  columns : (or/c +inf.0 (and/c exact-integer? (>/c 5)))
parameter
(current-write-relative-directory)
 -> (or/c (and/c path? complete-path?)
          (cons/c (and/c path? complete-path?)
                  (and/c path? complete-path?))
          #f)
(current-write-relative-directory path) -> void?
  path : (or/c (and/c path-string? complete-path?)
               (cons/c (and/c path-string? complete-path?)
                       (and/c path-string? complete-path?))
               #f)
procedure
(port-write-handler out) -> (any/c output-port? . -> . any)
  out : output-port?
(port-write-handler out proc) -> void?
  out : output-port?
  proc : (any/c output-port? . -> . any)
procedure
(port-display-handler out) -> (any/c output-port? . -> . any)
  out : output-port?
(port-display-handler out proc) -> void?
  out : output-port?
  proc : (any/c output-port? . -> . any)
procedure
(port-print-handler out)
 -> ((any/c output-port?) ((or/c 0 1)) . ->* . any)
  out : output-port?
(port-print-handler out proc) -> void?
  out : output-port?
  proc : (any/c output-port? . -> . any)
procedure
(global-port-print-handler)
 -> (->* (any/c output-port?) ((or/c 0 1)) any)
(global-port-print-handler proc) -> void?
  proc : (or/c (->* (any/c output-port?) ((or/c 0 1)) any)
               (any/c output-port? . -> . any))
procedure
(pretty-print  v                         
              [port                      
               quote-depth               
               #:newline? newline?]) -> void?
  v : any/c
  port : output-port? = (current-output-port)
  quote-depth : (or/c 0 1) = 0
  newline? : boolean? = #t
procedure
(pretty-write v [port #:newline? newline?]) -> void?
  v : any/c
  port : output-port? = (current-output-port)
  newline? : boolean? = #t
procedure
(pretty-display v [port #:newline? newline?]) -> void?
  v : any/c
  port : output-port? = (current-output-port)
  newline? : boolean? = #t
procedure
(pretty-format v [columns #:mode mode]) -> string?
  v : any/c
  columns : exact-nonnegative-integer? = (pretty-print-columns)
  mode : (or/c 'print 'write 'display) = 'print
procedure
(pretty-print-handler v) -> void?
  v : any/c
parameter
(pretty-print-columns)
 -> (or/c exact-positive-integer? 'infinity)
(pretty-print-columns width) -> void?
  width : (or/c exact-positive-integer? 'infinity)
parameter
(pretty-print-depth) -> (or/c exact-nonnegative-integer? #f)
(pretty-print-depth depth) -> void?
  depth : (or/c exact-nonnegative-integer? #f)
parameter
(pretty-print-exact-as-decimal) -> boolean?
(pretty-print-exact-as-decimal as-decimal?) -> void?
  as-decimal? : any/c
parameter
(pretty-print-.-symbol-without-bars) -> boolean?
(pretty-print-.-symbol-without-bars on?) -> void?
  on? : any/c
parameter
(pretty-print-show-inexactness) -> boolean?
(pretty-print-show-inexactness show?) -> void?
  show? : any/c
parameter
(pretty-print-abbreviate-read-macros) -> boolean?
(pretty-print-abbreviate-read-macros abbrev?) -> void?
  abbrev? : any/c
procedure
(pretty-print-style-table? v) -> boolean?
  v : any/c
parameter
(pretty-print-current-style-table) -> pretty-print-style-table?
(pretty-print-current-style-table style-table) -> void?
  style-table : pretty-print-style-table?
procedure
(pretty-print-extend-style-table style-table       
                                 symbol-list       
                                 like-symbol-list) 
 -> pretty-print-style-table?
  style-table : pretty-print-style-table?
  symbol-list : (listof symbol?)
  like-symbol-list : (listof symbol?)
parameter
(pretty-print-remap-stylable)
 -> (any/c . -> . (or/c symbol? #f))
(pretty-print-remap-stylable proc) -> void?
  proc : (any/c . -> . (or/c symbol? #f))
procedure
(pretty-print-newline port width) -> void?
  port : output-port?
  width : exact-nonnegative-integer?
parameter
(pretty-print-print-line)
 -> ((or/c exact-nonnegative-integer? #f)
     output-port?
     exact-nonnegative-integer?
     (or/c exact-nonnegative-integer? 'infinity)
     . -> .
     exact-nonnegative-integer?)
(pretty-print-print-line proc) -> void?
  proc : ((or/c exact-nonnegative-integer? #f)
          output-port?
          exact-nonnegative-integer?
          (or/c exact-nonnegative-integer? 'infinity)
          . -> .
          exact-nonnegative-integer?)
parameter
(pretty-print-size-hook)
 -> (any/c boolean? output-port?
     . -> .
     (or/c #f exact-nonnegative-integer?))
(pretty-print-size-hook proc) -> void?
  proc : (any/c boolean? output-port?
          . -> .
          (or/c #f exact-nonnegative-integer?))
parameter
(pretty-print-print-hook)
 -> (any/c boolean? output-port? . -> . void?)
(pretty-print-print-hook proc) -> void?
  proc : (any/c boolean? output-port? . -> . void?)
parameter
(pretty-print-pre-print-hook)
 -> (any/c output-port? . -> . void)
(pretty-print-pre-print-hook proc) -> void?
  proc : (any/c output-port? . -> . void)
parameter
(pretty-print-post-print-hook)
 -> (any/c output-port? . -> . void)
(pretty-print-post-print-hook proc) -> void?
  proc : (any/c output-port? . -> . void)
parameter
(pretty-printing) -> boolean?
(pretty-printing on?) -> void?
  on? : any/c
procedure
(make-tentative-pretty-print-output-port out             
                                         width           
                                         overflow-thunk) 
 -> output-port?
  out : output-port?
  width : exact-nonnegative-integer?
  overflow-thunk : (-> any)
procedure
(tentative-pretty-print-port-transfer tentative-out     
                                      orig-out)     -> void?
  tentative-out : output-port?
  orig-out : output-port?
procedure
(tentative-pretty-print-port-cancel tentative-out) -> void?
  tentative-out : output-port?
procedure
(readtable? v) -> boolean?
  v : any/c
procedure
(make-readtable readtable key mode action ...) -> readtable?
  readtable : (or/c readtable? #f)
  key : (or/c char? #f)
  mode : (or/c 'terminating-macro
               'non-terminating-macro
               'dispatch-macro
               char?)
  action : (or/c procedure?
                 readtable?
                 #f)
procedure
(readtable-mapping readtable char)
 -> (or/c char?
          'terminating-macro
          'non-terminating-macro)
    (or/c #f procedure?)
    (or/c #f procedure?)
  readtable : readtable?
  char : char?
procedure
(make-special-comment v) -> special-comment?
  v : any/c
procedure
(special-comment? v) -> boolean?
  v : any/c
procedure
(special-comment-value sc) -> any
  sc : special-comment?
value
gen:custom-write : any/c
value
prop:custom-write : struct-type-property?
procedure
(custom-write? v) -> boolean?
  v : any/c
procedure
(custom-write-accessor v)
 -> (custom-write? output-port? (or/c #t #f 0 1) . -> . any)
  v : custom-write?
value
prop:custom-print-quotable : struct-type-property?
value
custom-print-quotable? : struct-type-property?
value
custom-print-quotable-accessor : struct-type-property?
procedure
(serializable? v) -> boolean?
  v : any/c
procedure
(serialize                                                             
            v                                                          
           [#:relative-directory relative-to                           
            #:deserialize-relative-directory deserialize-relative-to]) 
 -> any
  v : serializable?
  relative-to : (or/c (and/c path? complete-path?)          = #f
                      (cons/c (and/c path? complete-path?)
                              (and/c path? complete-path?))
                      #f)
  deserialize-relative-to : (or/c (and/c path? complete-path?)
                                  (cons/c (and/c path? complete-path?)
                                          (and/c path? complete-path?))
                                  #f)
                          = relative-to
procedure
(deserialize v) -> any
  v : any/c
procedure
(serialized=? v1 v2) -> boolean?
  v1 : any/c
  v2 : any/c
parameter
(deserialize-module-guard)
 -> (-> module-path? symbol?
        (or/c void? (cons/c module-path? symbol?)))
(deserialize-module-guard guard) -> void?
  guard : (-> module-path? symbol?
              (or/c void? (cons/c module-path? symbol?)))
syntax
(serializable-struct id maybe-super (field ...)
                     struct-option ...)
syntax
(define-serializable-struct id-maybe-super (field ...)
                             struct-option ...)
syntax
(serializable-struct/versions id maybe-super vers (field ...)
                              (other-version-clause ...)
                              struct-option ...)
 
other-version-clause = (other-vers make-proc-expr
                                   cycle-make-proc-expr)
syntax
(define-serializable-struct/versions id-maybe-super vers (field ...)
                                     (other-version-clause ...)
                                     struct-option ...)
procedure
(make-deserialize-info make cycle-make) -> any
  make : procedure?
  cycle-make : (-> (values any/c procedure?))
value
prop:serializable : property?
procedure
(make-serialize-info to-vector          
                     deserialize-id     
                     can-cycle?         
                     dir)           -> any
  to-vector : (any/c . -> . vector?)
  deserialize-id : (or identifier?
                       symbol?
                       (cons/c symbol?
                               module-path-index?)
                       (-> any/c))
  can-cycle? : any/c
  dir : path-string?
procedure
(s-exp->fasl  v                               
             [out                             
              #:keep-mutable? keep-mutable?   
              #:handle-fail handle-fail       
              #:external-lift? external-lift? 
              #:skip-prefix? skip-prefix?])   
 -> (or/c (void) bytes?)
  v : any/c
  out : (or/c output-port? #f) = #f
  keep-mutable? : any/c = #f
  handle-fail : (or/c #f (any/c . -> . any/c)) = #f
  external-lift? : (or/c #f (any/c . -> . any/c)) = #f
  skip-prefix? : any/c = #f
procedure
(fasl->s-exp  in                                  
             [#:datum-intern? datum-intern?       
              #:external-lifts external-lifts     
              #:skip-prefix? skip-prefix?])   -> any/c
  in : (or/c input-port? bytes?)
  datum-intern? : any/c = #t
  external-lifts : vector? = '#()
  skip-prefix? : any/c = #f
procedure
(sha1-bytes in [start end]) -> bytes?
  in : (or/c bytes? input-port?)
  start : exact-nonnegative-integer? = 0
  end : (or/c #f exact-nonnegative-integer?) = #f
procedure
(sha224-bytes in [start end]) -> bytes?
  in : (or/c bytes? input-port?)
  start : exact-nonnegative-integer? = 0
  end : (or/c #f exact-nonnegative-integer?) = #f
procedure
(sha256-bytes in [start end]) -> bytes?
  in : (or/c bytes? input-port?)
  start : exact-nonnegative-integer? = 0
  end : (or/c #f exact-nonnegative-integer?) = #f
procedure
(namespace? v) -> boolean?
  v : any/c
procedure
(make-empty-namespace) -> namespace?
procedure
(make-base-empty-namespace) -> namespace?
procedure
(make-base-namespace) -> namespace?
syntax
(define-namespace-anchor id)
procedure
(namespace-anchor? v) -> boolean?
  v : any/c
procedure
(namespace-anchor->empty-namespace a) -> namespace?
  a : namespace-anchor?
procedure
(namespace-anchor->namespace a) -> namespace?
  a : namespace-anchor?
parameter
(current-namespace) -> namespace?
(current-namespace n) -> void?
  n : namespace?
procedure
(namespace-symbol->identifier sym) -> identifier?
  sym : symbol?
procedure
(namespace-base-phase [namespace]) -> exact-integer?
  namespace : namespace? = (current-namespace)
procedure
(namespace-module-identifier [where]) -> identifier?
  where : (or/c namespace? exact-integer? #f)
        = (current-namespace)
procedure
(namespace-variable-value  sym               
                          [use-mapping?      
                           failure-thunk     
                           namespace])   -> any
  sym : symbol?
  use-mapping? : any/c = #t
  failure-thunk : (or/c (-> any) #f) = #f
  namespace : namespace? = (current-namespace)
procedure
(namespace-set-variable-value!  sym                
                                v                  
                               [map?               
                                namespace          
                                as-constant?]) -> void?
  sym : symbol?
  v : any/c
  map? : any/c = #f
  namespace : namespace? = (current-namespace)
  as-constant? : any/c = #f
procedure
(namespace-undefine-variable!  sym             
                              [namespace]) -> void?
  sym : symbol?
  namespace : namespace? = (current-namespace)
procedure
(namespace-mapped-symbols [namespace]) -> (listof symbol?)
  namespace : namespace? = (current-namespace)
procedure
(namespace-require  quoted-raw-require-spec     
                   [namespace])             -> void?
  quoted-raw-require-spec : any/c
  namespace : namespace? = (current-namespace)
procedure
(namespace-require/copy  quoted-raw-require-spec     
                        [namespace])             -> void?
  quoted-raw-require-spec : any/c
  namespace : namespace? = (current-namespace)
procedure
(namespace-require/constant  quoted-raw-require-spec     
                            [namespace])             -> void?
  quoted-raw-require-spec : any/c
  namespace : namespace? = (current-namespace)
procedure
(namespace-require/expansion-time  quoted-raw-require-spec 
                                  [namespace])             
 -> void?
  quoted-raw-require-spec : any/c
  namespace : namespace? = (current-namespace)
procedure
(namespace-attach-module  src-namespace        
                          modname              
                         [dest-namespace]) -> void?
  src-namespace : namespace?
  modname : (or module-path? resolved-module-path?)
  dest-namespace : namespace? = (current-namespace)
procedure
(namespace-attach-module-declaration  src-namespace        
                                      modname              
                                     [dest-namespace]) -> void?
  src-namespace : namespace?
  modname : module-path?
  dest-namespace : namespace? = (current-namespace)
procedure
(namespace-unprotect-module  inspector       
                             modname         
                            [namespace]) -> void?
  inspector : inspector?
  modname : module-path?
  namespace : namespace? = (current-namespace)
procedure
(namespace-module-registry namespace) -> any
  namespace : namespace?
procedure
(namespace-call-with-registry-lock namespace     
                                   thunk)    -> any
  namespace : namespace?
  thunk : (-> any)
procedure
(module->namespace mod [src-namespace]) -> namespace?
  mod : (or/c module-path?
              resolved-module-path?
              module-path-index?)
  src-namespace : namespace? = (current-namespace)
procedure
(namespace-syntax-introduce stx [namespace]) -> syntax?
  stx : syntax?
  namespace : namespace? = (current-namespace)
procedure
(module-provide-protected? module-path-index     
                           sym)              -> boolean?
  module-path-index : (or/c symbol? module-path-index?)
  sym : symbol?
procedure
(variable-reference? v) -> boolean?
  v : any/c
procedure
(variable-reference-constant? varref) -> boolean?
  varref : variable-reference?
procedure
(variable-reference->empty-namespace varref) -> namespace?
  varref : variable-reference?
procedure
(variable-reference->namespace varref) -> namespace?
  varref : variable-reference?
procedure
(variable-reference->resolved-module-path varref)
 -> (or/c resolved-module-path? #f)
  varref : variable-reference?
procedure
(variable-reference->module-path-index varref)
 -> (or/c module-path-index? #f)
  varref : variable-reference?
procedure
(variable-reference->module-source varref)
 -> (or/c symbol? (and/c path? complete-path?) #f)
  varref : variable-reference?
procedure
(variable-reference->phase varref) -> exact-nonnegative-integer?
  varref : variable-reference?
procedure
(variable-reference->module-base-phase varref) -> exact-integer?
  varref : variable-reference?
procedure
(variable-reference->module-declaration-inspector varref)
 -> inspector?
  varref : variable-reference?
procedure
(variable-reference-from-unsafe? varref) -> boolean?
  varref : variable-reference?
parameter
(current-eval) -> (any/c . -> . any)
(current-eval proc) -> void?
  proc : (any/c . -> . any)
procedure
(eval top-level-form) -> any
  top-level-form : any/c
(eval top-level-form namespace) -> any
  top-level-form : any/c
  namespace : namespace?
procedure
(eval-syntax stx) -> any
  stx : syntax?
(eval-syntax stx namespace) -> any
  stx : syntax?
  namespace : namespace?
parameter
(current-load)
 -> (path? (or/c #f
                 symbol?
                 (cons/c (or/c #f symbol?)
                         (non-empty-listof symbol?)))
           . -> .
           any)
(current-load proc) -> void?
  proc : (path? (or/c #f
                      symbol?
                      (cons/c (or/c #f symbol?)
                              (non-empty-listof symbol?)))
                . -> .
                any)
procedure
(load file) -> any
  file : path-string?
procedure
(load-relative file) -> any
  file : path-string?
procedure
(load/cd file) -> any
  file : path-string?
parameter
(current-load-extension)
 -> (path? (or/c #f
                 symbol?
                 (cons/c (or/c #f symbol?)
                         (non-empty-listof symbol?)))
     . -> .
     any)
(current-load-extension proc) -> void?
  proc : (path? (or/c #f
                      symbol?
                      (cons/c (or/c #f symbol?)
                              (non-empty-listof symbol?)))
          . -> .
          any)
procedure
(load-extension file) -> any
  file : path-string?
procedure
(load-relative-extension file) -> any
  file : path-string?
parameter
(current-load/use-compiled)
 -> (path? (or/c #f
                 symbol?
                 (cons/c (or/c #f symbol?)
                         (non-empty-listof symbol?)))
           . -> . any)
(current-load/use-compiled proc) -> void?
  proc : (path? (or/c #f
                      symbol?
                      (cons/c (or/c #f symbol?)
                              (non-empty-listof symbol?)))
                . -> . any)
procedure
(load/use-compiled file) -> any
  file : path-string?
parameter
(current-load-relative-directory)
 -> (or/c (and/c path-string? complete-path?) #f)
(current-load-relative-directory path) -> void?
  path : (or/c (and/c path-string? complete-path?) #f)
parameter
(use-compiled-file-paths)
 -> (listof (and/c path? relative-path?))
(use-compiled-file-paths paths) -> void?
  paths : (listof (and/c path-string? relative-path?))
parameter
(current-compiled-file-roots) -> (listof (or/c path? 'same))
(current-compiled-file-roots paths) -> void?
  paths : (listof (or/c path-string? 'same))
procedure
(find-compiled-file-roots) -> (listof (or/c path? 'same))
parameter
(use-compiled-file-check) -> (or/c 'modify-seconds 'exists)
(use-compiled-file-check check) -> void?
  check : (or/c 'modify-seconds 'exists)
procedure
(read-eval-print-loop) -> any
parameter
(current-prompt-read) -> (-> any)
(current-prompt-read proc) -> void?
  proc : (-> any)
parameter
(current-get-interaction-input-port) -> (-> input-port?)
(current-get-interaction-input-port proc) -> void?
  proc : (-> input-port?)
parameter
(current-get-interaction-evt) -> (-> evt?)
(current-get-interaction-evt proc) -> void?
  proc : (-> evt?)
parameter
(current-read-interaction) -> (any/c input-port? -> any)
(current-read-interaction proc) -> void?
  proc : (any/c input-port? -> any)
parameter
(current-print) -> (any/c -> any)
(current-print proc) -> void?
  proc : (any/c -> any)
parameter
(current-compile)
 -> (any/c boolean? . -> . compiled-expression?)
(current-compile proc) -> void?
  proc : (any/c boolean? . -> . compiled-expression?)
procedure
(compile top-level-form) -> compiled-expression?
  top-level-form : any/c
procedure
(compile-syntax stx) -> compiled-expression?
  stx : syntax?
procedure
(compiled-expression-recompile ce) -> compiled-expression?
  ce : compiled-expression?
procedure
(compiled-expression? v) -> boolean?
  v : any/c
parameter
(compile-enforce-module-constants) -> boolean?
(compile-enforce-module-constants on?) -> void?
  on? : any/c
parameter
(compile-allow-set!-undefined) -> boolean?
(compile-allow-set!-undefined allow?) -> void?
  allow? : any/c
parameter
(compile-context-preservation-enabled) -> boolean?
(compile-context-preservation-enabled on?) -> void?
  on? : any/c
parameter
(current-compile-target-machine)
 -> (or/c #f (and/c symbol? compile-target-machine?))
(current-compile-target-machine target) -> void?
  target : (or/c #f (and/c symbol? compile-target-machine?))
procedure
(compile-target-machine? sym) -> boolean?
  sym : symbol?
parameter
(current-compile-realm) -> symbol?
(current-compile-realm realm) -> void?
  realm : symbol?
parameter
(eval-jit-enabled) -> boolean?
(eval-jit-enabled on?) -> void?
  on? : any/c
parameter
(load-on-demand-enabled) -> boolean?
(load-on-demand-enabled on?) -> void?
  on? : any/c
procedure
(resolved-module-path? v) -> boolean?
  v : any/c
procedure
(make-resolved-module-path path) -> resolved-module-path?
  path : (or/c symbol?
               (and/c path? complete-path?)
               (cons/c (or/c symbol?
                             (and/c path? complete-path?))
                       (non-empty-listof symbol?)))
procedure
(resolved-module-path-name module-path)
 -> (or/c symbol?
          (and/c path? complete-path?)
          (cons/c (or/c symbol?
                        (and/c path? complete-path?))
                  (non-empty-listof symbol?)))
  module-path : resolved-module-path?
procedure
(module-path? v) -> boolean?
  v : any/c
parameter
(current-module-name-resolver)
 -> (case->
     (resolved-module-path? (or/c #f namespace?) . -> . any)
     (module-path?
      (or/c #f resolved-module-path?)
      (or/c #f syntax?)
      boolean?
      . -> .
      resolved-module-path?))
(current-module-name-resolver proc) -> void?
  proc : (case->
          (resolved-module-path? (or/c #f namespace?) . -> . any)
          (module-path?
           (or/c #f resolved-module-path?)
           (or/c #f syntax?)
           boolean?
           . -> .
           resolved-module-path?))
parameter
(current-module-declare-name)
 -> (or/c resolved-module-path? #f)
(current-module-declare-name name) -> void?
  name : (or/c resolved-module-path? #f)
parameter
(current-module-declare-source)
 -> (or/c symbol? (and/c path? complete-path?) #f)
(current-module-declare-source src) -> void?
  src : (or/c symbol? (and/c path? complete-path?) #f)
parameter
(current-module-path-for-load)
 -> (or/c #f module-path?
          (and/c syntax?
                 (lambda (stx)
                   (module-path? (syntax->datum s)))))
(current-module-path-for-load path) -> void?
  path : (or/c #f module-path?
               (and/c syntax?
                      (lambda (stx)
                        (module-path? (syntax->datum s)))))
procedure
(module-path-index? v) -> boolean?
  v : any/c
procedure
(module-path-index-resolve  mpi           
                           [load?         
                            src-stx]) -> resolved-module-path?
  mpi : module-path-index?
  load? : any/c = #f
  src-stx : (or/c syntax? #f) = #f
procedure
(module-path-index-split mpi)
 -> (or/c module-path? #f)
    (or/c module-path-index? resolved-module-path? #f)
  mpi : module-path-index?
procedure
(module-path-index-submodule mpi)
 -> (or/c #f (non-empty-listof symbol?))
  mpi : module-path-index?
procedure
(module-path-index-join path base [submod]) -> module-path-index?
  path : (or/c module-path? #f)
  base : (or/c module-path-index? resolved-module-path? #f)
  submod : (or/c #f (non-empty-listof symbol?)) = #f
procedure
(compiled-module-expression? v) -> boolean?
  v : any/c
procedure
(module-compiled-name compiled-module-code)
 -> (or/c symbol? (cons/c symbol? (non-empty-listof symbol?)))
  compiled-module-code : compiled-module-expression?
(module-compiled-name compiled-module-code 
                      name)                
 -> compiled-module-expression?
  compiled-module-code : compiled-module-expression?
  name : (or/c symbol? (cons/c symbol? (non-empty-listof symbol?)))
procedure
(module-compiled-submodules compiled-module-code 
                            non-star?)           
 -> (listof compiled-module-expression?)
  compiled-module-code : compiled-module-expression?
  non-star? : any/c
(module-compiled-submodules compiled-module-code 
                            non-star?            
                            submodules)          
 -> compiled-module-expression?
  compiled-module-code : compiled-module-expression?
  non-star? : any/c
  submodules : (listof compiled-module-expression?)
procedure
(module-compiled-imports compiled-module-code)
 -> (listof (cons/c (or/c exact-integer? #f)
                    (listof module-path-index?)))
  compiled-module-code : compiled-module-expression?
procedure
(module-compiled-exports  compiled-module-code 
                         [verbosity])          
 -> (listof (cons/c phase+space? list?))
    (listof (cons/c phase+space? list?))
  compiled-module-code : compiled-module-expression?
  verbosity : (or/c #f 'defined-names) = #f
procedure
(module-compiled-indirect-exports compiled-module-code)
 -> (listof (cons/c exact-integer? (listof symbol?)))
  compiled-module-code : compiled-module-expression?
procedure
(module-compiled-language-info compiled-module-code)
 -> (or/c #f (vector/c module-path? symbol? any/c))
  compiled-module-code : compiled-module-expression?
procedure
(module-compiled-cross-phase-persistent? compiled-module-code)
 -> boolean?
  compiled-module-code : compiled-module-expression?
procedure
(module-compiled-realm compiled-module-code) -> symbol?
  compiled-module-code : compiled-module-expression?
procedure
(dynamic-require mod provided [fail-thunk]) -> (or/c void? any/c)
  mod : (or/c module-path?
              resolved-module-path?
              module-path-index?)
  provided : (or/c symbol? #f 0 void?)
  fail-thunk : (-> any) = (lambda () ....)
procedure
(dynamic-require-for-syntax  mod              
                             provided         
                            [fail-thunk]) -> any
  mod : module-path?
  provided : (or/c symbol? #f)
  fail-thunk : (-> any) = (lambda () ....)
procedure
(module-declared? mod [load?]) -> boolean?
  mod : (or/c module-path? module-path-index?
              resolved-module-path?)
  load? : any/c = #f
procedure
(module->language-info mod [load?])
 -> (or/c #f (vector/c module-path? symbol? any/c))
  mod : (or/c module-path? module-path-index?
              resolved-module-path?)
  load? : any/c = #f
procedure
(module->imports mod)
 -> (listof (cons/c (or/c exact-integer? #f)
                    (listof module-path-index?)))
  mod : (or/c module-path? module-path-index?
              resolved-module-path?)
procedure
(module->exports mod [verbosity])
 -> (listof (cons/c phase+space? list?))
    (listof (cons/c phase+space? list?))
  mod : (or/c module-path? module-path-index?
              resolved-module-path?)
  verbosity : (or/c #f 'defined-names) = #f
procedure
(module->indirect-exports mod)
 -> (listof (cons/c exact-integer? (listof symbol?)))
  mod : (or/c module-path? module-path-index?
              resolved-module-path?)
procedure
(module->realm mod) -> symbol?
  mod : (or/c module-path? module-path-index?
              resolved-module-path?)
procedure
(module-predefined? mod) -> boolean?
  mod : (or/c module-path? module-path-index?
              resolved-module-path?)
procedure
(module-cache-clear!) -> void?
procedure
(impersonator? v) -> boolean?
  v : any/c
procedure
(chaperone? v) -> boolean?
  v : any/c
procedure
(impersonator-of? v1 v2) -> boolean?
  v1 : any/c
  v2 : any/c
procedure
(chaperone-of? v1 v2) -> boolean?
  v1 : any/c
  v2 : any/c
procedure
(impersonator-ephemeron v) -> ephemeron?
  v : any/c
procedure
(procedure-impersonator*? v) -> boolean?
  v : any/c
procedure
(impersonate-procedure proc         
                       wrapper-proc 
                       prop         
                       prop-val ... 
                       ...)         
 -> (and/c procedure? impersonator?)
  proc : procedure?
  wrapper-proc : (or/c procedure? #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-procedure* proc         
                        wrapper-proc 
                        prop         
                        prop-val ... 
                        ...)         
 -> (and/c procedure? impersonator?)
  proc : procedure?
  wrapper-proc : (or/c procedure? #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-struct  v                     
                    [struct-type]          
                     orig-proc             
                     redirect-proc ...     
                     ...                   
                     prop                  
                     prop-val ...          
                     ...)              -> any/c
  v : any/c
  struct-type : struct-type? = unspecified
  orig-proc : (or/c struct-accessor-procedure?
                    struct-mutator-procedure?
                    struct-type-property-accessor-procedure?)
  redirect-proc : (or/c procedure? #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-vector vec          
                    ref-proc     
                    set-proc     
                    prop         
                    prop-val ... 
                    ...)         
 -> (and/c vector? impersonator?)
  vec : (and/c vector? (not/c immutable?))
  ref-proc : (or/c (vector? exact-nonnegative-integer? any/c . ->
. any/c) #f)
  set-proc : (or/c (vector? exact-nonnegative-integer? any/c . ->
. any/c) #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-vector* vec          
                     ref-proc     
                     set-proc     
                     prop         
                     prop-val ... 
                     ...)         
 -> (and/c vector? impersonator?)
  vec : (and/c vector? (not/c immutable?))
  ref-proc : (or/c (vector? vector? exact-nonnegative-integer? any/c .
-> . any/c) #f)
  set-proc : (or/c (vector? vector? exact-nonnegative-integer? any/c .
-> . any/c) #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-box box              
                 unbox-proc       
                 set-proc         
                 prop             
                 prop-val ...     
                 ...)         -> (and/c box? impersonator?)
  box : (and/c box? (not/c immutable?))
  unbox-proc : (box? any/c . -> . any/c)
  set-proc : (box? any/c . -> . any/c)
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-hash  hash                
                   ref-proc            
                   set-proc            
                   remove-proc         
                   key-proc            
                  [clear-proc          
                   equal-key-proc]     
                   prop                
                   prop-val ...        
                   ...)            -> (and/c hash? impersonator?)
  hash : (and/c hash? (not/c immutable?))
  ref-proc : (hash? any/c . -> . (values
                                  any/c
                                  (hash? any/c any/c . -> . any/c)))
  set-proc : (hash? any/c any/c . -> . (values any/c any/c))
  remove-proc : (hash? any/c . -> . any/c)
  key-proc : (hash? any/c . -> . any/c)
  clear-proc : (or/c #f (hash? . -> . any)) = #f
  equal-key-proc : (or/c #f (hash? any/c . -> . any/c)) = #f
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-channel channel      
                     get-proc     
                     put-proc     
                     prop         
                     prop-val ... 
                     ...)         
 -> (and/c channel? impersonator?)
  channel : channel?
  get-proc : (channel? . -> . (values channel? (any/c . -> . any/c)))
  put-proc : (channel? any/c . -> . any/c)
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-prompt-tag  prompt-tag               
                         handle-proc              
                         abort-proc               
                        [cc-guard-proc            
                         callcc-impersonate-proc] 
                         prop                     
                         prop-val ...             
                         ...)                     
 -> (and/c continuation-prompt-tag? impersonator?)
  prompt-tag : continuation-prompt-tag?
  handle-proc : procedure?
  abort-proc : procedure?
  cc-guard-proc : procedure? = values
  callcc-impersonate-proc : (procedure? . -> . procedure?)
                          = (lambda (p) p)
  prop : impersonator-property?
  prop-val : any/c
procedure
(impersonate-continuation-mark-key key          
                                   get-proc     
                                   set-proc     
                                   prop         
                                   prop-val ... 
                                   ...)         
 -> (and/c continuation-mark? impersonator?)
  key : continuation-mark-key?
  get-proc : procedure?
  set-proc : procedure?
  prop : impersonator-property?
  prop-val : any/c
value
prop:impersonator-of : struct-type-property?
value
prop:authentic : struct-type-property?
procedure
(chaperone-procedure proc         
                     wrapper-proc 
                     prop         
                     prop-val ... 
                     ...)         
 -> (and/c procedure? chaperone?)
  proc : procedure?
  wrapper-proc : (or/c procedure? #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-procedure* proc         
                      wrapper-proc 
                      prop         
                      prop-val ... 
                      ...)         
 -> (and/c procedure? chaperone?)
  proc : procedure?
  wrapper-proc : (or/c procedure? #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-struct  v                     
                  [struct-type]          
                   orig-proc             
                   redirect-proc ...     
                   ...                   
                   prop                  
                   prop-val ...          
                   ...)              -> any/c
  v : any/c
  struct-type : struct-type? = unspecified
  orig-proc : (or/c struct-accessor-procedure?
                    struct-mutator-procedure?
                    struct-type-property-accessor-procedure?
                    (one-of/c struct-info))
  redirect-proc : (or/c procedure? #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-vector vec              
                  ref-proc         
                  set-proc         
                  prop             
                  prop-val ...     
                  ...)         -> (and/c vector? chaperone?)
  vec : vector?
  ref-proc : (or/c (vector? exact-nonnegative-integer? any/c . ->
. any/c) #f)
  set-proc : (or/c (vector? exact-nonnegative-integer? any/c . ->
. any/c) #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-vector* vec              
                   ref-proc         
                   set-proc         
                   prop             
                   prop-val ...     
                   ...)         -> (and/c vector? chaperone?)
  vec : (and/c vector? (not/c immutable?))
  ref-proc : (or/c (vector? vector? exact-nonnegative-integer? any/c .
-> . any/c) #f)
  set-proc : (or/c (vector? vector? exact-nonnegative-integer? any/c .
-> . any/c) #f)
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-box box              
               unbox-proc       
               set-proc         
               prop             
               prop-val ...     
               ...)         -> (and/c box? chaperone?)
  box : box?
  unbox-proc : (box? any/c . -> . any/c)
  set-proc : (box? any/c . -> . any/c)
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-hash  hash                
                 ref-proc            
                 set-proc            
                 remove-proc         
                 key-proc            
                [clear-proc          
                 equal-key-proc]     
                 prop                
                 prop-val ...        
                 ...)            -> (and/c hash? chaperone?)
  hash : hash?
  ref-proc : (hash? any/c . -> . (values
                                  any/c
                                  (hash? any/c any/c . -> . any/c)))
  set-proc : (hash? any/c any/c . -> . (values any/c any/c))
  remove-proc : (hash? any/c . -> . any/c)
  key-proc : (hash? any/c . -> . any/c)
  clear-proc : (or/c #f (hash? . -> . any)) = #f
  equal-key-proc : (or/c #f (hash? any/c . -> . any/c)) = #f
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-struct-type struct-type           
                       struct-info-proc      
                       make-constructor-proc 
                       guard-proc            
                       prop                  
                       prop-val ...          
                       ...)                  
 -> (and/c struct-type? chaperone?)
  struct-type : struct-type?
  struct-info-proc : procedure?
  make-constructor-proc : (procedure? . -> . procedure?)
  guard-proc : procedure?
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-evt evt proc prop prop-val ... ...)
 -> (and/c evt? chaperone?)
  evt : evt?
  proc : (evt? . -> . (values evt? (any/c . -> . any/c)))
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-channel channel          
                   get-proc         
                   put-proc         
                   prop             
                   prop-val ...     
                   ...)         -> (and/c channel? chaperone?)
  channel : channel?
  get-proc : (channel? . -> . (values channel? (any/c . -> . any/c)))
  put-proc : (channel? any/c . -> . any/c)
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-prompt-tag  prompt-tag             
                       handle-proc            
                       abort-proc             
                      [cc-guard-proc          
                       callcc-chaperone-proc] 
                       prop                   
                       prop-val ...           
                       ...)                   
 -> (and/c continuation-prompt-tag? chaperone?)
  prompt-tag : continuation-prompt-tag?
  handle-proc : procedure?
  abort-proc : procedure?
  cc-guard-proc : procedure? = values
  callcc-chaperone-proc : (procedure? . -> . procedure?)
                        = (lambda (p) p)
  prop : impersonator-property?
  prop-val : any/c
procedure
(chaperone-continuation-mark-key key          
                                 get-proc     
                                 set-proc     
                                 prop         
                                 prop-val ... 
                                 ...)         
 -> (and/c continuation-mark-key? chaperone?)
  key : continuation-mark-key?
  get-proc : procedure?
  set-proc : procedure?
  prop : impersonator-property?
  prop-val : any/c
procedure
(make-impersonator-property name)
 -> impersonator-property?
    (-> any/c boolean?)
    (->* (impersonator?) (any/c) any)
  name : symbol?
procedure
(impersonator-property? v) -> boolean?
  v : any/c
procedure
(impersonator-property-accessor-procedure? v) -> boolean?
  v : any/c
value
impersonator-prop:application-mark : impersonator-property?
procedure
(security-guard? v) -> boolean?
  v : any/c
procedure
(make-security-guard  parent            
                      file-guard        
                      network-guard     
                     [link-guard])  -> security-guard?
  parent : security-guard?
  file-guard : (symbol?
                (or/c path? #f)
                (listof symbol?)
                . -> . any)
  network-guard : (symbol?
                   (or/c (and/c string? immutable?) #f)
                   (or/c (integer-in 1 65535) #f)
                   (or/c 'server 'client)
                   . -> . any)
  link-guard : (or/c (symbol? path? path? . -> . any) #f) = #f
parameter
(current-security-guard) -> security-guard?
(current-security-guard guard) -> void?
  guard : security-guard?
procedure
(custodian? v) -> boolean?
  v : any/c
procedure
(make-custodian [cust]) -> custodian?
  cust : (and/c custodian? (not/c custodian-shut-down?))
       = (current-custodian)
procedure
(custodian-shutdown-all cust) -> void?
  cust : custodian?
procedure
(custodian-shut-down? cust) -> boolean?
  cust : custodian?
parameter
(current-custodian) -> custodian?
(current-custodian cust) -> void?
  cust : custodian?
procedure
(custodian-managed-list cust super) -> list?
  cust : custodian?
  super : custodian?
procedure
(custodian-memory-accounting-available?) -> boolean?
procedure
(custodian-require-memory limit-cust     
                          need-amt       
                          stop-cust) -> void?
  limit-cust : custodian?
  need-amt : exact-nonnegative-integer?
  stop-cust : custodian?
procedure
(custodian-limit-memory  limit-cust      
                         limit-amt       
                        [stop-cust]) -> void?
  limit-cust : custodian?
  limit-amt : exact-nonnegative-integer?
  stop-cust : custodian? = limit-cust
procedure
(make-custodian-box cust v) -> custodian-box?
  cust : custodian?
  v : any/c
procedure
(custodian-box? v) -> boolean?
  v : any/c
procedure
(custodian-box-value cb) -> any
  cb : custodian-box?
procedure
(make-thread-group [group]) -> thread-group?
  group : thread-group? = (current-thread-group)
procedure
(thread-group? v) -> boolean?
  v : any/c
parameter
(current-thread-group) -> thread-group?
(current-thread-group group) -> void?
  group : thread-group?
procedure
(inspector? v) -> boolean?
  v : any/c
procedure
(make-inspector [inspector]) -> inspector?
  inspector : inspector? = (current-inspector)
procedure
(make-sibling-inspector [inspector]) -> inspector?
  inspector : inspector? = (current-inspector)
procedure
(inspector-superior? inspector               
                     maybe-subinspector) -> boolean?
  inspector : inspector?
  maybe-subinspector : inspector?
parameter
(current-inspector) -> inspector?
(current-inspector insp) -> void?
  insp : inspector?
procedure
(struct-info v) -> (or/c struct-type? #f) boolean?
  v : any/c
procedure
(struct-type-info struct-type)
 -> symbol?
    exact-nonnegative-integer?
    exact-nonnegative-integer?
    struct-accessor-procedure?
    struct-mutator-procedure?
    (listof exact-nonnegative-integer?)
    (or/c struct-type? #f)
    boolean?
  struct-type : struct-type?
procedure
(struct-type-sealed? struct-type) -> boolean?
  struct-type : struct-type?
procedure
(struct-type-authentic? struct-type) -> boolean?
  struct-type : struct-type?
procedure
(struct-type-make-constructor  struct-type        
                              [constructor-name]) 
 -> struct-constructor-procedure?
  struct-type : struct-type?
  constructor-name : (or/c symbol? #f) = #f
procedure
(struct-type-make-predicate struct-type) -> any
  struct-type : any/c
procedure
(object-name v) -> any
  v : any/c
value
prop:object-name : struct-type-property?
parameter
(current-code-inspector) -> inspector?
(current-code-inspector insp) -> void?
  insp : inspector?
procedure
(plumber? v) -> boolean?
  v : any/c
procedure
(make-plumber) -> plumber?
parameter
(current-plumber) -> plumber?
(current-plumber plumber) -> void?
  plumber : plumber?
procedure
(plumber-flush-all plumber) -> void?
  plumber : plumber?
procedure
(plumber-flush-handle? v) -> boolean?
  v : any/c
procedure
(plumber-add-flush! plumber proc [weak?]) -> plumber-flush-handle?
  plumber : plumber?
  proc : (plumber-flush-handle? . -> . any)
  weak? : any/c = #f
procedure
(plumber-flush-handle-remove! handle) -> void?
  handle : plumber-flush-handle?
procedure
(make-evaluator                                                        
                 language                                              
                 input-program ...                                     
                [#:requires requires                                   
                 #:allow-for-require allow-for-require                 
                 #:allow-for-load allow-for-load                       
                 #:allow-read allow-read                               
                 #:allow-syntactic-requires allow-syntactic-requires]) 
 -> (any/c . -> . any)
  language : (or/c module-path?
                   (list/c 'special symbol?)
                   (cons/c 'begin list?))
  input-program : any/c
  requires : (listof (or/c module-path? path-string?
                           (cons/c 'for-syntax (listof module-path?))))
           = null
  allow-for-require : (listof (or/c module-path? path?)) = null
  allow-for-load : (listof path-string?) = null
  allow-read : (listof (or/c module-path? path-string?)) = null
  allow-syntactic-requires : (or/c #f (listof module-path?))
                           = #f
(make-module-evaluator                                                        
                        module-decl                                           
                       [#:language lang                                       
                        #:readers readers                                     
                        #:allow-for-require allow-for-require                 
                        #:allow-for-load allow-for-load                       
                        #:allow-read allow-read                               
                        #:allow-syntactic-requires allow-syntactic-requires]) 
 -> (any/c . -> . any)
  module-decl : (or/c syntax? pair? path? input-port? string? bytes?)
  lang : (or/c #f module-path?) = #f
  readers : (or/c #f (listof module-path?))
          = (and lang (default-language-readers lang))
  allow-for-require : (listof (or/c module-path? path?)) = null
  allow-for-load : (listof path-string?) = null
  allow-read : (listof (or/c module-path? path-string?)) = null
  allow-syntactic-requires : (or/c #f (listof module-path?))
                           = #f
procedure
(exn:fail:sandbox-terminated? v) -> boolean?
  v : any/c
(exn:fail:sandbox-terminated-reason exn) -> symbol?
  exn : exn:fail:sandbox-terminated?
procedure
(call-with-trusted-sandbox-configuration thunk) -> any
  thunk : (-> any)
parameter
(sandbox-init-hook) -> (-> any)
(sandbox-init-hook thunk) -> void?
  thunk : (-> any)
parameter
(sandbox-reader) -> (any/c . -> . any)
(sandbox-reader proc) -> void?
  proc : (any/c . -> . any)
parameter
(sandbox-input) -> (or/c #f
                         string? bytes?
                         input-port?
                         'pipe
                         (-> input-port?))
(sandbox-input in) -> void?
  in : (or/c #f
             string? bytes?
             input-port?
             'pipe
             (-> input-port?))
parameter
(sandbox-output) -> (or/c #f
                          output-port?
                          'pipe
                          'bytes
                          'string
                          (-> output-port?))
(sandbox-output in) -> void?
  in : (or/c #f
             output-port?
             'pipe
             'bytes
             'string
             (-> output-port?))
parameter
(sandbox-error-output) -> (or/c #f
                                output-port?
                                'pipe
                                'bytes
                                'string
                                (-> output-port?))
(sandbox-error-output in) -> void?
  in : (or/c #f
             output-port?
             'pipe
             'bytes
             'string
             (-> output-port?))
parameter
(sandbox-coverage-enabled) -> boolean?
(sandbox-coverage-enabled enabled?) -> void?
  enabled? : any/c
parameter
(sandbox-propagate-breaks) -> boolean?
(sandbox-propagate-breaks propagate?) -> void?
  propagate? : any/c
parameter
(sandbox-propagate-exceptions) -> boolean?
(sandbox-propagate-exceptions propagate?) -> void?
  propagate? : any/c
parameter
(sandbox-namespace-specs) -> (cons/c (-> namespace?)
                                     (listof module-path?))
(sandbox-namespace-specs spec) -> void?
  spec : (cons/c (-> namespace?)
                 (listof module-path?))
procedure
(sandbox-make-namespace) -> namespace?
parameter
(sandbox-gui-available) -> boolean?
(sandbox-gui-available avail?) -> void?
  avail? : any/c
parameter
(sandbox-override-collection-paths) -> (listof path-string?)
(sandbox-override-collection-paths paths) -> void?
  paths : (listof path-string?)
parameter
(sandbox-security-guard)
 -> (or/c security-guard? (-> security-guard?))
(sandbox-security-guard guard) -> void?
  guard : (or/c security-guard? (-> security-guard?))
parameter
(sandbox-path-permissions)
 -> (listof (list/c (or/c 'execute 'write 'delete
                          'read-bytecode 'read 'exists)
                    (or/c byte-regexp? bytes? string? path?)))
(sandbox-path-permissions perms) -> void?
  perms : (listof (list/c (or/c 'execute 'write 'delete
                                'read-bytecode 'read 'exists)
                          (or/c byte-regexp? bytes? string? path?)))
parameter
(sandbox-network-guard)
 -> (symbol?
     (or/c (and/c string? immutable?) #f)
     (or/c (integer-in 1 65535) #f)
     (or/c 'server 'client)
     . -> . any)
(sandbox-network-guard proc) -> void?
  proc : (symbol?
          (or/c (and/c string? immutable?) #f)
          (or/c (integer-in 1 65535) #f)
          (or/c 'server 'client)
          . -> . any)
parameter
(sandbox-exit-handler) -> (any/c . -> . any)
(sandbox-exit-handler handler) -> void?
  handler : (any/c . -> . any)
parameter
(sandbox-memory-limit) -> (or/c (>=/c 0) #f)
(sandbox-memory-limit limit) -> void?
  limit : (or/c (>=/c 0) #f)
parameter
(sandbox-eval-limits) -> (or/c (list/c (or/c (>=/c 0) #f)
                                       (or/c (>=/c 0) #f))
                               #f)
(sandbox-eval-limits limits) -> void?
  limits : (or/c (list/c (or/c (>=/c 0) #f)
                         (or/c (>=/c 0) #f))
                 #f)
parameter
(sandbox-eval-handlers)
 -> (list/c (or/c #f ((-> any) . -> . any))
            (or/c #f ((-> any) . -> . any)))
(sandbox-eval-handlers handlers) -> void?
  handlers : (list/c (or/c #f ((-> any) . -> . any))
                     (or/c #f ((-> any) . -> . any)))
parameter
(sandbox-run-submodules) -> (list/c symbol?)
(sandbox-run-submodules submod-syms) -> void?
  submod-syms : (list/c symbol?)
parameter
(sandbox-make-inspector) -> (-> inspector?)
(sandbox-make-inspector make) -> void?
  make : (-> inspector?)
parameter
(sandbox-make-code-inspector) -> (-> inspector?)
(sandbox-make-code-inspector make) -> void?
  make : (-> inspector?)
parameter
(sandbox-make-logger) -> (-> logger?)
(sandbox-make-logger make) -> void?
  make : (-> logger?)
parameter
(sandbox-make-plumber) -> (or/c (-> plumber?) 'propagate)
(sandbox-make-plumber make) -> void?
  make : (or/c (-> plumber?) 'propagate)
parameter
(sandbox-make-environment-variables)
 -> (-> environment-variables?)
(sandbox-make-environment-variables make) -> void?
  make : (-> environment-variables?)
procedure
(default-language-readers lang) -> (listof module-path?)
  lang : module-path?
procedure
(evaluator-alive? evaluator) -> boolean?
  evaluator : (any/c . -> . any)
procedure
(kill-evaluator evaluator) -> void?
  evaluator : (any/c . -> . any)
procedure
(break-evaluator evaluator) -> void?
  evaluator : (any/c . -> . any)
procedure
(get-user-custodian evaluator) -> void?
  evaluator : (any/c . -> . any)
procedure
(set-eval-limits evaluator secs mb) -> void?
  evaluator : (any/c . -> . any)
  secs : (or/c exact-nonnegative-integer? #f)
  mb : (or/c exact-nonnegative-integer? #f)
procedure
(set-eval-handler evaluator handler) -> void?
  evaluator : (any/c . -> . any)
  handler : (or/c #f ((-> any) . -> . any))
procedure
(call-with-custodian-shutdown thunk) -> any
  thunk : (-> any)
(call-with-killing-threads thunk) -> any
  thunk : (-> any)
procedure
(put-input evaluator) -> output-port?
  evaluator : (any/c . -> . any)
(put-input evaluator i/o) -> void?
  evaluator : (any/c . -> . any)
  i/o : (or/c bytes? string? eof-object?)
procedure
(get-output evaluator) -> (or/c #f input-port? bytes? string?)
  evaluator : (any/c . -> . any)
(get-error-output evaluator)
 -> (or/c #f input-port? bytes? string?)
  evaluator : (any/c . -> . any)
procedure
(get-uncovered-expressions  evaluator     
                           [prog?         
                            src])     -> (listof syntax?)
  evaluator : (any/c . -> . any)
  prog? : any/c = #t
  src : any/c = default-src
procedure
(call-in-sandbox-context  evaluator           
                          thunk               
                         [unrestricted?]) -> any
  evaluator : (any/c . -> . any)
  thunk : (-> any)
  unrestricted? : boolean? = #f
value
gui? : boolean?
procedure
(call-with-limits secs mb thunk) -> any
  secs : (or/c exact-nonnegative-integer? #f)
  mb : (or/c exact-nonnegative-integer? #f)
  thunk : (-> any)
syntax
(with-limits sec-expr mb-expr body ...)
procedure
(call-with-deep-time-limit secs thunk) -> any
  secs : exact-nonnegative-integer?
  thunk : (-> any)
syntax
(with-deep-time-limit secs-expr body ...)
procedure
(exn:fail:resource? v) -> boolean?
  v : any/c
(exn:fail:resource-resource exn)
 -> (or/c 'time 'memory 'deep-time)
  exn : exn:fail:resource?

(linklet [[imported-id/renamed ...] ...]
         [exported-id/renamed ...]
  defn-or-expr ...)
 
imported-id/renamed = imported-id
                    | (external-imported-id internal-imported-id)
                       
exported-id/renamed = exported-id
                    | (internal-exported-id external-exported-id)
procedure
(linklet? v) -> boolean?
  v : any/c
procedure
(compile-linklet  form            
                 [name            
                  import-keys     
                  get-import      
                  options])   -> linklet?
  form : (or/c correlated? any/c)
  name : any/c = #f
  import-keys : #f = #f
  get-import : #f = #f
  options : (listof (or/c 'serializable 'unsafe 'static 'quick
                           'use-prompt 'uninterned-literal))
          = '(serializable)
(compile-linklet  form            
                  name            
                  import-keys     
                 [get-import      
                  options])   -> linklet? vector?
  form : (or/c correlated? any/c)
  name : any/c
  import-keys : vector?
  get-import : (or/c #f (any/c . -> . (values (or/c linklet? instance? #f)
                                              (or/c vector? #f))))
             = #f
  options : (listof (or/c 'serializable 'unsafe 'static 'quick
                          'use-prompt 'uninterned-literal))
          = '(serializable)
procedure
(recompile-linklet  linklet         
                   [name            
                    import-keys     
                    get-import      
                    options])   -> linklet?
  linklet : linklet?
  name : any/c = #f
  import-keys : #f = #f
  get-import : #f = #f
  options : (listof (or/c 'serializable 'unsafe 'static 'quick
                          'use-prompt 'uninterned-literal))
          = '(serializable)
(recompile-linklet  linklet         
                    name            
                    import-keys     
                   [get-import      
                    options])   -> linklet? vector?
  linklet : linklet?
  name : any/c
  import-keys : vector?
  get-import : (or/c (any/c . -> . (values (or/c linklet? #f)
                                           (or/c vector? #f)))
                     #f)
             = (lambda (import-key) (values #f #f))
  options : (listof (or/c 'serializable 'unsafe 'static 'quick
                          'use-prompt 'uninterned-literal))
          = '(serializable)
procedure
(eval-linklet linklet) -> linklet?
  linklet : linklet?
procedure
(instantiate-linklet  linklet              
                      import-instances     
                     [target-instance?     
                      use-prompt?])    -> instance?
  linklet : linklet?
  import-instances : (listof instance?)
  target-instance? : #f = #f
  use-prompt? : any/c = #t
(instantiate-linklet  linklet              
                      import-instances     
                      target-instance      
                     [use-prompt?])    -> any
  linklet : linklet?
  import-instances : (listof instance?)
  target-instance : instance?
  use-prompt? : any/c = #t
procedure
(linklet-import-variables linklet) -> (listof (listof symbol?))
  linklet : linklet?
procedure
(linklet-export-variables linklet) -> (listof symbol?)
  linklet : linklet?
procedure
(linklet-directory? v) -> boolean?
  v : any/c
procedure
(hash->linklet-directory content) -> linklet-directory?
  content : (and/c hash? hash-eq? immutable? (not/c impersonator?))
procedure
(linklet-directory->hash linklet-directory)
 -> (and/c hash? hash-eq? immutable? (not/c impersonator?))
  linklet-directory : linklet-directory?
procedure
(linklet-bundle? v) -> boolean?
  v : any/c
procedure
(hash->linklet-bundle content) -> linklet-bundle?
  content : (and/c hash? hash-eq? immutable? (not/c impersonator?))
procedure
(linklet-bundle->hash linklet-bundle)
 -> (and/c hash? hash-eq? immutable? (not/c impersonator?))
  linklet-bundle : linklet-bundle?
procedure
(linklet-body-reserved-symbol? sym) -> boolean?
  sym : symbol?
procedure
(instance? v) -> boolean?
  v : any/c
procedure
(make-instance  name                   
               [data                   
                mode]                  
                variable-name          
                variable-value ...     
                ...)               -> instance?
  name : any/c
  data : any/c = #f
  mode : (or/c #f 'constant 'consistent) = #f
  variable-name : symbol?
  variable-value : any/c
procedure
(instance-name instance) -> any/c
  instance : instance?
procedure
(instance-data instance) -> any/c
  instance : instance?
procedure
(instance-variable-names instance) -> (list symbol?)
  instance : instance?
procedure
(instance-variable-value  instance     
                          name         
                         [fail-k]) -> any
  instance : instance?
  name : symbol?
  fail-k : any/c = (lambda () (error ....))
procedure
(instance-set-variable-value!  instance     
                               name         
                               v            
                              [mode])   -> void?
  instance : instance?
  name : symbol?
  v : any/c
  mode : (or/c #f 'constant 'consistent) = #f
procedure
(instance-unset-variable! instance name) -> void?
  instance : instance?
  name : symbol?
procedure
(instance-describe-variable! instance     
                             name         
                             desc-v)  -> void?
  instance : instance?
  name : symbol?
  desc-v : any/c
procedure
(variable-reference->instance  varref      
                              [ref-site?]) 
 -> (if ref-site? (or/c instance? #f symbol?) instance?)
  varref : variable-reference?
  ref-site? : any/c = #f
procedure
(correlated? v) -> boolean?
  v : any/c
procedure
(correlated-source crlt) -> any
  crlt : correlated?
procedure
(correlated-line crlt) -> (or/c exact-positive-integer? #f)
  crlt : correlated?
procedure
(correlated-column crlt) -> (or/c exact-nonnegative-integer? #f)
  crlt : correlated?
procedure
(correlated-position crlt) -> (or/c exact-positive-integer? #f)
  crlt : correlated?
procedure
(correlated-span crlt) -> (or/c exact-nonnegative-integer? #f)
  crlt : correlated?
procedure
(correlated-e crlt) -> any
  crlt : correlated?
procedure
(correlated->datum crlt) -> any
  crlt : (or/c correlated? any/c)
procedure
(datum->correlated v [srcloc prop]) -> correlated?
  v : any/c
  srcloc : (or/c correlated? #f
                 (list/c any/c
                         (or/c exact-positive-integer? #f)
                         (or/c exact-nonnegative-integer? #f)
                         (or/c exact-positive-integer? #f)
                         (or/c exact-nonnegative-integer? #f))
                 (vector/c any/c
                          (or/c exact-positive-integer? #f)
                          (or/c exact-nonnegative-integer? #f)
                          (or/c exact-positive-integer? #f)
                          (or/c exact-nonnegative-integer? #f)))
         = #f
  prop : (or/c correlated? #f) = #f
procedure
(correlated-property crlt key val) -> correlated?
  crlt : correlated?
  key : any/c
  val : any/c
(correlated-property crlt key) -> any/c
  crlt : correlated?
  key : any/c
procedure
(correlated-property-symbol-keys crlt) -> list?
  crlt : correlated?
procedure
(path? v) -> boolean?
  v : any/c
procedure
(path-string? v) -> boolean?
  v : any/c
procedure
(path-for-some-system? v) -> boolean?
  v : any/c
procedure
(string->path str) -> path?
  str : string?
procedure
(bytes->path bstr [type]) -> path?
  bstr : bytes?
  type : (or/c 'unix 'windows) = (system-path-convention-type)
procedure
(path->string path) -> string?
  path : path?
procedure
(path->bytes path) -> bytes?
  path : path-for-some-system?
procedure
(string->path-element  str                     
                      [false-on-non-element?]) 
 -> (or/c (and/c path? path-element?) #f)
  str : string?
  false-on-non-element? : any/c = #f
procedure
(bytes->path-element  bstr                    
                     [type                    
                      false-on-non-element?]) 
 -> (or/c path-element? #f)
  bstr : bytes?
  type : (or/c 'unix 'windows) = (system-path-convention-type)
  false-on-non-element? : any/c = #f
procedure
(path-element->string path) -> string?
  path : path-element?
procedure
(path-element->bytes path) -> bytes?
  path : path-element?
procedure
(path<? a-path b-path ...) -> boolean?
  a-path : path?
  b-path : path?
procedure
(path-convention-type path) -> (or/c 'unix 'windows)
  path : path-for-some-system?
procedure
(system-path-convention-type) -> (or/c 'unix 'windows)
procedure
(build-path base sub ...) -> path-for-some-system?
  base : (or/c path-string? path-for-some-system? 'up 'same)
  sub : (or/c (and/c (or/c path-string? path-for-some-system?)
                     (not/c complete-path?))
              (or/c 'up 'same))
procedure
(build-path/convention-type type         
                            base         
                            sub ...) -> path-for-some-system?
  type : (or/c 'unix 'windows)
  base : (or/c path-string? path-for-some-system? 'up 'same)
  sub : (or/c (and/c (or/c path-string? path-for-some-system?)
                     (not/c complete-path?))
              (or/c 'up 'same))
procedure
(absolute-path? path) -> boolean?
  path : (or/c path? string? path-for-some-system?)
procedure
(relative-path? path) -> boolean?
  path : (or/c path? string? path-for-some-system?)
procedure
(complete-path? path) -> boolean?
  path : (or/c path? string? path-for-some-system?)
procedure
(path->complete-path path [base]) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
  base : (or/c path-string? path-for-some-system?)
       = (current-directory)
procedure
(path->directory-path path) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
procedure
(resolve-path path) -> path?
  path : path-string?
procedure
(cleanse-path path) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
procedure
(expand-user-path path) -> path?
  path : path-string?
procedure
(simplify-path path [use-filesystem?]) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
  use-filesystem? : boolean? = #t
procedure
(normal-case-path path) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
procedure
(split-path path) -> (or/c path-for-some-system? 'relative #f)
                     (or/c path-for-some-system? 'up 'same)
                     boolean?
  path : (or/c path-string? path-for-some-system?)
procedure
(explode-path path)
 -> (listof (or/c path-for-some-system? 'up 'same))
  path : (or/c path-string? path-for-some-system?)
procedure
(path-replace-extension path ext) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
  ext : (or/c string? bytes?)
procedure
(path-add-extension path ext [sep]) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
  ext : (or/c string? bytes?)
  sep : (or/c string? bytes?) = #"_"
procedure
(path-replace-suffix path ext) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
  ext : (or/c string? bytes?)
procedure
(path-add-suffix path ext) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
  ext : (or/c string? bytes?)
procedure
(reroot-path path root-path) -> path-for-some-system?
  path : (or/c path-string? path-for-some-system?)
  root-path : (or/c path-string? path-for-some-system?)
procedure
(file-name-from-path path) -> (or/c path-for-some-system? #f)
  path : (or/c path-string? path-for-some-system?)
procedure
(path-get-extension path) -> (or/c bytes? #f)
  path : (or/c path-string? path-for-some-system?)
procedure
(path-has-extension? path ext) -> boolean?
  path : (or/c path-string? path-for-some-system?)
  ext : (or/c bytes? string?)
procedure
(filename-extension path) -> (or/c bytes? #f)
  path : (or/c path-string? path-for-some-system?)
procedure
(find-relative-path  base                                
                     path                                
                    [#:more-than-root? more-than-root?   
                     #:more-than-same? more-than-same?   
                     #:normalize-case? normalize-case?]) 
 -> (or/c path-for-some-system? path-string?)
  base : (or/c path-string? path-for-some-system?)
  path : (or/c path-string?  path-for-some-system?)
  more-than-root? : any/c = #f
  more-than-same? : any/c = #t
  normalize-case? : any/c = #t
procedure
(normalize-path path [wrt]) -> path?
  path : path-string?
  wrt : (and/c path-string? complete-path?)
      = (current-directory)
procedure
(path-element? path) -> boolean?
  path : any/c
procedure
(path-only path) -> (or/c #f path-for-some-system?)
  path : (or/c path-string? path-for-some-system?)
procedure
(simple-form-path path) -> path?
  path : path-string?
procedure
(some-system-path->string path) -> string?
  path : path-for-some-system?
procedure
(string->some-system-path str kind) -> path-for-some-system?
  str : string?
  kind : (or/c 'unix 'windows)
procedure
(shrink-path-wrt pth other-pths) -> (or/c #f path?)
  pth : path?
  other-pths : (listof path?)
procedure
(find-system-path kind) -> path?
  kind : symbol?
procedure
(path-list-string->path-list str                
                             default-path-list) 
 -> (listof (or/c path? 'same))
  str : (or/c string? bytes?)
  default-path-list : (listof (or/c path? 'same))
procedure
(find-executable-path  program        
                      [related        
                       deepest?]) -> (or/c path? #f)
  program : path-string?
  related : (or/c path-string? #f) = #f
  deepest? : any/c = #f
procedure
(file-exists? path) -> boolean?
  path : path-string?
procedure
(link-exists? path) -> boolean?
  path : path-string?
procedure
(file-or-directory-type path [must-exist?])
 -> (or/c 'file 'directory 'link 'directory-link #f)
  path : path-string?
  must-exist? : any/c = #f
procedure
(delete-file path) -> void?
  path : path-string?
procedure
(rename-file-or-directory  old              
                           new              
                          [exists-ok?]) -> void?
  old : path-string?
  new : path-string?
  exists-ok? : any/c = #f
procedure
(file-or-directory-modify-seconds  path         
                                  [secs-n]) -> exact-integer?
  path : path-string?
  secs-n : #f = #f
(file-or-directory-modify-seconds path        
                                  secs-n) -> void?
  path : path-string?
  secs-n : exact-integer?
(file-or-directory-modify-seconds  path             
                                  [secs-n           
                                   fail-thunk]) -> any
  path : path-string?
  secs-n : (or/c exact-integer? #f) = #f
  fail-thunk : (-> any)
             = (lambda () (raise (make-exn:fail:filesystem ....)))
procedure
(file-or-directory-permissions path [mode])
 -> (listof (or/c 'read 'write 'execute))
  path : path-string?
  mode : #f = #f
(file-or-directory-permissions path mode) -> (integer-in 0 65535)
  path : path-string?
  mode : 'bits
(file-or-directory-permissions path mode) -> void
  path : path-string?
  mode : (integer-in 0 65535)
procedure
(file-or-directory-stat path [as-link?])
 -> (and/c (hash/c symbol? any/c) hash-eq?)
  path : path-string?
  as-link? : boolean? = #f
procedure
(file-or-directory-identity path [as-link?])
 -> exact-positive-integer?
  path : path-string?
  as-link? : any/c = #f
procedure
(file-size path) -> exact-nonnegative-integer?
  path : path-string?
procedure
(copy-file  src                                               
            dest                                              
           [exists-ok?/pos                                    
            #:exists-ok? exists-ok?                           
            #:permissions permissions                         
            #:replace-permissions? replace-permissions?]) -> void?
  src : path-string?
  dest : path-string?
  exists-ok?/pos : any/c = #f
  exists-ok? : any/c = exists-ok?/pos
  permissions : (or/c #f (integer-in 0 65535)) = #f
  replace-permissions? : any/c = #t
procedure
(make-file-or-directory-link to path) -> void?
  to : path-string?
  path : path-string?
parameter
(current-force-delete-permissions) -> boolean?
(current-force-delete-permissions force?) -> void?
  force? : any/c
 = #t
parameter
(current-directory) -> (and/c path? complete-path?)
(current-directory path) -> void?
  path : path-string?
parameter
(current-directory-for-user) -> (and/c path? complete-path?)
(current-directory-for-user path) -> void?
  path : path-string?
procedure
(current-drive) -> path?
procedure
(directory-exists? path) -> boolean?
  path : path-string?
procedure
(make-directory path [permissions]) -> void?
  path : path-string?
  permissions : (integer-in 0 65535) = #o777
procedure
(delete-directory path) -> void?
  path : path-string?
procedure
(directory-list [path #:build? build?]) -> (listof path?)
  path : path-string? = (current-directory)
  build? : any/c = #f
procedure
(filesystem-root-list) -> (listof path?)
procedure
(filesystem-change-evt? v) -> boolean?
  v : any/c
procedure
(filesystem-change-evt path [failure-thunk])
 -> (or/c filesystem-change-evt? any)
  path : path-string?
  failure-thunk : (or/c (-> any) #f) = #f
procedure
(filesystem-change-evt-cancel evt) -> void?
  evt : filesystem-change-evt?
syntax
(define-runtime-path id maybe-runtime?-id expr)
 
maybe-runtime?-id = 
                  | #:runtime?-id runtime?-id
syntax
(define-runtime-paths (id ...) maybe-runtime?-id expr)
syntax
(define-runtime-path-list id maybe-runtime?-id expr)
syntax
(define-runtime-module-path-index id maybe-runtime?-id module-path-expr)
syntax
(runtime-require module-path)
syntax
(define-runtime-module-path id module-path)
syntax
(runtime-paths module-path)
procedure
(file->string path [#:mode mode-flag]) -> string?
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
procedure
(file->bytes path [#:mode mode-flag]) -> bytes?
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
procedure
(file->value path [#:mode mode-flag]) -> any
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
procedure
(file->list path [proc #:mode mode-flag]) -> (listof any/c)
  path : path-string?
  proc : (input-port? . -> . any/c) = read
  mode-flag : (or/c 'binary 'text) = 'binary
procedure
(file->lines  path                        
             [#:mode mode-flag            
              #:line-mode line-mode]) -> (listof string?)
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
            = 'any
procedure
(file->bytes-lines  path                        
                   [#:mode mode-flag            
                    #:line-mode line-mode]) -> (listof bytes?)
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
  line-mode : (or/c 'linefeed 'return 'return-linefeed 'any 'any-one)
            = 'any
procedure
(display-to-file  v                          
                  path                       
                 [#:mode mode-flag           
                  #:exists exists-flag]) -> void?
  v : any/c
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
  exists-flag : (or/c 'error 'append 'update
                      'replace 'truncate 'truncate/replace)
              = 'error
procedure
(write-to-file  v                          
                path                       
               [#:mode mode-flag           
                #:exists exists-flag]) -> void?
  v : any/c
  path : path-string?
  mode-flag : (or/c 'binary 'text) = 'binary
  exists-flag : (or/c 'error 'append 'update
                      'replace 'truncate 'truncate/replace)
              = 'error
procedure
(display-lines-to-file  lst                        
                        path                       
                       [#:separator separator      
                        #:mode mode-flag           
                        #:exists exists-flag]) -> void?
  lst : list?
  path : path-string?
  separator : any/c = #"\n"
  mode-flag : (or/c 'binary 'text) = 'binary
  exists-flag : (or/c 'error 'append 'update
                      'replace 'truncate 'truncate/replace)
              = 'error
procedure
(copy-directory/files                                              
                       src                                         
                       dest                                        
                      [#:keep-modify-seconds? keep-modify-seconds? 
                       #:preserve-links? preserve-links?])         
 -> void?
  src : path-string?
  dest : path-string?
  keep-modify-seconds? : any/c = #f
  preserve-links? : any/c = #f
procedure
(delete-directory/files  path                            
                        [#:must-exist? must-exist?]) -> void?
  path : path-string?
  must-exist? : any/c = #t
procedure
(find-files                                                      
             predicate                                           
            [start-path                                          
             #:skip-filtered-directory? skip-filtered-directory? 
             #:follow-links? follow-links?])                     
 -> (listof path?)
  predicate : (path? . -> . any/c)
  start-path : (or/c path-string? #f) = #f
  skip-filtered-directory? : any/c = #f
  follow-links? : any/c = #f
procedure
(pathlist-closure  path-list                       
                  [#:path-filter path-filter       
                   #:follow-links? follow-links?]) 
 -> (listof path?)
  path-list : (listof path-string?)
  path-filter : (or/c #f (path? . -> . any/c)) = #f
  follow-links? : any/c = #f
procedure
(fold-files  proc                
             init-val            
            [start-path          
             follow-links?]) -> any
  proc : (or/c (path? (or/c 'file 'dir 'link) any/c
                 . -> . any/c)
               (path? (or/c 'file 'dir 'link) any/c
                 . -> . (values any/c any/c)))
  init-val : any/c
  start-path : (or/c path-string? #f) = #f
  follow-links? : any/c = #t
procedure
(make-directory* path) -> void?
  path : path-string?
procedure
(make-parent-directory* path) -> void?
  path : path-string?
procedure
(make-temporary-file [template              
                      #:copy-from copy-from 
                      #:base-dir base-dir   
                      compat-copy-from      
                      compat-base-dir])     
 -> (and/c path? complete-path?)
  template : string? = "rkttmp~a"
  copy-from : (or/c path-string? #f 'directory) = #f
  base-dir : (or/c path-string? #f) = #f
  compat-copy-from : (or/c path-string? #f 'directory)
                   = copy-from
  compat-base-dir : (or/c path-string? #f) = base-dir
procedure
(make-temporary-directory [template              
                           #:base-dir base-dir]) 
 -> (and/c path? complete-path?)
  template : string? = "rkttmp~a"
  base-dir : (or/c path-string? #f) = #f
procedure
(make-temporary-file*  prefix                
                       suffix                
                      [#:copy-from copy-from 
                       #:base-dir base-dir]) 
 -> (and/c path? complete-path?)
  prefix : bytes?
  suffix : bytes?
  copy-from : (or/c path-string? #f) = #f
  base-dir : (or/c path-string? #f) = #f
procedure
(make-temporary-directory*  prefix                
                            suffix                
                           [#:base-dir base-dir]) 
 -> (and/c path? complete-path?)
  prefix : bytes?
  suffix : bytes?
  base-dir : (or/c path-string? #f) = #f
procedure
(call-with-atomic-output-file                                              
                               file                                        
                               proc                                        
                              [#:security-guard security-guard             
                               #:rename-fail-handler rename-fail-handler]) 
 -> any
  file : path-string?
  proc : (output-port? path? . -> . any)
  security-guard : (or/c #f security-guard?) = #f
  rename-fail-handler : (or/c #f (exn:fail:filesystem? path? . -> . any))
                      = #f
procedure
(get-preference  name                                        
                [failure-thunk                               
                 flush-mode                                  
                 filename                                    
                 #:use-lock? use-lock?                       
                 #:timeout-lock-there timeout-lock-there     
                 #:lock-there lock-there])               -> any
  name : symbol?
  failure-thunk : (-> any) = (lambda () #f)
  flush-mode : any/c = 'timestamp
  filename : (or/c path-string? #f) = #f
  use-lock? : any/c = #t
  timeout-lock-there : (or/c (path? . -> . any) #f) = #f
  lock-there : (or/c (path? . -> . any) #f)
             = (make-handle-get-preference-locked
                0.01 name failure-thunk flush-mode filename
                #:lock-there timeout-lock-there)
procedure
(put-preferences  names           
                  vals            
                 [locked-proc     
                  filename])  -> void?
  names : (listof symbol?)
  vals : list?
  locked-proc : (or/c #f (path? . -> . any)) = #f
  filename : (or/c #f path-string?) = #f
procedure
(preferences-lock-file-mode) -> (or/c 'exists 'file-lock)
procedure
(make-handle-get-preference-locked  delay                   
                                    name                    
                                   [failure-thunk           
                                    flush-mode              
                                    filename                
                                    #:lock-there lock-there 
                                    #:max-delay max-delay]) 
 -> (path-string? . -> . any)
  delay : real?
  name : symbol?
  failure-thunk : (-> any) = (lambda () #f)
  flush-mode : any/c = 'timestamp
  filename : (or/c path-string? #f) = #f
  lock-there : (or/c (path? . -> . any) #f) = #f
  max-delay : real? = 0.2
procedure
(call-with-file-lock/timeout  filename                    
                              kind                        
                              thunk                       
                              failure-thunk               
                             [#:lock-file lock-file       
                              #:delay delay               
                              #:max-delay max-delay]) -> any
  filename : (or/c path-string? #f)
  kind : (or/c 'shared 'exclusive)
  thunk : (-> any)
  failure-thunk : (-> any)
  lock-file : (or/c #f path-string?) = #f
  delay : (and/c real? (not/c negative?)) = 0.01
  max-delay : (and/c real? (not/c negative?)) = 0.2
procedure
(make-lock-file-name path) -> path?
  path : (or/c path-string? path-for-some-system?)
(make-lock-file-name dir name) -> path?
  dir : (or/c path-string? path-for-some-system?)
  name : path-element?
value
file-type-bits : #o170000
value
socket-type-bits : #o140000
value
symbolic-link-type-bits : #o120000
value
regular-file-type-bits : #o100000
value
block-device-type-bits : #o060000
value
directory-type-bits : #o040000
value
character-device-type-bits : #o020000
value
fifo-type-bits : #o010000
value
set-user-id-bit : #o004000
value
set-group-id-bit : #o002000
value
sticky-bit : #o001000
value
user-permission-bits : #o000700
value
user-read-bit : #o000400
value
user-write-bit : #o000200
value
user-execute-bit : #o000100
value
group-permission-bits : #o000070
value
group-read-bit : #o000040
value
group-write-bit : #o000020
value
group-execute-bit : #o000010
value
other-permission-bits : #o000007
value
other-read-bit : #o000004
value
other-write-bit : #o000002
value
other-execute-bit : #o000001
procedure
(tcp-listen  port-no            
            [max-allow-wait     
             reuse?             
             hostname])     -> tcp-listener?
  port-no : listen-port-number?
  max-allow-wait : exact-nonnegative-integer? = 4
  reuse? : any/c = #f
  hostname : (or/c string? #f) = #f
procedure
(tcp-connect  hostname            
              port-no             
             [local-hostname      
              local-port-no]) -> input-port? output-port?
  hostname : string?
  port-no : port-number?
  local-hostname : (or/c string? #f) = #f
  local-port-no : (or/c port-number? #f) = #f
procedure
(tcp-connect/enable-break  hostname        
                           port-no         
                          [local-hostname] 
                           local-port-no)  
 -> input-port? output-port?
  hostname : string?
  port-no : port-number?
  local-hostname : (or/c string? #f) = #f
  local-port-no : (or/c port-number? #f)
procedure
(tcp-accept listener) -> input-port? output-port?
  listener : tcp-listener?
procedure
(tcp-accept/enable-break listener) -> input-port? output-port?
  listener : tcp-listener?
procedure
(tcp-accept-ready? listener) -> boolean?
  listener : tcp-listener?
procedure
(tcp-close listener) -> void?
  listener : tcp-listener?
procedure
(tcp-listener? v) -> boolean?
  v : any/c
procedure
(tcp-accept-evt listener) -> evt?
  listener : tcp-listener?
procedure
(tcp-abandon-port tcp-port) -> void?
  tcp-port : tcp-port?
procedure
(tcp-addresses tcp-port [port-numbers?])
 -> (or/c (values string? string?)
          (values string? port-number?
                  string? listen-port-number?))
  tcp-port : (or/c tcp-port? tcp-listener? udp?)
  port-numbers? : any/c = #f
procedure
(tcp-port? v) -> boolean?
  v : any/c
value
port-number? : contract?
value
listen-port-number? : contract?
procedure
(udp-open-socket [family-hostname      
                  family-port-no]) -> udp?
  family-hostname : (or/c string? #f) = #f
  family-port-no : (or/c port-number? #f) = #f
procedure
(udp-bind!  udp-socket          
            hostname-string     
            port-no             
           [reuse?])        -> void?
  udp-socket : udp?
  hostname-string : (or/c string? #f)
  port-no : listen-port-number?
  reuse? : any/c = #f
procedure
(udp-connect! udp-socket          
              hostname-string     
              port-no)        -> void?
  udp-socket : udp?
  hostname-string : (or/c string? #f)
  port-no : (or/c port-number? #f)
procedure
(udp-send-to  udp-socket     
              hostname       
              port-no        
              bstr           
             [start-pos      
              end-pos])  -> void?
  udp-socket : udp?
  hostname : string?
  port-no : port-number?
  bstr : bytes?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-send udp-socket bstr [start-pos end-pos]) -> void?
  udp-socket : udp?
  bstr : bytes?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-send-to*  udp-socket     
               hostname       
               port-no        
               bstr           
              [start-pos      
               end-pos])  -> boolean?
  udp-socket : udp?
  hostname : string?
  port-no : port-number?
  bstr : bytes?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-send* udp-socket bstr [start-pos end-pos]) -> boolean?
  udp-socket : udp?
  bstr : bytes?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-send-to/enable-break  udp-socket     
                           hostname       
                           port-no        
                           bstr           
                          [start-pos      
                           end-pos])  -> void?
  udp-socket : udp?
  hostname : string?
  port-no : port-number?
  bstr : bytes?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-send/enable-break  udp-socket     
                        bstr           
                       [start-pos      
                        end-pos])  -> void?
  udp-socket : udp?
  bstr : bytes?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-receive!  udp-socket     
               bstr           
              [start-pos      
               end-pos])  -> exact-nonnegative-integer?
                             string?
                             port-number?
  udp-socket : udp?
  bstr : (and/c bytes? (not immutable?))
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-receive!*  udp-socket 
                bstr       
               [start-pos  
                end-pos])  
 -> (or/c exact-nonnegative-integer? #f)
    (or/c string? #f)
    (or/c port-number? #f)
  udp-socket : udp?
  bstr : (and/c bytes? (not immutable?))
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-receive!/enable-break  udp-socket 
                            bstr       
                           [start-pos  
                            end-pos])  
 -> exact-nonnegative-integer?
    string?
    port-number?
  udp-socket : udp?
  bstr : (and/c bytes? (not immutable?))
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-set-receive-buffer-size! udp-socket     
                              size)      -> void?
  udp-socket : udp?
  size : exact-positive-integer?
procedure
(udp-close udp-socket) -> void?
  udp-socket : udp?
procedure
(udp? v) -> boolean?
  v : any/c
procedure
(udp-bound? udp-socket) -> boolean?
  udp-socket : udp?
procedure
(udp-connected? udp-socket) -> boolean?
  udp-socket : udp?
procedure
(udp-send-ready-evt udp-socket) -> evt?
  udp-socket : udp?
procedure
(udp-receive-ready-evt udp-socket) -> evt?
  udp-socket : udp?
procedure
(udp-send-to-evt  udp-socket     
                  hostname       
                  port-no        
                  bstr           
                 [start-pos      
                  end-pos])  -> evt?
  udp-socket : udp?
  hostname : string?
  port-no : port-number?
  bstr : bytes?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-send-evt  udp-socket     
               bstr           
              [start-pos      
               end-pos])  -> evt?
  udp-socket : udp?
  bstr : bytes?
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-receive!-evt  udp-socket     
                   bstr           
                  [start-pos      
                   end-pos])  -> evt?
  udp-socket : udp?
  bstr : (and/c bytes? (not immutable?))
  start-pos : exact-nonnegative-integer? = 0
  end-pos : exact-nonnegative-integer? = (bytes-length bstr)
procedure
(udp-addresses udp-port [port-numbers?])
 -> (or/c (values string? string?)
          (values string? listen-port-number?
                  string? listen-port-number?))
  udp-port : udp?
  port-numbers? : any/c = #f
procedure
(udp-set-ttl! udp-socket ttl) -> void?
  udp-socket : udp?
  ttl : byte?
procedure
(udp-ttl udp-socket) -> byte?
  udp-socket : udp?
procedure
(udp-multicast-join-group! udp-socket         
                           multicast-addr     
                           hostname)      -> void?
  udp-socket : udp?
  multicast-addr : string?
  hostname : (or/c string? #f)
procedure
(udp-multicast-leave-group! udp-socket         
                            multicast-addr     
                            hostname)      -> void?
  udp-socket : udp?
  multicast-addr : string?
  hostname : (or/c string? #f)
procedure
(udp-multicast-interface udp-socket) -> string?
  udp-socket : udp?
procedure
(udp-multicast-set-interface! udp-socket     
                              hostname)  -> void?
  udp-socket : udp?
  hostname : (or/c string? #f)
procedure
(udp-multicast-set-loopback! udp-socket     
                             loopback?) -> void?
  udp-socket : udp?
  loopback? : any/c
procedure
(udp-multicast-loopback? udp-socket) -> boolean?
  udp-socket : udp?
procedure
(udp-multicast-set-ttl! udp-socket ttl) -> void?
  udp-socket : udp?
  ttl : byte?
procedure
(udp-multicast-ttl udp-socket) -> byte?
  udp-socket : udp?
procedure
(subprocess  stdout   
             stdin    
             stderr   
            [group]   
             command  
             arg ...) 
 -> subprocess?
    (or/c (and/c input-port? file-stream-port?) #f)
    (or/c (and/c output-port? file-stream-port?) #f)
    (or/c (and/c input-port? file-stream-port?) #f)
  stdout : (or/c (and/c output-port? file-stream-port?) #f)
  stdin : (or/c (and/c input-port? file-stream-port?) #f)
  stderr : (or/c (and/c output-port? file-stream-port?) #f 'stdout)
  group : (or/c #f 'new subprocess)
        = (and (subprocess-group-enabled) 'new)
  command : path-string?
  arg : (or/c path? string-no-nuls? bytes-no-nuls?)
(subprocess  stdout  
             stdin   
             stderr  
            [group]  
             command 
             exact   
             arg)    
 -> subprocess?
    (or/c (and/c input-port? file-stream-port?) #f)
    (or/c (and/c output-port? file-stream-port?) #f)
    (or/c (and/c input-port? file-stream-port?) #f)
  stdout : (or/c (and/c output-port? file-stream-port?) #f)
  stdin : (or/c (and/c input-port? file-stream-port?) #f)
  stderr : (or/c (and/c output-port? file-stream-port?) #f)
  group : (or/c #f 'new subprocess)
        = (and (subprocess-group-enabled) 'new)
  command : path-string?
  exact : 'exact
  arg : string?
procedure
(subprocess-wait subproc) -> void?
  subproc : subprocess?
procedure
(subprocess-status subproc) -> (or/c 'running
                                     exact-nonnegative-integer?)
  subproc : subprocess?
procedure
(subprocess-kill subproc force?) -> void?
  subproc : subprocess?
  force? : any/c
procedure
(subprocess-pid subproc) -> exact-nonnegative-integer?
  subproc : subprocess?
procedure
(subprocess? v) -> boolean?
  v : any/c
parameter
(current-subprocess-custodian-mode)
 -> (or/c #f 'kill 'interrupt)
(current-subprocess-custodian-mode mode) -> void?
  mode : (or/c #f 'kill 'interrupt)
parameter
(subprocess-group-enabled) -> boolean?
(subprocess-group-enabled on?) -> void?
  on? : any/c
parameter
(current-subprocess-keep-file-descriptors)
 -> (or/c 'inherited 'all '())
(current-subprocess-keep-file-descriptors keeps) -> void?
  keeps : (or/c 'inherited 'all '())
procedure
(shell-execute verb           
               target         
               parameters     
               dir            
               show-mode) -> #f
  verb : (or/c string? #f)
  target : string?
  parameters : string?
  dir : path-string?
  show-mode : symbol?
procedure
(system command [#:set-pwd? set-pwd?]) -> boolean?
  command : (or/c string-no-nuls? bytes-no-nuls?)
  set-pwd? : any/c = (member (system-type) '(unix macosx))
procedure
(system* command arg ... [#:set-pwd? set-pwd?]) -> boolean?
  command : path-string?
  arg : (or/c path? string-no-nuls? bytes-no-nuls?)
  set-pwd? : any/c = (member (system-type) '(unix macosx))
(system*  command                   
          exact                     
          arg                       
         [#:set-pwd? set-pwd?]) -> boolean?
  command : path-string?
  exact : 'exact
  arg : string?
  set-pwd? : any/c = (member (system-type) '(unix macosx))
procedure
(system/exit-code  command                   
                  [#:set-pwd? set-pwd?]) -> byte?
  command : (or/c string-no-nuls? bytes-no-nuls?)
  set-pwd? : any/c = (member (system-type) '(unix macosx))
procedure
(system*/exit-code  command                   
                    arg ...                   
                   [#:set-pwd? set-pwd?]) -> byte?
  command : path-string?
  arg : (or/c path? string-no-nuls? bytes-no-nuls?)
  set-pwd? : any/c = (member (system-type) '(unix macosx))
(system*/exit-code  command                   
                    exact                     
                    arg                       
                   [#:set-pwd? set-pwd?]) -> byte?
  command : path-string?
  exact : 'exact
  arg : string?
  set-pwd? : any/c = (member (system-type) '(unix macosx))
procedure
(process command [#:set-pwd? set-pwd?])
 -> (list input-port?
          output-port?
          exact-nonnegative-integer?
          input-port?
          ((or/c 'status 'wait 'interrupt 'kill) . -> . any))
  command : (or/c string-no-nuls? bytes-no-nuls?)
  set-pwd? : any/c = (member (system-type) '(unix macosx))
procedure
(process*  command                   
           arg ...                   
          [#:set-pwd? set-pwd?]) -> list?
  command : path-string?
  arg : (or/c path? string-no-nuls? bytes-no-nuls?)
  set-pwd? : any/c = (member (system-type) '(unix macosx))
(process*  command                   
           exact                     
           arg                       
          [#:set-pwd? set-pwd?]) -> list?
  command : path-string?
  exact : 'exact
  arg : string?
  set-pwd? : any/c = (member (system-type) '(unix macosx))
procedure
(process/ports  out                       
                in                        
                error-out                 
                command                   
               [#:set-pwd? set-pwd?]) -> list?
  out : (or/c #f output-port?)
  in : (or/c #f input-port?)
  error-out : (or/c #f output-port? 'stdout)
  command : (or/c path? string-no-nuls? bytes-no-nuls?)
  set-pwd? : any/c = (member (system-type) '(unix macosx))
procedure
(process*/ports  out                       
                 in                        
                 error-out                 
                 command                   
                 arg ...                   
                [#:set-pwd? set-pwd?]) -> list?
  out : (or/c #f output-port?)
  in : (or/c #f input-port?)
  error-out : (or/c #f output-port? 'stdout)
  command : path-string?
  arg : (or/c path? string-no-nuls? bytes-no-nuls?)
  set-pwd? : any/c = (member (system-type) '(unix macosx))
(process*/ports  out                       
                 in                        
                 error-out                 
                 command                   
                 exact                     
                 arg                       
                [#:set-pwd? set-pwd?]) -> list?
  out : (or/c #f output-port?)
  in : (or/c #f input-port?)
  error-out : (or/c #f output-port? 'stdout)
  command : path-string?
  exact : 'exact
  arg : string?
  set-pwd? : any/c = (member (system-type) '(unix macosx))
procedure
(string-no-nuls? x) -> boolean?
  x : any/c
procedure
(bytes-no-nuls? x) -> boolean?
  x : any/c
procedure
(logger? v) -> boolean?
  v : any/c
procedure
(make-logger [topic                    
              parent                   
              propagate-level          
              propagate-topic ...]     
              ...)                 -> logger?
  topic : (or/c symbol? #f) = #f
  parent : (or/c logger? #f) = #f
  propagate-level : log-level/c = 'debug
  propagate-topic : (or/c #f symbol?) = #f
procedure
(logger-name logger) -> (or/c symbol? #f)
  logger : logger?
parameter
(current-logger) -> logger?
(current-logger logger) -> void?
  logger : logger?
syntax
(define-logger id maybe-parent)
 
maybe-parent = 
             | #:parent parent-expr
 
  parent-expr : (or/c logger? #f)
procedure
(log-message  logger                
              level                 
             [topic]                
              message               
             [data                  
              prefix-message?]) -> void?
  logger : logger?
  level : log-level/c
  topic : (or/c symbol? #f) = (logger-name logger)
  message : string?
  data : any/c = #f
  prefix-message? : any/c = #t
procedure
(log-level? logger level [topic]) -> boolean?
  logger : logger?
  level : log-level/c
  topic : (or/c symbol? #f) = #f
procedure
(log-max-level logger [topic]) -> (or/c log-level/c #f)
  logger : logger?
  topic : (or/c symbol? #f) = #f
procedure
(log-all-levels logger) -> (list/c (or/c #f log-level/c)
                                   (or/c #f symbol?)
                                   ... ...)
  logger : logger?
procedure
(log-level-evt logger) -> evt?
  logger : logger?
syntax
(log-fatal string-expr)
(log-fatal format-string-expr v ...)
syntax
(log-error string-expr)
(log-error format-string-expr v ...)
syntax
(log-warning string-expr)
(log-warning format-string-expr v ...)
syntax
(log-info string-expr)
(log-info format-string-expr v ...)
syntax
(log-debug string-expr)
(log-debug format-string-expr v ...)
procedure
(log-receiver? v) -> boolean?
  v : any/c
procedure
(make-log-receiver logger level [topic ...] ...) -> log-receiver?
  logger : logger?
  level : log-level/c
  topic : (or/c #f symbol?) = #f
procedure
(log-level/c v) -> boolean?
  v : any/c
procedure
(with-intercepted-logging  interceptor          
                           proc                 
                          [#:logger logger]     
                           level                
                          [topic ...]           
                           ...)             -> any
  interceptor : (-> (vector/c
                      log-level/c
                      string?
                      any/c
                      (or/c symbol? #f))
                     any)
  proc : (-> any)
  logger : logger? = #f
  level : log-level/c
  topic : (or/c #f symbol?) = #f
procedure
(with-logging-to-port  port                 
                       proc                 
                      [#:logger logger]     
                       level                
                      [topic ...]           
                       ...)             -> any
  port : output-port?
  proc : (-> any)
  logger : logger? = #f
  level : log-level/c
  topic : (or/c #f symbol?) = #f
procedure
(current-seconds) -> exact-integer?
procedure
(current-inexact-milliseconds) -> real?
procedure
(current-inexact-monotonic-milliseconds) -> real?
procedure
(seconds->date secs-n [local-time?]) -> date*?
  secs-n : real?
  local-time? : any/c = #t
struct
(struct date (second
              minute
              hour
              day
              month
              year
              week-day
              year-day
              dst?
              time-zone-offset)
    #:extra-constructor-name make-date
    #:transparent)
  second : (integer-in 0 60)
  minute : (integer-in 0 59)
  hour : (integer-in 0 23)
  day : (integer-in 1 31)
  month : (integer-in 1 12)
  year : exact-integer?
  week-day : (integer-in 0 6)
  year-day : (integer-in 0 365)
  dst? : boolean?
  time-zone-offset : exact-integer?
struct
(struct date* date (nanosecond time-zone-name)
    #:extra-constructor-name make-date*)
  nanosecond : (integer-in 0 999999999)
  time-zone-name : (and/c string? immutable?)
procedure
(current-milliseconds) -> exact-integer?
procedure
(current-process-milliseconds [scope]) -> exact-integer?
  scope : (or/c #f thread? 'subprocesses) = #f
procedure
(current-gc-milliseconds) -> exact-integer?
procedure
(time-apply proc lst) -> list?
                         exact-integer?
                         exact-integer?
                         exact-integer?
  proc : procedure?
  lst : list?
syntax
(time body ...+)
procedure
(current-date) -> date*?
procedure
(date->string date [time?]) -> string?
  date : date?
  time? : any/c = #f
parameter
(date-display-format) -> (or/c 'american
                               'chinese
                               'german
                               'indian
                               'irish
                               'iso-8601
                               'rfc2822
                               'julian)
(date-display-format format) -> void?
  format : (or/c 'american
                 'chinese
                 'german
                 'indian
                 'irish
                 'iso-8601
                 'rfc2822
                 'julian)
procedure
(date->seconds date [local-time?]) -> exact-integer?
  date : date?
  local-time? : any/c = #t
procedure
(date*->seconds date [local-time?]) -> real?
  date : date?
  local-time? : any/c = #t
procedure
(find-seconds  second            
               minute            
               hour              
               day               
               month             
               year              
              [local-time?]) -> exact-integer?
  second : (integer-in 0 61)
  minute : (integer-in 0 59)
  hour : (integer-in 0 23)
  day : (integer-in 1 31)
  month : (integer-in 1 12)
  year : exact-nonnegative-integer?
  local-time? : any/c = #t
procedure
(date->julian/scaliger date) -> exact-integer?
  date : date?
procedure
(julian/scaliger->string date-number) -> string?
  date-number : exact-integer?
procedure
(date->julian/scalinger date) -> exact-integer?
  date : date?
procedure
(julian/scalinger->string date-number) -> string?
  date-number : exact-integer?
procedure
(environment-variables? v) -> boolean?
  v : any/c
parameter
(current-environment-variables) -> environment-variables?
(current-environment-variables env) -> void?
  env : environment-variables?
procedure
(bytes-environment-variable-name? v) -> boolean?
  v : any/c
procedure
(make-environment-variables name val ... ...)
 -> environment-variables?
  name : bytes-environment-variable-name?
  val : bytes-no-nuls?
procedure
(environment-variables-ref env name)
 -> (or/c #f (and/c bytes-no-nuls? immutable?))
  env : environment-variables?
  name : bytes-environment-variable-name?
procedure
(environment-variables-set!  env            
                             name           
                             maybe-bstr     
                            [fail])     -> any
  env : environment-variables?
  name : bytes-environment-variable-name?
  maybe-bstr : (or/c bytes-no-nuls? #f)
  fail : (-> any) = (lambda ()
                      (raise (make-exn:fail ....)))
procedure
(environment-variables-names env)
 -> (listof (and/c bytes-environment-variable-name? immutable?))
  env : environment-variables?
procedure
(environment-variables-copy env) -> environment-variables?
  env : environment-variables?
procedure
(getenv name) -> (or/c string-no-nuls? #f)
  name : string-environment-variable-name?
procedure
(putenv name value) -> boolean?
  name : string-environment-variable-name?
  value : string-no-nuls?
procedure
(string-environment-variable-name? v) -> boolean?
  v : any/c
procedure
(system-type [mode])
 -> (or/c symbol? string? bytes? exact-positive-integer? vector? #f)
  mode : (or/c 'os 'os* 'arch 'word 'vm 'gc 'link 'machine 'target-machine
               'so-suffix 'so-mode 'fs-change 'cross)
       = 'os
procedure
(system-language+country) -> string?
procedure
(system-library-subpath [mode]) -> path?
  mode : (or/c 'cgc '3m 'cs #f) = (system-type 'gc)
procedure
(version) -> (and/c string? immutable?)
procedure
(banner) -> (and/c string? immutable?)
parameter
(current-command-line-arguments)
 -> (vectorof (and/c string? immutable?))
(current-command-line-arguments argv) -> void?
  argv : (vectorof string?)
parameter
(current-thread-initial-stack-size) -> exact-positive-integer?
(current-thread-initial-stack-size size) -> void?
  size : exact-positive-integer?
procedure
(vector-set-performance-stats! results [thd]) -> void?
  results : (and/c vector?
                   (not/c immutable?))
  thd : (or/c thread? #f) = #f
syntax
(command-line optional-name-expr optional-argv-expr
              flag-clause ...
              finish-clause)
 
optional-name-expr = 
                   | #:program name-expr
                      
optional-argv-expr = 
                   | #:argv argv-expr
                      
       flag-clause = #:multi flag-spec ...
                   | #:once-each flag-spec ...
                   | #:once-any flag-spec ...
                   | #:final flag-spec ...
                   | #:usage-help string ...
                   | #:help-labels string ...
                   | #:ps string ...
                      
         flag-spec = (flags id ... help-spec body ...+)
                   | (flags => handler-expr help-expr)
                      
             flags = flag-string
                   | (flag-string ...+)
                      
         help-spec = string
                   | (string-expr ...+)
                      
     finish-clause = 
                   | #:args arg-formals body ...+
                   | #:handlers handlers-exprs
                      
       arg-formals = rest-id
                   | (arg ...)
                   | (arg ...+ . rest-id)
                      
               arg = id
                   | [id default-expr]
                      
    handlers-exprs = finish-expr arg-strings-expr
                   | finish-expr arg-strings-expr help-expr
                   | finish-expr arg-strings-expr help-expr
                     unknown-expr
procedure
(parse-command-line  name               
                     argv               
                     table              
                     finish-proc        
                     arg-help-strs      
                    [help-proc          
                     unknown-proc]) -> any
  name : (or/c string? path?)
  argv : (or/c (listof string?) (vectorof string?))
  table : (listof (cons/c symbol? list?))
  finish-proc : ((list?) () #:rest list? . ->* . any)
  arg-help-strs : (listof string?)
  help-proc : (string? . -> . any) = (lambda (str) ....)
  unknown-proc : (string? . -> . any) = (lambda (str) ...)
procedure
(gethostname) -> string?
procedure
(getpid) -> exact-integer?
procedure
(make-weak-box v) -> weak-box?
  v : any/c
procedure
(weak-box-value weak-box [gced-v]) -> any/c
  weak-box : weak-box?
  gced-v : any/c = #f
procedure
(weak-box? v) -> boolean?
  v : any/c
procedure
(make-ephemeron key v) -> ephemeron?
  key : any/c
  v : any/c
procedure
(ephemeron-value ephemeron [gced-v retain-v]) -> any/c
  ephemeron : ephemeron?
  gced-v : any/c = #f
  retain-v : any/c = #f
procedure
(ephemeron? v) -> boolean?
  v : any/c
procedure
(make-will-executor) -> will-executor?
procedure
(will-executor? v) -> boolean?
  v : any/c
procedure
(will-register executor v proc) -> void?
  executor : will-executor?
  v : any/c
  proc : (any/c . -> . any)
procedure
(will-execute executor) -> any
  executor : will-executor?
procedure
(will-try-execute executor [v]) -> any
  executor : any/c
  v : any/c = #f
procedure
(collect-garbage [request]) -> void?
  request : (or/c 'major 'minor 'incremental) = 'major
procedure
(current-memory-use [mode]) -> exact-nonnegative-integer?
  mode : (or/c #f 'cumulative custodian?) = #f
procedure
(dump-memory-stats v ...) -> any
  v : any/c
procedure
(phantom-bytes? v) -> boolean?
  v : any/c
procedure
(make-phantom-bytes k) -> phantom-bytes?
  k : exact-nonnegative-integer?
procedure
(set-phantom-bytes! phantom-bstr k) -> phantom-bytes?
  phantom-bstr : phantom-bytes?
  k : exact-nonnegative-integer?
procedure
(unsafe-fx+ a ...) -> fixnum?
  a : fixnum?
procedure
(unsafe-fx- a b ...) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fx* a ...) -> fixnum?
  a : fixnum?
procedure
(unsafe-fxquotient a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fxremainder a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fxmodulo a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fxabs a) -> fixnum?
  a : fixnum?
procedure
(unsafe-fxand a ...) -> fixnum?
  a : fixnum?
procedure
(unsafe-fxior a ...) -> fixnum?
  a : fixnum?
procedure
(unsafe-fxxor a ...) -> fixnum?
  a : fixnum?
procedure
(unsafe-fxnot a) -> fixnum?
  a : fixnum?
procedure
(unsafe-fxlshift a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fxrshift a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fxpopcount a) -> fixnum?
  a : (and/c fixnum? (not/c negative?))
procedure
(unsafe-fxpopcount32 a) -> fixnum?
  a : (and/c fixnum? (integer-in 0 #xFFFFFFFF))
procedure
(unsafe-fxpopcount16 a) -> fixnum?
  a : (and/c fixnum? (integer-in 0 #xFFFF))
procedure
(unsafe-fx+/wraparound a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fx-/wraparound a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fx*/wraparound a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fxlshift/wraparound a b) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fx= a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fx< a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fx> a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fx<= a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fx>= a b ...) -> boolean?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fxmin a b ...) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fxmax a b ...) -> fixnum?
  a : fixnum?
  b : fixnum?
procedure
(unsafe-fl+ a ...) -> flonum?
  a : flonum?
procedure
(unsafe-fl- a b ...) -> flonum?
  a : flonum?
  b : flonum?
procedure
(unsafe-fl* a ...) -> flonum?
  a : flonum?
procedure
(unsafe-fl/ a b ...) -> flonum?
  a : flonum?
  b : flonum?
procedure
(unsafe-flabs a) -> flonum?
  a : flonum?
procedure
(unsafe-fl= a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(unsafe-fl< a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(unsafe-fl> a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(unsafe-fl<= a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(unsafe-fl>= a b ...) -> boolean?
  a : flonum?
  b : flonum?
procedure
(unsafe-flmin a b ...) -> flonum?
  a : flonum?
  b : flonum?
procedure
(unsafe-flmax a b ...) -> flonum?
  a : flonum?
  b : flonum?
procedure
(unsafe-flround a) -> flonum?
  a : flonum?
procedure
(unsafe-flfloor a) -> flonum?
  a : flonum?
procedure
(unsafe-flceiling a) -> flonum?
  a : flonum?
procedure
(unsafe-fltruncate a) -> flonum?
  a : flonum?
procedure
(unsafe-flsingle a) -> flonum?
  a : flonum?
procedure
(unsafe-flsin a) -> flonum?
  a : flonum?
procedure
(unsafe-flcos a) -> flonum?
  a : flonum?
procedure
(unsafe-fltan a) -> flonum?
  a : flonum?
procedure
(unsafe-flasin a) -> flonum?
  a : flonum?
procedure
(unsafe-flacos a) -> flonum?
  a : flonum?
procedure
(unsafe-flatan a) -> flonum?
  a : flonum?
procedure
(unsafe-fllog a) -> flonum?
  a : flonum?
procedure
(unsafe-flexp a) -> flonum?
  a : flonum?
procedure
(unsafe-flsqrt a) -> flonum?
  a : flonum?
procedure
(unsafe-flexpt a b) -> flonum?
  a : flonum?
  b : flonum?
procedure
(unsafe-make-flrectangular a b)
 -> (and/c complex?
           (lambda (c) (flonum? (real-part c)))
           (lambda (c) (flonum? (imag-part c))))
  a : flonum?
  b : flonum?
procedure
(unsafe-flreal-part a) -> flonum?
  a : (and/c complex?
             (lambda (c) (flonum? (real-part c)))
             (lambda (c) (flonum? (imag-part c))))
procedure
(unsafe-flimag-part a) -> flonum?
  a : (and/c complex?
             (lambda (c) (flonum? (real-part c)))
             (lambda (c) (flonum? (imag-part c))))
procedure
(unsafe-fx->fl a) -> flonum?
  a : fixnum?
procedure
(unsafe-fl->fx a) -> fixnum?
  a : flonum?
procedure
(unsafe-flrandom rand-gen) -> (and flonum? (>/c 0) (</c 1))
  rand-gen : pseudo-random-generator?
procedure
(unsafe-char=? a b ...) -> boolean?
  a : char?
  b : char?
procedure
(unsafe-char<? a b ...) -> boolean?
  a : char?
  b : char?
procedure
(unsafe-char>? a b ...) -> boolean?
  a : char?
  b : char?
procedure
(unsafe-char<=? a b ...) -> boolean?
  a : char?
  b : char?
procedure
(unsafe-char>=? a b ...) -> boolean?
  a : char?
  b : char?
procedure
(unsafe-char->integer a) -> fixnum?
  a : char?
procedure
(unsafe-car p) -> any/c
  p : pair?
procedure
(unsafe-cdr p) -> any/c
  p : pair?
procedure
(unsafe-mcar p) -> any/c
  p : mpair?
procedure
(unsafe-mcdr p) -> any/c
  p : mpair?
procedure
(unsafe-set-mcar! p v) -> void?
  p : mpair?
  v : any/c
procedure
(unsafe-set-mcdr! p v) -> void?
  p : mpair?
  v : any/c
procedure
(unsafe-cons-list v rest) -> (and/c pair? list?)
  v : any/c
  rest : list?
procedure
(unsafe-list-ref lst pos) -> any/c
  lst : pair?
  pos : (and/c exact-nonnegative-integer? fixnum?)
procedure
(unsafe-list-tail lst pos) -> any/c
  lst : any/c
  pos : (and/c exact-nonnegative-integer? fixnum?)
procedure
(unsafe-set-immutable-car! p v) -> void?
  p : pair?
  v : any/c
procedure
(unsafe-set-immutable-cdr! p v) -> void?
  p : pair?
  v : any/c
procedure
(unsafe-unbox b) -> fixnum?
  b : box?
procedure
(unsafe-set-box! b k) -> void?
  b : box?
  k : fixnum?
procedure
(unsafe-unbox* v) -> any/c
  v : (and/c box? (not/c impersonator?))
procedure
(unsafe-set-box*! v val) -> void?
  v : (and/c box? (not/c impersonator?))
  val : any/c
procedure
(unsafe-box*-cas! loc old new) -> boolean?
  loc : box?
  old : any/c
  new : any/c
procedure
(unsafe-vector-length v) -> fixnum?
  v : vector?
procedure
(unsafe-vector-ref v k) -> any/c
  v : vector?
  k : fixnum?
procedure
(unsafe-vector-set! v k val) -> void?
  v : vector?
  k : fixnum?
  val : any/c
procedure
(unsafe-vector*-length v) -> fixnum?
  v : (and/c vector? (not/c impersonator?))
procedure
(unsafe-vector*-ref v k) -> any/c
  v : (and/c vector? (not/c impersonator?))
  k : fixnum?
procedure
(unsafe-vector*-set! v k val) -> void?
  v : (and/c vector? (not/c impersonator?))
  k : fixnum?
  val : any/c
procedure
(unsafe-vector*-cas! v k old-val new-val) -> boolean?
  v : (and/c vector? (not/c impersonator?))
  k : fixnum?
  old-val : any/c
  new-val : any/c
procedure
(unsafe-vector*->immutable-vector! v)
 -> (and/c vector? immutable?)
  v : (and/c vector? (not/c impersonator?))
procedure
(unsafe-string-length str) -> fixnum?
  str : string?
procedure
(unsafe-string-ref str k)
 -> (and/c char? (lambda (ch) (<= 0 (char->integer ch) 255)))
  str : string?
  k : fixnum?
procedure
(unsafe-string-set! str k ch) -> void?
  str : (and/c string? (not/c immutable?))
  k : fixnum?
  ch : char?
procedure
(unsafe-string->immutable-string! str)
 -> (and/c string? immutable?)
  str : string?
procedure
(unsafe-bytes-length bstr) -> fixnum?
  bstr : bytes?
procedure
(unsafe-bytes-ref bstr k) -> byte?
  bstr : bytes?
  k : fixnum?
procedure
(unsafe-bytes-set! bstr k b) -> void?
  bstr : (and/c bytes? (not/c immutable?))
  k : fixnum?
  b : byte?
procedure
(unsafe-bytes-copy!  dest           
                     dest-start     
                     src            
                    [src-start      
                     src-end])  -> void?
  dest : (and/c bytes? (not/c immutable?))
  dest-start : fixnum?
  src : bytes?
  src-start : fixnum? = 0
  src-end : fixnum? = (bytes-length src)
procedure
(unsafe-bytes->immutable-bytes! bstr)
 -> (and/c bytes? immutable?)
  bstr : bytes?
procedure
(unsafe-fxvector-length v) -> fixnum?
  v : fxvector?
procedure
(unsafe-fxvector-ref v k) -> fixnum?
  v : fxvector?
  k : fixnum?
procedure
(unsafe-fxvector-set! v k x) -> void?
  v : fxvector?
  k : fixnum?
  x : fixnum?
procedure
(unsafe-flvector-length v) -> fixnum?
  v : flvector?
procedure
(unsafe-flvector-ref v k) -> flonum?
  v : flvector?
  k : fixnum?
procedure
(unsafe-flvector-set! v k x) -> void?
  v : flvector?
  k : fixnum?
  x : flonum?
procedure
(unsafe-f64vector-ref vec k) -> flonum?
  vec : f64vector?
  k : fixnum?
procedure
(unsafe-f64vector-set! vec k n) -> void?
  vec : f64vector?
  k : fixnum?
  n : flonum?
procedure
(unsafe-s16vector-ref vec k) -> (integer-in -32768 32767)
  vec : s16vector?
  k : fixnum?
procedure
(unsafe-s16vector-set! vec k n) -> void?
  vec : s16vector?
  k : fixnum?
  n : (integer-in -32768 32767)
procedure
(unsafe-u16vector-ref vec k) -> (integer-in 0 65535)
  vec : u16vector?
  k : fixnum?
procedure
(unsafe-u16vector-set! vec k n) -> void?
  vec : u16vector?
  k : fixnum?
  n : (integer-in 0 65535)
procedure
(unsafe-stencil-vector mask v ...) -> stencil-vector?
  mask : (integer-in 0 (sub1 (expt 2 (stencil-vector-mask-width))))
  v : any/c
procedure
(unsafe-stencil-vector-mask vec)
 -> (integer-in 0 (sub1 (expt 2 (stencil-vector-mask-width))))
  vec : stencil-vector?
procedure
(unsafe-stencil-vector-length vec)
 -> (integer-in 0 (sub1 (stencil-vector-mask-width)))
  vec : stencil-vector?
procedure
(unsafe-stencil-vector-ref vec pos) -> any/c
  vec : stencil-vector?
  pos : exact-nonnegative-integer?
procedure
(unsafe-stencil-vector-set! vec pos v) -> avoid?
  vec : stencil-vector?
  pos : exact-nonnegative-integer?
  v : any/c
procedure
(unsafe-stencil-vector-update vec             
                              remove-mask     
                              add-mask        
                              v ...)      -> stencil-vector?
  vec : stencil-vector?
  remove-mask : (integer-in 0 (sub1 (expt 2 (stencil-vector-mask-width))))
  add-mask : (integer-in 0 (sub1 (expt 2 (stencil-vector-mask-width))))
  v : any/c
procedure
(unsafe-struct-ref v k) -> any/c
  v : any/c
  k : fixnum?
procedure
(unsafe-struct-set! v k val) -> void?
  v : any/c
  k : fixnum?
  val : any/c
procedure
(unsafe-struct*-ref v k) -> any/c
  v : (not/c impersonator?)
  k : fixnum?
procedure
(unsafe-struct*-set! v k val) -> void?
  v : (not/c impersonator?)
  k : fixnum?
  val : any/c
procedure
(unsafe-struct*-cas! v k old-val new-val) -> boolean?
  v : (not/c impersonator?)
  k : fixnum?
  old-val : any/c
  new-val : any/c
procedure
(unsafe-mutable-hash-iterate-first hash) -> (or/c #f any/c)
  hash : (and/c hash? (not/c immutable?) hash-strong?)
procedure
(unsafe-mutable-hash-iterate-next hash pos) -> (or/c #f any/c)
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
procedure
(unsafe-mutable-hash-iterate-key hash pos) -> any/c
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
procedure
(unsafe-mutable-hash-iterate-key hash             
                                 pos              
                                 bad-index-v) -> any/c
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-mutable-hash-iterate-value hash     
                                   pos) -> any/c
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
procedure
(unsafe-mutable-hash-iterate-value hash             
                                   pos              
                                   bad-index-v) -> any/c
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-mutable-hash-iterate-key+value hash     
                                       pos) -> any/c any/c
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
procedure
(unsafe-mutable-hash-iterate-key+value hash         
                                       pos          
                                       bad-index-v) 
 -> any/c any/c
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-mutable-hash-iterate-pair hash pos) -> pair?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
procedure
(unsafe-mutable-hash-iterate-pair hash             
                                  pos              
                                  bad-index-v) -> pair?
  hash : (and/c hash? (not/c immutable?) hash-strong?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-immutable-hash-iterate-first hash) -> (or/c #f any/c)
  hash : (and/c hash? immutable?)
procedure
(unsafe-immutable-hash-iterate-next hash     
                                    pos) -> (or/c #f any/c)
  hash : (and/c hash? immutable?)
  pos : any/c
procedure
(unsafe-immutable-hash-iterate-key hash     
                                   pos) -> any/c
  hash : (and/c hash? immutable?)
  pos : any/c
procedure
(unsafe-immutable-hash-iterate-key hash             
                                   pos              
                                   bad-index-v) -> any/c
  hash : (and/c hash? immutable?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-immutable-hash-iterate-value hash     
                                     pos) -> any/c
  hash : (and/c hash? immutable?)
  pos : any/c
procedure
(unsafe-immutable-hash-iterate-value hash             
                                     pos              
                                     bad-index-v) -> any/c
  hash : (and/c hash? immutable?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-immutable-hash-iterate-key+value hash     
                                         pos) -> any/c any/c
  hash : (and/c hash? immutable?)
  pos : any/c
procedure
(unsafe-immutable-hash-iterate-key+value hash         
                                         pos          
                                         bad-index-v) 
 -> any/c any/c
  hash : (and/c hash? immutable?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-immutable-hash-iterate-pair hash     
                                    pos) -> pair?
  hash : (and/c hash? immutable?)
  pos : any/c
procedure
(unsafe-immutable-hash-iterate-pair hash             
                                    pos              
                                    bad-index-v) -> pair?
  hash : (and/c hash? immutable?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-weak-hash-iterate-first hash) -> (or/c #f any/c)
  hash : (and/c hash? hash-weak?)
procedure
(unsafe-weak-hash-iterate-next hash pos) -> (or/c #f any/c)
  hash : (and/c hash? hash-weak?)
  pos : any/c
procedure
(unsafe-weak-hash-iterate-key hash pos) -> any/c
  hash : (and/c hash? hash-weak?)
  pos : any/c
procedure
(unsafe-weak-hash-iterate-key hash             
                              pos              
                              bad-index-v) -> any/c
  hash : (and/c hash? hash-weak?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-weak-hash-iterate-value hash pos) -> any/c
  hash : (and/c hash? hash-weak?)
  pos : any/c
procedure
(unsafe-weak-hash-iterate-value hash             
                                pos              
                                bad-index-v) -> any/c
  hash : (and/c hash? hash-weak?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-weak-hash-iterate-key+value hash     
                                    pos) -> any/c any/c
  hash : (and/c hash? hash-weak?)
  pos : any/c
procedure
(unsafe-weak-hash-iterate-key+value hash             
                                    pos              
                                    bad-index-v) -> any/c any/c
  hash : (and/c hash? hash-weak?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-weak-hash-iterate-pair hash pos) -> pair?
  hash : (and/c hash? hash-weak?)
  pos : any/c
procedure
(unsafe-weak-hash-iterate-pair hash             
                               pos              
                               bad-index-v) -> pair?
  hash : (and/c hash? hash-weak?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-ephemeron-hash-iterate-first hash) -> (or/c #f any/c)
  hash : (and/c hash? hash-ephemeron?)
procedure
(unsafe-ephemeron-hash-iterate-next hash     
                                    pos) -> (or/c #f any/c)
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
procedure
(unsafe-ephemeron-hash-iterate-key hash     
                                   pos) -> any/c
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
procedure
(unsafe-ephemeron-hash-iterate-key hash             
                                   pos              
                                   bad-index-v) -> any/c
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-ephemeron-hash-iterate-value hash     
                                     pos) -> any/c
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
procedure
(unsafe-ephemeron-hash-iterate-value hash             
                                     pos              
                                     bad-index-v) -> any/c
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-ephemeron-hash-iterate-key+value hash     
                                         pos) -> any/c any/c
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
procedure
(unsafe-ephemeron-hash-iterate-key+value hash         
                                         pos          
                                         bad-index-v) 
 -> any/c any/c
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-ephemeron-hash-iterate-pair hash     
                                    pos) -> pair?
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
procedure
(unsafe-ephemeron-hash-iterate-pair hash             
                                    pos              
                                    bad-index-v) -> pair?
  hash : (and/c hash? hash-ephemeron?)
  pos : any/c
  bad-index-v : any/c
procedure
(unsafe-make-srcloc source       
                    line         
                    column       
                    position     
                    span)    -> srcloc?
  source : any/c
  line : (or/c exact-positive-integer? #f)
  column : (or/c exact-nonnegative-integer? #f)
  position : (or/c exact-positive-integer? #f)
  span : (or/c exact-nonnegative-integer? #f)
procedure
(unsafe-extfl+ a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extfl- a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extfl* a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extfl/ a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extflabs a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extfl= a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extfl< a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extfl> a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extfl<= a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extfl>= a b) -> boolean?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extflmin a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extflmax a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-extflround a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflfloor a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflceiling a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extfltruncate a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflsin a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflcos a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extfltan a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflasin a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflacos a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflatan a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extfllog a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflexp a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflsqrt a) -> extflonum?
  a : extflonum?
procedure
(unsafe-extflexpt a b) -> extflonum?
  a : extflonum?
  b : extflonum?
procedure
(unsafe-fx->extfl a) -> extflonum?
  a : fixnum?
procedure
(unsafe-extfl->fx a) -> fixnum?
  a : extflonum?
procedure
(unsafe-extflvector-length v) -> fixnum?
  v : extflvector?
procedure
(unsafe-extflvector-ref v k) -> extflonum?
  v : extflvector?
  k : fixnum?
procedure
(unsafe-extflvector-set! v k x) -> void?
  v : extflvector?
  k : fixnum?
  x : extflonum?
procedure
(unsafe-impersonate-procedure proc             
                              replacement-proc 
                              prop             
                              prop-val ...     
                              ...)             
 -> (and/c procedure? impersonator?)
  proc : procedure?
  replacement-proc : procedure?
  prop : impersonator-property?
  prop-val : any
procedure
(unsafe-chaperone-procedure proc         
                            wrapper-proc 
                            prop         
                            prop-val ... 
                            ...)         
 -> (and/c procedure? chaperone?)
  proc : procedure?
  wrapper-proc : procedure?
  prop : impersonator-property?
  prop-val : any
procedure
(unsafe-impersonate-vector vec             
                           replacement-vec 
                           prop            
                           prop-val ...    
                           ...)            
 -> (and/c vector? impersonator?)
  vec : vector?
  replacement-vec : (and/c vector? (not/c impersonator?))
  prop : impersonator-property?
  prop-val : any/c
procedure
(unsafe-chaperone-vector vec             
                         replacement-vec 
                         prop            
                         prop-val ...    
                         ...)            
 -> (and/c vector? chaperone?)
  vec : vector?
  replacement-vec : (and/c vector? (not/c impersonator?))
  prop : impersonator-property?
  prop-val : any/c
procedure
(unsafe-assert-unreachable) -> none/c
value
unsafe-undefined : any/c
procedure
(check-not-unsafe-undefined v sym)
 -> (and/c any/c (not/c (one-of/c unsafe-undefined)))
  v : any/c
  sym : symbol?
procedure
(check-not-unsafe-undefined/assign v sym)
 -> (and/c any/c (not/c (one-of/c unsafe-undefined)))
  v : any/c
  sym : symbol?
procedure
(chaperone-struct-unsafe-undefined v) -> any/c
  v : any/c
value
prop:chaperone-unsafe-undefined : struct-type-property?
procedure
(find-library-collection-paths [pre-extras      
                                post-extras     
                                config]         
                                name)       -> (listof path?)
  pre-extras : (listof path-string?) = null
  post-extras : (listof path-string?) = null
  config : hash? = (read-installation-configuration-table)
  name : (get-installation-name config)
procedure
(find-library-collection-links [config] name)
 -> (listof (or/c #f (and/c path? complete-path?)))
  config : hash? = (read-installation-configuration-table)
  name : (get-installation-name config)
procedure
(collection-file-path  file                                
                       collection ...+                     
                      [#:check-compiled? check-compiled?]) 
 -> path?
  file : path-string?
  collection : path-string?
  check-compiled? : any/c = (regexp-match? #rx"[.]rkt$" file)
(collection-file-path  file                                    
                       collection ...+                         
                       #:fail fail-proc                        
                      [#:check-compiled? check-compiled?]) -> any
  file : path-string?
  collection : path-string?
  fail-proc : (string? . -> . any)
  check-compiled? : any/c = (regexp-match? #rx"[.]rkt$" file)
procedure
(collection-path collection ...+) -> path?
  collection : path-string?
(collection-path collection            
                 ...+                  
                 #:fail fail-proc) -> any
  collection : path-string?
  fail-proc : (string? . -> . any)
parameter
(current-library-collection-paths)
 -> (listof (and/c path? complete-path?))
(current-library-collection-paths paths) -> void?
  paths : (listof (and/c path-string? complete-path?))
parameter
(current-library-collection-links)
 -> (listof (or/c #f
                  (and/c path? complete-path?)
                  (hash/c (or/c (and/c symbol? module-path?) #f)
                          (listof (and/c path? complete-path?)))))
(current-library-collection-links paths) -> void?
  paths : (listof (or/c #f
                        (and/c path-string? complete-path?)
                        (hash/c (or/c (and/c symbol? module-path?) #f)
                                (listof (and/c path-string? complete-path?)))))
parameter
(use-user-specific-search-paths) -> boolean?
(use-user-specific-search-paths on?) -> void?
  on? : any/c
parameter
(use-collection-link-paths) -> boolean?
(use-collection-link-paths on?) -> void?
  on? : any/c
procedure
(read-installation-configuration-table)
 -> (and/c hash? immutable?)
syntax
help
(help string ...)
(help id)
(help id #:from module-path)
(help #:search datum ...)
parameter
(current-interaction-info)
 -> (or/c #f (vector/c module-path? symbol? any/c))
(current-interaction-info info) -> void?
  info : (or/c #f (vector/c module-path? symbol? any/c))
syntax
(enter! module-path)
(enter! #f)
(enter! module-path flag ...+)
 
flag = #:quiet
     | #:verbose-reload
     | #:verbose
     | #:dont-re-require-enter
procedure
(dynamic-enter!  mod                                         
                [#:verbosity verbosity                       
                 #:re-require-enter? re-require-enter?]) -> void?
  mod : (or/c module-path? #f)
  verbosity : (or/c 'all 'reload 'none) = 'reload
  re-require-enter? : any/c = #t
procedure
(dynamic-rerequire  module-path                 
                   [#:verbosity verbosity]) -> (listof path?)
  module-path : module-path?
  verbosity : (or/c 'all 'reload 'none) = 'reload
syntax
(trace id ...)
syntax
(trace-define id expr)
(trace-define (head args) body ...+)
syntax
(trace-define-syntax id expr)
(trace-define-syntax (head args) body ...+)
syntax
(trace-lambda [#:name id] args expr)
syntax
(trace-let id ([arg expr] ...+) body ...+)
syntax
(untrace id ...)
parameter
(current-trace-notify) -> (string? . -> . any)
(current-trace-notify proc) -> void?
  proc : (string? . -> . any)
procedure
(trace-call id proc #:<kw> kw-arg ...) -> any/c
  id : symbol?
  proc : procedure?
  kw-arg : any/c
parameter
(current-trace-print-args) -> (-> symbol?
                                  list?
                                  (listof keyword?)
                                  list?
                                  number?
                                  void?)
(current-trace-print-args trace-print-args) -> void?
  trace-print-args : (-> symbol?
                         list?
                         (listof keyword?)
                         list?
                         number?
                         void?)
parameter
(current-trace-print-results) -> (-> symbol?
                                     list?
                                     number?
                                     any)
(current-trace-print-results trace-print-results) -> void?
  trace-print-results : (-> symbol?
                            list?
                            number?
                            any)
parameter
(current-prefix-in) -> string?
(current-prefix-in prefix) -> void?
  prefix : string?
parameter
(current-prefix-out) -> string?
(current-prefix-out prefix) -> void?
  prefix : string?
