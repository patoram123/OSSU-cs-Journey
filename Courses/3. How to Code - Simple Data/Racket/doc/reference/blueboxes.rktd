194401
((3) 0 () 144 ((q quote #%kernel) (q lib "racket/unsafe/ops.rkt") (q lib "racket/dict.rkt") (q lib "racket/require-transform.rkt") (q lib "racket/system.rkt") (q lib "racket/function.rkt") (q lib "racket/private/base.rkt") (q lib "racket/stream.rkt") (q lib "racket/list.rkt") (q lib "racket/private/class-internal.rkt") (q lib "racket/vector.rkt") (q lib "racket/fixnum.rkt") (q lib "racket/sandbox.rkt") (q lib "racket/set.rkt") (q lib "racket/place.rkt") (q lib "racket/port.rkt") (q lib "racket/extflonum.rkt") (q lib "racket/file.rkt") (q lib "racket/format.rkt") (q lib "racket/contract/collapsible.rkt") (q lib "racket/tcp.rkt") (q lib "racket/linklet.rkt") (q lib "racket/sequence.rkt") (q lib "racket/contract/base.rkt") (q lib "racket/provide-transform.rkt") (q lib "racket/pretty.rkt") (q lib "racket/contract/private/misc.rkt") (q lib "racket/private/letstx-scheme.rkt") (q 308474 . 17) (q lib "racket/string.rkt") (q lib "racket/private/more-scheme.rkt") (q lib "racket/control.rkt") (q lib "racket/generic.rkt") (q 308997 . 5) (q lib "racket/trait.rkt") (q 241119 . 5) (q 240367 . 9) (q lib "racket/udp.rkt") (q lib "racket/class.rkt") (q lib "racket/trace.rkt") (q lib "racket/contract/private/guts.rkt") (q lib "racket/unit.rkt") (q lib "racket/private/list.rkt") (q lib "racket/private/misc.rkt") (q lib "racket/flonum.rkt") (q 161625 . 4) (q lib "racket/serialize.rkt") (q 256031 . 6) (q lib "racket/match.rkt") (q lib "racket/private/stxcase-scheme.rkt") (q 417723 . 40) (q lib "racket/path.rkt") (q 257604 . 5) (q lib "racket/contract/private/base.rkt") (q lib "racket/splicing.rkt") (q lib "racket/require.rkt") (q lib "racket/future.rkt") (q lib "racket/contract.rkt") (q 258089 . 4) (q 260499 . 9) (q 481087 . 23) (q lib "racket/contract/private/prop.rkt") (q lib "racket/random.rkt") (q 481747 . 5) (q lib "racket/private/qqstx.rkt") (q lib "racket/promise.rkt") (q lib "racket/contract/private/blame.rkt") (q lib "racket/runtime-path.rkt") (q 310809 . 8) (q 259870 . 5) (q 225255 . 4) (q 260024 . 4) (q lib "racket/async-channel.rkt") (q lib "racket/struct-info.rkt") (q 256221 . 4) (q lib "racket/engine.rkt") (q lib "racket/syntax.rkt") (q 427221 . 6) (q lib "racket/private/serialize.rkt") (q 258911 . 7) (q lib "racket/date.rkt") (q lib "racket/contract/combinator.rkt") (q lib "racket/math.rkt") (q 259130 . 4) (q 258680 . 5) (q 257795 . 5) (q 258521 . 4) (q 259478 . 4) (q lib "racket/phase+space.rkt") (q 258232 . 4) (q lib "racket/contract/private/opt.rkt") (q lib "racket/contract/private/ds.rkt") (q lib "racket/unit-exptime.rkt") (q lib "racket/generator.rkt") (q 240209 . 5) (q 259256 . 5) (q lib "racket/lazy-require.rkt") (q 256777 . 5) (q lib "racket/contract/private/vector.rkt") (q lib "racket/cmdline.rkt") (q lib "racket/logging.rkt") (q 428427 . 6) (q lib "racket/bool.rkt") (q lib "racket/contract/region.rkt") (q 257296 . 5) (q lib "racket/performance-hint.rkt") (q 190728 . 3) (q lib "racket/include.rkt") (q 256957 . 4) (q 170250 . 3) (q lib "racket/os.rkt") (q 256454 . 4) (q lib "racket/fasl.rkt") (q 240966 . 5) (q 257956 . 4) (q lib "racket/struct.rkt") (q lib "racket/private/map.rkt") (q 347769 . 29) (q 256603 . 5) (q 259616 . 4) (q 257120 . 5) (q 260153 . 4) (q lib "racket/unsafe/undefined.rkt") (q lib "racket/contract/private/hash.rkt") (q 241347 . 4) (q 259750 . 4) (q 256326 . 4) (q lib "racket/contract/private/box.rkt") (q lib "racket/contract/parametric.rkt") (q 258364 . 4) (q lib "racket/hash.rkt") (q 420238 . 5) (q lib "racket/enter.rkt") (q lib "racket/contract/private/struct-dc.rkt") (q lib "racket/bytes.rkt") (q lib "racket/keyword-transform.rkt") (q lib "racket/stxparam.rkt") (q lib "racket/provide.rkt") (q 257457 . 4) (q 426855 . 5) (q lib "racket/require-syntax.rkt") (q lib "racket/provide-syntax.rkt") (q lib "racket/contract/private/provide.rkt") (q lib "racket/stxparam-exptime.rkt")) () (h ! (equal) ((c def c (c (? . 0) q write-special)) q (360389 . 4)) ((c def c (c (? . 4) q system)) q (472686 . 4)) ((c def c (c (? . 0) q exn:fail:filesystem:errno-errno)) c (? . 84)) ((c def c (c (? . 10) q vector-split-at-right)) q (110102 . 4)) ((c def c (c (? . 0) q struct:exn:break:hang-up)) c (? . 71)) ((c def c (c (? . 6) q exn:fail:filesystem)) c (? . 89)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-key)) q (505470 . 5)) ((c def c (c (? . 0) q evt?)) q (272719 . 3)) ((c def c (c (? . 132) q dynamic-enter!)) q (519850 . 7)) ((c def c (c (? . 8) q tenth)) q (99190 . 3)) ((c def c (c (? . 1) q unsafe-fx-)) q (491157 . 4)) ((c def c (c (? . 2) q dict-map)) q (140606 . 4)) ((c form c (c (? . 7) q stream)) q (135660 . 2)) ((c form c (c (? . 38) q case->m)) q (184884 . 2)) ((c def c (c (? . 0) q raise-arity-mask-error)) q (252118 . 5)) ((c def c (c (? . 0) q vector-set-performance-stats!)) q (486877 . 5)) ((c def c (c (? . 0) q struct-type-info)) q (416077 . 11)) ((c def c (c (? . 2) q dict-clear!)) q (141219 . 3)) ((c def c (c (? . 0) q variable-reference-from-unsafe?)) q (385973 . 3)) ((c def c (c (? . 2) q dict-iterate-next)) q (139178 . 4)) ((c form c (c (? . 0) q begin-for-syntax)) q (14289 . 2)) ((c def c (c (? . 1) q unsafe-list-tail)) q (497086 . 4)) ((q form ((lib "racket/block.rkt") block)) q (19407 . 2)) ((c def c (c (? . 16) q extflround)) q (42586 . 3)) ((c def c (c (? . 0) q current-continuation-marks)) q (267644 . 5)) ((c def c (c (? . 17) q preferences-lock-file-mode)) q (457424 . 2)) ((c def c (c (? . 0) q hash-iterate-key+value)) q (122554 . 4)) ((c def c (c (? . 73) q prop:struct-field-info)) q (174325 . 2)) ((c def c (c (? . 0) q printf)) q (366175 . 4)) ((c def c (c (? . 0) q cdar)) q (96173 . 3)) ((c def c (c (? . 1) q unsafe-vector-length)) q (497832 . 3)) ((c def c (c (? . 0) q current-readtable)) q (364349 . 4)) ((c def c (c (? . 0) q thread-suspend-evt)) q (272270 . 3)) ((c def c (c (? . 3) q import)) c (? . 28)) ((c def c (c (? . 0) q raise)) q (246241 . 4)) ((c def c (c (? . 22) q sequence-ref)) q (133575 . 4)) ((c def c (c (? . 37) q udp-connect!)) q (462702 . 7)) ((c def c (c (? . 0) q string-locale-ci<?)) q (50283 . 4)) ((c def c (c (? . 3) q import-source-mode)) c (? . 33)) ((c def c (c (? . 0) q continuation-mark-set->context)) q (270085 . 5)) ((q form ((lib "racket/unreachable.rkt") with-assert-unreachable)) q (271104 . 3)) ((c def c (c (? . 12) q call-with-trusted-sandbox-configuration)) q (420408 . 3)) ((c def c (c (? . 11) q fxnot)) q (38375 . 3)) ((c def c (c (? . 56) q make-fsemaphore)) q (279777 . 3)) ((c def c (c (? . 5) q arity=?)) q (163709 . 4)) ((c def c (c (? . 4) q system*)) q (472876 . 13)) ((c form c (c (? . 13) q for*/seteqv)) q (149433 . 2)) ((c def c (c (? . 0) q module-path-index-join)) q (394534 . 5)) ((c def c (c (? . 0) q environment-variables-ref)) q (484806 . 5)) ((c form c (c (? . 0) q #%expression)) q (10914 . 2)) ((c def c (c (? . 1) q unsafe-set-box*!)) q (497607 . 4)) ((c def c (c (? . 5) q const)) q (162827 . 3)) ((c form c (c (? . 9) q override)) q (177958 . 2)) ((c def c (c (? . 0) q module-compiled-realm)) q (396921 . 3)) ((c def c (c (? . 6) q make-base-namespace)) q (380233 . 2)) ((c def c (c (? . 0) q impersonate-prompt-tag)) q (404239 . 18)) ((c def c (c (? . 0) q current-subprocess-keep-file-descriptors)) q (472165 . 5)) ((c def c (c (? . 93) q yield)) q (137514 . 3)) ((c def c (c (? . 7) q gen:stream)) q (137207 . 2)) ((c def c (c (? . 24) q prop:provide-pre-transformer)) q (310612 . 2)) ((c def c (c (? . 8) q seventh)) q (99037 . 3)) ((c form c (c (? . 14) q place)) q (282189 . 2)) ((c def c (c (? . 6) q in-input-port-chars)) q (125979 . 3)) ((c def c (c (? . 1) q unsafe-char->integer)) q (496423 . 3)) ((c def c (c (? . 8) q dropf-right)) q (101313 . 4)) ((c def c (c (? . 15) q make-pipe-with-specials)) q (339796 . 7)) ((c def c (c (? . 1) q unsafe-extfl->fx)) q (513872 . 3)) ((c def c (c (? . 0) q sin)) q (25565 . 3)) ((c form c (c (? . 9) q define/augment-final)) q (179478 . 3)) ((c def c (c (? . 20) q tcp-accept-ready?)) q (461400 . 3)) ((c def c (c (? . 10) q vector-drop-right)) q (109871 . 4)) ((c form c (c (? . 39) q trace)) q (520426 . 2)) ((c def c (c (? . 6) q prop:procedure)) q (161761 . 2)) ((c def c (c (? . 0) q primitive-closure?)) q (162626 . 3)) ((c def c (c (? . 0) q module-compiled-language-info)) q (396595 . 4)) ((c def c (c (? . 49) q generate-temporaries)) q (291664 . 3)) ((c def c (c (? . 82) q pi)) q (32371 . 2)) ((c form c (c (? . 11) q for/fxvector)) q (40900 . 2)) ((c def c (c (? . 1) q unsafe-fxabs)) q (491556 . 3)) ((c def c (c (? . 18) q ~e)) q (57037 . 25)) ((c def c (c (? . 0) q string-port?)) q (328254 . 3)) ((c def c (c (? . 8) q shuffle)) q (104307 . 3)) ((c def c (c (? . 12) q set-eval-handler)) q (426703 . 4)) ((c def c (c (? . 0) q vector-set!)) q (107123 . 5)) ((c def c (c (? . 0) q read-string)) q (350127 . 4)) ((c form c (c (? . 5) q thunk)) q (162939 . 2)) ((c def c (c (? . 11) q fxand)) q (38204 . 3)) ((c def c (c (? . 0) q length)) q (92586 . 3)) ((c def c (c (? . 13) q set-rest)) q (152204 . 3)) ((c def c (c (? . 0) q hash-ref-key)) q (118583 . 7)) ((c def c (c (? . 92) q unit-static-signatures)) q (198382 . 9)) ((c def c (c (? . 0) q impersonator-property-accessor-procedure?)) q (412714 . 3)) ((c form c (c (? . 14) q place*)) q (282220 . 9)) ((c def c (c (? . 0) q raise-arity-error)) q (251252 . 9)) ((c def c (c (? . 6) q arity-at-least)) c (? . 45)) ((c def c (c (? . 0) q hash-set!)) q (117784 . 5)) ((c form c (c (? . 9) q rename-inner)) q (178407 . 2)) ((c def c (c (? . 0) q syntax-taint)) q (314125 . 3)) ((c def c (c (? . 2) q dict-update)) q (140327 . 8)) ((c form c (c (? . 0) q module*)) q (1695 . 3)) ((c form c (c (? . 9) q pubment*)) q (178477 . 2)) ((c def c (c (? . 0) q values)) q (246074 . 3)) ((c def c (c (? . 0) q semaphore-wait)) q (274990 . 3)) ((c def c (c (? . 51) q path-only)) q (443080 . 3)) ((c def c (c (? . 21) q eval-linklet)) q (431479 . 3)) ((c def c (c (? . 6) q apply)) q (157686 . 6)) ((c def c (c (? . 0) q exact?)) q (22831 . 3)) ((c def c (c (? . 6) q real->decimal-string)) q (30235 . 4)) ((c def c (c (? . 0) q make-shared-bytes)) q (65178 . 4)) ((c def c (c (? . 0) q round)) q (24237 . 3)) ((c form c (c (? . 6) q for*/hasheq)) q (16952 . 2)) ((c def c (c (? . 0) q chaperone?)) q (399145 . 3)) ((c form c (c (? . 6) q submod)) q (5390 . 4)) ((c def c (c (? . 0) q file-or-directory-stat)) q (445910 . 5)) ((c def c (c (? . 0) q syntax-local-submodules)) q (305609 . 2)) ((c def c (c (? . 0) q call-with-values)) q (246126 . 4)) ((c form c (c (? . 9) q send*)) q (181436 . 5)) ((c def c (c (? . 15) q reencode-input-port)) q (340939 . 16)) ((c def c (c (? . 61) q build-contract-property)) q (231965 . 50)) ((c def c (c (? . 0) q output-port?)) q (319882 . 3)) ((c form c (c (? . 6) q for-syntax)) q (7051 . 2)) ((c def c (c (? . 16) q extflvector)) q (44025 . 3)) ((c def c (c (? . 1) q unsafe-flatan)) q (494831 . 3)) ((c def c (c (? . 11) q fxquotient)) q (37919 . 4)) ((c def c (c (? . 0) q quotient/remainder)) q (23689 . 4)) ((c def c (c (? . 0) q cdaddr)) q (98057 . 3)) ((c def c (c (? . 13) q set-copy-clear)) q (152433 . 3)) ((c def c (c (? . 0) q stencil-vector-ref)) q (113013 . 4)) ((c def c (c (? . 0) q path->bytes)) q (437467 . 3)) ((c def c (c (? . 1) q unsafe-f64vector-ref)) q (500567 . 4)) ((c def c (c (? . 19) q collapsible-leaf/c-missing-party-list)) c (? . 36)) ((c def c (c (? . 0) q regexp-match-peek)) q (80618 . 15)) ((c def c (c (? . 0) q local-transformer-expand)) q (298975 . 11)) ((c def c (c (? . 0) q memory-order-acquire)) q (282888 . 2)) ((c def c (c (? . 0) q integer-sqrt)) q (25215 . 3)) ((c def c (c (? . 15) q merge-input)) q (340197 . 5)) ((c def c (c (? . 0) q identifier-prune-to-source-module)) q (291984 . 3)) ((c def c (c (? . 0) q executable-yield-handler)) q (270920 . 4)) ((c def c (c (? . 0) q current-thread-initial-stack-size)) q (486712 . 4)) ((c def c (c (? . 80) q julian/scaliger->string)) q (484070 . 3)) ((c def c (c (? . 17) q file->string)) q (448831 . 4)) ((c def c (c (? . 18) q ~r)) q (58273 . 31)) ((c def c (c (? . 11) q fx=)) q (39188 . 4)) ((c def c (c (? . 29) q string-split)) q (52251 . 9)) ((c def c (c (? . 0) q exn:missing-module?)) q (260995 . 3)) ((c def c (c (? . 2) q dict-mutable?)) q (138143 . 3)) ((c def c (c (? . 25) q pretty-print-columns)) q (370321 . 5)) ((c def c (c (? . 0) q string<=?)) q (48513 . 4)) ((c form c (c (? . 13) q for/setalw)) q (149282 . 2)) ((c def c (c (? . 26) q flat-contract-with-explanation)) q (199354 . 6)) ((c form c (c (? . 30) q with-handlers)) q (254584 . 3)) ((c form c (c (? . 0) q define-syntaxes)) q (13679 . 2)) ((c def c (c (? . 1) q unsafe-fxvector-set!)) q (500189 . 5)) ((c def c (c (? . 0) q string-grapheme-span)) q (50647 . 5)) ((c form c (c (? . 13) q for*/mutable-setalw)) q (149945 . 2)) ((c def c (c (? . 0) q namespace-base-phase)) q (380745 . 3)) ((c def c (c (? . 0) q impersonator-of?)) q (399201 . 4)) ((c def c (c (? . 23) q one-of/c)) q (201130 . 3)) ((c def c (c (? . 19) q struct:collapsible-count-property)) c (? . 35)) ((c def c (c (? . 20) q tcp-accept-evt)) q (461618 . 3)) ((c def c (c (? . 0) q datum->syntax)) q (288687 . 20)) ((c def c (c (? . 21) q instance-name)) q (433759 . 3)) ((c def c (c (? . 12) q sandbox-propagate-exceptions)) q (422333 . 4)) ((c def c (c (? . 0) q print)) q (365495 . 5)) ((c def c (c (? . 2) q make-custom-hash)) q (143780 . 14)) ((c def c (c (? . 22) q sequence-tail)) q (133672 . 4)) ((c def c (c (? . 0) q chaperone-vector)) q (407202 . 14)) ((c def c (c (? . 21) q instance-unset-variable!)) q (434583 . 4)) ((c form c (c (? . 32) q chaperone-generics)) q (170763 . 4)) ((c def c (c (? . 14) q place-wait)) q (281362 . 3)) ((c def c (c (? . 0) q bytes-convert)) q (68914 . 21)) ((c def c (c (? . 0) q exn:fail:read?)) c (? . 85)) ((c form c (c (? . 9) q inherit-field)) q (177765 . 2)) ((c form c (c (? . 34) q trait-exclude-field)) q (183573 . 2)) ((c form c (c (? . 6) q for/product)) q (15765 . 2)) ((c def c (c (? . 0) q list->bytes)) q (65109 . 3)) ((c def c (c (? . 0) q struct:date*)) c (? . 63)) ((c def c (c (? . 88) q phase+space-shift+)) q (319551 . 4)) ((c form c (c (? . 9) q field)) q (177733 . 2)) ((c def c (c (? . 23) q integer-in)) q (200749 . 4)) ((c def c (c (? . 0) q read-char)) q (349480 . 3)) ((c def c (c (? . 2) q dict-count)) q (141022 . 3)) ((c def c (c (? . 6) q exn:fail:syntax:missing-module)) c (? . 52)) ((c def c (c (? . 0) q current-logger)) q (477735 . 4)) ((c def c (c (? . 1) q unsafe-extflcos)) q (513165 . 3)) ((c form c (c (? . 64) q quasisyntax/loc)) q (286539 . 14)) ((c def c (c (? . 1) q unsafe-fxand)) q (491615 . 3)) ((c def c (c (? . 14) q place-channel-put)) q (281714 . 4)) ((c def c (c (? . 24) q syntax-local-provide-certifier)) q (311049 . 4)) ((c def c (c (? . 0) q module-compiled-submodules)) q (395298 . 13)) ((c form c (c (? . 46) q define-serializable-struct/versions)) q (377527 . 4)) ((c def c (c (? . 9) q interface?)) q (188870 . 3)) ((c def c (c (? . 0) q chaperone-continuation-mark-key)) q (411974 . 13)) ((c def c (c (? . 2) q dict-clear)) q (141160 . 3)) ((c form c (c (? . 27) q let*)) q (11955 . 2)) ((c def c (c (? . 15) q special-filter-input-port)) q (346341 . 8)) ((c def c (c (? . 0) q prop:impersonator-of)) q (405579 . 2)) ((c def c (c (? . 0) q real->floating-point-bytes)) q (31818 . 12)) ((c def c (c (? . 25) q pretty-print-pre-print-hook)) q (373078 . 5)) ((c def c (c (? . 23) q predicate/c)) q (212505 . 2)) ((c def c (c (? . 1) q unsafe-set-immutable-cdr!)) q (497298 . 4)) ((c def c (c (? . 26) q >=/c)) q (200535 . 3)) ((c form c (c (? . 27) q else)) q (13068 . 2)) ((c form c (c (? . 11) q for*/fxvector)) q (40966 . 9)) ((c def c (c (? . 6) q exn:fail:syntax:unbound)) c (? . 138)) ((c def c (c (? . 0) q make-semaphore)) q (274825 . 3)) ((c def c (c (? . 100) q log-level/c)) q (479604 . 3)) ((c def c (c (? . 17) q group-execute-bit)) q (459941 . 2)) ((c def c (c (? . 3) q make-import)) c (? . 28)) ((c def c (c (? . 16) q extflsin)) q (42843 . 3)) ((c def c (c (? . 24) q make-provide-pre-transformer)) q (310391 . 5)) ((c def c (c (? . 29) q string-join)) q (51174 . 11)) ((c def c (c (? . 0) q variable-reference->module-base-phase)) q (385739 . 3)) ((c def c (c (? . 26) q promise/c)) q (206029 . 3)) ((c form c (c (? . 91) q define-contract-struct)) q (213025 . 2)) ((c def c (c (? . 0) q raise-result-arity-error*)) q (252936 . 11)) ((c def c (c (? . 0) q error-syntax->string-handler)) q (255723 . 9)) ((q def ((lib "racket/exn.rkt") exn->string)) q (261176 . 3)) ((c def c (c (? . 0) q bitwise-and)) q (26422 . 3)) ((c def c (c (? . 11) q make-fxvector)) q (40026 . 4)) ((c form c (c (? . 31) q prompt0-at)) q (266867 . 2)) ((c form c (c (? . 23) q struct-guard/c)) q (214215 . 2)) ((c def c (c (? . 0) q channel?)) q (274325 . 3)) ((c def c (c (? . 0) q struct-type-authentic?)) q (416464 . 3)) ((c def c (c (? . 15) q read-string-evt)) q (347201 . 4)) ((c form c (c (? . 6) q for*/first)) q (17407 . 2)) ((c def c (c (? . 40) q contract?)) q (235969 . 3)) ((c def c (c (? . 9) q class-info)) q (190457 . 10)) ((c form c (c (? . 27) q quasiquote)) q (19246 . 2)) ((c form c (c (? . 9) q class-field-mutator)) q (182132 . 2)) ((c def c (c (? . 48) q prop:legacy-match-expander)) q (245431 . 2)) ((c def c (c (? . 6) q exn:fail:contract:variable)) c (? . 120)) ((c def c (c (? . 13) q set-eqv?)) q (146482 . 3)) ((c def c (c (? . 0) q global-port-print-handler)) q (369096 . 6)) ((c def c (c (? . 13) q set-add!)) q (151717 . 4)) ((c def c (c (? . 0) q uncaught-exception-handler)) q (254445 . 4)) ((c def c (c (? . 1) q unsafe-string-ref)) q (498837 . 5)) ((c def c (c (? . 12) q sandbox-namespace-specs)) q (422467 . 6)) ((c form c (c (? . 30) q log-info)) q (479230 . 3)) ((c def c (c (? . 0) q peek-char-or-special)) q (356611 . 10)) ((c def c (c (? . 0) q struct:exn:break)) c (? . 69)) ((c def c (c (? . 2) q in-dict-values)) q (141581 . 3)) ((c def c (c (? . 19) q has-impersonator-prop:collapsible?)) q (240794 . 3)) ((c def c (c (? . 0) q peek-char)) q (356251 . 4)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-next)) q (503131 . 4)) ((c form c (c (? . 133) q struct/c)) q (203354 . 2)) ((c def c (c (? . 31) q spawn)) q (267070 . 3)) ((c def c (c (? . 14) q dynamic-place*)) q (280736 . 14)) ((c def c (c (? . 32) q struct:exn:fail:support)) c (? . 109)) ((c def c (c (? . 0) q module-provide-protected?)) q (384634 . 5)) ((c form c (c (? . 30) q case)) q (13137 . 5)) ((c def c (c (? . 3) q import-source)) c (? . 33)) ((c def c (c (? . 13) q set-implements?)) q (150705 . 4)) ((c def c (c (? . 78) q serializable?)) q (375502 . 3)) ((c def c (c (? . 0) q custodian-box-value)) q (415056 . 3)) ((c def c (c (? . 7) q prop:stream)) q (137234 . 2)) ((c form c (c (? . 13) q for*/setalw)) q (149485 . 2)) ((c def c (c (? . 5) q negate)) q (162996 . 3)) ((c def c (c (? . 12) q exn:fail:sandbox-terminated-reason)) c (? . 131)) ((c def c (c (? . 0) q simplify-path)) q (440184 . 4)) ((c form c (c (? . 34) q trait-exclude)) q (183534 . 2)) ((c def c (c (? . 26) q make-none/c)) q (236937 . 3)) ((c form c (c (? . 54) q splicing-let-values)) q (312455 . 2)) ((c form c (c (? . 9) q super)) q (179784 . 3)) ((c form c (c (? . 6) q relative-in)) q (4824 . 2)) ((c def c (c (? . 19) q merge)) q (238928 . 6)) ((c form c (c (? . 53) q recursive-contract)) q (237011 . 10)) ((c form c (c (? . 41) q define-unit)) q (194517 . 7)) ((c def c (c (? . 0) q identifier-transformer-binding)) q (294479 . 15)) ((c form c (c (? . 9) q define/override)) q (179060 . 3)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-key+value)) q (510372 . 5)) ((c def c (c (? . 0) q port-count-lines!)) q (321605 . 3)) ((c def c (c (? . 0) q char-lower-case?)) q (71991 . 3)) ((c def c (c (? . 0) q syntax-bound-phases)) q (297508 . 3)) ((c def c (c (? . 2) q dict-empty?)) q (140959 . 3)) ((c form c (c (? . 30) q let/cc)) q (264933 . 2)) ((c def c (c (? . 0) q string-locale-ci=?)) q (50179 . 4)) ((c def c (c (? . 0) q syntax-local-context)) q (305254 . 3)) ((c def c (c (? . 8) q index-of)) q (99733 . 5)) ((c def c (c (? . 0) q expand-once)) q (314451 . 4)) ((c def c (c (? . 0) q regexp-match-peek-positions-immediate)) q (82869 . 19)) ((c def c (c (? . 19) q collapsible-count-property?)) c (? . 35)) ((c def c (c (? . 0) q syntax-local-transforming-module-provides?)) q (307368 . 2)) ((c def c (c (? . 19) q collapsible-leaf/c-blame-list)) c (? . 36)) ((c def c (c (? . 43) q println)) q (365895 . 5)) ((c def c (c (? . 6) q namespace-anchor?)) q (380318 . 3)) ((c def c (c (? . 81) q make-flat-contract)) q (220254 . 32)) ((c def c (c (? . 0) q struct:exn:fail:read:eof)) c (? . 114)) ((c def c (c (? . 0) q number?)) q (21757 . 3)) ((c def c (c (? . 0) q caaddr)) q (97257 . 3)) ((c def c (c (? . 0) q environment-variables-set!)) q (484990 . 10)) ((c def c (c (? . 0) q namespace-require/constant)) q (382594 . 5)) ((c def c (c (? . 0) q syntax-local-introduce)) q (306595 . 3)) ((c form c (c (? . 6) q for/foldr)) q (16303 . 9)) ((c def c (c (? . 37) q udp-send-to/enable-break)) q (464316 . 13)) ((c def c (c (? . 0) q peek-byte)) q (356431 . 4)) ((c def c (c (? . 0) q set-mcar!)) q (106446 . 4)) ((c form c (c (? . 31) q control-at)) q (266527 . 2)) ((c def c (c (? . 0) q chaperone-box)) q (408344 . 12)) ((c def c (c (? . 2) q in-dict-pairs)) q (141648 . 3)) ((c def c (c (? . 0) q port-commit-peeked)) q (357779 . 6)) ((c def c (c (? . 29) q string-suffix?)) q (53240 . 4)) ((c def c (c (? . 0) q dynamic-require-for-syntax)) q (397343 . 7)) ((c form c (c (? . 6) q lambda)) q (11223 . 2)) ((c form c (c (? . 6) q for/hash)) q (15320 . 2)) ((c def c (c (? . 0) q current-directory)) q (447217 . 4)) ((c def c (c (? . 0) q module->language-info)) q (397804 . 6)) ((c def c (c (? . 0) q syntax-local-make-delta-introducer)) q (305942 . 3)) ((c def c (c (? . 6) q hash->list)) q (120978 . 4)) ((c def c (c (? . 62) q crypto-random-bytes)) q (28697 . 3)) ((c def c (c (? . 0) q struct:exn)) c (? . 47)) ((c def c (c (? . 8) q filter-map)) q (103544 . 4)) ((c def c (c (? . 14) q place-kill)) q (281482 . 3)) ((c def c (c (? . 1) q unsafe-extflfloor)) q (512882 . 3)) ((c form c (c (? . 55) q path-up)) q (10585 . 2)) ((c def c (c (? . 25) q pretty-print-exact-as-decimal)) q (370668 . 4)) ((c def c (c (? . 8) q group-by)) q (105022 . 5)) ((c form c (c (? . 31) q reset0)) q (266773 . 2)) ((c def c (c (? . 0) q stencil-vector-set!)) q (113132 . 5)) ((c def c (c (? . 24) q struct:export)) c (? . 68)) ((c def c (c (? . 38) q is-a?/c)) q (188108 . 3)) ((c def c (c (? . 0) q hash-iterate-next)) q (121607 . 5)) ((c def c (c (? . 0) q regexp-max-lookbehind)) q (75306 . 3)) ((c form c (c (? . 6) q for/fold/derived)) q (17787 . 4)) ((c form c (c (? . 6) q #%top-interaction)) q (19372 . 2)) ((c def c (c (? . 0) q unquoted-printing-string)) q (254143 . 3)) ((c def c (c (? . 1) q unsafe-fl>)) q (493799 . 4)) ((c def c (c (? . 6) q hash-set*!)) q (117914 . 5)) ((c def c (c (? . 0) q raise-arguments-error)) q (248648 . 10)) ((c def c (c (? . 13) q set-remove)) q (151796 . 4)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-value)) q (507914 . 4)) ((c def c (c (? . 6) q namespace-anchor->empty-namespace)) q (380381 . 3)) ((c def c (c (? . 19) q struct:collapsible-property)) c (? . 113)) ((c def c (c (? . 6) q syntax-recertify)) q (292082 . 9)) ((c form c (c (? . 6) q except-in)) q (4641 . 2)) ((c form c (c (? . 9) q inherit/inner)) q (178328 . 2)) ((c def c (c (? . 0) q logger?)) q (477177 . 3)) ((c def c (c (? . 21) q hash->linklet-directory)) q (432503 . 3)) ((c def c (c (? . 1) q unsafe-fxior)) q (491679 . 3)) ((c def c (c (? . 5) q curry)) q (163229 . 6)) ((c def c (c (? . 2) q dict-set*)) q (139670 . 5)) ((c def c (c (? . 16) q extflexp)) q (43273 . 3)) ((c form c (c (? . 9) q pubment)) q (177879 . 2)) ((c form c (c (? . 38) q object/c)) q (185093 . 11)) ((c def c (c (? . 0) q port-waiting-peer?)) q (320710 . 3)) ((c form c (c (? . 32) q define-generics)) q (169365 . 22)) ((c def c (c (? . 0) q syntax-local-expand-expression)) q (298763 . 6)) ((c def c (c (? . 7) q stream-empty?)) q (135092 . 3)) ((c def c (c (? . 0) q compile-syntax)) q (390396 . 3)) ((c def c (c (? . 39) q current-trace-notify)) q (520740 . 4)) ((c def c (c (? . 19) q collapsible-ho/c)) c (? . 94)) ((c def c (c (? . 0) q integer-bytes->integer)) q (30378 . 11)) ((c form c (c (? . 6) q for*/list)) q (16651 . 2)) ((c def c (c (? . 42) q remq)) q (93812 . 4)) ((c def c (c (? . 0) q exn:fail:read:non-char?)) c (? . 58)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-first)) q (505168 . 3)) ((c def c (c (? . 2) q dict-map/copy)) q (140722 . 4)) ((c def c (c (? . 6) q make-exn:fail:network)) c (? . 83)) ((c def c (c (? . 26) q evt/c)) q (205788 . 3)) ((c def c (c (? . 6) q for-clause-syntax-protect)) q (18886 . 3)) ((c def c (c (? . 16) q extflmax)) q (42501 . 4)) ((c form c (c (? . 90) q define-opt/c)) q (237510 . 2)) ((c form c (c (? . 6) q for)) q (14464 . 18)) ((c form c (c (? . 65) q delay/idle)) q (262627 . 8)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-key+value)) q (508300 . 5)) ((c def c (c (? . 0) q custodian?)) q (413727 . 3)) ((c def c (c (? . 0) q stencil-vector?)) q (112466 . 3)) ((c def c (c (? . 44) q flrandom)) q (36104 . 3)) ((c form c (c (? . 31) q prompt-at)) q (266479 . 2)) ((c def c (c (? . 6) q make-keyword-procedure)) q (160142 . 5)) ((c form c (c (? . 9) q instantiate)) q (180545 . 2)) ((c form c (c (? . 6) q only-meta-in)) q (4877 . 2)) ((c def c (c (? . 13) q set-union)) q (152678 . 4)) ((c form c (c (? . 40) q with-collapsible-contract-continuation-mark)) q (238739 . 2)) ((c def c (c (? . 25) q pretty-print)) q (369362 . 9)) ((c def c (c (? . 1) q unsafe-char>?)) q (496172 . 4)) ((c def c (c (? . 0) q srcloc-position)) c (? . 59)) ((c def c (c (? . 0) q >)) q (25021 . 4)) ((c def c (c (? . 0) q custom-write?)) q (375134 . 3)) ((c def c (c (? . 0) q prop:authentic)) q (405632 . 2)) ((c form c (c (? . 41) q define-unit/s)) q (196760 . 6)) ((c def c (c (? . 42) q memf)) q (95233 . 4)) ((c def c (c (? . 15) q peek-string!-evt)) c (? . 117)) ((c def c (c (? . 31) q new-prompt)) q (267306 . 2)) ((c def c (c (? . 0) q hash-iterate-key)) q (121751 . 4)) ((c def c (c (? . 0) q open-output-bytes)) q (328580 . 3)) ((c def c (c (? . 43) q string-environment-variable-name?)) q (485910 . 3)) ((c def c (c (? . 17) q make-handle-get-preference-locked)) q (457496 . 16)) ((c def c (c (? . 3) q prop:require-transformer)) q (308351 . 2)) ((c def c (c (? . 44) q flvector-length)) q (36452 . 3)) ((c def c (c (? . 0) q arity-at-least-value)) c (? . 45)) ((c def c (c (? . 0) q byte-pregexp)) q (74903 . 6)) ((c def c (c (? . 44) q shared-flvector)) q (37539 . 3)) ((c def c (c (? . 1) q unsafe-extfl+)) q (511758 . 4)) ((c def c (c (? . 0) q chaperone-struct)) q (406414 . 18)) ((c def c (c (? . 0) q module-compiled-indirect-exports)) q (396411 . 4)) ((c def c (c (? . 0) q prop:equal+hash)) q (21145 . 2)) ((c def c (c (? . 38) q subclass?/c)) q (188284 . 3)) ((c def c (c (? . 12) q put-input)) q (427004 . 6)) ((c def c (c (? . 43) q find-executable-path)) q (443930 . 7)) ((c def c (c (? . 10) q vector-member)) q (110922 . 4)) ((c def c (c (? . 0) q bytes-append)) q (64970 . 3)) ((c def c (c (? . 13) q set/c)) q (150884 . 14)) ((c def c (c (? . 15) q eof-evt)) q (346792 . 3)) ((c form c (c (? . 96) q lazy-require-syntax)) q (19961 . 5)) ((c def c (c (? . 8) q combinations)) q (104361 . 6)) ((c def c (c (? . 16) q extflvector?)) q (43967 . 3)) ((c def c (c (? . 0) q primitive-result-arity)) q (162689 . 3)) ((c form c (c (? . 46) q define-serializable-struct)) q (377017 . 3)) ((c def c (c (? . 1) q unsafe-extflmax)) q (512720 . 4)) ((c form c (c (? . 67) q define-runtime-path)) q (448358 . 5)) ((c def c (c (? . 0) q port-try-file-lock?)) q (327950 . 4)) ((c def c (c (? . 16) q extflonum-available?)) q (41569 . 2)) ((c def c (c (? . 0) q placeholder-set!)) q (105613 . 4)) ((c def c (c (? . 0) q eqv?)) q (20261 . 4)) ((c def c (c (? . 6) q make-exn)) c (? . 47)) ((c def c (c (? . 0) q handle-evt?)) q (274042 . 3)) ((c def c (c (? . 24) q pre-expand-export)) q (309837 . 4)) ((c def c (c (? . 0) q log-all-levels)) q (478731 . 5)) ((c def c (c (? . 13) q in-weak-set)) q (150583 . 3)) ((c def c (c (? . 0) q thread/suspend-to-kill)) q (271307 . 3)) ((c def c (c (? . 1) q unsafe-fx<=)) q (492942 . 4)) ((c form c (c (? . 27) q when)) q (14326 . 2)) ((c def c (c (? . 110) q gethostname)) q (489473 . 2)) ((c def c (c (? . 0) q exact-integer?)) q (22024 . 3)) ((c def c (c (? . 26) q procedure-arity-includes/c)) q (204747 . 3)) ((c def c (c (? . 0) q make-derived-parameter)) q (278548 . 7)) ((c form c (c (? . 48) q ==)) q (245986 . 3)) ((c def c (c (? . 20) q tcp-listen)) q (460125 . 9)) ((c form c (c (? . 9) q private)) q (178195 . 2)) ((c form c (c (? . 9) q public*)) q (178443 . 2)) ((c def c (c (? . 0) q srcloc->string)) q (260856 . 3)) ((c def c (c (? . 0) q set!-transformer?)) q (297604 . 3)) ((c def c (c (? . 6) q member)) q (94747 . 5)) ((c def c (c (? . 0) q syntax-local-value)) q (303605 . 9)) ((c def c (c (? . 37) q udp-send/enable-break)) q (464838 . 9)) ((c def c (c (? . 0) q truncate)) q (24488 . 3)) ((c def c (c (? . 0) q prop:rename-transformer)) q (298212 . 2)) ((c def c (c (? . 13) q set-equal-always?)) q (146419 . 3)) ((c def c (c (? . 12) q sandbox-eval-handlers)) q (424855 . 7)) ((c def c (c (? . 6) q collection-path)) q (517869 . 8)) ((c def c (c (? . 12) q make-module-evaluator)) c (? . 50)) ((c def c (c (? . 0) q peek-byte-or-special)) q (357034 . 12)) ((c form c (c (? . 49) q syntax)) q (284574 . 22)) ((c def c (c (? . 0) q thread-cell-set!)) q (277844 . 4)) ((c def c (c (? . 1) q unsafe-extflexp)) q (513576 . 3)) ((c def c (c (? . 44) q flabs)) q (33963 . 3)) ((c def c (c (? . 15) q read-line-evt)) q (347427 . 5)) ((c def c (c (? . 38) q make-mixin-contract)) q (188010 . 3)) ((c def c (c (? . 0) q syntax-local-phase-level)) q (305356 . 2)) ((c def c (c (? . 12) q make-evaluator)) c (? . 50)) ((c def c (c (? . 43) q load-relative-extension)) q (387893 . 3)) ((c def c (c (? . 22) q sequence/c)) q (134667 . 5)) ((c def c (c (? . 8) q drop)) q (100453 . 4)) ((c def c (c (? . 0) q tan)) q (25665 . 3)) ((c def c (c (? . 12) q set-eval-limits)) q (426502 . 5)) ((c def c (c (? . 18) q ~.s)) q (62266 . 25)) ((c form c (c (? . 9) q override-final)) q (178034 . 2)) ((c def c (c (? . 8) q last)) q (99240 . 3)) ((c def c (c (? . 0) q string-locale>?)) q (50078 . 4)) ((c form c (c (? . 48) q define-match-expander)) q (245283 . 3)) ((c form c (c (? . 6) q for*/foldr)) q (17647 . 4)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-next)) q (509266 . 5)) ((c def c (c (? . 0) q <=)) q (24949 . 4)) ((c def c (c (? . 0) q char=?)) q (70984 . 4)) ((c def c (c (? . 134) q bytes-join)) q (70499 . 4)) ((c def c (c (? . 2) q dict-for-each)) q (140850 . 4)) ((c def c (c (? . 51) q path-has-extension?)) q (441994 . 4)) ((c def c (c (? . 0) q local-transformer-expand/capture-lifts)) q (300118 . 13)) ((c def c (c (? . 0) q string-append-immutable)) q (47942 . 3)) ((c def c (c (? . 0) q eq?)) q (20334 . 4)) ((c def c (c (? . 12) q sandbox-exit-handler)) q (424204 . 4)) ((c def c (c (? . 0) q write-bytes-avail*)) q (359585 . 10)) ((c def c (c (? . 1) q unsafe-make-srcloc)) q (511316 . 11)) ((c def c (c (? . 0) q collect-garbage)) q (490499 . 3)) ((c def c (c (? . 12) q get-output)) c (? . 77)) ((c def c (c (? . 13) q weak-seteq)) q (147817 . 3)) ((c form c (c (? . 9) q send-generic)) q (182229 . 3)) ((c def c (c (? . 0) q namespace-attach-module)) q (383062 . 7)) ((c def c (c (? . 0) q exn:fail:syntax:missing-module?)) c (? . 52)) ((c def c (c (? . 0) q module-compiled-imports)) q (395868 . 5)) ((c def c (c (? . 0) q bytes-copy!)) q (64436 . 11)) ((c def c (c (? . 0) q quotient)) q (23530 . 4)) ((c def c (c (? . 13) q set-add)) q (151632 . 4)) ((c def c (c (? . 0) q string-locale-upcase)) q (50491 . 3)) ((c form c (c (? . 9) q augment-final*)) q (178736 . 2)) ((c def c (c (? . 0) q current-inexact-milliseconds)) q (480858 . 2)) ((c def c (c (? . 0) q mcdr)) q (106398 . 3)) ((c def c (c (? . 57) q contract-random-generate-stash)) q (243440 . 5)) ((c def c (c (? . 0) q make-thread-cell)) q (277663 . 4)) ((c def c (c (? . 0) q namespace-module-registry)) q (383991 . 3)) ((c def c (c (? . 0) q struct-predicate-procedure?)) q (172495 . 3)) ((c def c (c (? . 0) q procedure-arity-includes?)) q (159077 . 5)) ((c def c (c (? . 11) q fxmodulo)) q (38076 . 4)) ((c def c (c (? . 1) q unsafe-struct*-ref)) q (502606 . 4)) ((c def c (c (? . 0) q exact-nonnegative-integer?)) q (22084 . 3)) ((c form c (c (? . 53) q invariant-assertion)) q (215535 . 2)) ((c def c (c (? . 0) q custodian-box?)) q (414996 . 3)) ((c form c (c (? . 23) q ->i)) q (207611 . 60)) ((c form c (c (? . 6) q prefix-out)) q (6647 . 2)) ((c def c (c (? . 0) q syntax->datum)) q (288625 . 3)) ((c def c (c (? . 6) q date)) c (? . 60)) ((c def c (c (? . 6) q random)) q (27154 . 13)) ((c def c (c (? . 0) q variable-reference->namespace)) q (385112 . 3)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-pair)) q (508762 . 4)) ((c def c (c (? . 1) q unsafe-stencil-vector-set!)) q (501830 . 5)) ((c form c (c (? . 54) q splicing-let-syntaxes)) q (312569 . 2)) ((c def c (c (? . 42) q assv)) q (95713 . 4)) ((c def c (c (? . 0) q bytes->list)) q (65038 . 3)) ((c def c (c (? . 0) q hash-set)) q (118055 . 5)) ((c def c (c (? . 0) q continuation-mark-key?)) q (269949 . 3)) ((c form c (c (? . 55) q multi-in)) q (10619 . 8)) ((c def c (c (? . 16) q ->extfl)) q (43482 . 3)) ((c def c (c (? . 0) q write-bytes-avail/enable-break)) q (359969 . 10)) ((c def c (c (? . 9) q object->vector)) q (189231 . 4)) ((c def c (c (? . 9) q make-object)) q (180396 . 4)) ((c def c (c (? . 1) q unsafe-make-flrectangular)) q (495150 . 7)) ((c def c (c (? . 0) q thread-cell-ref)) q (277775 . 3)) ((c form c (c (? . 9) q define-local-member-name)) q (179948 . 2)) ((c def c (c (? . 0) q fprintf)) q (366063 . 5)) ((c def c (c (? . 6) q in-immutable-hash-pairs)) q (128842 . 3)) ((c form c (c (? . 56) q for*/async)) q (279712 . 2)) ((c def c (c (? . 1) q unsafe-flasin)) q (494711 . 3)) ((c def c (c (? . 0) q acos)) q (25766 . 3)) ((c def c (c (? . 44) q ->fl)) q (35380 . 3)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-key)) q (509456 . 5)) ((c def c (c (? . 0) q syntax-position)) q (288066 . 3)) ((c def c (c (? . 57) q contract-random-generate)) q (242617 . 5)) ((c def c (c (? . 6) q chaperone-procedure*)) q (406044 . 11)) ((c def c (c (? . 0) q build-path/convention-type)) q (438820 . 9)) ((c def c (c (? . 0) q port-read-handler)) q (364906 . 10)) ((c def c (c (? . 4) q bytes-no-nuls?)) q (477117 . 3)) ((c form c (c (? . 9) q class*)) q (174874 . 59)) ((c def c (c (? . 0) q syntax-line)) q (287881 . 3)) ((c def c (c (? . 29) q string-append*)) q (51067 . 4)) ((c def c (c (? . 0) q make-immutable-hasheq)) q (117643 . 4)) ((c def c (c (? . 1) q unsafe-assert-unreachable)) q (515881 . 2)) ((c def c (c (? . 0) q struct:exn:fail:read:non-char)) c (? . 58)) ((c def c (c (? . 0) q file-truncate)) q (321462 . 4)) ((c def c (c (? . 17) q socket-type-bits)) q (459305 . 2)) ((c form c (c (? . 6) q #%plain-lambda)) q (11811 . 2)) ((c form c (c (? . 0) q module)) q (1651 . 2)) ((c form c (c (? . 6) q for*/fold/derived)) q (17920 . 4)) ((c def c (c (? . 0) q read-bytes)) q (350283 . 4)) ((c def c (c (? . 0) q syntax-local-lift-provide)) q (305105 . 3)) ((c form c (c (? . 41) q except)) q (193640 . 2)) ((c def c (c (? . 0) q struct:srcloc)) c (? . 59)) ((c def c (c (? . 1) q unsafe-flround)) q (494223 . 3)) ((c def c (c (? . 0) q pregexp)) q (74572 . 6)) ((c def c (c (? . 2) q dict-values)) q (141337 . 3)) ((c def c (c (? . 8) q takef)) q (100654 . 4)) ((c def c (c (? . 0) q *)) q (23364 . 3)) ((c def c (c (? . 76) q record-disappeared-uses)) q (318173 . 4)) ((c def c (c (? . 15) q transplant-output-port)) q (344332 . 19)) ((c def c (c (? . 9) q class?)) q (188818 . 3)) ((c def c (c (? . 12) q sandbox-make-inspector)) q (425319 . 4)) ((c def c (c (? . 0) q box-cas!)) q (114223 . 5)) ((c def c (c (? . 1) q unsafe-fx+/wraparound)) q (492329 . 4)) ((c def c (c (? . 0) q hash-keys-subset?)) q (121110 . 4)) ((c def c (c (? . 102) q symbol=?)) q (21401 . 4)) ((c def c (c (? . 11) q fxpopcount32)) q (38665 . 3)) ((c form c (c (? . 9) q inner)) q (179852 . 3)) ((c form c (c (? . 39) q trace-let)) q (520658 . 2)) ((c def c (c (? . 0) q /)) q (23417 . 6)) ((c def c (c (? . 0) q date-week-day)) c (? . 60)) ((c def c (c (? . 0) q numerator)) q (24574 . 3)) ((c form c (c (? . 6) q for*/foldr/derived)) q (18193 . 4)) ((c def c (c (? . 6) q exn:fail:contract:divide-by-zero)) c (? . 118)) ((c def c (c (? . 0) q caaaar)) q (96957 . 3)) ((c def c (c (? . 6) q in-naturals)) q (124846 . 3)) ((c form c (c (? . 41) q define-unit/contract)) q (197926 . 15)) ((c def c (c (? . 8) q fifth)) q (98937 . 3)) ((c def c (c (? . 0) q make-polar)) q (26006 . 4)) ((c def c (c (? . 0) q custodian-limit-memory)) q (414622 . 7)) ((c def c (c (? . 135) q syntax-procedure-converted-arguments-property)) q (311513 . 8)) ((c form c (c (? . 6) q define-sequence-syntax)) q (18333 . 8)) ((c def c (c (? . 61) q chaperone-contract-property?)) q (235156 . 3)) ((c def c (c (? . 6) q exn:fail:filesystem:missing-module)) c (? . 79)) ((c def c (c (? . 62) q random-sample)) q (28944 . 10)) ((c def c (c (? . 6) q make-date*)) c (? . 63)) ((c def c (c (? . 99) q parse-command-line)) q (488751 . 15)) ((c def c (c (? . 0) q byte-regexp)) q (74731 . 6)) ((c def c (c (? . 42) q assq)) q (95820 . 4)) ((c def c (c (? . 6) q procedure-reduce-arity-mask)) q (159560 . 9)) ((c def c (c (? . 0) q make-hasheqv-placeholder)) q (106032 . 3)) ((c def c (c (? . 0) q procedure-result-arity)) q (160043 . 3)) ((c def c (c (? . 0) q exn:fail:contract:non-fixnum-result?)) c (? . 97)) ((c def c (c (? . 0) q exn:fail:network:errno?)) c (? . 95)) ((c def c (c (? . 17) q fold-files)) q (453278 . 12)) ((c def c (c (? . 0) q sub1)) q (23916 . 3)) ((c def c (c (? . 0) q unbox)) q (113858 . 3)) ((c form c (c (? . 64) q quasisyntax)) q (285634 . 2)) ((c def c (c (? . 8) q remf*)) q (105347 . 4)) ((c def c (c (? . 2) q keyword-apply/dict)) q (145979 . 11)) ((c def c (c (? . 48) q exn:misc:match?)) q (245200 . 3)) ((c def c (c (? . 2) q dict->list)) q (141397 . 3)) ((c def c (c (? . 0) q date-second)) c (? . 60)) ((c def c (c (? . 0) q symbol->string)) q (73630 . 3)) ((c def c (c (? . 0) q port-writes-atomic?)) q (361127 . 3)) ((c def c (c (? . 0) q hash-ref)) q (118348 . 7)) ((c def c (c (? . 13) q set-first)) q (152113 . 3)) ((c def c (c (? . 57) q contract-random-generate-fail?)) q (243289 . 3)) ((c def c (c (? . 0) q internal-definition-context-introduce)) q (302820 . 7)) ((c def c (c (? . 2) q dict-value-contract)) q (141829 . 3)) ((c def c (c (? . 0) q fixnum?)) q (22284 . 3)) ((c def c (c (? . 13) q set->stream)) q (152301 . 3)) ((c def c (c (? . 66) q struct:exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 0) q cons)) q (92091 . 4)) ((c def c (c (? . 31) q fcontrol)) q (266297 . 4)) ((c def c (c (? . 10) q vector-take)) q (109547 . 4)) ((c def c (c (? . 37) q udp-multicast-interface)) q (469213 . 3)) ((c def c (c (? . 1) q unsafe-extfltruncate)) q (513024 . 3)) ((c form c (c (? . 30) q set!-values)) q (14426 . 2)) ((c def c (c (? . 42) q compose)) q (157832 . 3)) ((c def c (c (? . 4) q process/ports)) q (475337 . 11)) ((c def c (c (? . 6) q exn:fail:filesystem:version)) c (? . 86)) ((c def c (c (? . 0) q find-compiled-file-roots)) q (389186 . 2)) ((c def c (c (? . 0) q regexp-match)) q (75427 . 17)) ((c def c (c (? . 2) q dict-update!)) q (139930 . 10)) ((c form c (c (? . 0) q begin0)) q (14261 . 2)) ((c def c (c (? . 37) q udp-close)) q (466678 . 3)) ((c def c (c (? . 43) q rationalize)) q (24714 . 4)) ((c def c (c (? . 0) q custodian-shutdown-all)) q (413931 . 3)) ((c form c (c (? . 55) q subtract-in)) q (10482 . 2)) ((c def c (c (? . 65) q promise-forced?)) q (262196 . 3)) ((c def c (c (? . 0) q current-milliseconds)) q (481948 . 2)) ((c def c (c (? . 12) q get-user-custodian)) q (426410 . 3)) ((c def c (c (? . 0) q module->indirect-exports)) q (398562 . 5)) ((c def c (c (? . 48) q syntax-local-match-introduce)) q (245619 . 3)) ((c def c (c (? . 66) q blame-negative)) q (224334 . 3)) ((c def c (c (? . 1) q unsafe-flvector-ref)) q (500369 . 4)) ((c def c (c (? . 30) q call-with-parameterization)) q (279009 . 5)) ((c def c (c (? . 37) q udp-multicast-loopback?)) q (469635 . 3)) ((c def c (c (? . 17) q make-lock-file-name)) q (459038 . 6)) ((c def c (c (? . 17) q delete-directory/files)) q (452193 . 5)) ((c def c (c (? . 1) q unsafe-flsin)) q (494534 . 3)) ((c form c (c (? . 6) q for/list)) q (15008 . 2)) ((c form c (c (? . 41) q init-depend)) q (193900 . 2)) ((c form c (c (? . 31) q control0)) q (266801 . 2)) ((c def c (c (? . 0) q raise-argument-error*)) q (247284 . 16)) ((c def c (c (? . 0) q struct:exn:fail:out-of-memory)) c (? . 87)) ((c def c (c (? . 4) q process)) q (474344 . 9)) ((c form c (c (? . 48) q match*)) q (243835 . 6)) ((c def c (c (? . 4) q process*)) q (474720 . 15)) ((c def c (c (? . 1) q unsafe-extfl/)) q (512028 . 4)) ((c def c (c (? . 8) q third)) q (98836 . 3)) ((c def c (c (? . 0) q vector-fill!)) q (108143 . 4)) ((c def c (c (? . 0) q sync/enable-break)) q (272966 . 3)) ((c def c (c (? . 15) q with-output-to-bytes)) q (336238 . 3)) ((c def c (c (? . 15) q peeking-input-port)) q (340521 . 10)) ((c def c (c (? . 15) q with-input-from-bytes)) q (336640 . 4)) ((c def c (c (? . 1) q unsafe-struct*-cas!)) q (502828 . 6)) ((c form c (c (? . 6) q require)) q (2182 . 56)) ((c form c (c (? . 48) q match-let*-values)) q (244926 . 2)) ((c def c (c (? . 0) q string-normalize-nfkd)) q (49642 . 3)) ((c def c (c (? . 56) q would-be-future)) q (279519 . 3)) ((c form c (c (? . 34) q trait)) q (182560 . 18)) ((c form c (c (? . 6) q rename-in)) q (4727 . 2)) ((c def c (c (? . 0) q prop:object-name)) q (416936 . 2)) ((c def c (c (? . 44) q flsqrt)) q (35253 . 3)) ((c def c (c (? . 1) q unsafe-mcar)) q (496594 . 3)) ((c def c (c (? . 0) q local-expand/capture-lifts)) q (299487 . 13)) ((c def c (c (? . 0) q read)) q (361280 . 3)) ((q def ((lib "racket/private/stx.rkt") identifier?)) q (287762 . 3)) ((c def c (c (? . 0) q char-general-category)) q (72739 . 3)) ((c form c (c (? . 6) q except-out)) q (6594 . 2)) ((c def c (c (? . 13) q list->weak-set)) q (148720 . 4)) ((c def c (c (? . 0) q current-thread)) q (271267 . 2)) ((c def c (c (? . 0) q impersonate-vector)) q (401023 . 15)) ((c def c (c (? . 66) q blame-missing-party?)) q (225005 . 3)) ((c def c (c (? . 24) q provide-pre-transformer?)) q (310739 . 3)) ((c def c (c (? . 25) q pretty-print-.-symbol-without-bars)) q (370806 . 4)) ((q form ((lib "racket/shared.rkt") shared)) q (12711 . 2)) ((c def c (c (? . 0) q string-normalize-nfkc)) q (49797 . 3)) ((c form c (c (? . 54) q splicing-syntax-parameterize)) q (312720 . 2)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-pair)) q (504728 . 4)) ((c form c (c (? . 32) q generic-instance/c)) q (170365 . 4)) ((c def c (c (? . 0) q date-year)) c (? . 60)) ((c def c (c (? . 15) q input-port-append)) q (336738 . 7)) ((c def c (c (? . 0) q input-port?)) q (319825 . 3)) ((c def c (c (? . 0) q cddar)) q (96793 . 3)) ((c def c (c (? . 1) q unsafe-unbox)) q (497385 . 3)) ((c def c (c (? . 3) q import-src-mod-path)) c (? . 28)) ((c def c (c (? . 0) q bytes=?)) q (65348 . 4)) ((c def c (c (? . 17) q find-files)) q (452392 . 11)) ((c def c (c (? . 0) q file-or-directory-modify-seconds)) q (444825 . 16)) ((c def c (c (? . 0) q cddddr)) q (98457 . 3)) ((c def c (c (? . 0) q cleanse-path)) q (439997 . 3)) ((c def c (c (? . 0) q make-hash)) q (115420 . 4)) ((c def c (c (? . 0) q subprocess)) q (469903 . 37)) ((c def c (c (? . 44) q flround)) q (34558 . 3)) ((c def c (c (? . 30) q hash-has-key?)) q (118941 . 4)) ((c def c (c (? . 61) q prop:flat-contract)) q (225679 . 2)) ((c def c (c (? . 0) q custom-write-accessor)) q (375193 . 4)) ((c form c (c (? . 6) q only-space-in)) q (4931 . 2)) ((c def c (c (? . 0) q current-library-collection-paths)) q (518169 . 5)) ((c def c (c (? . 0) q chaperone-vector*)) q (407746 . 14)) ((c def c (c (? . 0) q void?)) q (163905 . 3)) ((c form c (c (? . 67) q define-runtime-path-list)) q (448558 . 2)) ((c def c (c (? . 0) q use-compiled-file-paths)) q (388821 . 5)) ((c def c (c (? . 8) q list-prefix?)) q (101500 . 5)) ((c def c (c (? . 11) q fx-/wraparound)) q (38937 . 4)) ((c def c (c (? . 24) q export-mode)) c (? . 68)) ((c def c (c (? . 6) q in-ephemeron-hash-keys)) q (130184 . 3)) ((c form c (c (? . 54) q splicing-letrec-values)) q (312482 . 2)) ((c def c (c (? . 0) q bitwise-not)) q (26576 . 3)) ((c def c (c (? . 0) q make-syntax-delta-introducer)) q (306985 . 9)) ((c def c (c (? . 40) q contract-first-order-passes?)) q (235775 . 4)) ((c def c (c (? . 20) q tcp-abandon-port)) q (461696 . 3)) ((c def c (c (? . 0) q module-path-index-split)) q (394251 . 5)) ((c def c (c (? . 0) q current-load-relative-directory)) q (388607 . 5)) ((c def c (c (? . 40) q coerce-contracts)) q (222269 . 4)) ((c def c (c (? . 141) q syntax-local-provide-introduce)) q (14134 . 3)) ((c def c (c (? . 9) q object-method-arity-includes?)) q (190047 . 7)) ((c form c (c (? . 40) q define/final-prop)) q (235299 . 6)) ((c def c (c (? . 3) q import-source-mod-path-stx)) c (? . 33)) ((c def c (c (? . 0) q cdr)) q (92203 . 3)) ((c def c (c (? . 0) q make-vector)) q (106643 . 4)) ((c form c (c (? . 41) q define-unit-binding)) q (195680 . 6)) ((c def c (c (? . 6) q in-parallel)) q (131576 . 3)) ((c def c (c (? . 13) q make-custom-set-types)) q (156519 . 25)) ((c form c (c (? . 48) q match-letrec)) q (244992 . 2)) ((c def c (c (? . 0) q impersonate-hash)) q (402642 . 22)) ((c form c (c (? . 6) q for-template)) q (7090 . 2)) ((c def c (c (? . 0) q read-bytes-avail!*)) q (351376 . 10)) ((c def c (c (? . 37) q udp-multicast-leave-group!)) q (468948 . 7)) ((c def c (c (? . 1) q unsafe-stencil-vector-length)) q (501571 . 4)) ((c def c (c (? . 0) q print-mpair-curly-braces)) q (366531 . 4)) ((c def c (c (? . 7) q stream?)) q (135039 . 3)) ((c def c (c (? . 26) q none/c)) q (199963 . 2)) ((c def c (c (? . 1) q unsafe-string-set!)) q (498985 . 5)) ((c def c (c (? . 0) q char-utf-8-length)) q (70905 . 3)) ((c def c (c (? . 0) q prop:evt)) q (274102 . 2)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-value)) q (503727 . 5)) ((c def c (c (? . 37) q udp-open-socket)) q (462195 . 5)) ((c def c (c (? . 43) q path-replace-suffix)) q (441233 . 4)) ((c def c (c (? . 0) q syntax-local-lift-context)) q (304643 . 2)) ((c def c (c (? . 6) q in-hash-keys)) q (126584 . 6)) ((c def c (c (? . 0) q current-input-port)) q (320256 . 4)) ((c def c (c (? . 0) q semaphore-post)) q (274922 . 3)) ((c form c (c (? . 41) q unit/new-import-export)) q (196262 . 6)) ((c def c (c (? . 0) q equal?/recur)) q (20406 . 5)) ((c def c (c (? . 7) q stream-take)) q (136131 . 4)) ((c def c (c (? . 13) q set-weak?)) q (146697 . 3)) ((c def c (c (? . 0) q exn:break?)) c (? . 69)) ((c def c (c (? . 18) q ~.a)) q (59774 . 25)) ((c form c (c (? . 9) q overment)) q (177996 . 2)) ((c def c (c (? . 6) q in-mutable-hash-pairs)) q (127880 . 3)) ((c def c (c (? . 0) q exit-handler)) q (270803 . 4)) ((c def c (c (? . 0) q call-with-semaphore/enable-break)) q (275690 . 9)) ((c def c (c (? . 44) q in-flvector)) q (36970 . 6)) ((c def c (c (? . 0) q char-ready?)) q (358077 . 3)) ((c def c (c (? . 9) q subclass?)) q (189590 . 4)) ((c def c (c (? . 6) q double-flonum?)) q (22390 . 3)) ((c def c (c (? . 66) q exn:fail:contract:blame?)) c (? . 70)) ((c def c (c (? . 0) q struct-mutator-procedure?)) q (172640 . 3)) ((c def c (c (? . 37) q udp-multicast-ttl)) q (469826 . 3)) ((c def c (c (? . 6) q in-value)) q (131316 . 3)) ((c def c (c (? . 0) q string-copy!)) q (47323 . 11)) ((c def c (c (? . 9) q object%)) q (174849 . 2)) ((c def c (c (? . 0) q terminal-port?)) q (320650 . 3)) ((c def c (c (? . 37) q udp-receive!)) q (465196 . 11)) ((c def c (c (? . 0) q string=?)) q (48325 . 4)) ((c def c (c (? . 1) q unsafe-unbox*)) q (497519 . 3)) ((c def c (c (? . 0) q exn:break:hang-up?)) c (? . 71)) ((c def c (c (? . 0) q string-length)) q (46745 . 3)) ((c def c (c (? . 6) q make-exn:fail)) c (? . 74)) ((c form c (c (? . 31) q cupto)) q (267376 . 2)) ((c def c (c (? . 37) q udp-send*)) q (464077 . 6)) ((c def c (c (? . 20) q tcp-close)) q (461485 . 3)) ((c def c (c (? . 3) q make-import-source)) c (? . 33)) ((c def c (c (? . 1) q unsafe-extfl<)) q (512274 . 4)) ((c def c (c (? . 13) q in-mutable-set)) q (150513 . 3)) ((c form c (c (? . 27) q let/ec)) q (264964 . 2)) ((c def c (c (? . 75) q engine?)) q (282599 . 3)) ((c def c (c (? . 17) q set-user-id-bit)) q (459587 . 2)) ((c def c (c (? . 11) q fxabs)) q (38152 . 3)) ((c form c (c (? . 13) q for*/mutable-seteq)) q (149826 . 2)) ((c form c (c (? . 13) q for/mutable-setalw)) q (149710 . 2)) ((c def c (c (? . 0) q read-accept-graph)) q (363343 . 4)) ((c def c (c (? . 0) q syntax-local-lift-values-expression)) q (304502 . 5)) ((c form c (c (? . 128) q parametric->/c)) q (212643 . 2)) ((c def c (c (? . 0) q impersonator-property?)) q (412646 . 3)) ((c def c (c (? . 72) q async-channel-get)) q (276243 . 3)) ((c def c (c (? . 72) q async-channel-try-get)) q (276316 . 3)) ((c def c (c (? . 12) q sandbox-memory-limit)) q (424343 . 4)) ((c def c (c (? . 0) q hashalw)) q (115011 . 5)) ((c form c (c (? . 9) q define/pubment)) q (178890 . 3)) ((c def c (c (? . 6) q impersonate-procedure)) q (399508 . 11)) ((c def c (c (? . 98) q vectorof)) q (201267 . 9)) ((c def c (c (? . 6) q make-exn:break:hang-up)) c (? . 71)) ((c def c (c (? . 0) q print-as-expression)) q (367419 . 4)) ((c def c (c (? . 37) q udp-ttl)) q (468619 . 3)) ((c form c (c (? . 41) q define-signature-form)) q (196896 . 4)) ((c def c (c (? . 2) q dict-ref!)) q (139822 . 5)) ((c form c (c (? . 41) q define-values-for-export)) q (193515 . 2)) ((c def c (c (? . 37) q udp-bound?)) q (466797 . 3)) ((c form c (c (? . 9) q define-member-name)) q (179991 . 2)) ((c def c (c (? . 43) q channel-get)) q (274418 . 3)) ((c def c (c (? . 17) q pathlist-closure)) q (452942 . 8)) ((c def c (c (? . 0) q current-module-path-for-load)) q (393443 . 11)) ((c def c (c (? . 0) q syntax-local-lift-module)) q (304692 . 3)) ((c def c (c (? . 72) q impersonate-async-channel)) q (276646 . 13)) ((c def c (c (? . 5) q curryr)) q (163365 . 6)) ((c def c (c (? . 0) q write-bytes-avail-evt)) q (360630 . 9)) ((c def c (c (? . 13) q set)) q (146752 . 3)) ((c def c (c (? . 0) q symbol<?)) q (73998 . 4)) ((c def c (c (? . 40) q coerce-contract/f)) q (222822 . 3)) ((c def c (c (? . 0) q equal-always?)) q (20179 . 4)) ((c def c (c (? . 31) q abort)) q (266164 . 3)) ((c def c (c (? . 0) q print-pair-curly-braces)) q (366421 . 4)) ((c def c (c (? . 0) q exp)) q (25429 . 3)) ((c def c (c (? . 0) q explode-path)) q (440707 . 4)) ((c def c (c (? . 25) q make-tentative-pretty-print-output-port)) q (373530 . 8)) ((c def c (c (? . 8) q indexes-of)) q (100045 . 6)) ((c def c (c (? . 0) q variable-reference->resolved-module-path)) q (385213 . 4)) ((c def c (c (? . 116) q andmap)) q (93124 . 4)) ((c def c (c (? . 10) q vector-sort)) q (111230 . 13)) ((c form c (c (? . 9) q class-field-accessor)) q (182080 . 2)) ((c def c (c (? . 73) q struct-auto-info?)) q (174131 . 3)) ((c form c (c (? . 6) q define-struct/derived)) q (165531 . 3)) ((c def c (c (? . 8) q split-common-prefix)) q (101936 . 5)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-key+value)) q (506366 . 5)) ((c form c (c (? . 13) q for/weak-seteqv)) q (150113 . 2)) ((c def c (c (? . 0) q thread-receive-evt)) q (272610 . 2)) ((c form c (c (? . 6) q file)) q (5245 . 2)) ((c def c (c (? . 0) q error-value->string-handler)) q (255433 . 9)) ((c def c (c (? . 0) q arithmetic-shift)) q (26974 . 4)) ((c def c (c (? . 0) q will-execute)) q (490324 . 3)) ((c def c (c (? . 12) q evaluator-alive?)) q (426140 . 3)) ((c def c (c (? . 0) q make-will-executor)) q (490075 . 2)) ((c def c (c (? . 0) q hash-weak?)) q (114749 . 3)) ((c def c (c (? . 43) q putenv)) q (485787 . 4)) ((c def c (c (? . 0) q vector*-set!)) q (107530 . 5)) ((c def c (c (? . 1) q unsafe-car)) q (496488 . 3)) ((c form c (c (? . 6) q )) q (11263 . 11)) ((c def c (c (? . 0) q continuation-prompt-tag?)) q (265349 . 3)) ((c def c (c (? . 1) q unsafe-vector*-ref)) q (498190 . 4)) ((c def c (c (? . 42) q build-vector)) q (108887 . 4)) ((c def c (c (? . 1) q unsafe-fl-)) q (493344 . 4)) ((c def c (c (? . 21) q linklet-bundle->hash)) q (433017 . 4)) ((c def c (c (? . 0) q string-locale-ci>?)) q (50387 . 4)) ((c def c (c (? . 0) q cdadr)) q (96711 . 3)) ((c def c (c (? . 12) q sandbox-reader)) q (420607 . 4)) ((c form c (c (? . 54) q splicing-let-syntax)) q (312512 . 2)) ((c def c (c (? . 6) q exn:fail)) c (? . 74)) ((c form c (c (? . 103) q define-struct/contract)) q (215194 . 6)) ((c def c (c (? . 0) q cadr)) q (96109 . 3)) ((c def c (c (? . 14) q place-location?)) q (282128 . 3)) ((c def c (c (? . 19) q collapsible-leaf/c)) c (? . 36)) ((c def c (c (? . 14) q place-message-allowed?)) q (282008 . 3)) ((c def c (c (? . 0) q shell-execute)) q (472359 . 11)) ((c def c (c (? . 1) q unsafe-extfl>=)) q (512539 . 4)) ((c def c (c (? . 0) q parameter?)) q (278797 . 3)) ((c def c (c (? . 0) q char-extended-pictographic?)) q (72660 . 3)) ((c def c (c (? . 13) q set-union!)) q (152781 . 4)) ((c def c (c (? . 8) q in-permutations)) q (104742 . 3)) ((c def c (c (? . 0) q char-upper-case?)) q (72059 . 3)) ((c def c (c (? . 11) q fl->fx)) q (39784 . 3)) ((c def c (c (? . 0) q cadar)) q (96465 . 3)) ((c def c (c (? . 0) q chaperone-prompt-tag)) q (411194 . 18)) ((c def c (c (? . 12) q exn:fail:resource?)) c (? . 101)) ((c def c (c (? . 40) q contract-first-order)) q (235886 . 3)) ((c def c (c (? . 12) q sandbox-override-collection-paths)) q (422897 . 4)) ((c def c (c (? . 16) q extfl<=)) q (42252 . 4)) ((c def c (c (? . 72) q async-channel-put)) q (276393 . 4)) ((c def c (c (? . 0) q namespace-symbol->identifier)) q (380662 . 3)) ((c form c (c (? . 48) q match-define-values)) q (245147 . 2)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-value)) q (509909 . 5)) ((c def c (c (? . 0) q impersonator?)) q (399086 . 3)) ((c def c (c (? . 3) q import-orig-mode)) c (? . 28)) ((c def c (c (? . 0) q print-struct)) q (366825 . 4)) ((c def c (c (? . 22) q sequence->list)) q (133431 . 3)) ((c def c (c (? . 0) q syntax-tainted?)) q (313571 . 3)) ((c def c (c (? . 0) q list)) q (92321 . 3)) ((c def c (c (? . 11) q fxrshift)) q (38503 . 4)) ((c def c (c (? . 0) q open-input-string)) q (328446 . 4)) ((c def c (c (? . 0) q regexp-replace)) q (89577 . 15)) ((c def c (c (? . 112) q s-exp->fasl)) q (378491 . 14)) ((c def c (c (? . 0) q syntax-disarm)) q (313867 . 4)) ((c form c (c (? . 6) q #%module-begin)) q (1801 . 2)) ((c form c (c (? . 32) q impersonate-generics)) q (170463 . 10)) ((c def c (c (? . 75) q engine-result)) q (282756 . 3)) ((c def c (c (? . 6) q sequence-generate*)) q (133264 . 5)) ((c def c (c (? . 14) q place-channel)) q (281652 . 2)) ((c def c (c (? . 0) q make-rename-transformer)) q (298012 . 3)) ((c def c (c (? . 22) q sequence-length)) q (133492 . 3)) ((c form c (c (? . 0) q #%declare)) q (1921 . 8)) ((c def c (c (? . 13) q proper-subset?)) q (153704 . 4)) ((c def c (c (? . 0) q exn:fail:user?)) c (? . 125)) ((c def c (c (? . 1) q unsafe-flvector-set!)) q (500458 . 5)) ((c def c (c (? . 6) q in-sequences)) q (131436 . 3)) ((c def c (c (? . 0) q procedure-specialize)) q (162491 . 3)) ((c def c (c (? . 1) q unsafe-extflvector-set!)) q (514113 . 5)) ((c def c (c (? . 6) q in-mutable-hash)) q (127067 . 3)) ((c def c (c (? . 0) q regexp-match-positions)) q (77844 . 19)) ((c def c (c (? . 7) q stream-length)) q (135861 . 3)) ((c def c (c (? . 44) q fl->exact-integer)) q (35438 . 3)) ((c def c (c (? . 6) q copy-file)) q (446301 . 13)) ((c def c (c (? . 6) q raise-syntax-error)) q (253366 . 18)) ((c def c (c (? . 12) q sandbox-make-plumber)) q (425704 . 4)) ((c def c (c (? . 0) q char-titlecase)) q (73206 . 3)) ((c def c (c (? . 12) q sandbox-propagate-breaks)) q (422207 . 4)) ((c def c (c (? . 16) q extfl*)) q (41782 . 4)) ((c def c (c (? . 0) q current-memory-use)) q (490613 . 3)) ((c form c (c (? . 6) q for*/product)) q (17340 . 2)) ((c def c (c (? . 40) q impersonator-prop:blame)) q (225883 . 2)) ((c def c (c (? . 76) q syntax-local-eval)) q (318626 . 7)) ((c def c (c (? . 0) q syntax-e)) q (288495 . 3)) ((c def c (c (? . 0) q char-iso-control?)) q (72591 . 3)) ((c form c (c (? . 0) q define-values)) q (13564 . 2)) ((c form c (c (? . 9) q inherit/super)) q (178285 . 2)) ((c def c (c (? . 0) q read-single-flonum)) q (363663 . 4)) ((c def c (c (? . 0) q prop:set!-transformer)) q (297893 . 2)) ((c def c (c (? . 12) q sandbox-eval-limits)) q (424480 . 8)) ((c def c (c (? . 3) q import-src-sym)) c (? . 28)) ((c def c (c (? . 1) q unsafe-fxlshift)) q (491866 . 4)) ((c def c (c (? . 15) q call-with-output-string)) q (335972 . 3)) ((c def c (c (? . 20) q listen-port-number?)) q (462155 . 2)) ((c def c (c (? . 0) q current-error-message-adjuster)) q (261802 . 5)) ((c def c (c (? . 24) q export?)) c (? . 68)) ((c def c (c (? . 0) q make-prefab-struct)) q (172792 . 4)) ((c def c (c (? . 44) q fl<=)) q (34246 . 4)) ((c def c (c (? . 37) q udp-connected?)) q (466870 . 3)) ((c def c (c (? . 0) q current-compiled-file-roots)) q (389010 . 4)) ((c def c (c (? . 0) q not)) q (21247 . 3)) ((c def c (c (? . 0) q date-dst?)) c (? . 60)) ((c def c (c (? . 8) q partition)) q (103746 . 4)) ((c def c (c (? . 0) q thread-try-receive)) q (272568 . 2)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-value)) q (505913 . 5)) ((c def c (c (? . 6) q syntax-serialize)) q (315011 . 12)) ((c def c (c (? . 0) q bytes-close-converter)) q (68824 . 3)) ((c def c (c (? . 13) q mutable-seteq)) q (147419 . 4)) ((c def c (c (? . 0) q port-closed-evt)) q (320193 . 3)) ((c def c (c (? . 0) q delete-file)) q (444512 . 3)) ((c form c (c (? . 65) q delay)) q (262097 . 2)) ((c def c (c (? . 1) q unsafe-f64vector-set!)) q (500662 . 5)) ((c def c (c (? . 0) q exn:fail:contract:arity?)) c (? . 111)) ((c def c (c (? . 0) q bytes-copy)) q (64375 . 3)) ((c def c (c (? . 1) q unsafe-fxvector-length)) q (500029 . 3)) ((c def c (c (? . 0) q read-accept-reader)) q (364153 . 4)) ((c def c (c (? . 8) q second)) q (98785 . 3)) ((c def c (c (? . 0) q expt)) q (25357 . 4)) ((c def c (c (? . 11) q fx->fl)) q (39731 . 3)) ((c def c (c (? . 0) q hash-iterate-first)) q (121506 . 4)) ((c def c (c (? . 10) q vector-count)) q (110604 . 4)) ((c def c (c (? . 0) q single-flonum-available?)) q (22510 . 2)) ((c def c (c (? . 66) q blame-value)) q (224450 . 3)) ((c def c (c (? . 0) q char>?)) q (71261 . 4)) ((c def c (c (? . 29) q string-contains?)) q (53046 . 4)) ((c def c (c (? . 6) q in-ephemeron-hash)) q (129953 . 3)) ((c def c (c (? . 66) q make-exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 0) q read/recursive)) q (361551 . 6)) ((c def c (c (? . 16) q shared-extflvector)) q (45363 . 3)) ((c def c (c (? . 1) q unsafe-extflceiling)) q (512952 . 3)) ((c def c (c (? . 0) q bytes-length)) q (63867 . 3)) ((c def c (c (? . 12) q sandbox-coverage-enabled)) q (422085 . 4)) ((c def c (c (? . 0) q syntax-local-module-required-identifiers)) q (307522 . 8)) ((c def c (c (? . 0) q hash-count)) q (121363 . 3)) ((c def c (c (? . 0) q string->keyword)) q (91707 . 3)) ((c def c (c (? . 0) q stencil-vector-mask)) q (112752 . 4)) ((c def c (c (? . 0) q immutable?)) q (21296 . 3)) ((c def c (c (? . 8) q filter-not)) q (104208 . 4)) ((c def c (c (? . 0) q current-load-extension)) q (387274 . 15)) ((c def c (c (? . 2) q dict-has-key?)) q (139441 . 4)) ((c def c (c (? . 0) q continuation-mark-set->iterator)) q (268618 . 11)) ((c def c (c (? . 1) q unsafe-extflabs)) q (512118 . 3)) ((c def c (c (? . 1) q unsafe-set-mcar!)) q (496704 . 4)) ((c def c (c (? . 25) q pretty-print-remap-stylable)) q (371791 . 5)) ((c def c (c (? . 0) q box-immutable)) q (113782 . 3)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-pair)) q (506842 . 5)) ((c def c (c (? . 1) q unsafe-stencil-vector-mask)) q (501429 . 4)) ((c def c (c (? . 6) q call-with-input-file*)) q (325529 . 7)) ((c def c (c (? . 0) q environment-variables-names)) q (485425 . 4)) ((c def c (c (? . 43) q bytes-environment-variable-name?)) q (484566 . 3)) ((c def c (c (? . 0) q arity-at-least?)) c (? . 45)) ((c def c (c (? . 6) q in-indexed)) q (131371 . 3)) ((c def c (c (? . 0) q procedure-arity)) q (158851 . 3)) ((c form c (c (? . 6) q for*/lists)) q (16715 . 3)) ((c def c (c (? . 0) q variable-reference->empty-namespace)) q (385005 . 3)) ((c def c (c (? . 6) q in-port)) q (125765 . 4)) ((c def c (c (? . 0) q bytes->path-element)) q (437766 . 8)) ((c def c (c (? . 12) q get-error-output)) c (? . 77)) ((c def c (c (? . 11) q in-fxvector)) q (40660 . 6)) ((c def c (c (? . 16) q extflexpt)) q (43396 . 4)) ((c def c (c (? . 4) q string-no-nuls?)) q (477056 . 3)) ((c def c (c (? . 44) q flvector?)) q (36217 . 3)) ((c def c (c (? . 6) q regexp-match-peek-positions*)) q (83918 . 17)) ((c def c (c (? . 73) q struct-auto-info-lists)) q (174194 . 4)) ((c form c (c (? . 26) q any)) q (206018 . 2)) ((c def c (c (? . 21) q linklet-export-variables)) q (432345 . 3)) ((c def c (c (? . 7) q empty-stream)) q (135773 . 2)) ((c def c (c (? . 0) q use-compiled-file-check)) q (389259 . 4)) ((c def c (c (? . 40) q chaperone-contract?)) q (236024 . 3)) ((c def c (c (? . 0) q syntax-local-value/immediate)) q (303999 . 9)) ((c form c (c (? . 49) q ~@)) q (285545 . 2)) ((c def c (c (? . 0) q vector*-length)) q (107276 . 3)) ((c def c (c (? . 9) q field-names)) q (190290 . 3)) ((c def c (c (? . 0) q make-ephemeron-hasheqv)) q (116898 . 4)) ((c def c (c (? . 0) q port-provides-progress-evts?)) q (357698 . 3)) ((c def c (c (? . 0) q chaperone-channel)) q (410686 . 12)) ((q def ((lib "racket/rerequire.rkt") dynamic-rerequire)) q (520202 . 5)) ((c def c (c (? . 0) q char-ci>?)) q (71732 . 4)) ((c def c (c (? . 66) q blame-replace-negative)) q (224741 . 4)) ((c def c (c (? . 0) q exn-continuation-marks)) c (? . 47)) ((c def c (c (? . 0) q thread-resume-evt)) q (272205 . 3)) ((c form c (c (? . 9) q public-final)) q (177916 . 2)) ((c def c (c (? . 51) q file-name-from-path)) q (441742 . 3)) ((c form c (c (? . 30) q define-logger)) q (477834 . 7)) ((c def c (c (? . 17) q directory-type-bits)) q (459468 . 2)) ((c def c (c (? . 23) q cons/c)) q (202715 . 4)) ((c def c (c (? . 56) q fsemaphore-post)) q (279925 . 3)) ((c def c (c (? . 0) q dynamic-require)) q (397047 . 7)) ((c def c (c (? . 1) q unsafe-vector*-length)) q (498089 . 3)) ((c def c (c (? . 0) q make-immutable-hashalw)) q (117348 . 4)) ((c form c (c (? . 27) q let-syntax)) q (12245 . 2)) ((c def c (c (? . 0) q path-for-some-system?)) q (437136 . 3)) ((c def c (c (? . 0) q make-empty-namespace)) q (380130 . 2)) ((c def c (c (? . 26) q flat-contract-predicate)) q (206183 . 3)) ((c def c (c (? . 0) q variable-reference?)) q (384842 . 3)) ((c def c (c (? . 57) q raise-contract-error)) q (242064 . 13)) ((c def c (c (? . 16) q extfl->exact-integer)) q (43546 . 3)) ((c def c (c (? . 0) q shared-bytes)) q (65287 . 3)) ((c def c (c (? . 78) q serialized=?)) q (376533 . 4)) ((c def c (c (? . 15) q with-output-to-string)) q (336162 . 3)) ((c def c (c (? . 22) q sequence-andmap)) q (133934 . 4)) ((c def c (c (? . 48) q match-equality-test)) q (245698 . 4)) ((c def c (c (? . 0) q error-print-source-location)) q (255305 . 4)) ((c def c (c (? . 0) q call-with-escape-continuation)) q (264659 . 3)) ((c def c (c (? . 75) q engine)) q (282508 . 3)) ((c def c (c (? . 8) q remf)) q (105266 . 4)) ((c def c (c (? . 0) q string->bytes/latin-1)) q (67094 . 9)) ((c def c (c (? . 44) q fl>)) q (34169 . 4)) ((c form c (c (? . 34) q trait-rename)) q (183663 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:missing-module-path)) c (? . 79)) ((c def c (c (? . 0) q error-message->adjusted-string)) q (261250 . 9)) ((c def c (c (? . 0) q syntax-local-module-interned-scope-symbols)) q (305668 . 3)) ((c def c (c (? . 76) q format-symbol)) q (317207 . 5)) ((c def c (c (? . 0) q string>?)) q (48608 . 4)) ((c form c (c (? . 6) q for-space)) q (7169 . 2)) ((c def c (c (? . 80) q date->seconds)) q (483219 . 4)) ((c def c (c (? . 0) q make-log-receiver)) q (479431 . 5)) ((c def c (c (? . 17) q file->list)) q (449256 . 5)) ((c def c (c (? . 0) q print-graph)) q (366739 . 4)) ((c def c (c (? . 21) q linklet-directory?)) q (432439 . 3)) ((c def c (c (? . 21) q correlated-line)) q (435283 . 3)) ((c def c (c (? . 81) q make-chaperone-contract)) q (218338 . 32)) ((c def c (c (? . 0) q custodian-memory-accounting-available?)) q (414299 . 2)) ((c def c (c (? . 0) q namespace-mapped-symbols)) q (382034 . 3)) ((c form c (c (? . 6) q for*/sum)) q (17277 . 2)) ((c def c (c (? . 15) q make-input-port/read-to-peek)) q (336989 . 50)) ((c def c (c (? . 13) q set->list)) q (153803 . 3)) ((c def c (c (? . 8) q fourth)) q (98886 . 3)) ((c def c (c (? . 1) q unsafe-flexp)) q (494950 . 3)) ((c def c (c (? . 0) q syntax-local-name)) q (305213 . 2)) ((c def c (c (? . 0) q raise-arguments-error*)) q (248951 . 12)) ((c def c (c (? . 0) q internal-definition-context?)) q (301301 . 3)) ((c def c (c (? . 22) q empty-sequence)) q (133396 . 2)) ((c def c (c (? . 66) q exn:fail:contract:blame-object)) c (? . 70)) ((c def c (c (? . 82) q pi.f)) q (32392 . 2)) ((c def c (c (? . 6) q procedure->method)) q (158191 . 3)) ((c def c (c (? . 17) q call-with-file-lock/timeout)) q (458263 . 15)) ((c def c (c (? . 40) q build-compound-type-name)) q (222110 . 3)) ((c form c (c (? . 31) q prompt)) q (266418 . 2)) ((c form c (c (? . 41) q define-signature)) q (192569 . 25)) ((c def c (c (? . 0) q hash?)) q (114380 . 3)) ((c form c (c (? . 48) q match-define)) q (245114 . 2)) ((c form c (c (? . 46) q serializable-struct)) q (376896 . 3)) ((c form c (c (? . 30) q log-error)) q (479082 . 3)) ((c form c (c (? . 6) q define-syntax)) q (13604 . 3)) ((c form c (c (? . 107) q include-at/relative-to)) q (316084 . 2)) ((c def c (c (? . 6) q exn:fail:network)) c (? . 83)) ((c form c (c (? . 31) q reset0-at)) q (266916 . 2)) ((c def c (c (? . 0) q subprocess-group-enabled)) q (472053 . 4)) ((c def c (c (? . 82) q degrees->radians)) q (32439 . 3)) ((c form c (c (? . 30) q parameterize-break)) q (270363 . 2)) ((c form c (c (? . 9) q get-field)) q (181741 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:errno?)) c (? . 84)) ((c def c (c (? . 0) q syntax-transforming-with-lifts?)) q (306239 . 2)) ((c def c (c (? . 11) q most-negative-fixnum)) q (41467 . 2)) ((c def c (c (? . 17) q sticky-bit)) q (459658 . 2)) ((c def c (c (? . 0) q struct:exn:fail:network)) c (? . 83)) ((c def c (c (? . 0) q current-process-milliseconds)) q (482001 . 3)) ((c def c (c (? . 0) q module-path-index?)) q (393912 . 3)) ((c def c (c (? . 16) q extflvector-copy)) q (44579 . 5)) ((c form c (c (? . 13) q for/mutable-seteq)) q (149593 . 2)) ((c def c (c (? . 0) q make-special-comment)) q (374840 . 3)) ((c def c (c (? . 0) q rename-transformer?)) q (297947 . 3)) ((c def c (c (? . 44) q make-flrectangular)) q (35509 . 7)) ((c def c (c (? . 6) q make-exn:fail:read)) c (? . 85)) ((c def c (c (? . 9) q member-name-key?)) q (180124 . 3)) ((c def c (c (? . 43) q read-eval-print-loop)) q (389424 . 2)) ((c def c (c (? . 0) q syntax-local-get-shadower)) q (305747 . 5)) ((c def c (c (? . 0) q path<?)) q (438247 . 4)) ((c form c (c (? . 27) q =>)) q (13080 . 2)) ((c def c (c (? . 7) q stream-force)) q (135601 . 3)) ((c def c (c (? . 13) q set-intersect)) q (152878 . 4)) ((c form c (c (? . 48) q match/values)) q (244031 . 2)) ((c def c (c (? . 43) q path-add-extension)) q (441019 . 5)) ((c def c (c (? . 21) q variable-reference->instance)) q (434922 . 6)) ((c def c (c (? . 9) q object-interface)) q (189417 . 3)) ((c def c (c (? . 0) q string>=?)) q (48702 . 4)) ((c form c (c (? . 41) q define-compound-unit/infer)) q (195528 . 5)) ((c def c (c (? . 17) q user-permission-bits)) q (459688 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:version?)) c (? . 86)) ((c def c (c (? . 15) q call-with-input-string)) q (336312 . 4)) ((c form c (c (? . 48) q match)) q (243676 . 6)) ((c def c (c (? . 0) q make-portal-syntax)) q (311927 . 3)) ((c def c (c (? . 1) q unsafe-extfl<=)) q (512450 . 4)) ((c def c (c (? . 29) q string-prefix?)) q (53147 . 4)) ((c def c (c (? . 56) q fsemaphore?)) q (279868 . 3)) ((c form c (c (? . 9) q class/derived)) q (179650 . 5)) ((c def c (c (? . 7) q stream-append)) q (136229 . 3)) ((c def c (c (? . 6) q make-exn:fail:out-of-memory)) c (? . 87)) ((c def c (c (? . 17) q fifo-type-bits)) q (459553 . 2)) ((c def c (c (? . 40) q get/build-collapsible-late-neg-projection)) q (238506 . 4)) ((c def c (c (? . 82) q order-of-magnitude)) q (33183 . 3)) ((c def c (c (? . 82) q sgn)) q (32607 . 3)) ((c form c (c (? . 64) q unsyntax-splicing)) q (285689 . 2)) ((c def c (c (? . 127) q box/c)) q (202081 . 9)) ((c def c (c (? . 0) q make-thread-group)) q (415127 . 3)) ((c def c (c (? . 17) q file->lines)) q (449463 . 8)) ((c def c (c (? . 11) q fxxor)) q (38318 . 3)) ((c def c (c (? . 0) q file-or-directory-permissions)) q (445524 . 11)) ((c def c (c (? . 0) q current-load)) q (386509 . 15)) ((c def c (c (? . 0) q current-plumber)) q (417195 . 4)) ((c def c (c (? . 0) q channel-put-evt)) q (274614 . 4)) ((c form c (c (? . 105) q define-inline)) q (19530 . 14)) ((c form c (c (? . 30) q log-debug)) q (479300 . 3)) ((c def c (c (? . 6) q in-weak-hash-keys)) q (129286 . 3)) ((c def c (c (? . 8) q argmin)) q (104808 . 4)) ((c def c (c (? . 0) q bytes-fill!)) q (64860 . 4)) ((c def c (c (? . 0) q list-tail)) q (92759 . 4)) ((c form c (c (? . 6) q prefix-in)) q (4683 . 2)) ((c def c (c (? . 40) q collapsible-contract-continuation-mark-key)) q (238662 . 3)) ((c def c (c (? . 0) q thread?)) q (271215 . 3)) ((c def c (c (? . 0) q current-print)) q (390016 . 4)) ((c def c (c (? . 3) q require-transformer?)) q (308408 . 3)) ((c def c (c (? . 0) q internal-definition-context-splice-binding-identifier)) q (301835 . 7)) ((c def c (c (? . 30) q hash-update)) q (119457 . 9)) ((c def c (c (? . 0) q raise-argument-error)) q (246888 . 13)) ((c def c (c (? . 0) q version)) q (486432 . 2)) ((c def c (c (? . 42) q assoc)) q (95430 . 5)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-key)) q (507536 . 4)) ((c def c (c (? . 0) q current-inspector)) q (415887 . 4)) ((c def c (c (? . 0) q string-utf-8-length)) q (67455 . 5)) ((c def c (c (? . 40) q get/build-late-neg-projection)) q (238395 . 4)) ((c def c (c (? . 2) q dict-iterate-key)) q (139267 . 4)) ((c def c (c (? . 37) q udp-multicast-set-loopback!)) q (469474 . 5)) ((c def c (c (? . 0) q chaperone-hash)) q (408780 . 22)) ((c def c (c (? . 6) q stop-after)) q (131900 . 4)) ((c def c (c (? . 0) q load-on-demand-enabled)) q (391540 . 4)) ((c def c (c (? . 1) q unsafe-bytes-set!)) q (499387 . 5)) ((c def c (c (? . 0) q make-weak-box)) q (489549 . 3)) ((c def c (c (? . 0) q date-day)) c (? . 60)) ((c def c (c (? . 0) q filesystem-root-list)) q (447968 . 2)) ((c def c (c (? . 88) q phase+space)) q (319132 . 4)) ((c def c (c (? . 24) q export-local-id)) c (? . 68)) ((c def c (c (? . 0) q read-curly-brace-as-paren)) q (362691 . 4)) ((c def c (c (? . 0) q date-month)) c (? . 60)) ((c def c (c (? . 0) q namespace-undefine-variable!)) q (381842 . 5)) ((c def c (c (? . 6) q gen:custom-write)) q (375051 . 2)) ((c def c (c (? . 9) q make-exn:fail:object)) c (? . 106)) ((c def c (c (? . 3) q struct:import-source)) c (? . 33)) ((c def c (c (? . 6) q regexp-quote)) q (75078 . 7)) ((c form c (c (? . 9) q interface)) q (174538 . 5)) ((c def c (c (? . 0) q exn:fail:filesystem?)) c (? . 89)) ((c def c (c (? . 13) q list->weak-seteq)) q (149034 . 3)) ((c def c (c (? . 9) q writable<%>)) q (188732 . 2)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-first)) q (502993 . 3)) ((c def c (c (? . 8) q append-map)) q (104115 . 4)) ((c def c (c (? . 0) q bytes>?)) q (65538 . 4)) ((c def c (c (? . 0) q variable-reference->module-declaration-inspector)) q (385852 . 4)) ((c def c (c (? . 0) q absolute-path?)) q (439268 . 3)) ((c def c (c (? . 0) q compile)) q (390305 . 3)) ((c form c (c (? . 6) q struct)) q (164034 . 33)) ((c def c (c (? . 34) q trait-sum)) q (183472 . 3)) ((c def c (c (? . 72) q make-async-channel)) q (276126 . 3)) ((c def c (c (? . 0) q variable-reference-constant?)) q (384907 . 3)) ((c def c (c (? . 0) q namespace-call-with-registry-lock)) q (384078 . 5)) ((c def c (c (? . 6) q syntax-deserialize)) q (315634 . 7)) ((c def c (c (? . 38) q instanceof/c)) q (185384 . 3)) ((c def c (c (? . 0) q file-stream-port?)) q (320587 . 3)) ((c def c (c (? . 0) q chaperone-struct-type)) q (409833 . 15)) ((c def c (c (? . 0) q vector-length)) q (106937 . 3)) ((c def c (c (? . 0) q error)) q (246329 . 10)) ((c def c (c (? . 0) q prefab-struct-type-key+field-count)) q (172889 . 4)) ((c def c (c (? . 18) q ~s)) q (55801 . 25)) ((c def c (c (? . 0) q exn:fail:syntax-exprs)) c (? . 104)) ((c def c (c (? . 1) q unsafe-string-length)) q (498766 . 3)) ((c def c (c (? . 66) q blame?)) q (223189 . 3)) ((c def c (c (? . 13) q list->seteqv)) q (148102 . 3)) ((c def c (c (? . 0) q cdddar)) q (98357 . 3)) ((c def c (c (? . 0) q struct->vector)) q (172211 . 4)) ((c def c (c (? . 0) q make-custodian-box)) q (414896 . 4)) ((c def c (c (? . 0) q close-input-port)) q (319991 . 3)) ((c def c (c (? . 19) q struct:collapsible-leaf/c)) c (? . 36)) ((c def c (c (? . 23) q first-or/c)) q (200069 . 3)) ((c def c (c (? . 1) q unsafe-s16vector-set!)) q (500892 . 5)) ((c def c (c (? . 0) q vector-immutable)) q (106809 . 4)) ((c form c (c (? . 41) q define-values/invoke-unit)) q (194045 . 4)) ((c form c (c (? . 90) q opt/c)) q (237416 . 5)) ((c def c (c (? . 0) q compile-context-preservation-enabled)) q (390898 . 4)) ((c form c (c (? . 91) q contract-struct)) q (212850 . 2)) ((c def c (c (? . 23) q *list/c)) q (203174 . 4)) ((c def c (c (? . 6) q open-input-output-file)) q (323445 . 16)) ((c def c (c (? . 0) q hasheqv)) q (115286 . 5)) ((c def c (c (? . 40) q value-blame)) q (236477 . 3)) ((c def c (c (? . 0) q read-installation-configuration-table)) q (519280 . 3)) ((c def c (c (? . 0) q prefab-key?)) q (173171 . 3)) ((c def c (c (? . 0) q prefab-struct-key)) q (172711 . 3)) ((c def c (c (? . 6) q make-exn:fail:read:non-char)) c (? . 58)) ((c def c (c (? . 0) q module-compiled-exports)) q (396101 . 7)) ((c form c (c (? . 48) q match/derived)) q (245853 . 2)) ((c def c (c (? . 0) q read-on-demand-source)) q (364718 . 5)) ((c form c (c (? . 39) q untrace)) q (520714 . 2)) ((c def c (c (? . 21) q linklet-bundle?)) q (432816 . 3)) ((c def c (c (? . 13) q set-symmetric-difference)) q (153292 . 4)) ((c def c (c (? . 38) q implementation?/c)) q (188194 . 3)) ((c def c (c (? . 48) q match-expander?)) q (245490 . 3)) ((c form c (c (? . 54) q splicing-let)) q (312412 . 2)) ((c def c (c (? . 0) q exn:fail:filesystem:missing-module?)) c (? . 79)) ((c def c (c (? . 37) q udp-set-ttl!)) q (468524 . 4)) ((c def c (c (? . 16) q extflvector-set!)) q (44436 . 5)) ((c form c (c (? . 48) q match-lambda*)) q (244684 . 2)) ((c def c (c (? . 0) q chaperone-evt)) q (410447 . 7)) ((c def c (c (? . 0) q read-bytes-avail!/enable-break)) q (351778 . 10)) ((c def c (c (? . 92) q signature-members)) q (198728 . 8)) ((c def c (c (? . 44) q flvector-set!)) q (36648 . 5)) ((c def c (c (? . 25) q pretty-print-show-inexactness)) q (370938 . 4)) ((c def c (c (? . 0) q symbol-unreadable?)) q (73560 . 3)) ((c def c (c (? . 40) q has-blame?)) q (236549 . 3)) ((c def c (c (? . 4) q system*/exit-code)) q (473664 . 15)) ((c def c (c (? . 0) q set-box*!)) q (114095 . 4)) ((c form c (c (? . 9) q inspect)) q (177634 . 2)) ((c def c (c (? . 0) q syntax-shift-phase-level)) q (291541 . 4)) ((c def c (c (? . 26) q real-in)) q (200671 . 4)) ((c def c (c (? . 1) q unsafe-fl+)) q (493282 . 3)) ((c def c (c (? . 0) q make-inspector)) q (415476 . 3)) ((c def c (c (? . 0) q string-locale-downcase)) q (50568 . 3)) ((c def c (c (? . 17) q set-group-id-bit)) q (459622 . 2)) ((c form c (c (? . 9) q init-rest)) q (177808 . 3)) ((c def c (c (? . 0) q prop:exn:missing-module)) q (260939 . 2)) ((c def c (c (? . 0) q use-user-specific-search-paths)) q (519042 . 4)) ((c def c (c (? . 7) q stream-for-each)) q (136576 . 4)) ((c def c (c (? . 0) q thread-dead-evt)) q (272142 . 3)) ((c def c (c (? . 13) q list->mutable-seteqv)) q (148506 . 4)) ((c def c (c (? . 0) q eval)) q (386191 . 6)) ((c def c (c (? . 15) q port->bytes)) q (334863 . 4)) ((c def c (c (? . 93) q generator?)) q (137337 . 3)) ((c form c (c (? . 65) q for/list/concurrent)) q (262858 . 8)) ((c def c (c (? . 0) q integer-sqrt/remainder)) q (25276 . 3)) ((c def c (c (? . 12) q sandbox-network-guard)) q (423796 . 13)) ((c def c (c (? . 6) q syntax-binding-set-extend)) q (289994 . 25)) ((c def c (c (? . 0) q hash-iterate-pair)) q (122265 . 4)) ((c form c (c (? . 55) q matching-identifiers-in)) q (10427 . 2)) ((c def c (c (? . 82) q conjugate)) q (32701 . 3)) ((c def c (c (? . 44) q fl<)) q (34092 . 4)) ((c def c (c (? . 0) q peek-bytes-avail!/enable-break)) q (354923 . 14)) ((c def c (c (? . 16) q extfltruncate)) q (42777 . 3)) ((c def c (c (? . 76) q internal-definition-context-apply)) q (318431 . 5)) ((c def c (c (? . 26) q any/c)) q (199932 . 2)) ((q form ((lib "racket/surrogate.rkt") surrogate)) q (191529 . 11)) ((c def c (c (? . 7) q stream/c)) q (137278 . 3)) ((c def c (c (? . 6) q make-arity-at-least)) c (? . 45)) ((c def c (c (? . 0) q continuation-marks)) q (267420 . 5)) ((c def c (c (? . 13) q set?)) q (146589 . 3)) ((c def c (c (? . 40) q prop:contracted)) q (225730 . 2)) ((c def c (c (? . 0) q make-weak-hash)) q (115994 . 4)) ((c def c (c (? . 37) q udp-receive!*)) q (465646 . 12)) ((c def c (c (? . 0) q max)) q (24015 . 3)) ((c def c (c (? . 0) q caaadr)) q (97057 . 3)) ((c def c (c (? . 0) q prop:custom-print-quotable)) q (375325 . 2)) ((c form c (c (? . 6) q for-meta)) q (7001 . 2)) ((c def c (c (? . 9) q externalizable<%>)) q (188655 . 2)) ((c def c (c (? . 6) q exn:fail:contract:continuation)) c (? . 108)) ((c def c (c (? . 10) q vector-drop)) q (109765 . 4)) ((c def c (c (? . 16) q real->extfl)) q (43623 . 3)) ((c def c (c (? . 0) q plumber-add-flush!)) q (417442 . 5)) ((c def c (c (? . 0) q read-case-sensitive)) q (362469 . 4)) ((c def c (c (? . 19) q collapsible-ho/c-missing-party)) c (? . 94)) ((c def c (c (? . 25) q pretty-write)) q (369706 . 5)) ((c def c (c (? . 0) q current-eval)) q (386074 . 4)) ((c def c (c (? . 0) q namespace-unprotect-module)) q (383713 . 7)) ((c def c (c (? . 0) q syntax-local-identifier-as-binding)) q (306362 . 5)) ((c form c (c (? . 9) q send/apply)) q (180909 . 2)) ((c def c (c (? . 7) q stream-count)) q (136790 . 4)) ((c def c (c (? . 0) q resolved-module-path?)) q (391648 . 3)) ((c form c (c (? . 9) q define/public)) q (178812 . 3)) ((c def c (c (? . 37) q udp-addresses)) q (468257 . 7)) ((c def c (c (? . 6) q call-with-output-file)) q (324588 . 18)) ((c def c (c (? . 0) q struct:exn:fail:network:errno)) c (? . 95)) ((c def c (c (? . 0) q sync/timeout/enable-break)) q (273032 . 4)) ((c def c (c (? . 66) q blame-replaced-negative?)) q (224831 . 3)) ((c def c (c (? . 0) q regexp-match?)) q (79860 . 13)) ((c def c (c (? . 0) q sha224-bytes)) q (379676 . 5)) ((c def c (c (? . 10) q vector-filter)) q (110412 . 4)) ((c def c (c (? . 0) q struct:arity-at-least)) c (? . 45)) ((c def c (c (? . 11) q fx>=)) q (39497 . 4)) ((c def c (c (? . 0) q system-idle-evt)) q (273899 . 2)) ((c def c (c (? . 0) q subprocess-wait)) q (471382 . 3)) ((c def c (c (? . 8) q split-at-right)) q (101113 . 4)) ((c def c (c (? . 61) q make-contract)) q (216542 . 32)) ((c def c (c (? . 0) q bitwise-bit-field)) q (26759 . 6)) ((c def c (c (? . 0) q environment-variables?)) q (484345 . 3)) ((c def c (c (? . 0) q read-bytes-line)) q (349909 . 5)) ((c def c (c (? . 13) q in-set)) q (154079 . 3)) ((c def c (c (? . 0) q procedure-impersonator*?)) q (399438 . 3)) ((c form c (c (? . 6) q for/hasheq)) q (15383 . 2)) ((c def c (c (? . 0) q string->bytes/locale)) q (66847 . 6)) ((c def c (c (? . 9) q class->interface)) q (189344 . 3)) ((c form c (c (? . 49) q syntax-case*)) q (284426 . 3)) ((c def c (c (? . 37) q udp-send-to-evt)) q (467104 . 13)) ((c def c (c (? . 0) q date-minute)) c (? . 60)) ((c def c (c (? . 0) q identifier-binding-symbol)) q (296687 . 6)) ((c def c (c (? . 0) q syntax-column)) q (287971 . 3)) ((c def c (c (? . 66) q blame-source)) q (224505 . 3)) ((c def c (c (? . 0) q make-hashalw-placeholder)) q (106131 . 3)) ((c def c (c (? . 80) q date->julian/scalinger)) q (484167 . 3)) ((c def c (c (? . 9) q member-name-key=?)) q (180186 . 4)) ((c def c (c (? . 0) q string<?)) q (48419 . 4)) ((c def c (c (? . 25) q pretty-print-print-line)) q (372095 . 15)) ((c def c (c (? . 0) q procedure-arity-mask)) q (158994 . 3)) ((c def c (c (? . 26) q <=/c)) q (200479 . 3)) ((c form c (c (? . 96) q lazy-require)) q (19837 . 5)) ((c form c (c (? . 67) q define-runtime-paths)) q (448492 . 2)) ((c def c (c (? . 1) q unsafe-extfllog)) q (513508 . 3)) ((c form c (c (? . 49) q ~?)) q (285569 . 2)) ((c form c (c (? . 49) q syntax-rules)) q (287393 . 3)) ((c def c (c (? . 0) q syntax-local-make-definition-context)) q (301375 . 6)) ((c def c (c (? . 40) q coerce-chaperone-contracts)) q (222482 . 5)) ((c def c (c (? . 1) q unsafe-extflmin)) q (512628 . 4)) ((c def c (c (? . 0) q thread-cell-values?)) q (278120 . 3)) ((c def c (c (? . 17) q make-temporary-directory*)) q (455155 . 8)) ((c def c (c (? . 0) q module->namespace)) q (384252 . 6)) ((c def c (c (? . 78) q prop:serializable)) q (377941 . 2)) ((c form c (c (? . 27) q and)) q (13090 . 2)) ((c form c (c (? . 0) q if)) q (12758 . 2)) ((c def c (c (? . 6) q exn:fail:contract:non-fixnum-result)) c (? . 97)) ((c form c (c (? . 39) q trace-define)) q (520450 . 3)) ((c def c (c (? . 1) q unsafe-chaperone-procedure)) q (514654 . 11)) ((c def c (c (? . 0) q syntax-local-lift-require)) q (304854 . 7)) ((c def c (c (? . 16) q extflmin)) q (42416 . 4)) ((c def c (c (? . 0) q path->string)) q (437404 . 3)) ((c def c (c (? . 15) q convert-stream)) q (349103 . 9)) ((c def c (c (? . 0) q error-print-width)) q (254993 . 4)) ((c def c (c (? . 12) q gui?)) q (427995 . 2)) ((c def c (c (? . 0) q current-pseudo-random-generator)) q (27986 . 4)) ((c def c (c (? . 0) q impersonator-ephemeron)) q (399368 . 3)) ((c def c (c (? . 6) q exn:fail:network:errno)) c (? . 95)) ((c def c (c (? . 0) q read-accept-bar-quote)) q (363237 . 4)) ((c def c (c (? . 98) q vector/c)) q (201704 . 8)) ((c def c (c (? . 0) q struct:exn:fail:contract)) c (? . 126)) ((c def c (c (? . 37) q udp-send)) q (463389 . 6)) ((c def c (c (? . 43) q displayln)) q (365777 . 4)) ((q def ((lib "racket/interaction-info.rkt") current-interaction-info)) q (519467 . 5)) ((c def c (c (? . 6) q in-weak-hash-pairs)) q (129730 . 3)) ((c form c (c (? . 16) q for/extflvector)) q (45025 . 2)) ((c def c (c (? . 0) q poll-guard-evt)) q (273631 . 3)) ((c def c (c (? . 0) q make-struct-type-property)) q (168185 . 19)) ((c def c (c (? . 24) q export-out-sym)) c (? . 68)) ((c form c (c (? . 12) q with-limits)) q (428200 . 2)) ((c def c (c (? . 15) q read-bytes!-evt)) q (346953 . 4)) ((c def c (c (? . 11) q fxvector-copy)) q (40469 . 5)) ((c def c (c (? . 19) q collapsible-leaf/c-proj-list)) c (? . 36)) ((c def c (c (? . 0) q custodian-shut-down?)) q (414007 . 3)) ((c def c (c (? . 0) q checked-procedure-check-and-extract)) q (162089 . 11)) ((c form c (c (? . 0) q quote)) q (10866 . 2)) ((c def c (c (? . 88) q phase+space?)) q (319074 . 3)) ((c def c (c (? . 8) q count)) q (103637 . 4)) ((c def c (c (? . 0) q handle-evt)) q (273347 . 4)) ((c def c (c (? . 0) q resolve-path)) q (439929 . 3)) ((c def c (c (? . 0) q plumber-flush-all)) q (417300 . 3)) ((c def c (c (? . 0) q format)) q (366338 . 4)) ((c def c (c (? . 0) q thread-running?)) q (271961 . 3)) ((c def c (c (? . 17) q user-write-bit)) q (459761 . 2)) ((c def c (c (? . 10) q vector-filter-not)) q (110506 . 4)) ((c def c (c (? . 0) q never-evt)) q (273874 . 2)) ((c def c (c (? . 1) q unsafe-extflvector-ref)) q (514015 . 4)) ((c def c (c (? . 0) q identifier-template-binding)) q (295096 . 12)) ((c def c (c (? . 0) q exit)) q (270749 . 3)) ((c def c (c (? . 0) q port-next-location)) q (321741 . 6)) ((c form c (c (? . 99) q command-line)) q (487064 . 43)) ((c def c (c (? . 0) q string->number)) q (29489 . 19)) ((c def c (c (? . 0) q read-syntax/recursive)) q (361799 . 11)) ((c def c (c (? . 13) q list->set)) q (147911 . 3)) ((c def c (c (? . 0) q char-foldcase)) q (73269 . 3)) ((c form c (c (? . 31) q reset-at)) q (266638 . 2)) ((c def c (c (? . 6) q make-exn:fail:filesystem:missing-module)) c (? . 79)) ((c def c (c (? . 0) q bytes-set!)) q (64049 . 5)) ((c def c (c (? . 0) q read-curly-brace-with-tag)) q (362925 . 4)) ((c def c (c (? . 1) q unsafe-fx<)) q (492774 . 4)) ((c def c (c (? . 0) q read-string!)) q (350437 . 7)) ((c def c (c (? . 0) q zero?)) q (22561 . 3)) ((c def c (c (? . 13) q set-clear!)) q (152616 . 3)) ((c def c (c (? . 0) q peek-bytes!)) q (353170 . 12)) ((q def ((lib "racket/undefined.rkt") undefined)) q (164008 . 2)) ((c def c (c (? . 0) q current-namespace)) q (380561 . 4)) ((c def c (c (? . 2) q dict-key-contract)) q (141765 . 3)) ((c def c (c (? . 44) q flvector-copy)) q (36779 . 5)) ((c def c (c (? . 12) q sandbox-gui-available)) q (422785 . 4)) ((c def c (c (? . 0) q string-locale=?)) q (49875 . 4)) ((c def c (c (? . 10) q vector-append)) q (109478 . 3)) ((c form c (c (? . 9) q send)) q (180809 . 3)) ((c form c (c (? . 31) q control)) q (266446 . 2)) ((c def c (c (? . 0) q rename-file-or-directory)) q (444579 . 7)) ((c def c (c (? . 0) q syntax-property-preserved?)) q (313157 . 4)) ((c def c (c (? . 0) q char-downcase)) q (73144 . 3)) ((c def c (c (? . 6) q in-producer)) q (131119 . 7)) ((c def c (c (? . 0) q struct:exn:fail)) c (? . 74)) ((c def c (c (? . 0) q date*-nanosecond)) c (? . 63)) ((c def c (c (? . 0) q syntax-binding-set?)) q (289698 . 3)) ((c def c (c (? . 0) q bytes-utf-8-index)) q (68254 . 12)) ((c def c (c (? . 1) q unsafe-extfltan)) q (513233 . 3)) ((c def c (c (? . 37) q udp-receive!/enable-break)) q (466068 . 12)) ((c form c (c (? . 6) q struct-field-index)) q (165168 . 2)) ((c def c (c (? . 65) q promise/name?)) q (262381 . 3)) ((c def c (c (? . 44) q fltruncate)) q (34722 . 3)) ((c def c (c (? . 100) q with-intercepted-logging)) q (479661 . 17)) ((c form c (c (? . 13) q for*/weak-seteq)) q (150279 . 2)) ((c def c (c (? . 0) q will-executor?)) q (490126 . 3)) ((c def c (c (? . 0) q string-grapheme-count)) q (50856 . 6)) ((c def c (c (? . 2) q dict-iter-contract)) q (141895 . 3)) ((c def c (c (? . 21) q instance-variable-value)) q (434001 . 7)) ((c def c (c (? . 0) q string-ci>?)) q (49089 . 4)) ((c def c (c (? . 13) q weak-set)) q (147520 . 3)) ((c def c (c (? . 1) q unsafe-extflsqrt)) q (513644 . 3)) ((c def c (c (? . 19) q collapsible-ho/c?)) c (? . 94)) ((c def c (c (? . 0) q real?)) q (21864 . 3)) ((c def c (c (? . 3) q import-local-id)) c (? . 28)) ((c form c (c (? . 6) q module+)) q (1769 . 2)) ((c def c (c (? . 8) q in-combinations)) q (104515 . 6)) ((c form c (c (? . 65) q delay/strict)) q (262452 . 2)) ((c def c (c (? . 0) q read-square-bracket-as-paren)) q (362571 . 4)) ((c def c (c (? . 0) q string-titlecase)) q (49420 . 3)) ((c def c (c (? . 12) q kill-evaluator)) q (426233 . 3)) ((c form c (c (? . 65) q delay/thread)) q (262518 . 5)) ((c def c (c (? . 0) q exn:break-continuation)) c (? . 69)) ((c def c (c (? . 12) q exn:fail:resource-resource)) c (? . 101)) ((c def c (c (? . 16) q extflsqrt)) q (43334 . 3)) ((c def c (c (? . 18) q ~v)) q (54565 . 25)) ((c def c (c (? . 61) q prop:chaperone-contract)) q (225623 . 2)) ((c def c (c (? . 0) q struct:exn:break:terminate)) c (? . 121)) ((c def c (c (? . 14) q dynamic-place)) q (280396 . 9)) ((c def c (c (? . 0) q log-receiver?)) q (479372 . 3)) ((c def c (c (? . 0) q list->vector)) q (107986 . 3)) ((c def c (c (? . 0) q print-syntax-width)) q (367521 . 5)) ((c def c (c (? . 2) q in-dict-keys)) q (141516 . 3)) ((c form c (c (? . 142) q provide/contract)) q (214142 . 2)) ((c def c (c (? . 66) q blame-context)) q (224199 . 3)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:version)) c (? . 86)) ((c def c (c (? . 80) q current-date)) q (482416 . 2)) ((c def c (c (? . 0) q regexp-match-peek-positions/end)) q (86622 . 22)) ((c form c (c (? . 0) q #%require)) q (7214 . 41)) ((c def c (c (? . 0) q call-with-current-continuation)) q (263941 . 6)) ((c def c (c (? . 81) q build-chaperone-contract-property)) q (228685 . 51)) ((c def c (c (? . 0) q free-template-identifier=?)) q (293362 . 4)) ((c def c (c (? . 8) q dropf)) q (100736 . 4)) ((c form c (c (? . 102) q nand)) q (21610 . 2)) ((c def c (c (? . 0) q current-inexact-monotonic-milliseconds)) q (480910 . 2)) ((c def c (c (? . 23) q listof)) q (202470 . 3)) ((c form c (c (? . 103) q define/contract)) q (214719 . 3)) ((c def c (c (? . 0) q struct:exn:fail:syntax)) c (? . 104)) ((c def c (c (? . 0) q path?)) q (437027 . 3)) ((c form c (c (? . 105) q begin-encourage-inline)) q (19487 . 2)) ((c def c (c (? . 16) q extflceiling)) q (42712 . 3)) ((c def c (c (? . 6) q exn:fail:syntax)) c (? . 104)) ((c def c (c (? . 43) q getenv)) q (485682 . 3)) ((c def c (c (? . 3) q expand-import)) q (307993 . 4)) ((c form c (c (? . 39) q trace-define-syntax)) q (520523 . 3)) ((c def c (c (? . 0) q portal-syntax-content)) q (312003 . 3)) ((c def c (c (? . 6) q syntax-local-certifier)) q (306040 . 5)) ((c form c (c (? . 48) q match-letrec-values)) q (245046 . 2)) ((c def c (c (? . 0) q caar)) q (96045 . 3)) ((c def c (c (? . 0) q internal-definition-context-seal)) q (303139 . 3)) ((c def c (c (? . 9) q make-generic)) q (182351 . 4)) ((c def c (c (? . 0) q append)) q (92859 . 6)) ((c def c (c (? . 0) q peek-bytes-avail!*)) q (354291 . 14)) ((c def c (c (? . 25) q pretty-print-print-hook)) q (372886 . 5)) ((c def c (c (? . 0) q system-language+country)) q (486266 . 2)) ((c def c (c (? . 9) q exn:fail:object?)) c (? . 106)) ((c def c (c (? . 2) q dict-implements?)) q (137971 . 4)) ((c def c (c (? . 0) q channel-put-evt?)) q (274707 . 3)) ((c def c (c (? . 26) q >/c)) q (200424 . 3)) ((c def c (c (? . 1) q unsafe-fl>=)) q (493968 . 4)) ((c form c (c (? . 30) q time)) q (482390 . 2)) ((c def c (c (? . 0) q print-box)) q (366913 . 4)) ((c def c (c (? . 0) q port-file-unlock)) q (328080 . 3)) ((c def c (c (? . 8) q ninth)) q (99140 . 3)) ((c def c (c (? . 0) q default-continuation-prompt-tag)) q (263867 . 2)) ((c def c (c (? . 0) q make-set!-transformer)) q (297667 . 3)) ((c def c (c (? . 16) q extfl/)) q (41865 . 4)) ((c def c (c (? . 40) q coerce-flat-contracts)) q (222706 . 4)) ((c def c (c (? . 0) q byte?)) q (63816 . 3)) ((c form c (c (? . 31) q shift0-at)) q (267018 . 2)) ((c def c (c (? . 82) q cosh)) q (32808 . 3)) ((c def c (c (? . 0) q find-library-collection-links)) q (516851 . 5)) ((c def c (c (? . 21) q linklet-directory->hash)) q (432649 . 4)) ((c def c (c (? . 44) q fltan)) q (34938 . 3)) ((c def c (c (? . 0) q vector*-ref)) q (107393 . 4)) ((c def c (c (? . 43) q channel-put)) q (274536 . 4)) ((c def c (c (? . 0) q custodian-require-memory)) q (414364 . 7)) ((c def c (c (? . 1) q unsafe-vector*-set!)) q (498307 . 5)) ((c def c (c (? . 8) q list-set)) q (99593 . 5)) ((c def c (c (? . 0) q char->integer)) q (70645 . 3)) ((c def c (c (? . 13) q set-empty?)) q (151966 . 3)) ((c def c (c (? . 0) q hash-equal-always?)) q (114494 . 3)) ((c def c (c (? . 0) q floating-point-bytes->real)) q (31415 . 9)) ((c form c (c (? . 9) q interface*)) q (174663 . 7)) ((c def c (c (? . 0) q inexact-real?)) q (22225 . 3)) ((c form c (c (? . 41) q define-compound-unit)) q (195398 . 5)) ((c def c (c (? . 6) q in-immutable-hash)) q (128155 . 3)) ((c def c (c (? . 0) q char>=?)) q (71353 . 4)) ((c def c (c (? . 0) q hash-eqv?)) q (114564 . 3)) ((c def c (c (? . 0) q syntax-local-module-exports)) q (305413 . 5)) ((c def c (c (? . 122) q check-not-unsafe-undefined/assign)) q (516107 . 5)) ((c form c (c (? . 107) q include)) q (315967 . 6)) ((c def c (c (? . 12) q sandbox-error-output)) q (421585 . 14)) ((c def c (c (? . 1) q unsafe-bytes-ref)) q (499300 . 4)) ((c form c (c (? . 9) q inherit)) q (178248 . 2)) ((c def c (c (? . 1) q unsafe-fl=)) q (493631 . 4)) ((c def c (c (? . 1) q unsafe-u16vector-ref)) q (501027 . 4)) ((c def c (c (? . 0) q namespace?)) q (380074 . 3)) ((c def c (c (? . 13) q chaperone-hash-set)) q (155092 . 21)) ((c def c (c (? . 21) q correlated-source)) q (435213 . 3)) ((c def c (c (? . 15) q read-string!-evt)) q (347306 . 4)) ((c def c (c (? . 7) q stream-andmap)) q (136375 . 4)) ((c def c (c (? . 1) q unsafe-flimag-part)) q (495569 . 5)) ((c def c (c (? . 0) q replace-evt)) q (273729 . 4)) ((c def c (c (? . 0) q cddadr)) q (98257 . 3)) ((c def c (c (? . 0) q regexp-match-peek-positions-immediate/end)) q (87744 . 22)) ((c def c (c (? . 0) q plumber-flush-handle-remove!)) q (417626 . 3)) ((c def c (c (? . 0) q port-count-lines-enabled)) q (322292 . 4)) ((c def c (c (? . 30) q call-with-exception-handler)) q (254331 . 4)) ((c form c (c (? . 6) q for/hasheqv)) q (15448 . 2)) ((c def c (c (? . 0) q keyword?)) q (91578 . 3)) ((c def c (c (? . 42) q assf)) q (95927 . 4)) ((c def c (c (? . 16) q extfl->fx)) q (43759 . 3)) ((c def c (c (? . 51) q find-relative-path)) q (442262 . 12)) ((c def c (c (? . 12) q call-with-deep-time-limit)) q (428251 . 4)) ((c def c (c (? . 73) q checked-struct-info?)) q (173725 . 3)) ((c def c (c (? . 0) q struct:exn:fail:contract:continuation)) c (? . 108)) ((c def c (c (? . 0) q set-mcdr!)) q (106518 . 4)) ((c def c (c (? . 13) q weak-setalw)) q (147615 . 4)) ((c def c (c (? . 0) q write-string)) q (358639 . 7)) ((c def c (c (? . 0) q make-impersonator-property)) q (412484 . 6)) ((c def c (c (? . 43) q load-relative)) q (387146 . 3)) ((c def c (c (? . 19) q collapsible-wrapper-property)) c (? . 124)) ((c form c (c (? . 7) q for/stream)) q (137076 . 2)) ((c form c (c (? . 41) q prefix)) q (193716 . 2)) ((c def c (c (? . 15) q relocate-output-port)) q (343043 . 13)) ((c def c (c (? . 20) q tcp-listener?)) q (461559 . 3)) ((c def c (c (? . 0) q exn:fail?)) c (? . 74)) ((c def c (c (? . 19) q get-impersonator-prop:collapsible)) q (240874 . 3)) ((c def c (c (? . 13) q setalw)) q (146837 . 3)) ((c def c (c (? . 0) q current-module-declare-source)) q (393231 . 5)) ((c def c (c (? . 0) q always-evt)) q (273848 . 2)) ((c def c (c (? . 17) q group-write-bit)) q (459906 . 2)) ((c def c (c (? . 0) q real-part)) q (26104 . 3)) ((c def c (c (? . 0) q log-max-level)) q (478595 . 4)) ((c def c (c (? . 40) q value-contract)) q (236337 . 3)) ((c def c (c (? . 0) q gcd)) q (24119 . 3)) ((c def c (c (? . 0) q srcloc-source)) c (? . 59)) ((c def c (c (? . 1) q unsafe-s16vector-ref)) q (500777 . 4)) ((c form c (c (? . 136) q syntax-parameterize)) q (312131 . 2)) ((c def c (c (? . 0) q read-accept-infix-dot)) q (363857 . 4)) ((c def c (c (? . 9) q printable<%>)) q (188698 . 2)) ((c def c (c (? . 19) q collapsible-ho/c-latest-blame)) c (? . 94)) ((c def c (c (? . 0) q boolean?)) q (21193 . 3)) ((c def c (c (? . 0) q make-continuation-prompt-tag)) q (263708 . 4)) ((c form c (c (? . 54) q splicing-parameterize)) q (312691 . 2)) ((c def c (c (? . 1) q unsafe-fxmodulo)) q (491473 . 4)) ((c def c (c (? . 73) q prop:struct-auto-info)) q (174077 . 2)) ((c def c (c (? . 21) q correlated->datum)) q (435760 . 3)) ((c def c (c (? . 0) q identifier-binding)) q (293696 . 20)) ((c def c (c (? . 6) q in-weak-hash)) q (129075 . 3)) ((c def c (c (? . 72) q async-channel/c)) q (276580 . 3)) ((c form c (c (? . 49) q ...)) q (287599 . 2)) ((c def c (c (? . 51) q shrink-path-wrt)) q (443499 . 4)) ((c def c (c (? . 13) q set-map)) q (153864 . 4)) ((c form c (c (? . 6) q for*/and)) q (17152 . 2)) ((c def c (c (? . 0) q date*?)) c (? . 63)) ((c def c (c (? . 12) q sandbox-input)) q (420728 . 12)) ((c form c (c (? . 41) q invoke-unit)) q (193956 . 3)) ((c def c (c (? . 39) q current-prefix-in)) q (522000 . 4)) ((c def c (c (? . 21) q instance-variable-names)) q (433907 . 3)) ((c def c (c (? . 0) q hash)) q (114878 . 5)) ((c form c (c (? . 67) q define-runtime-module-path-index)) q (448621 . 2)) ((c def c (c (? . 0) q syntax-arm)) q (313638 . 5)) ((c def c (c (? . 1) q unsafe-fx>)) q (492858 . 4)) ((c def c (c (? . 88) q phase+space-phase)) q (319230 . 3)) ((c def c (c (? . 0) q read-accept-dot)) q (363763 . 4)) ((c form c (c (? . 53) q contract-first-order-try-less-hard)) q (238019 . 2)) ((c def c (c (? . 0) q hash-strong?)) q (114685 . 3)) ((c def c (c (? . 15) q read-bytes-evt)) q (346849 . 4)) ((c def c (c (? . 0) q raise-arity-mask-error*)) q (252275 . 9)) ((c def c (c (? . 21) q correlated-e)) q (435695 . 3)) ((c def c (c (? . 0) q read-language)) q (362271 . 5)) ((c def c (c (? . 82) q tanh)) q (32859 . 3)) ((c def c (c (? . 3) q make-require-transformer)) q (308112 . 5)) ((c form c (c (? . 54) q splicing-local)) q (312669 . 2)) ((c def c (c (? . 21) q compile-linklet)) q (429008 . 27)) ((c def c (c (? . 43) q path-add-suffix)) q (441396 . 4)) ((c def c (c (? . 1) q unsafe-flsqrt)) q (495009 . 3)) ((c def c (c (? . 2) q dict-set)) q (138731 . 5)) ((c def c (c (? . 8) q range)) q (103839 . 7)) ((c def c (c (? . 0) q integer->char)) q (70716 . 5)) ((c def c (c (? . 123) q hash/c)) q (204846 . 9)) ((c def c (c (? . 0) q will-register)) q (490186 . 5)) ((c def c (c (? . 78) q deserialize-module-guard)) q (376614 . 7)) ((c def c (c (? . 93) q generator-state)) q (137706 . 3)) ((c form c (c (? . 6) q protect-out)) q (6756 . 2)) ((c def c (c (? . 8) q splitf-at-right)) q (101401 . 4)) ((c def c (c (? . 44) q flexpt)) q (35306 . 4)) ((c def c (c (? . 0) q pseudo-random-generator->vector)) q (28157 . 4)) ((c def c (c (? . 0) q make-placeholder)) q (105547 . 3)) ((c def c (c (? . 23) q list/c)) q (203107 . 3)) ((c form c (c (? . 53) q contract)) q (216117 . 9)) ((c def c (c (? . 0) q mcons)) q (106282 . 4)) ((c def c (c (? . 0) q gensym)) q (73912 . 3)) ((c def c (c (? . 1) q unsafe-flabs)) q (493572 . 3)) ((c def c (c (? . 6) q in-range)) q (124555 . 7)) ((c def c (c (? . 22) q sequence-for-each)) q (134143 . 4)) ((c def c (c (? . 12) q break-evaluator)) q (426321 . 3)) ((c def c (c (? . 0) q make-channel)) q (274379 . 2)) ((c def c (c (? . 1) q unsafe-flceiling)) q (494345 . 3)) ((c def c (c (? . 16) q extflfloor)) q (42649 . 3)) ((c def c (c (? . 6) q in-mlist)) q (124995 . 3)) ((c def c (c (? . 17) q put-preferences)) q (457089 . 9)) ((c def c (c (? . 0) q abort-current-continuation)) q (263557 . 5)) ((c def c (c (? . 66) q blame-positive)) q (224276 . 3)) ((c def c (c (? . 40) q coerce-flat-contract)) q (222611 . 4)) ((c def c (c (? . 0) q -)) q (23251 . 6)) ((c def c (c (? . 0) q make-struct-field-accessor)) q (166934 . 12)) ((c def c (c (? . 0) q prop:liberal-define-context)) q (307864 . 2)) ((c def c (c (? . 66) q current-blame-format)) q (225410 . 4)) ((c def c (c (? . 0) q exn:fail:syntax:missing-module-path)) c (? . 52)) ((c def c (c (? . 0) q caadr)) q (96383 . 3)) ((c def c (c (? . 0) q vector-copy!)) q (108253 . 11)) ((c form c (c (? . 9) q rename-super)) q (178371 . 2)) ((c form c (c (? . 31) q shift0)) q (266835 . 2)) ((c def c (c (? . 3) q convert-relative-module-path)) q (309361 . 6)) ((c def c (c (? . 76) q current-recorded-disappeared-uses)) q (317767 . 5)) ((c form c (c (? . 0) q let-values)) q (12055 . 2)) ((c form c (c (? . 41) q unit/s)) q (196640 . 6)) ((c def c (c (? . 1) q unsafe-extfl>)) q (512362 . 4)) ((c form c (c (? . 30) q parameterize)) q (278362 . 5)) ((c def c (c (? . 0) q ephemeron-value)) q (489862 . 5)) ((c def c (c (? . 30) q hash-update!)) q (119029 . 11)) ((c def c (c (? . 15) q call-with-input-bytes)) q (336427 . 4)) ((c form c (c (? . 9) q define/augride)) q (179398 . 3)) ((c def c (c (? . 0) q portal-syntax?)) q (311867 . 3)) ((c def c (c (? . 0) q read-line)) q (349696 . 5)) ((c def c (c (? . 0) q lcm)) q (24178 . 3)) ((c def c (c (? . 82) q nonpositive-integer?)) q (33515 . 3)) ((c def c (c (? . 0) q current-gc-milliseconds)) q (482127 . 2)) ((c def c (c (? . 20) q tcp-accept)) q (461197 . 3)) ((c form c (c (? . 6) q provide)) q (5573 . 24)) ((c form c (c (? . 6) q all-from-out)) q (6507 . 2)) ((c def c (c (? . 6) q make-exn:fail:filesystem:errno)) c (? . 84)) ((c def c (c (? . 6) q regexp-match-positions*)) q (78823 . 17)) ((c def c (c (? . 25) q pretty-printing)) q (373436 . 4)) ((c def c (c (? . 0) q exn:fail:network:errno-errno)) c (? . 95)) ((c def c (c (? . 0) q continuation?)) q (265290 . 3)) ((c form c (c (? . 31) q %)) q (266215 . 4)) ((c def c (c (? . 18) q ~a)) q (53333 . 25)) ((c def c (c (? . 26) q not/c)) q (200224 . 3)) ((c def c (c (? . 0) q write-byte)) q (358433 . 4)) ((c def c (c (? . 32) q exn:fail:support?)) c (? . 109)) ((c def c (c (? . 0) q read-accept-box)) q (363039 . 4)) ((c def c (c (? . 25) q pretty-print-size-hook)) q (372600 . 9)) ((c def c (c (? . 26) q parameter/c)) q (204475 . 7)) ((c def c (c (? . 13) q list->setalw)) q (148001 . 4)) ((c def c (c (? . 0) q unquoted-printing-string?)) q (254072 . 3)) ((c def c (c (? . 51) q path-get-extension)) q (441876 . 3)) ((c def c (c (? . 76) q wrong-syntax)) q (317639 . 5)) ((c def c (c (? . 13) q mutable-set)) q (147102 . 4)) ((c def c (c (? . 0) q use-collection-link-paths)) q (519166 . 4)) ((c def c (c (? . 93) q sequence->generator)) q (137771 . 3)) ((c def c (c (? . 1) q unsafe-vector-ref)) q (497899 . 4)) ((c def c (c (? . 26) q char-in)) q (200872 . 4)) ((c def c (c (? . 0) q vector->list)) q (107925 . 3)) ((c form c (c (? . 9) q this)) q (177609 . 2)) ((c def c (c (? . 0) q dynamic-wind)) q (265419 . 7)) ((c def c (c (? . 30) q current-parameterization)) q (278949 . 2)) ((c def c (c (? . 17) q other-read-bit)) q (460019 . 2)) ((c form c (c (? . 27) q let)) q (11856 . 3)) ((c def c (c (? . 0) q current-read-interaction)) q (389857 . 4)) ((c form c (c (? . 27) q unless)) q (14363 . 2)) ((c def c (c (? . 0) q call-with-continuation-barrier)) q (264995 . 3)) ((c def c (c (? . 0) q current-custodian)) q (414084 . 4)) ((c def c (c (? . 73) q struct:struct-info)) q (173986 . 2)) ((c form c (c (? . 41) q unit/c)) q (197473 . 16)) ((c def c (c (? . 0) q current-code-inspector)) q (416985 . 4)) ((c def c (c (? . 1) q unsafe-fl<)) q (493715 . 4)) ((c def c (c (? . 0) q current-module-name-resolver)) q (392456 . 19)) ((c def c (c (? . 0) q syntax-binding-set->syntax)) q (289819 . 5)) ((c form c (c (? . 0) q case-lambda)) q (11681 . 6)) ((c def c (c (? . 6) q regexp-replace-quote)) q (91446 . 5)) ((c def c (c (? . 16) q extflacos)) q (43088 . 3)) ((c def c (c (? . 75) q engine-run)) q (282647 . 4)) ((c def c (c (? . 1) q unsafe-vector*->immutable-vector!)) q (498631 . 4)) ((c def c (c (? . 0) q peek-string)) q (352228 . 5)) ((c def c (c (? . 0) q call-with-semaphore)) q (275366 . 9)) ((c def c (c (? . 0) q resolved-module-path-name)) q (392059 . 8)) ((c def c (c (? . 37) q udp-set-receive-buffer-size!)) q (466502 . 5)) ((c def c (c (? . 6) q in-ephemeron-hash-values)) q (130425 . 3)) ((c def c (c (? . 29) q string-replace)) q (52077 . 6)) ((c def c (c (? . 0) q read-accept-quasiquote)) q (364045 . 4)) ((c def c (c (? . 42) q filter)) q (93614 . 4)) ((c def c (c (? . 0) q symbol?)) q (73439 . 3)) ((c form c (c (? . 102) q nor)) q (21635 . 2)) ((c def c (c (? . 42) q compose1)) q (157903 . 3)) ((c def c (c (? . 43) q reroot-path)) q (441555 . 4)) ((c def c (c (? . 15) q relocate-input-port)) q (342523 . 13)) ((c def c (c (? . 0) q read-accept-lang)) q (364253 . 4)) ((c def c (c (? . 15) q copy-port)) q (349384 . 4)) ((c def c (c (? . 0) q load/use-compiled)) q (388536 . 3)) ((c form c (c (? . 46) q serializable-struct/versions)) q (377160 . 7)) ((c def c (c (? . 2) q prop:dict/contract)) q (141714 . 2)) ((c def c (c (? . 0) q list->string)) q (48113 . 3)) ((c def c (c (? . 0) q prop:checked-procedure)) q (162034 . 2)) ((c def c (c (? . 51) q simple-form-path)) q (443204 . 3)) ((c def c (c (? . 0) q make-security-guard)) q (412930 . 16)) ((c def c (c (? . 1) q unsafe-extflsin)) q (513097 . 3)) ((c def c (c (? . 6) q memw)) q (94921 . 4)) ((c def c (c (? . 40) q impersonator-contract?)) q (236089 . 3)) ((c def c (c (? . 19) q build-collapsible-contract-property)) q (239337 . 15)) ((c def c (c (? . 0) q current-thread-group)) q (415299 . 4)) ((c def c (c (? . 0) q >=)) q (25092 . 4)) ((c def c (c (? . 10) q vector-argmin)) q (110722 . 4)) ((c form c (c (? . 9) q new)) q (180495 . 2)) ((c def c (c (? . 20) q port-number?)) q (462122 . 2)) ((c def c (c (? . 0) q current-environment-variables)) q (484413 . 4)) ((c def c (c (? . 32) q raise-support-error)) q (170160 . 4)) ((c def c (c (? . 0) q srcloc-column)) c (? . 59)) ((c def c (c (? . 0) q char-blank?)) q (72528 . 3)) ((c def c (c (? . 11) q fxmin)) q (39575 . 4)) ((c def c (c (? . 110) q getpid)) q (489510 . 2)) ((c def c (c (? . 25) q pretty-print-extend-style-table)) q (371458 . 8)) ((c form c (c (? . 93) q generator)) q (137393 . 6)) ((c def c (c (? . 6) q make-exn:fail:contract:arity)) c (? . 111)) ((c form c (c (? . 9) q augride*)) q (178701 . 2)) ((c def c (c (? . 5) q conjoin)) q (163061 . 4)) ((c form c (c (? . 30) q log-warning)) q (479154 . 3)) ((c def c (c (? . 112) q fasl->s-exp)) q (379089 . 9)) ((c def c (c (? . 8) q append*)) q (102591 . 7)) ((c def c (c (? . 115) q make-constructor-style-printer)) q (173228 . 6)) ((c def c (c (? . 43) q channel-try-get)) q (274475 . 3)) ((c def c (c (? . 9) q class-unseal)) q (191382 . 5)) ((c def c (c (? . 22) q sequence-ormap)) q (134039 . 4)) ((c def c (c (? . 0) q bytes->string/latin-1)) q (66239 . 9)) ((c def c (c (? . 0) q subprocess-status)) q (471458 . 4)) ((c def c (c (? . 9) q struct:exn:fail:object)) c (? . 106)) ((c def c (c (? . 0) q environment-variables-copy)) q (485575 . 3)) ((c def c (c (? . 29) q non-empty-string?)) q (52983 . 3)) ((c def c (c (? . 1) q unsafe-fx+)) q (491095 . 3)) ((c def c (c (? . 12) q call-with-killing-threads)) c (? . 139)) ((c def c (c (? . 6) q regexp-match-exact?)) q (80448 . 4)) ((c def c (c (? . 73) q struct-field-info-list)) q (174444 . 3)) ((c def c (c (? . 9) q generate-member-key)) q (180070 . 2)) ((c form c (c (? . 9) q send/keyword-apply)) q (180975 . 4)) ((c def c (c (? . 1) q unsafe-flmax)) q (494138 . 4)) ((c def c (c (? . 11) q fxmax)) q (39653 . 4)) ((c def c (c (? . 0) q system-path-convention-type)) q (438446 . 2)) ((c form c (c (? . 23) q flat-murec-contract)) q (205939 . 2)) ((c def c (c (? . 16) q extflcos)) q (42904 . 3)) ((c form c (c (? . 7) q stream*)) q (135684 . 2)) ((c def c (c (? . 0) q exn:fail:read-srclocs)) c (? . 85)) ((c def c (c (? . 0) q bytes-convert-end)) q (69756 . 13)) ((c def c (c (? . 1) q unsafe-fxxor)) q (491743 . 3)) ((c def c (c (? . 81) q skip-projection-wrapper?)) q (222898 . 5)) ((c def c (c (? . 42) q remw)) q (93952 . 4)) ((c def c (c (? . 39) q current-trace-print-args)) q (521006 . 14)) ((c def c (c (? . 6) q in-hash-pairs)) q (126906 . 6)) ((c def c (c (? . 0) q eqv-hash-code)) q (21020 . 3)) ((c def c (c (? . 0) q read-char-or-special)) q (355627 . 8)) ((c def c (c (? . 16) q extfl->floating-point-bytes)) q (45987 . 10)) ((c def c (c (? . 0) q make-hash-placeholder)) q (105838 . 3)) ((c def c (c (? . 26) q if/c)) q (238066 . 5)) ((c def c (c (? . 42) q reverse)) q (92984 . 3)) ((c def c (c (? . 37) q udp-multicast-set-interface!)) q (469298 . 5)) ((c def c (c (? . 0) q syntax-bound-symbols)) q (297189 . 8)) ((c def c (c (? . 2) q in-dict)) q (141456 . 3)) ((c form c (c (? . 56) q for/async)) q (279648 . 2)) ((c def c (c (? . 0) q liberal-define-context?)) q (307924 . 3)) ((c def c (c (? . 23) q the-unsupplied-arg)) q (212537 . 2)) ((c def c (c (? . 1) q unsafe-flsingle)) q (494472 . 3)) ((c def c (c (? . 0) q mcar)) q (106350 . 3)) ((c def c (c (? . 2) q prop:dict)) q (138355 . 2)) ((c def c (c (? . 19) q collapsible-property-neg-party)) c (? . 113)) ((c def c (c (? . 0) q atan)) q (25817 . 6)) ((c def c (c (? . 23) q symbols)) q (201196 . 3)) ((c def c (c (? . 80) q find-seconds)) q (483449 . 15)) ((c def c (c (? . 18) q ~.v)) q (61018 . 25)) ((c def c (c (? . 0) q ephemeron?)) q (490019 . 3)) ((c def c (c (? . 9) q object?)) q (188765 . 3)) ((c def c (c (? . 0) q equal-secondary-hash-code)) q (20749 . 3)) ((c form c (c (? . 6) q #%app)) q (11097 . 2)) ((c def c (c (? . 6) q exn:fail:read:eof)) c (? . 114)) ((c def c (c (? . 0) q regexp-match/end)) q (84953 . 20)) ((c def c (c (? . 17) q user-execute-bit)) q (459795 . 2)) ((c def c (c (? . 0) q error-escape-handler)) q (254729 . 4)) ((c def c (c (? . 0) q object-name)) q (416884 . 3)) ((c def c (c (? . 0) q print-boolean-long-form)) q (367193 . 4)) ((c def c (c (? . 24) q export-protect?)) c (? . 68)) ((c def c (c (? . 5) q normalize-arity)) q (163574 . 4)) ((c def c (c (? . 12) q sandbox-security-guard)) q (423062 . 5)) ((c def c (c (? . 0) q exn:fail:unsupported?)) c (? . 119)) ((c def c (c (? . 2) q dict-can-functional-set?)) q (138269 . 3)) ((c def c (c (? . 6) q regexp-try-match)) q (77252 . 14)) ((c def c (c (? . 115) q struct->list)) q (173508 . 4)) ((c def c (c (? . 1) q unsafe-stencil-vector-ref)) q (501704 . 4)) ((c def c (c (? . 42) q remw*)) q (94304 . 4)) ((c def c (c (? . 0) q syntax-transforming?)) q (306192 . 2)) ((c def c (c (? . 0) q prop:sealed)) q (168141 . 2)) ((c def c (c (? . 0) q variable-reference->module-source)) q (385479 . 4)) ((c def c (c (? . 7) q stream-filter)) q (136892 . 4)) ((c form c (c (? . 9) q define-serializable-class)) q (188571 . 3)) ((c def c (c (? . 0) q string-foldcase)) q (49493 . 3)) ((c def c (c (? . 0) q set-port-next-location!)) q (321922 . 9)) ((c def c (c (? . 0) q readtable-mapping)) q (374597 . 9)) ((c def c (c (? . 0) q internal-definition-context-binding-identifiers)) q (302672 . 4)) ((c def c (c (? . 13) q set-symmetric-difference!)) q (153410 . 4)) ((c form c (c (? . 5) q thunk*)) q (162968 . 2)) ((c def c (c (? . 40) q contract-projection)) q (236727 . 3)) ((c def c (c (? . 16) q extfl-)) q (41699 . 4)) ((c def c (c (? . 0) q string)) q (46587 . 3)) ((c def c (c (? . 13) q set-clear)) q (152527 . 3)) ((c def c (c (? . 15) q filter-read-input-port)) q (345101 . 27)) ((c def c (c (? . 0) q date?)) c (? . 60)) ((c def c (c (? . 0) q set-box!)) q (113909 . 4)) ((c def c (c (? . 130) q hash-union)) q (123010 . 12)) ((c def c (c (? . 44) q flacos)) q (35043 . 3)) ((c def c (c (? . 1) q unsafe-fl*)) q (493427 . 3)) ((c def c (c (? . 78) q make-deserialize-info)) q (377803 . 4)) ((c def c (c (? . 5) q identity)) q (162776 . 3)) ((c def c (c (? . 0) q char-upcase)) q (73084 . 3)) ((c def c (c (? . 0) q caddr)) q (96547 . 3)) ((c def c (c (? . 0) q angle)) q (26295 . 3)) ((c def c (c (? . 6) q hash-set*)) q (118196 . 5)) ((c def c (c (? . 116) q map)) q (93038 . 4)) ((c def c (c (? . 0) q procedure-struct-type?)) q (161808 . 3)) ((c form c (c (? . 9) q init)) q (177667 . 2)) ((c def c (c (? . 12) q sandbox-output)) q (421127 . 14)) ((c def c (c (? . 0) q module-compiled-name)) q (394855 . 9)) ((c def c (c (? . 15) q peek-bytes-evt)) c (? . 117)) ((c def c (c (? . 0) q make-parameter)) q (278185 . 5)) ((c def c (c (? . 0) q system-library-subpath)) q (486315 . 3)) ((c def c (c (? . 0) q port-file-identity)) q (328157 . 3)) ((c form c (c (? . 6) q for/foldr/derived)) q (18054 . 4)) ((c def c (c (? . 0) q close-output-port)) q (320058 . 3)) ((c form c (c (? . 23) q case->)) q (211097 . 9)) ((c def c (c (? . 43) q port?)) q (319940 . 3)) ((c def c (c (? . 14) q place-break)) q (281536 . 4)) ((c def c (c (? . 0) q impersonator-prop:application-mark)) q (412801 . 2)) ((c form c (c (? . 13) q for/seteq)) q (149181 . 2)) ((c form c (c (? . 40) q define/subexpression-pos-prop)) q (235435 . 6)) ((c def c (c (? . 6) q exn:fail:read:non-char)) c (? . 58)) ((c form c (c (? . 0) q letrec-values)) q (12180 . 2)) ((c def c (c (? . 41) q unit?)) q (197371 . 3)) ((c def c (c (? . 0) q raise-result-arity-error)) q (252584 . 9)) ((c def c (c (? . 7) q stream-ormap)) q (136476 . 4)) ((c def c (c (? . 0) q locale-string-encoding)) q (70352 . 2)) ((c def c (c (? . 0) q parameter-procedure=?)) q (278853 . 4)) ((c def c (c (? . 6) q gen:equal-mode+hash)) q (21109 . 2)) ((c def c (c (? . 0) q file-exists?)) q (444195 . 3)) ((c def c (c (? . 0) q write-bytes)) q (358919 . 7)) ((c form c (c (? . 9) q generic)) q (182183 . 2)) ((c def c (c (? . 0) q exn:fail:contract:divide-by-zero?)) c (? . 118)) ((c def c (c (? . 0) q struct:exn:fail:unsupported)) c (? . 119)) ((c def c (c (? . 0) q find-system-path)) q (443620 . 3)) ((c def c (c (? . 0) q system-type)) q (485989 . 6)) ((c def c (c (? . 0) q readtable?)) q (374150 . 3)) ((c def c (c (? . 102) q false)) q (21376 . 2)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-next)) q (507402 . 4)) ((c def c (c (? . 0) q free-transformer-identifier=?)) q (293244 . 4)) ((c def c (c (? . 43) q path-replace-extension)) q (440853 . 4)) ((c def c (c (? . 44) q flimag-part)) q (35914 . 5)) ((c def c (c (? . 17) q other-write-bit)) q (460053 . 2)) ((c def c (c (? . 116) q ormap)) q (93211 . 4)) ((c form c (c (? . 2) q define-custom-hash-types)) q (141960 . 12)) ((c def c (c (? . 56) q future?)) q (279466 . 3)) ((c def c (c (? . 21) q correlated-span)) q (435592 . 3)) ((c def c (c (? . 8) q take-right)) q (100911 . 4)) ((c form c (c (? . 0) q #%provide)) q (9130 . 31)) ((c def c (c (? . 0) q rational?)) q (21915 . 3)) ((c def c (c (? . 9) q member-name-key-hash-code)) q (180306 . 3)) ((c def c (c (? . 0) q integer?)) q (21970 . 3)) ((c def c (c (? . 0) q integer->integer-bytes)) q (30842 . 14)) ((c form c (c (? . 9) q private*)) q (178777 . 2)) ((c form c (c (? . 34) q trait-rename-field)) q (183709 . 2)) ((c form c (c (? . 6) q planet)) q (5267 . 5)) ((c def c (c (? . 0) q file-or-directory-type)) q (444337 . 5)) ((c def c (c (? . 6) q make-exn:fail:contract:variable)) c (? . 120)) ((c def c (c (? . 57) q contract-exercise)) q (242815 . 7)) ((c def c (c (? . 16) q extflatan)) q (43150 . 3)) ((c def c (c (? . 73) q struct-field-info?)) q (174380 . 3)) ((c def c (c (? . 0) q dump-memory-stats)) q (490740 . 3)) ((c def c (c (? . 0) q namespace-set-variable-value!)) q (381392 . 11)) ((c def c (c (? . 26) q between/c)) q (200591 . 4)) ((c def c (c (? . 0) q syntax-transforming-module-expression?)) q (306297 . 2)) ((c def c (c (? . 44) q flvector-ref)) q (36539 . 4)) ((c def c (c (? . 6) q exn:break:terminate)) c (? . 121)) ((c def c (c (? . 0) q impersonate-box)) q (402161 . 12)) ((c def c (c (? . 0) q syntax->list)) q (288552 . 3)) ((c def c (c (? . 0) q eval-syntax)) q (386363 . 6)) ((c def c (c (? . 11) q fx+/wraparound)) q (38855 . 4)) ((c def c (c (? . 122) q check-not-unsafe-undefined)) q (515964 . 5)) ((c def c (c (? . 15) q transplant-input-port)) q (343573 . 19)) ((c form c (c (? . 54) q splicing-letrec-syntaxes)) q (312598 . 2)) ((c def c (c (? . 48) q prop:match-expander)) q (245379 . 2)) ((c def c (c (? . 43) q load/cd)) q (387213 . 3)) ((c def c (c (? . 72) q chaperone-async-channel)) q (277133 . 13)) ((c def c (c (? . 76) q generate-temporary)) q (318339 . 3)) ((c def c (c (? . 0) q integer-length)) q (27079 . 3)) ((c def c (c (? . 0) q syntax-original?)) q (288253 . 3)) ((c def c (c (? . 6) q hash-map/copy)) q (120532 . 5)) ((c def c (c (? . 0) q cddaar)) q (98157 . 3)) ((c def c (c (? . 0) q procedure?)) q (157630 . 3)) ((c def c (c (? . 2) q make-custom-hash-types)) q (142453 . 24)) ((c def c (c (? . 82) q exact-floor)) q (32977 . 3)) ((c def c (c (? . 73) q struct-info?)) q (173667 . 3)) ((c def c (c (? . 2) q make-weak-custom-hash)) q (144493 . 14)) ((c def c (c (? . 31) q call/comp)) q (265974 . 5)) ((c form c (c (? . 31) q shift)) q (266607 . 2)) ((c def c (c (? . 0) q module-compiled-cross-phase-persistent?)) q (396775 . 4)) ((c def c (c (? . 116) q for-each)) q (93297 . 4)) ((c form c (c (? . 27) q or)) q (13114 . 2)) ((c def c (c (? . 0) q subprocess-pid)) q (471722 . 3)) ((c def c (c (? . 1) q unsafe-flfloor)) q (494284 . 3)) ((c def c (c (? . 0) q cdddr)) q (96875 . 3)) ((c def c (c (? . 88) q phase+space+)) q (319438 . 4)) ((c def c (c (? . 0) q set!-transformer-procedure)) q (297770 . 4)) ((c def c (c (? . 65) q promise-running?)) q (262272 . 3)) ((c def c (c (? . 49) q syntax-pattern-variable?)) q (287639 . 3)) ((c def c (c (? . 42) q findf)) q (95348 . 4)) ((c def c (c (? . 0) q write-special-evt)) q (361010 . 4)) ((c def c (c (? . 1) q unsafe-weak-hash-iterate-first)) q (507290 . 3)) ((c def c (c (? . 51) q path-element?)) q (443015 . 3)) ((c def c (c (? . 23) q dynamic->*)) q (211283 . 19)) ((c def c (c (? . 1) q unsafe-fx-/wraparound)) q (492418 . 4)) ((c def c (c (? . 30) q hash-ref!)) q (118822 . 5)) ((c def c (c (? . 0) q raise-mismatch-error)) q (251017 . 8)) ((c def c (c (? . 0) q string-fill!)) q (47755 . 4)) ((c def c (c (? . 6) q regexp-match*)) q (76235 . 20)) ((c def c (c (? . 40) q has-contract?)) q (236418 . 3)) ((c def c (c (? . 13) q set-subtract)) q (153086 . 4)) ((c form c (c (? . 41) q unit-from-context)) q (196163 . 2)) ((c def c (c (? . 0) q prop:output-port)) q (329597 . 2)) ((c def c (c (? . 0) q make-reader-graph)) q (105429 . 3)) ((c def c (c (? . 0) q variable-reference->phase)) q (385626 . 3)) ((c def c (c (? . 82) q radians->degrees)) q (32498 . 3)) ((c def c (c (? . 0) q struct-type-property-accessor-procedure?)) q (169071 . 3)) ((c def c (c (? . 26) q string-len/c)) q (200992 . 3)) ((c def c (c (? . 29) q string-normalize-spaces)) q (51620 . 11)) ((c def c (c (? . 2) q make-immutable-custom-hash)) q (145226 . 14)) ((c def c (c (? . 0) q pseudo-random-generator-vector?)) q (28620 . 3)) ((c def c (c (? . 0) q bound-identifier=?)) q (292619 . 6)) ((c def c (c (? . 11) q fx-)) q (37788 . 4)) ((c def c (c (? . 0) q make-file-or-directory-link)) q (446964 . 4)) ((c def c (c (? . 6) q in-bytes)) q (125529 . 6)) ((c def c (c (? . 0) q struct:exn:fail:contract:non-fixnum-result)) c (? . 97)) ((c def c (c (? . 1) q unsafe-fl/)) q (493489 . 4)) ((c def c (c (? . 6) q procedure-keywords)) q (159898 . 4)) ((c def c (c (? . 0) q date*-time-zone-name)) c (? . 63)) ((c def c (c (? . 0) q continuation-mark-set->list)) q (267823 . 8)) ((c def c (c (? . 17) q make-temporary-file)) q (453928 . 13)) ((c def c (c (? . 0) q date-year-day)) c (? . 60)) ((c def c (c (? . 7) q stream-tail)) q (136033 . 4)) ((c def c (c (? . 15) q port->string)) q (334725 . 4)) ((c def c (c (? . 1) q unsafe-bytes->immutable-bytes!)) q (499926 . 4)) ((c def c (c (? . 93) q sequence->repeated-generator)) q (137841 . 3)) ((c form c (c (? . 38) q class/c)) q (183761 . 28)) ((c def c (c (? . 6) q procedure-reduce-keyword-arity)) q (160386 . 14)) ((c def c (c (? . 1) q unsafe-fx=)) q (492690 . 4)) ((c def c (c (? . 8) q take-common-prefix)) q (101641 . 5)) ((c def c (c (? . 1) q unsafe-char=?)) q (496006 . 4)) ((c form c (c (? . 65) q delay/sync)) q (262486 . 2)) ((c def c (c (? . 0) q read-syntax)) q (361360 . 4)) ((c def c (c (? . 57) q contract-random-generate-env?)) q (243365 . 3)) ((c form c (c (? . 41) q rename)) q (193675 . 2)) ((c def c (c (? . 0) q current-get-interaction-input-port)) q (389575 . 4)) ((c def c (c (? . 42) q build-list)) q (92451 . 4)) ((c def c (c (? . 0) q byte-pregexp?)) q (74357 . 3)) ((c form c (c (? . 0) q unquote)) q (19273 . 2)) ((c def c (c (? . 0) q hash-equal?)) q (114431 . 3)) ((c def c (c (? . 0) q break-enabled)) q (270273 . 4)) ((c def c (c (? . 0) q syntax-debug-info)) q (292346 . 5)) ((c def c (c (? . 42) q remove*)) q (94022 . 5)) ((c def c (c (? . 1) q unsafe-fxmax)) q (493197 . 4)) ((c def c (c (? . 0) q file-position*)) q (321366 . 3)) ((c form c (c (? . 6) q for*/fold)) q (17536 . 3)) ((c def c (c (? . 1) q unsafe-fx->extfl)) q (513806 . 3)) ((c form c (c (? . 0) q set!)) q (14402 . 2)) ((c def c (c (? . 0) q filesystem-change-evt?)) q (448022 . 3)) ((c form c (c (? . 6) q #%plain-app)) q (11162 . 3)) ((c def c (c (? . 0) q inspector?)) q (415420 . 3)) ((c def c (c (? . 11) q fx*/wraparound)) q (39019 . 4)) ((c def c (c (? . 0) q call-with-continuation-prompt)) q (263146 . 10)) ((c def c (c (? . 1) q unsafe-fx*)) q (491240 . 3)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-pair)) q (510858 . 5)) ((c form c (c (? . 123) q hash/dc)) q (205175 . 7)) ((c def c (c (? . 0) q module-path?)) q (392398 . 3)) ((c form c (c (? . 30) q log-fatal)) q (479010 . 3)) ((c def c (c (? . 56) q current-future)) q (279414 . 2)) ((c form c (c (? . 23) q ->)) q (206577 . 12)) ((c form c (c (? . 41) q link)) q (193822 . 2)) ((c def c (c (? . 0) q pregexp?)) q (74245 . 3)) ((c def c (c (? . 0) q hasheq)) q (115154 . 5)) ((c def c (c (? . 82) q negative-integer?)) q (33452 . 3)) ((c def c (c (? . 21) q linklet-body-reserved-symbol?)) q (433172 . 3)) ((c def c (c (? . 6) q hash-keys)) q (120748 . 4)) ((c def c (c (? . 0) q syntax-binding-set)) q (289763 . 2)) ((c def c (c (? . 10) q vector-map)) q (109253 . 4)) ((c form c (c (? . 6) q :do-in)) q (18596 . 9)) ((c form c (c (? . 48) q failure-cont)) q (245261 . 2)) ((c def c (c (? . 0) q file-position)) q (321166 . 6)) ((c def c (c (? . 23) q property/c)) q (206271 . 5)) ((c def c (c (? . 0) q syntax-property-remove)) q (313061 . 4)) ((c def c (c (? . 0) q continuation-prompt-available?)) q (265078 . 5)) ((c def c (c (? . 0) q make-environment-variables)) q (484644 . 5)) ((c def c (c (? . 98) q vector-immutableof)) q (201635 . 3)) ((c form c (c (? . 107) q include-at/relative-to/reader)) q (316192 . 2)) ((c def c (c (? . 13) q weak-seteqv)) q (147721 . 3)) ((c def c (c (? . 6) q sequence?)) q (124500 . 3)) ((c def c (c (? . 7) q stream-fold)) q (136671 . 5)) ((c def c (c (? . 42) q sort)) q (94383 . 9)) ((c def c (c (? . 15) q call-with-output-bytes)) q (336068 . 3)) ((c def c (c (? . 9) q dynamic-get-field)) q (181774 . 4)) ((c def c (c (? . 0) q struct:date)) c (? . 60)) ((c def c (c (? . 0) q cadadr)) q (97457 . 3)) ((c def c (c (? . 26) q flat-named-contract)) q (199618 . 8)) ((c def c (c (? . 19) q collapsible-property-ref)) c (? . 113)) ((c def c (c (? . 0) q semaphore-peek-evt)) q (275215 . 3)) ((c def c (c (? . 10) q vector-take-right)) q (109653 . 4)) ((c def c (c (? . 30) q break-parameterization?)) q (270680 . 3)) ((c def c (c (? . 0) q call-with-composable-continuation)) q (264391 . 6)) ((c def c (c (? . 0) q string->uninterned-symbol)) q (73760 . 3)) ((c def c (c (? . 19) q struct:collapsible-wrapper-property)) c (? . 124)) ((c def c (c (? . 0) q hash-for-each)) q (121208 . 5)) ((c form c (c (? . 9) q mixin)) q (182477 . 3)) ((c def c (c (? . 1) q unsafe-stencil-vector)) q (501267 . 4)) ((c def c (c (? . 44) q fl=)) q (34015 . 4)) ((q form ((lib "racket/local.rkt") local)) q (12665 . 2)) ((c def c (c (? . 0) q read-decimal-as-inexact)) q (363553 . 4)) ((c def c (c (? . 40) q contract-equivalent?)) q (235678 . 4)) ((c def c (c (? . 1) q unsafe-struct-set!)) q (502501 . 5)) ((c def c (c (? . 16) q extflabs)) q (41948 . 3)) ((c def c (c (? . 100) q with-logging-to-port)) q (480347 . 12)) ((c def c (c (? . 0) q struct-type-make-constructor)) q (416559 . 6)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:errno)) c (? . 84)) ((c def c (c (? . 0) q file-size)) q (446215 . 3)) ((c form c (c (? . 27) q letrec-syntaxes)) q (12428 . 2)) ((c def c (c (? . 0) q peek-string!)) q (352670 . 12)) ((c def c (c (? . 0) q =)) q (24803 . 4)) ((c form c (c (? . 13) q for/weak-setalw)) q (150169 . 2)) ((c form c (c (? . 30) q with-handlers*)) q (254656 . 3)) ((c def c (c (? . 78) q make-serialize-info)) q (377979 . 13)) ((c def c (c (? . 88) q phase+space-shift?)) q (319374 . 3)) ((c def c (c (? . 6) q make-date)) c (? . 60)) ((c def c (c (? . 0) q exn:fail:read:eof?)) c (? . 114)) ((c def c (c (? . 0) q current-directory-for-user)) q (447346 . 4)) ((c def c (c (? . 0) q bitwise-ior)) q (26345 . 3)) ((c def c (c (? . 13) q impersonate-hash-set)) q (154141 . 21)) ((c def c (c (? . 6) q chaperone-procedure)) q (405679 . 11)) ((c def c (c (? . 29) q string-trim)) q (52587 . 11)) ((c def c (c (? . 25) q pretty-print-post-print-hook)) q (373256 . 5)) ((c def c (c (? . 0) q read-bytes!)) q (350764 . 7)) ((c def c (c (? . 0) q char-numeric?)) q (72195 . 3)) ((c def c (c (? . 0) q build-path)) q (438515 . 6)) ((c form c (c (? . 107) q include/reader)) q (316144 . 2)) ((c def c (c (? . 0) q stencil-vector-length)) q (112887 . 4)) ((c def c (c (? . 19) q collapsible-property?)) c (? . 113)) ((c def c (c (? . 10) q vector-set*!)) q (109089 . 5)) ((c def c (c (? . 1) q unsafe-fxpopcount32)) q (492125 . 3)) ((c def c (c (? . 15) q port->list)) q (334576 . 4)) ((c form c (c (? . 27) q let-syntaxes)) q (12362 . 2)) ((c form c (c (? . 6) q for*/hashalw)) q (17085 . 2)) ((c def c (c (? . 6) q procedure-realm)) q (158120 . 3)) ((c def c (c (? . 61) q contract-property?)) q (235092 . 3)) ((c form c (c (? . 76) q with-disappeared-uses)) q (317961 . 4)) ((q form ((lib "racket/private/define.rkt") define-values-for-syntax)) q (13804 . 2)) ((c def c (c (? . 0) q sync)) q (272769 . 3)) ((c def c (c (? . 6) q procedure-rename)) q (157975 . 5)) ((c def c (c (? . 40) q coerce-contract)) q (222184 . 4)) ((c def c (c (? . 0) q thread-send)) q (272336 . 6)) ((c def c (c (? . 17) q call-with-atomic-output-file)) q (455457 . 12)) ((c form c (c (? . 54) q splicing-letrec-syntaxes+values)) q (312630 . 2)) ((c def c (c (? . 61) q flat-contract-property?)) q (235230 . 3)) ((c def c (c (? . 6) q exn)) c (? . 47)) ((c def c (c (? . 78) q serialize)) q (375561 . 16)) ((c form c (c (? . 6) q #%printing-module-begin)) q (1836 . 2)) ((c form c (c (? . 67) q define-runtime-module-path)) q (448742 . 2)) ((c def c (c (? . 19) q collapsible-property)) c (? . 113)) ((c def c (c (? . 0) q find-library-collection-paths)) q (516397 . 9)) ((c def c (c (? . 88) q phase+space-space)) q (319302 . 3)) ((c form c (c (? . 9) q overment*)) q (178588 . 2)) ((c def c (c (? . 0) q thread-receive)) q (272530 . 2)) ((c def c (c (? . 0) q make-weak-hasheqv)) q (116292 . 4)) ((c def c (c (? . 51) q normalize-path)) q (442856 . 5)) ((c def c (c (? . 2) q dict?)) q (137920 . 3)) ((c def c (c (? . 25) q tentative-pretty-print-port-transfer)) q (373840 . 5)) ((c def c (c (? . 14) q place-enabled?)) q (280243 . 2)) ((c def c (c (? . 16) q extflonum?)) q (41513 . 3)) ((c def c (c (? . 0) q local-expand)) q (298268 . 11)) ((c def c (c (? . 26) q </c)) q (200369 . 3)) ((c def c (c (? . 7) q stream-first)) q (135153 . 3)) ((c def c (c (? . 0) q system-big-endian?)) q (32326 . 2)) ((c def c (c (? . 24) q make-export)) c (? . 68)) ((c def c (c (? . 0) q memory-order-release)) q (282932 . 2)) ((c def c (c (? . 21) q correlated-property)) q (436728 . 8)) ((c def c (c (? . 12) q call-with-limits)) q (428019 . 5)) ((c def c (c (? . 8) q permutations)) q (104683 . 3)) ((c def c (c (? . 0) q current-subprocess-custodian-mode)) q (471875 . 5)) ((c form c (c (? . 38) q ->m)) q (184784 . 2)) ((c def c (c (? . 0) q inexact?)) q (22885 . 3)) ((c def c (c (? . 0) q identifier-binding-portal-syntax)) q (296927 . 7)) ((c def c (c (? . 81) q build-flat-contract-property)) q (225940 . 42)) ((c def c (c (? . 0) q eof)) q (320780 . 2)) ((c def c (c (? . 40) q contract-stronger?)) q (235583 . 4)) ((c def c (c (? . 0) q exn:missing-module-accessor)) q (261060 . 4)) ((c def c (c (? . 11) q shared-fxvector)) q (41229 . 3)) ((c def c (c (? . 9) q class-seal)) q (190830 . 15)) ((c def c (c (? . 0) q expand-syntax-once)) q (314594 . 4)) ((c def c (c (? . 72) q async-channel-put-evt)) q (276485 . 4)) ((c form c (c (? . 6) q struct-copy)) q (172079 . 5)) ((c def c (c (? . 0) q identifier-distinct-binding)) q (295975 . 18)) ((c def c (c (? . 6) q exn:break:hang-up)) c (? . 71)) ((c def c (c (? . 15) q open-output-nowhere)) q (340385 . 4)) ((c def c (c (? . 0) q security-guard?)) q (412869 . 3)) ((c def c (c (? . 15) q make-limited-input-port)) q (339529 . 7)) ((c def c (c (? . 16) q extflasin)) q (43026 . 3)) ((c def c (c (? . 2) q dict-remove)) q (138986 . 4)) ((c def c (c (? . 9) q object-or-false=?)) q (189057 . 4)) ((c def c (c (? . 3) q import-req-mode)) c (? . 28)) ((c def c (c (? . 8) q empty?)) q (98630 . 3)) ((c def c (c (? . 0) q path->complete-path)) q (439586 . 5)) ((c def c (c (? . 0) q module-declared?)) q (397625 . 5)) ((c def c (c (? . 7) q stream-rest)) q (135241 . 3)) ((c def c (c (? . 43) q guard-evt)) q (273458 . 3)) ((c def c (c (? . 13) q set=?)) q (153522 . 4)) ((c form c (c (? . 137) q matching-identifiers-out)) q (10763 . 2)) ((c def c (c (? . 19) q collapsible-ho/c-latest-ctc)) c (? . 94)) ((c def c (c (? . 0) q prop:custom-write)) q (375084 . 2)) ((c def c (c (? . 22) q sequence-append)) q (133776 . 3)) ((c def c (c (? . 0) q exact->inexact)) q (23001 . 3)) ((c def c (c (? . 0) q current-compile-realm)) q (391333 . 4)) ((c def c (c (? . 0) q read-byte)) q (349588 . 3)) ((c def c (c (? . 13) q set-implements/c)) q (150805 . 3)) ((c def c (c (? . 26) q channel/c)) q (205439 . 3)) ((c def c (c (? . 0) q error-display-handler)) q (254840 . 4)) ((c def c (c (? . 6) q exn:fail:out-of-memory)) c (? . 87)) ((c def c (c (? . 14) q place-dead-evt)) q (281425 . 3)) ((c def c (c (? . 0) q port-progress-evt)) q (357549 . 4)) ((c def c (c (? . 0) q struct:exn:fail:contract:arity)) c (? . 111)) ((c def c (c (? . 8) q list-update)) q (99433 . 5)) ((c form c (c (? . 0) q letrec-syntaxes+values)) q (12497 . 4)) ((c def c (c (? . 0) q make-input-port)) q (329646 . 50)) ((c def c (c (? . 2) q dict-set!)) q (138601 . 5)) ((c def c (c (? . 0) q stencil-vector)) q (112597 . 4)) ((c def c (c (? . 0) q hash-ephemeron?)) q (114811 . 3)) ((c def c (c (? . 1) q unsafe-struct*-set!)) q (502705 . 5)) ((c def c (c (? . 6) q make-srcloc)) c (? . 59)) ((c def c (c (? . 0) q string-ci>=?)) q (49186 . 4)) ((c def c (c (? . 21) q correlated-column)) q (435383 . 3)) ((c form c (c (? . 6) q combine-in)) q (4785 . 2)) ((c def c (c (? . 0) q print-vector-length)) q (366995 . 4)) ((c def c (c (? . 0) q min)) q (24067 . 3)) ((c form c (c (? . 49) q syntax/loc)) q (285722 . 14)) ((c def c (c (? . 8) q rest)) q (98734 . 3)) ((c def c (c (? . 0) q syntax-rearm)) q (313983 . 5)) ((c def c (c (? . 0) q keyword<?)) q (91774 . 4)) ((c form c (c (? . 140) q define-require-syntax)) q (13855 . 3)) ((c form c (c (? . 54) q splicing-letrec-syntax)) q (312539 . 2)) ((c form c (c (? . 6) q combine-out)) q (6716 . 2)) ((c def c (c (? . 0) q keyword->string)) q (91632 . 3)) ((c def c (c (? . 0) q prop:arity-string)) q (161984 . 2)) ((c def c (c (? . 0) q make-directory)) q (447606 . 4)) ((c form c (c (? . 32) q make-struct-type-property/generic)) q (170984 . 29)) ((c def c (c (? . 72) q async-channel?)) q (276066 . 3)) ((c def c (c (? . 62) q random-ref)) q (28778 . 5)) ((c def c (c (? . 0) q modulo)) q (23788 . 4)) ((c def c (c (? . 6) q exn:fail:contract:arity)) c (? . 111)) ((c def c (c (? . 23) q failure-result/c)) q (238240 . 2)) ((c form c (c (? . 6) q define)) q (13271 . 14)) ((c form c (c (? . 67) q runtime-paths)) q (448795 . 2)) ((c def c (c (? . 73) q make-struct-info)) q (173791 . 3)) ((c def c (c (? . 6) q gen:equal+hash)) q (21078 . 2)) ((c def c (c (? . 11) q fxvector-length)) q (40142 . 3)) ((c def c (c (? . 0) q string->path)) q (437203 . 3)) ((c def c (c (? . 0) q compiled-expression?)) q (390578 . 3)) ((c def c (c (? . 0) q equal-hash-code)) q (20689 . 3)) ((c form c (c (? . 0) q begin)) q (14215 . 3)) ((c def c (c (? . 34) q trait?)) q (183343 . 3)) ((c def c (c (? . 0) q bytes-ref)) q (63950 . 4)) ((c def c (c (? . 0) q exn-message)) c (? . 47)) ((c def c (c (? . 0) q choice-evt)) q (273189 . 3)) ((c def c (c (? . 6) q make-exn:fail:user)) c (? . 125)) ((c def c (c (? . 1) q unsafe-flrandom)) q (495886 . 3)) ((c def c (c (? . 0) q write-special-avail*)) q (360506 . 4)) ((c def c (c (? . 22) q sequence-filter)) q (134471 . 4)) ((c def c (c (? . 40) q get/build-val-first-projection)) q (238277 . 4)) ((c def c (c (? . 1) q unsafe-impersonate-procedure)) q (514231 . 11)) ((c def c (c (? . 0) q log-level?)) q (478444 . 5)) ((c def c (c (? . 82) q sinh)) q (32757 . 3)) ((c def c (c (? . 0) q continuation-mark-set?)) q (270017 . 3)) ((c form c (c (? . 23) q recontract-out)) q (214109 . 2)) ((c form c (c (? . 34) q trait-alias)) q (183618 . 2)) ((c form c (c (? . 23) q cons/dc)) q (202811 . 8)) ((c def c (c (? . 0) q module-path-index-resolve)) q (393976 . 7)) ((c def c (c (? . 6) q in-vector)) q (125057 . 6)) ((c def c (c (? . 0) q char<=?)) q (71168 . 4)) ((c def c (c (? . 15) q with-input-from-string)) q (336542 . 4)) ((c def c (c (? . 17) q user-read-bit)) q (459728 . 2)) ((c form c (c (? . 6) q for/last)) q (16069 . 2)) ((c def c (c (? . 0) q make-hashalw)) q (115561 . 4)) ((c def c (c (? . 0) q subprocess-kill)) q (471617 . 4)) ((c def c (c (? . 0) q struct-type-sealed?)) q (416372 . 3)) ((c def c (c (? . 0) q abs)) q (23967 . 3)) ((c def c (c (? . 0) q subprocess?)) q (471818 . 3)) ((c form c (c (? . 49) q _)) q (287610 . 2)) ((c def c (c (? . 1) q unsafe-extflacos)) q (513370 . 3)) ((c def c (c (? . 0) q thread-suspend)) q (271516 . 3)) ((c def c (c (? . 44) q flmin)) q (34402 . 4)) ((c def c (c (? . 31) q splitter)) q (267152 . 5)) ((c def c (c (? . 6) q open-output-file)) q (322706 . 15)) ((c def c (c (? . 6) q collection-file-path)) q (517078 . 16)) ((c def c (c (? . 0) q raise-user-error)) q (246592 . 10)) ((c def c (c (? . 0) q weak-box-value)) q (489609 . 4)) ((c def c (c (? . 56) q fsemaphore-count)) q (280149 . 3)) ((c def c (c (? . 0) q syntax-source)) q (287819 . 3)) ((c def c (c (? . 0) q char-grapheme-break-property)) q (72811 . 3)) ((c def c (c (? . 1) q unsafe-fxpopcount)) q (492032 . 3)) ((c form c (c (? . 41) q define-values/invoke-unit/infer)) q (195930 . 8)) ((c def c (c (? . 0) q exn:fail:contract?)) c (? . 126)) ((c def c (c (? . 6) q in-immutable-hash-keys)) q (128376 . 3)) ((c def c (c (? . 44) q flsingle)) q (34779 . 3)) ((c def c (c (? . 0) q single-flonum?)) q (22450 . 3)) ((c def c (c (? . 44) q flreal-part)) q (35724 . 5)) ((c def c (c (? . 0) q make-custodian)) q (413783 . 4)) ((c def c (c (? . 7) q stream->list)) q (135804 . 3)) ((c def c (c (? . 0) q relative-path?)) q (439374 . 3)) ((c form c (c (? . 9) q super-instantiate)) q (180648 . 2)) ((c def c (c (? . 75) q engine-kill)) q (282822 . 3)) ((c def c (c (? . 5) q arity-includes?)) q (163803 . 4)) ((c def c (c (? . 20) q tcp-connect/enable-break)) q (460817 . 10)) ((c def c (c (? . 13) q mutable-seteqv)) q (147316 . 4)) ((c def c (c (? . 0) q string->unreadable-symbol)) q (73836 . 3)) ((c form c (c (? . 6) q for*/or)) q (17215 . 2)) ((c def c (c (? . 0) q inexact->exact)) q (22941 . 3)) ((c form c (c (? . 41) q struct/ctc)) q (197066 . 10)) ((c def c (c (? . 44) q fl/)) q (33887 . 4)) ((c form c (c (? . 31) q shift-at)) q (266685 . 2)) ((c def c (c (? . 4) q process*/ports)) q (475849 . 27)) ((c def c (c (? . 17) q file-type-bits)) q (459271 . 2)) ((c def c (c (? . 0) q void)) q (163956 . 3)) ((c def c (c (? . 40) q prop:blame)) q (225840 . 2)) ((c def c (c (? . 44) q make-shared-flvector)) q (37608 . 4)) ((c def c (c (? . 0) q string-normalize-nfd)) q (49565 . 3)) ((c def c (c (? . 0) q pseudo-random-generator?)) q (27916 . 3)) ((c def c (c (? . 0) q make-plumber)) q (417156 . 2)) ((c def c (c (? . 0) q namespace-require/copy)) q (382372 . 5)) ((c def c (c (? . 0) q byte-ready?)) q (357985 . 3)) ((c def c (c (? . 0) q assert-unreachable)) q (271061 . 2)) ((c form c (c (? . 9) q define/overment)) q (179142 . 3)) ((c def c (c (? . 19) q collapsible-guard)) q (239125 . 5)) ((c def c (c (? . 6) q exn:fail:contract)) c (? . 126)) ((c def c (c (? . 1) q unsafe-fxmin)) q (493112 . 4)) ((c def c (c (? . 0) q vector?)) q (106590 . 3)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:missing-module)) c (? . 79)) ((c def c (c (? . 0) q char-title-case?)) q (72127 . 3)) ((c def c (c (? . 8) q make-list)) q (99341 . 4)) ((c def c (c (? . 0) q call-with-immediate-continuation-mark)) q (269517 . 7)) ((c def c (c (? . 0) q char-grapheme-step)) q (73331 . 4)) ((c def c (c (? . 40) q contract-name)) q (236277 . 3)) ((c def c (c (? . 1) q unsafe-flacos)) q (494771 . 3)) ((c def c (c (? . 13) q generic-set?)) q (150647 . 3)) ((c def c (c (? . 21) q make-instance)) q (433308 . 12)) ((c def c (c (? . 16) q extfllog)) q (43212 . 3)) ((c form c (c (? . 30) q parameterize*)) q (278473 . 3)) ((c def c (c (? . 0) q read-accept-compiled)) q (363133 . 4)) ((c def c (c (? . 0) q box?)) q (113687 . 3)) ((c def c (c (? . 0) q regexp?)) q (74192 . 3)) ((c def c (c (? . 13) q seteq)) q (147018 . 3)) ((c def c (c (? . 0) q namespace-module-identifier)) q (380864 . 4)) ((c def c (c (? . 17) q file->bytes-lines)) q (449816 . 8)) ((c def c (c (? . 0) q raise-range-error*)) q (249988 . 19)) ((c def c (c (? . 0) q exn:fail:contract:continuation?)) c (? . 108)) ((c def c (c (? . 17) q display-lines-to-file)) q (451104 . 13)) ((c def c (c (? . 0) q namespace-require/expansion-time)) q (382824 . 6)) ((c def c (c (? . 0) q make-weak-hasheq)) q (116437 . 4)) ((c def c (c (? . 21) q instance?)) q (433253 . 3)) ((c def c (c (? . 0) q hash-clear!)) q (120027 . 3)) ((c form c (c (? . 54) q splicing-letrec)) q (312432 . 2)) ((c def c (c (? . 2) q dict-iterate-value)) q (139353 . 4)) ((c def c (c (? . 143) q syntax-parameter-value)) q (312251 . 3)) ((c def c (c (? . 13) q set-remove!)) q (151884 . 4)) ((c def c (c (? . 6) q in-mutable-hash-values)) q (127603 . 3)) ((c def c (c (? . 15) q port->bytes-lines)) q (335343 . 8)) ((c form c (c (? . 6) q #%plain-module-begin)) q (1880 . 2)) ((c def c (c (? . 6) q in-values-sequence)) q (131647 . 3)) ((c def c (c (? . 1) q unsafe-fltruncate)) q (494408 . 3)) ((c def c (c (? . 0) q string-ref)) q (46828 . 4)) ((c def c (c (? . 8) q index-where)) q (99912 . 4)) ((c def c (c (? . 0) q struct-type-property?)) q (169004 . 3)) ((c def c (c (? . 10) q vector-memq)) q (111128 . 4)) ((c def c (c (? . 0) q equal-always-hash-code)) q (20819 . 3)) ((c def c (c (? . 25) q pretty-display)) q (369876 . 5)) ((c def c (c (? . 22) q sequence-map)) q (133847 . 4)) ((c def c (c (? . 12) q get-uncovered-expressions)) q (427456 . 7)) ((c def c (c (? . 1) q unsafe-flcos)) q (494593 . 3)) ((c def c (c (? . 1) q unsafe-extflround)) q (512812 . 3)) ((c def c (c (? . 51) q string->some-system-path)) q (443367 . 4)) ((c def c (c (? . 0) q link-exists?)) q (444266 . 3)) ((c form c (c (? . 9) q super-make-object)) q (180623 . 2)) ((c def c (c (? . 0) q variable-reference->module-path-index)) q (385349 . 4)) ((c def c (c (? . 44) q flfloor)) q (34612 . 3)) ((c def c (c (? . 0) q bytes-utf-8-length)) q (67669 . 7)) ((c def c (c (? . 51) q filename-extension)) q (442144 . 3)) ((c def c (c (? . 8) q cartesian-product)) q (105187 . 3)) ((c form c (c (? . 9) q class)) q (177558 . 2)) ((c def c (c (? . 0) q error-message-adjuster-key)) q (261998 . 2)) ((c form c (c (? . 6) q for/vector)) q (15071 . 8)) ((c form c (c (? . 103) q with-contract)) q (214259 . 12)) ((c def c (c (? . 56) q fsemaphore-try-wait?)) q (280069 . 3)) ((c def c (c (? . 0) q get-output-string)) q (329150 . 3)) ((c def c (c (? . 3) q struct:import)) c (? . 28)) ((c form c (c (? . 13) q for*/mutable-seteqv)) q (149885 . 2)) ((c form c (c (? . 49) q quote-syntax/prune)) q (287361 . 2)) ((c form c (c (? . 49) q syntax-id-rules)) q (287471 . 3)) ((c def c (c (? . 8) q add-between)) q (102095 . 13)) ((c def c (c (? . 16) q extfltan)) q (42965 . 3)) ((c def c (c (? . 0) q make-hasheq)) q (115854 . 4)) ((c def c (c (? . 102) q false?)) q (21558 . 3)) ((c def c (c (? . 21) q linklet-import-variables)) q (432241 . 3)) ((c def c (c (? . 0) q namespace-syntax-introduce)) q (384491 . 4)) ((c def c (c (? . 0) q char-graphic?)) q (72395 . 3)) ((c def c (c (? . 0) q flonum?)) q (22337 . 3)) ((c def c (c (? . 0) q bytes-utf-8-ref)) q (67948 . 7)) ((c def c (c (? . 44) q fl>=)) q (34324 . 4)) ((c form c (c (? . 32) q make-generic-struct-type-property)) q (171991 . 5)) ((c def c (c (? . 8) q inclusive-range)) q (103993 . 5)) ((c def c (c (? . 56) q touch)) q (279323 . 3)) ((c form c (c (? . 43) q define-syntax-rule)) q (287544 . 2)) ((c def c (c (? . 57) q contract-random-generate-get-current-environment)) q (243579 . 3)) ((c def c (c (? . 15) q peek-string-evt)) c (? . 117)) ((c def c (c (? . 88) q phase?)) q (318970 . 3)) ((c def c (c (? . 127) q box-immutable/c)) q (202404 . 3)) ((c def c (c (? . 76) q format-id)) q (316272 . 19)) ((c def c (c (? . 0) q compile-enforce-module-constants)) q (390644 . 4)) ((c def c (c (? . 0) q vector-cas!)) q (107710 . 6)) ((c def c (c (? . 9) q exn:fail:object)) c (? . 106)) ((c form c (c (? . 7) q stream-cons)) q (135332 . 5)) ((c def c (c (? . 56) q future)) q (279260 . 3)) ((c def c (c (? . 11) q fxlshift/wraparound)) q (39101 . 4)) ((c form c (c (? . 44) q for*/flvector)) q (37276 . 9)) ((c form c (c (? . 48) q define/match)) q (244082 . 18)) ((c def c (c (? . 0) q directory-exists?)) q (447530 . 3)) ((c def c (c (? . 66) q blame-swap)) q (224563 . 3)) ((c def c (c (? . 0) q bytes->string/utf-8)) q (65633 . 6)) ((c def c (c (? . 6) q make-exn:fail:contract:divide-by-zero)) c (? . 118)) ((c def c (c (? . 12) q sandbox-make-namespace)) q (422734 . 2)) ((c def c (c (? . 0) q make-bytes)) q (63566 . 4)) ((c def c (c (? . 15) q peek-bytes!-evt)) c (? . 117)) ((c def c (c (? . 6) q exn:fail:unsupported)) c (? . 119)) ((c def c (c (? . 16) q in-extflvector)) q (44779 . 6)) ((c form c (c (? . 6) q for*)) q (16592 . 2)) ((c def c (c (? . 0) q bytes->immutable-bytes)) q (63722 . 3)) ((c form c (c (? . 31) q prompt0)) q (266744 . 2)) ((c def c (c (? . 6) q make-exn:fail:read:eof)) c (? . 114)) ((c def c (c (? . 0) q namespace-require)) q (382160 . 5)) ((c def c (c (? . 8) q take)) q (100358 . 4)) ((c def c (c (? . 26) q natural-number/c)) q (200950 . 2)) ((c def c (c (? . 0) q make-hasheq-placeholder)) q (105934 . 3)) ((c def c (c (? . 0) q cos)) q (25615 . 3)) ((c def c (c (? . 0) q string-ci<=?)) q (48991 . 4)) ((c def c (c (? . 11) q fxlshift)) q (38427 . 4)) ((c def c (c (? . 13) q list->mutable-set)) q (148282 . 4)) ((c form c (c (? . 53) q current-contract-region)) q (215586 . 2)) ((c def c (c (? . 26) q false/c)) q (201060 . 2)) ((c form c (c (? . 12) q with-deep-time-limit)) q (428375 . 2)) ((c def c (c (? . 14) q prop:place-location)) q (282076 . 2)) ((c def c (c (? . 73) q prop:struct-info)) q (174028 . 2)) ((c def c (c (? . 14) q place-channel-get)) q (281822 . 3)) ((c def c (c (? . 24) q expand-export)) q (309701 . 4)) ((c def c (c (? . 6) q in-mutable-hash-keys)) q (127330 . 3)) ((c def c (c (? . 44) q flsin)) q (34834 . 3)) ((c def c (c (? . 25) q pretty-print-style-table?)) q (371206 . 3)) ((c def c (c (? . 5) q disjoin)) q (163145 . 4)) ((c form c (c (? . 31) q control0-at)) q (266964 . 2)) ((c def c (c (? . 0) q struct-type-property-predicate-procedure?)) q (169157 . 5)) ((c def c (c (? . 0) q error-contract->adjusted-string)) q (261609 . 5)) ((c def c (c (? . 3) q current-require-module-path)) q (309180 . 4)) ((c form c (c (? . 41) q define-unit/new-import-export)) q (196443 . 6)) ((c def c (c (? . 66) q blame-update)) q (224902 . 5)) ((c def c (c (? . 56) q fsemaphore-wait)) q (279997 . 3)) ((c def c (c (? . 0) q null?)) q (92040 . 3)) ((c form c (c (? . 6) q define-namespace-anchor)) q (380281 . 2)) ((c def c (c (? . 6) q in-hash)) q (126435 . 6)) ((c def c (c (? . 0) q current-prompt-read)) q (389466 . 4)) ((c form c (c (? . 6) q for*/hash)) q (16888 . 2)) ((c def c (c (? . 0) q kill-thread)) q (271713 . 3)) ((c def c (c (? . 0) q syntax-local-lift-module-end-declaration)) q (304765 . 3)) ((c def c (c (? . 82) q natural?)) q (33647 . 3)) ((c def c (c (? . 17) q make-parent-directory*)) q (453850 . 3)) ((c def c (c (? . 0) q compile-target-machine?)) q (391258 . 3)) ((c form c (c (? . 13) q for/seteqv)) q (149231 . 2)) ((c def c (c (? . 12) q sandbox-make-code-inspector)) q (425448 . 4)) ((c def c (c (? . 0) q caddar)) q (97557 . 3)) ((c def c (c (? . 128) q new-/c)) q (212680 . 3)) ((c def c (c (? . 0) q raise-result-error*)) q (248165 . 16)) ((c def c (c (? . 0) q logger-name)) q (477655 . 3)) ((c def c (c (? . 0) q bytes<?)) q (65443 . 4)) ((c form c (c (? . 41) q invoke-unit/infer)) q (195826 . 5)) ((c def c (c (? . 37) q udp?)) q (466747 . 3)) ((c def c (c (? . 38) q dynamic-object/c)) q (185473 . 9)) ((c def c (c (? . 8) q flatten)) q (102759 . 3)) ((c def c (c (? . 0) q list-ref)) q (92660 . 4)) ((c def c (c (? . 9) q generic?)) q (188926 . 3)) ((c def c (c (? . 0) q custodian-managed-list)) q (414191 . 4)) ((c def c (c (? . 65) q promise?)) q (262043 . 3)) ((c def c (c (? . 80) q date-display-format)) q (482552 . 18)) ((c def c (c (? . 0) q current-compile)) q (390127 . 5)) ((c def c (c (? . 19) q collapsible-property-c-c)) c (? . 113)) ((c def c (c (? . 14) q place-channel-put/get)) q (281912 . 4)) ((c def c (c (? . 0) q print-unreadable)) q (366643 . 4)) ((c def c (c (? . 13) q set-copy)) q (152366 . 3)) ((c def c (c (? . 0) q filesystem-change-evt)) q (448090 . 5)) ((c def c (c (? . 6) q procedure-reduce-arity)) q (159239 . 9)) ((c def c (c (? . 6) q make-exn:break:terminate)) c (? . 121)) ((c def c (c (? . 39) q current-trace-print-results)) q (521582 . 10)) ((c def c (c (? . 1) q unsafe-char<=?)) q (496255 . 4)) ((c def c (c (? . 0) q read-bytes-avail!)) q (351061 . 7)) ((c def c (c (? . 22) q sequence-add-between)) q (134577 . 4)) ((c form c (c (? . 30) q do)) q (19020 . 7)) ((c form c (c (? . 41) q compound-unit/infer)) q (194674 . 18)) ((c def c (c (? . 2) q dict-remove!)) q (138872 . 4)) ((c def c (c (? . 0) q exact-positive-integer?)) q (22156 . 3)) ((c def c (c (? . 34) q trait->mixin)) q (183395 . 3)) ((c def c (c (? . 1) q unsafe-immutable-hash-iterate-next)) q (505285 . 5)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-key+value)) q (504216 . 5)) ((c def c (c (? . 0) q current-module-declare-name)) q (393057 . 5)) ((c def c (c (? . 2) q dict-set*!)) q (139529 . 5)) ((c def c (c (? . 20) q tcp-port?)) q (462067 . 3)) ((c form c (c (? . 41) q export)) q (193784 . 2)) ((c def c (c (? . 0) q bitwise-bit-set?)) q (26648 . 4)) ((c def c (c (? . 42) q foldl)) q (93388 . 5)) ((c form c (c (? . 13) q for/weak-set)) q (150005 . 2)) ((c form c (c (? . 9) q define/private)) q (179570 . 3)) ((c def c (c (? . 21) q datum->correlated)) q (435845 . 16)) ((c def c (c (? . 1) q unsafe-fxpopcount16)) q (492229 . 3)) ((c def c (c (? . 37) q udp-send-evt)) q (467571 . 9)) ((c def c (c (? . 0) q pair?)) q (91989 . 3)) ((c def c (c (? . 32) q exn:fail:support)) c (? . 109)) ((c def c (c (? . 1) q unsafe-char>=?)) q (496339 . 4)) ((c def c (c (? . 0) q plumber?)) q (417102 . 3)) ((c def c (c (? . 0) q make-sibling-inspector)) q (415585 . 3)) ((c def c (c (? . 11) q fx<)) q (39265 . 4)) ((c def c (c (? . 6) q in-ephemeron-hash-pairs)) q (130668 . 3)) ((c def c (c (? . 0) q char-ci<?)) q (71541 . 4)) ((c def c (c (? . 9) q method-in-interface?)) q (189856 . 4)) ((c def c (c (? . 13) q list->weak-seteqv)) q (148932 . 4)) ((c def c (c (? . 0) q impersonate-struct)) q (400269 . 17)) ((c def c (c (? . 0) q expand)) q (314188 . 4)) ((c form c (c (? . 44) q for/flvector)) q (37210 . 2)) ((c def c (c (? . 11) q fx<=)) q (39419 . 4)) ((c form c (c (? . 13) q for*/weak-seteqv)) q (150335 . 2)) ((c form c (c (? . 41) q extends)) q (193941 . 2)) ((c def c (c (? . 0) q free-label-identifier=?)) q (293477 . 4)) ((c def c (c (? . 128) q new-/c)) q (212765 . 3)) ((c def c (c (? . 12) q sandbox-make-logger)) q (425587 . 4)) ((c def c (c (? . 1) q unsafe-extfl*)) q (511938 . 4)) ((c def c (c (? . 6) q srcloc)) c (? . 59)) ((c def c (c (? . 0) q caaar)) q (96301 . 3)) ((c def c (c (? . 0) q char-symbolic?)) q (72260 . 3)) ((c form c (c (? . 38) q ->*m)) q (184814 . 2)) ((c def c (c (? . 22) q sequence-fold)) q (134242 . 5)) ((c def c (c (? . 17) q other-execute-bit)) q (460088 . 2)) ((c def c (c (? . 0) q flush-output)) q (320863 . 3)) ((c form c (c (? . 6) q define-for-syntax)) q (13721 . 3)) ((c def c (c (? . 0) q +)) q (23198 . 3)) ((c def c (c (? . 1) q unsafe-fxlshift/wraparound)) q (492596 . 4)) ((c def c (c (? . 0) q will-try-execute)) q (490400 . 4)) ((c def c (c (? . 10) q vector-map!)) q (109350 . 4)) ((c def c (c (? . 0) q char-ci=?)) q (71446 . 4)) ((c def c (c (? . 6) q print-value-columns)) q (367717 . 5)) ((c def c (c (? . 0) q denominator)) q (24633 . 3)) ((c def c (c (? . 0) q syntax-local-module-defined-identifiers)) q (307437 . 3)) ((c def c (c (? . 13) q set-for-each)) q (153975 . 4)) ((c def c (c (? . 0) q time-apply)) q (482183 . 7)) ((c def c (c (? . 1) q unsafe-vector-set!)) q (497982 . 5)) ((c def c (c (? . 5) q normalized-arity?)) q (163503 . 3)) ((c def c (c (? . 0) q date-hour)) c (? . 60)) ((c def c (c (? . 0) q write-bytes-avail)) q (359199 . 9)) ((c form c (c (? . 31) q reset)) q (266580 . 2)) ((c def c (c (? . 0) q namespace-attach-module-declaration)) q (383384 . 7)) ((c form c (c (? . 7) q stream-lazy)) q (135523 . 3)) ((c def c (c (? . 61) q prop:contract)) q (225577 . 2)) ((c def c (c (? . 22) q in-slice)) q (134929 . 4)) ((c def c (c (? . 0) q placeholder-get)) q (105708 . 3)) ((c def c (c (? . 11) q fxvector-set!)) q (40338 . 5)) ((c form c (c (? . 48) q match-let-values)) q (244861 . 2)) ((c def c (c (? . 0) q set-phantom-bytes!)) q (490954 . 4)) ((c def c (c (? . 0) q current-force-delete-permissions)) q (447075 . 5)) ((c def c (c (? . 0) q custom-print-quotable?)) q (375384 . 2)) ((c form c (c (? . 32) q define/generic)) q (170320 . 2)) ((c form c (c (? . 6) q lib)) q (5210 . 2)) ((c form c (c (? . 0) q #%stratified-body)) q (19441 . 2)) ((c def c (c (? . 0) q print-reader-abbreviations)) q (367303 . 4)) ((c def c (c (? . 0) q string-set!)) q (46927 . 5)) ((c def c (c (? . 9) q dynamic-set-field!)) q (181919 . 5)) ((c def c (c (? . 37) q udp-receive-ready-evt)) q (467024 . 3)) ((c def c (c (? . 39) q current-prefix-out)) q (522105 . 4)) ((c form c (c (? . 6) q for*/last)) q (17472 . 2)) ((c def c (c (? . 0) q syntax-property)) q (312756 . 9)) ((c def c (c (? . 0) q string->symbol)) q (73695 . 3)) ((c def c (c (? . 1) q unsafe-set-mcdr!)) q (496783 . 4)) ((c def c (c (? . 16) q extfl+)) q (41616 . 4)) ((c form c (c (? . 9) q field-bound?)) q (182044 . 2)) ((c def c (c (? . 0) q module->realm)) q (398759 . 4)) ((c def c (c (? . 11) q fxior)) q (38261 . 3)) ((c form c (c (? . 9) q define/override-final)) q (179224 . 3)) ((c def c (c (? . 12) q sandbox-run-submodules)) q (425174 . 4)) ((c def c (c (? . 0) q display)) q (365379 . 4)) ((c def c (c (? . 82) q sqr)) q (32557 . 3)) ((c def c (c (? . 0) q syntax-property-symbol-keys)) q (313287 . 3)) ((c form c (c (? . 39) q trace-lambda)) q (520610 . 2)) ((c def c (c (? . 0) q struct:exn:fail:user)) c (? . 125)) ((c def c (c (? . 15) q regexp-match-evt)) q (348966 . 4)) ((c form c (c (? . 6) q for/sum)) q (15703 . 2)) ((c def c (c (? . 16) q extfl<)) q (42090 . 4)) ((c def c (c (? . 0) q sleep)) q (271895 . 3)) ((c def c (c (? . 0) q equal-always?/recur)) q (20544 . 5)) ((c def c (c (? . 1) q unsafe-fl->fx)) q (495826 . 3)) ((c def c (c (? . 6) q exn:fail:read)) c (? . 85)) ((c def c (c (? . 2) q dict-copy)) q (141102 . 3)) ((c def c (c (? . 0) q char-whitespace?)) q (72460 . 3)) ((c def c (c (? . 13) q set-subtract!)) q (153192 . 4)) ((c def c (c (? . 98) q vector-immutable/c)) q (202007 . 3)) ((q def ((lib "racket/keyword.rkt") keyword->immutable-string)) q (91891 . 3)) ((c form c (c (? . 13) q for/mutable-set)) q (149537 . 2)) ((c def c (c (? . 0) q make-struct-field-mutator)) q (167541 . 12)) ((c def c (c (? . 43) q path-list-string->path-list)) q (443687 . 6)) ((c def c (c (? . 66) q blame-contract)) q (224392 . 3)) ((c def c (c (? . 0) q call-in-continuation)) q (264835 . 4)) ((c def c (c (? . 0) q continuation-mark-set-first)) q (269095 . 10)) ((c def c (c (? . 0) q negative?)) q (22669 . 3)) ((c def c (c (? . 12) q call-in-sandbox-context)) q (427726 . 7)) ((c def c (c (? . 13) q seteqv)) q (146932 . 3)) ((c def c (c (? . 0) q exn:fail:out-of-memory?)) c (? . 87)) ((c def c (c (? . 0) q vector)) q (106753 . 3)) ((c def c (c (? . 0) q char-ci>=?)) q (71827 . 4)) ((c def c (c (? . 19) q collapsible-wrapper-property?)) c (? . 124)) ((c def c (c (? . 0) q path-element->bytes)) q (438170 . 3)) ((c def c (c (? . 0) q cdadar)) q (97957 . 3)) ((c form c (c (? . 65) q lazy)) q (262124 . 2)) ((c def c (c (? . 82) q exact-truncate)) q (33113 . 3)) ((c def c (c (? . 9) q object-info)) q (190368 . 3)) ((c def c (c (? . 0) q namespace-variable-value)) q (381017 . 9)) ((c def c (c (? . 7) q stream-ref)) q (135940 . 4)) ((c def c (c (? . 6) q namespace-anchor->namespace)) q (380474 . 3)) ((c def c (c (? . 78) q deserialize)) q (376481 . 3)) ((c form c (c (? . 0) q with-continuation-mark)) q (19181 . 2)) ((c form c (c (? . 49) q with-syntax)) q (284510 . 3)) ((c def c (c (? . 80) q julian/scalinger->string)) q (484247 . 3)) ((c def c (c (? . 26) q printable/c)) q (201093 . 2)) ((c def c (c (? . 2) q dict-can-remove-keys?)) q (138202 . 3)) ((c form c (c (? . 13) q for*/seteq)) q (149382 . 2)) ((c def c (c (? . 0) q continuation-mark-set->list*)) q (268165 . 10)) ((c def c (c (? . 0) q plumber-flush-handle?)) q (417375 . 3)) ((c def c (c (? . 0) q inspector-superior?)) q (415702 . 5)) ((c def c (c (? . 7) q in-stream)) q (135715 . 3)) ((c form c (c (? . 6) q only-in)) q (4587 . 2)) ((c def c (c (? . 0) q load)) q (387088 . 3)) ((c form c (c (? . 102) q implies)) q (21659 . 2)) ((c def c (c (? . 82) q nonnegative-integer?)) q (33581 . 3)) ((c form c (c (? . 48) q match-let*)) q (244809 . 2)) ((c def c (c (? . 16) q extfl=)) q (42009 . 4)) ((c def c (c (? . 0) q identifier-label-binding)) q (295530 . 12)) ((c def c (c (? . 3) q import-mode)) c (? . 28)) ((c form c (c (? . 27) q cond)) q (12803 . 7)) ((c form c (c (? . 38) q ->dm)) q (184935 . 6)) ((c def c (c (? . 0) q exn:fail:contract:variable?)) c (? . 120)) ((c def c (c (? . 3) q import-orig-stx)) c (? . 28)) ((c def c (c (? . 0) q exn:fail:filesystem:exists?)) c (? . 129)) ((c def c (c (? . 26) q =/c)) q (200314 . 3)) ((c def c (c (? . 17) q make-temporary-file*)) q (454768 . 10)) ((c def c (c (? . 21) q instantiate-linklet)) q (431552 . 17)) ((c def c (c (? . 0) q error-print-context-length)) q (255150 . 4)) ((c def c (c (? . 0) q expand-syntax)) q (314326 . 4)) ((c form c (c (? . 6) q for/hashalw)) q (15514 . 2)) ((c def c (c (? . 92) q unit-static-init-dependencies)) q (199086 . 7)) ((c def c (c (? . 0) q exn:srclocs?)) q (260335 . 3)) ((c def c (c (? . 80) q date->string)) q (482453 . 4)) ((c def c (c (? . 0) q parameterization?)) q (279197 . 3)) ((c def c (c (? . 21) q correlated-property-symbol-keys)) q (436941 . 3)) ((c def c (c (? . 0) q sqrt)) q (25164 . 3)) ((c def c (c (? . 40) q impersonator-prop:contracted)) q (225778 . 2)) ((c def c (c (? . 11) q most-positive-fixnum)) q (41421 . 2)) ((c def c (c (? . 0) q bytes)) q (63668 . 3)) ((c def c (c (? . 22) q in-syntax)) q (134867 . 3)) ((c form c (c (? . 6) q struct-out)) q (6692 . 2)) ((c def c (c (? . 102) q xor)) q (21690 . 4)) ((c def c (c (? . 6) q make-exn:fail:filesystem)) c (? . 89)) ((c def c (c (? . 6) q prop:sequence)) q (133061 . 2)) ((c def c (c (? . 0) q <)) q (24878 . 4)) ((c def c (c (? . 26) q flat-contract)) q (206089 . 3)) ((c def c (c (? . 12) q sandbox-init-hook)) q (420500 . 4)) ((c def c (c (? . 1) q unsafe-bytes-length)) q (499229 . 3)) ((c def c (c (? . 0) q string-locale<?)) q (49976 . 4)) ((c def c (c (? . 0) q struct:exn:fail:filesystem:exists)) c (? . 129)) ((c form c (c (? . 38) q object-contract)) q (185838 . 51)) ((c def c (c (? . 1) q unsafe-extfl-)) q (511848 . 4)) ((c def c (c (? . 8) q drop-common-prefix)) q (101785 . 5)) ((c form c (c (? . 55) q filtered-in)) q (10539 . 2)) ((c def c (c (? . 12) q sandbox-path-permissions)) q (423254 . 9)) ((c def c (c (? . 15) q port->lines)) q (334999 . 8)) ((c def c (c (? . 0) q struct?)) q (172314 . 3)) ((c def c (c (? . 17) q file->bytes)) q (448975 . 4)) ((c form c (c (? . 9) q super-new)) q (180720 . 2)) ((c def c (c (? . 1) q unsafe-bytes-copy!)) q (499524 . 11)) ((c def c (c (? . 0) q make-logger)) q (477230 . 10)) ((c def c (c (? . 130) q hash-intersect)) q (123994 . 12)) ((c def c (c (? . 17) q block-device-type-bits)) q (459426 . 2)) ((c def c (c (? . 8) q splitf-at)) q (100818 . 4)) ((c def c (c (? . 13) q list->seteq)) q (148193 . 3)) ((c def c (c (? . 13) q in-immutable-set)) q (150449 . 3)) ((c def c (c (? . 0) q thread-dead?)) q (272023 . 3)) ((c def c (c (? . 0) q file-or-directory-identity)) q (446072 . 5)) ((c def c (c (? . 0) q struct-constructor-procedure?)) q (172420 . 3)) ((c def c (c (? . 0) q thread-wait)) q (272082 . 3)) ((c def c (c (? . 1) q unsafe-extflexpt)) q (513713 . 4)) ((c def c (c (? . 6) q directory-list)) q (447816 . 4)) ((c form c (c (? . 41) q provide-signature-elements)) q (197422 . 2)) ((c def c (c (? . 0) q string-append)) q (47873 . 3)) ((c def c (c (? . 30) q call/cc)) q (264203 . 5)) ((c form c (c (? . 48) q match*/derived)) q (245915 . 2)) ((c def c (c (? . 0) q semaphore-wait/enable-break)) q (275134 . 3)) ((c def c (c (? . 40) q list-contract?)) q (236217 . 3)) ((c form c (c (? . 49) q syntax-case)) q (282976 . 31)) ((c def c (c (? . 0) q date-time-zone-offset)) c (? . 60)) ((c def c (c (? . 0) q pipe-content-length)) q (329450 . 3)) ((c def c (c (? . 44) q fl*)) q (33832 . 3)) ((c def c (c (? . 37) q udp-receive!-evt)) q (467892 . 9)) ((c def c (c (? . 15) q peek-bytes-avail!-evt)) c (? . 117)) ((c def c (c (? . 43) q writeln)) q (365661 . 4)) ((c form c (c (? . 9) q augment-final)) q (178152 . 2)) ((c def c (c (? . 0) q hash-map)) q (120370 . 5)) ((c def c (c (? . 0) q make-phantom-bytes)) q (490863 . 3)) ((c def c (c (? . 16) q extflvector-ref)) q (44318 . 4)) ((c def c (c (? . 25) q pretty-format)) q (370048 . 5)) ((c form c (c (? . 23) q unconstrained-domain->)) q (212456 . 2)) ((c def c (c (? . 21) q instance-set-variable-value!)) q (434249 . 9)) ((c def c (c (? . 0) q cadddr)) q (97657 . 3)) ((c def c (c (? . 0) q make-pseudo-random-generator)) q (27845 . 2)) ((c def c (c (? . 12) q exn:fail:sandbox-terminated?)) c (? . 131)) ((c def c (c (? . 13) q list->mutable-setalw)) q (148389 . 4)) ((c form c (c (? . 9) q absent)) q (184750 . 2)) ((c def c (c (? . 0) q syntax-local-lift-expression)) q (304419 . 3)) ((c def c (c (? . 10) q vector-sort!)) q (111831 . 13)) ((c def c (c (? . 11) q fxpopcount16)) q (38762 . 3)) ((c def c (c (? . 26) q suggest/c)) q (206455 . 5)) ((c def c (c (? . 44) q flexp)) q (35201 . 3)) ((c def c (c (? . 9) q object=-hash-code)) q (189167 . 3)) ((c def c (c (? . 17) q regular-file-type-bits)) q (459384 . 2)) ((c def c (c (? . 0) q make-ephemeron-hasheq)) q (117053 . 4)) ((c def c (c (? . 0) q current-command-line-arguments)) q (486539 . 5)) ((c def c (c (? . 6) q open-input-file)) q (322404 . 7)) ((c def c (c (? . 31) q abort/cc)) q (265883 . 4)) ((c def c (c (? . 21) q correlated-position)) q (435488 . 3)) ((c def c (c (? . 0) q char-punctuation?)) q (72326 . 3)) ((c def c (c (? . 2) q dict-ref)) q (138397 . 6)) ((c def c (c (? . 0) q prop:exn:srclocs)) q (260286 . 2)) ((c def c (c (? . 0) q thread-group?)) q (415240 . 3)) ((c def c (c (? . 0) q bitwise-xor)) q (26499 . 3)) ((c def c (c (? . 0) q print-hash-table)) q (367097 . 4)) ((c def c (c (? . 0) q make-interned-syntax-introducer)) q (306821 . 4)) ((c form c (c (? . 6) q for/or)) q (15642 . 2)) ((c def c (c (? . 38) q mixin-contract)) q (187975 . 2)) ((c def c (c (? . 11) q make-shared-fxvector)) q (41298 . 4)) ((c form c (c (? . 48) q struct*)) q (246025 . 2)) ((c def c (c (? . 0) q cddr)) q (96237 . 3)) ((c def c (c (? . 23) q unsupplied-arg?)) q (212582 . 3)) ((c def c (c (? . 0) q eof-object?)) q (320806 . 3)) ((c def c (c (? . 0) q read-syntax-accept-graph)) q (363441 . 4)) ((c def c (c (? . 0) q port-closed?)) q (320129 . 3)) ((c def c (c (? . 14) q place-channel?)) q (280336 . 3)) ((c def c (c (? . 0) q placeholder?)) q (105489 . 3)) ((c def c (c (? . 37) q udp-bind!)) q (462403 . 9)) ((c def c (c (? . 6) q keyword-apply)) q (158431 . 13)) ((c def c (c (? . 122) q unsafe-undefined)) q (515931 . 2)) ((c def c (c (? . 0) q syntax-local-bind-syntaxes)) q (302138 . 12)) ((c def c (c (? . 0) q path->directory-path)) q (439806 . 3)) ((c def c (c (? . 8) q argmax)) q (104915 . 4)) ((c def c (c (? . 10) q vector-split-at)) q (109983 . 4)) ((c def c (c (? . 40) q contract-continuation-mark-key)) q (237553 . 2)) ((c def c (c (? . 44) q flmax)) q (34480 . 4)) ((c def c (c (? . 30) q current-break-parameterization)) q (270417 . 2)) ((c def c (c (? . 25) q pretty-print-abbreviate-read-macros)) q (371064 . 4)) ((c def c (c (? . 0) q expand-syntax-to-top-form)) q (314874 . 4)) ((c def c (c (? . 0) q vector->values)) q (108685 . 5)) ((c def c (c (? . 0) q real->single-flonum)) q (23063 . 3)) ((c form c (c (? . 0) q #%top)) q (10952 . 2)) ((c form c (c (? . 16) q for*/extflvector)) q (45094 . 9)) ((c def c (c (? . 0) q seconds->date)) q (480972 . 4)) ((c form c (c (? . 9) q set-field!)) q (181879 . 2)) ((c def c (c (? . 0) q exn:fail:contract:variable-id)) c (? . 120)) ((c def c (c (? . 0) q make-struct-type)) q (165634 . 31)) ((c def c (c (? . 0) q floor)) q (24320 . 3)) ((c def c (c (? . 6) q hash-copy-clear)) q (120218 . 4)) ((c def c (c (? . 0) q free-identifier=?)) q (292827 . 10)) ((c def c (c (? . 0) q log-level-evt)) q (478943 . 3)) ((c def c (c (? . 0) q procedure-closure-contents-eq?)) q (158267 . 5)) ((c def c (c (? . 76) q syntax-local-value/record)) q (318046 . 4)) ((c def c (c (? . 0) q module-path-index-submodule)) q (394412 . 4)) ((c def c (c (? . 6) q with-output-to-file)) q (327040 . 18)) ((c def c (c (? . 10) q vector-memv)) q (111026 . 4)) ((c def c (c (? . 8) q last-pair)) q (99289 . 3)) ((c def c (c (? . 0) q string->immutable-string)) q (46649 . 3)) ((c form c (c (? . 0) q #%variable-reference)) q (10973 . 4)) ((c def c (c (? . 21) q hash->linklet-bundle)) q (432877 . 3)) ((c def c (c (? . 13) q set-count)) q (152031 . 3)) ((c form c (c (? . 6) q rename-out)) q (6547 . 2)) ((c def c (c (? . 0) q break-thread)) q (271773 . 4)) ((c def c (c (? . 1) q unsafe-set-immutable-car!)) q (497211 . 4)) ((c def c (c (? . 0) q random-seed)) q (27758 . 3)) ((c def c (c (? . 6) q regexp-replace*)) q (90213 . 15)) ((c form c (c (? . 6) q for*/hasheqv)) q (17018 . 2)) ((c def c (c (? . 15) q reencode-output-port)) q (341623 . 16)) ((c def c (c (? . 0) q make-rectangular)) q (25926 . 4)) ((c def c (c (? . 0) q get-output-bytes)) q (328801 . 9)) ((c form c (c (? . 6) q for-label)) q (7131 . 2)) ((c def c (c (? . 66) q exn:fail:contract:blame)) c (? . 70)) ((c def c (c (? . 0) q log)) q (25479 . 4)) ((c def c (c (? . 0) q current-reader-guard)) q (364585 . 4)) ((c def c (c (? . 13) q list->mutable-seteq)) q (148614 . 4)) ((c form c (c (? . 9) q with-method)) q (181669 . 3)) ((c def c (c (? . 42) q remq*)) q (94146 . 4)) ((c def c (c (? . 16) q extflvector-length)) q (44225 . 3)) ((c def c (c (? . 0) q stencil-vector-update)) q (113272 . 9)) ((c form c (c (? . 0) q #%datum)) q (10888 . 2)) ((c def c (c (? . 0) q imag-part)) q (26158 . 3)) ((c def c (c (? . 6) q regexp-replaces)) q (90960 . 8)) ((c def c (c (? . 21) q instance-data)) q (433833 . 3)) ((c form c (c (? . 6) q for/first)) q (16005 . 2)) ((c def c (c (? . 11) q fx>)) q (39342 . 4)) ((c def c (c (? . 1) q unsafe-fx->fl)) q (495766 . 3)) ((c def c (c (? . 0) q current-load/use-compiled)) q (387970 . 13)) ((c def c (c (? . 6) q in-bytes-lines)) q (126241 . 5)) ((c def c (c (? . 0) q syntax-source-module)) q (288321 . 5)) ((c def c (c (? . 0) q string-downcase)) q (49348 . 3)) ((c form c (c (? . 103) q struct/contract)) q (214869 . 6)) ((c def c (c (? . 0) q vector->immutable-vector)) q (108047 . 3)) ((c def c (c (? . 17) q write-to-file)) q (450649 . 11)) ((c def c (c (? . 0) q add1)) q (23865 . 3)) ((c def c (c (? . 0) q string->bytes/utf-8)) q (66601 . 6)) ((c def c (c (? . 4) q system/exit-code)) q (473424 . 5)) ((c def c (c (? . 0) q make-immutable-hasheqv)) q (117500 . 4)) ((q def ((lib "racket/syntax-srcloc.rkt") syntax-srcloc)) q (292543 . 3)) ((c def c (c (? . 16) q pi.t)) q (43941 . 2)) ((c def c (c (? . 56) q processor-count)) q (279591 . 2)) ((c def c (c (? . 44) q fllog)) q (35149 . 3)) ((c form c (c (? . 132) q enter!)) q (519673 . 9)) ((c def c (c (? . 2) q dict-keys)) q (141279 . 3)) ((c def c (c (? . 0) q procedure-arity?)) q (158932 . 3)) ((c def c (c (? . 0) q module-cache-clear!)) q (399043 . 2)) ((c form c (c (? . 41) q define-unit-from-context)) q (196207 . 2)) ((c def c (c (? . 0) q syntax-local-apply-transformer)) q (300785 . 11)) ((c def c (c (? . 49) q check-duplicate-identifier)) q (293589 . 3)) ((c def c (c (? . 51) q some-system-path->string)) q (443276 . 3)) ((c def c (c (? . 49) q syntax-protect)) q (313802 . 3)) ((c def c (c (? . 6) q exn:break)) c (? . 69)) ((c def c (c (? . 8) q check-duplicates)) q (102809 . 9)) ((c def c (c (? . 0) q struct-accessor-procedure?)) q (172568 . 3)) ((c def c (c (? . 21) q correlated?)) q (435156 . 3)) ((c def c (c (? . 6) q stop-before)) q (131794 . 4)) ((c form c (c (? . 23) q ->*)) q (206845 . 26)) ((c def c (c (? . 26) q syntax/c)) q (203285 . 3)) ((c def c (c (? . 0) q vector-ref)) q (107020 . 4)) ((c def c (c (? . 88) q space?)) q (319022 . 3)) ((c def c (c (? . 102) q boolean=?)) q (21478 . 4)) ((c def c (c (? . 0) q compiled-module-expression?)) q (394782 . 3)) ((c def c (c (? . 25) q pretty-print-current-style-table)) q (371277 . 4)) ((c def c (c (? . 44) q make-flvector)) q (36334 . 4)) ((c form c (c (? . 65) q for*/list/concurrent)) q (263055 . 3)) ((c def c (c (? . 1) q unsafe-vector*-cas!)) q (498448 . 6)) ((c def c (c (? . 0) q char?)) q (70594 . 3)) ((c def c (c (? . 0) q list?)) q (92270 . 3)) ((c def c (c (? . 6) q exn:fail:filesystem:errno)) c (? . 84)) ((c def c (c (? . 6) q make-exn:fail:contract)) c (? . 126)) ((c def c (c (? . 0) q make-syntax-introducer)) q (306668 . 4)) ((c form c (c (? . 41) q only)) q (193607 . 2)) ((c def c (c (? . 15) q combine-output)) q (340084 . 4)) ((c def c (c (? . 19) q collapsible-count-property-prev)) c (? . 35)) ((c def c (c (? . 17) q copy-directory/files)) q (451686 . 11)) ((c def c (c (? . 43) q normal-case-path)) q (440359 . 3)) ((c def c (c (? . 16) q make-shared-extflvector)) q (45441 . 4)) ((c form c (c (? . 13) q for/set)) q (149133 . 2)) ((c form c (c (? . 13) q for*/weak-set)) q (150225 . 2)) ((c def c (c (? . 3) q import-source?)) c (? . 33)) ((c def c (c (? . 19) q collapsible-contract-property?)) q (239261 . 3)) ((c form c (c (? . 67) q runtime-require)) q (448704 . 2)) ((c form c (c (? . 6) q all-defined-out)) q (6482 . 2)) ((c def c (c (? . 42) q assw)) q (95606 . 4)) ((c def c (c (? . 0) q impersonate-continuation-mark-key)) q (405058 . 13)) ((c def c (c (? . 6) q hash-values)) q (120862 . 4)) ((c def c (c (? . 9) q implementation?)) q (189669 . 4)) ((c def c (c (? . 0) q exn:break:terminate?)) c (? . 121)) ((c def c (c (? . 25) q pretty-print-newline)) q (371971 . 4)) ((c def c (c (? . 8) q drop-right)) q (101012 . 4)) ((c def c (c (? . 42) q foldr)) q (93501 . 5)) ((c def c (c (? . 0) q semaphore?)) q (274769 . 3)) ((c def c (c (? . 0) q hash-remove!)) q (119788 . 4)) ((c def c (c (? . 0) q thread)) q (271152 . 3)) ((c def c (c (? . 0) q memq)) q (95129 . 4)) ((c form c (c (? . 6) q struct/derived)) q (165368 . 5)) ((c def c (c (? . 1) q unsafe-flvector-length)) q (500298 . 3)) ((c def c (c (? . 19) q collapsible-leaf/c-contract-list)) c (? . 36)) ((c def c (c (? . 0) q eq-hash-code)) q (20963 . 3)) ((c form c (c (? . 64) q unsyntax)) q (285665 . 2)) ((c form c (c (? . 133) q struct/dc)) q (203403 . 27)) ((c def c (c (? . 1) q unsafe-stencil-vector-update)) q (501977 . 9)) ((c def c (c (? . 0) q eprintf)) q (366256 . 4)) ((c def c (c (? . 6) q sequence-generate)) q (133176 . 3)) ((c def c (c (? . 0) q real->double-flonum)) q (23134 . 3)) ((c form c (c (? . 9) q send+)) q (181553 . 5)) ((c def c (c (? . 0) q filesystem-change-evt-cancel)) q (448266 . 3)) ((c def c (c (? . 0) q make-ephemeron-hash)) q (116580 . 4)) ((c def c (c (? . 40) q contract-late-neg-projection)) q (236605 . 4)) ((c def c (c (? . 0) q expand-user-path)) q (440112 . 3)) ((c def c (c (? . 0) q cadaar)) q (97357 . 3)) ((c def c (c (? . 0) q syntax-span)) q (288160 . 3)) ((c form c (c (? . 9) q public-final*)) q (178512 . 2)) ((c def c (c (? . 0) q unquoted-printing-string-value)) q (254232 . 3)) ((c def c (c (? . 82) q positive-integer?)) q (33389 . 3)) ((c def c (c (? . 2) q dict-implements/c)) q (138063 . 3)) ((c def c (c (? . 8) q sixth)) q (98987 . 3)) ((c def c (c (? . 0) q bytes-open-converter)) q (68686 . 5)) ((c def c (c (? . 65) q force)) q (262150 . 3)) ((c form c (c (? . 6) q define-splicing-for-clause-syntax)) q (18962 . 2)) ((c def c (c (? . 6) q call-with-input-file)) q (324300 . 7)) ((c def c (c (? . 0) q regexp-match-positions/end)) q (85881 . 16)) ((c def c (c (? . 0) q exn?)) c (? . 47)) ((c def c (c (? . 1) q unsafe-fx>=)) q (493027 . 4)) ((c form c (c (? . 9) q augment)) q (178078 . 2)) ((c def c (c (? . 1) q unsafe-fxnot)) q (491807 . 3)) ((c form c (c (? . 76) q with-syntax*)) q (318877 . 5)) ((c def c (c (? . 76) q current-syntax-context)) q (317496 . 4)) ((c def c (c (? . 0) q asin)) q (25715 . 3)) ((c def c (c (? . 0) q semaphore-peek-evt?)) q (275301 . 3)) ((c def c (c (? . 0) q number->string)) q (29377 . 4)) ((c def c (c (? . 0) q thread-cell?)) q (277605 . 3)) ((c def c (c (? . 0) q custom-print-quotable-accessor)) q (375439 . 2)) ((c def c (c (? . 25) q pretty-print-depth)) q (370501 . 4)) ((c def c (c (? . 9) q interface->method-names)) q (189958 . 3)) ((c def c (c (? . 0) q prop:input-port)) q (329549 . 2)) ((c def c (c (? . 16) q extfl>)) q (42171 . 4)) ((c def c (c (? . 24) q prop:provide-transformer)) q (310555 . 2)) ((c def c (c (? . 13) q mutable-setalw)) q (147204 . 4)) ((c def c (c (? . 19) q collapsible-count-property-count)) c (? . 35)) ((c def c (c (? . 0) q odd?)) q (22778 . 3)) ((c def c (c (? . 0) q struct-info)) q (415994 . 3)) ((c def c (c (? . 1) q unsafe-fx*/wraparound)) q (492507 . 4)) ((c def c (c (? . 25) q tentative-pretty-print-port-cancel)) q (374042 . 3)) ((c def c (c (? . 0) q current-drive)) q (447493 . 2)) ((c def c (c (? . 102) q true)) q (21352 . 2)) ((c def c (c (? . 134) q bytes-append*)) q (70396 . 4)) ((c def c (c (? . 0) q car)) q (92157 . 3)) ((c def c (c (? . 0) q exn:srclocs-accessor)) q (260393 . 4)) ((c def c (c (? . 22) q sequence-count)) q (134365 . 4)) ((c def c (c (? . 0) q string-upcase)) q (49284 . 3)) ((c def c (c (? . 57) q contract-proc)) q (242439 . 6)) ((c def c (c (? . 0) q sha1-bytes)) q (379479 . 5)) ((c form c (c (? . 76) q define/with-syntax)) q (317421 . 4)) ((c def c (c (? . 0) q phantom-bytes?)) q (490803 . 3)) ((c def c (c (? . 23) q list*of)) q (202604 . 4)) ((c def c (c (? . 6) q make-exn:fail:contract:continuation)) c (? . 108)) ((c def c (c (? . 1) q unsafe-fltan)) q (494652 . 3)) ((c def c (c (? . 0) q list*)) q (92373 . 4)) ((c form c (c (? . 0) q quote-syntax)) q (19312 . 3)) ((c form c (c (? . 65) q delay/name)) q (262349 . 2)) ((c def c (c (? . 37) q udp-send-to*)) q (463624 . 13)) ((c form c (c (? . 26) q prompt-tag/c)) q (205503 . 8)) ((c def c (c (? . 0) q srcloc-span)) c (? . 59)) ((c def c (c (? . 0) q split-path)) q (440478 . 5)) ((c def c (c (? . 42) q remv*)) q (94225 . 4)) ((c def c (c (? . 0) q vector->pseudo-random-generator!)) q (28415 . 5)) ((c def c (c (? . 16) q make-extflvector)) q (44096 . 4)) ((c form c (c (? . 9) q public)) q (177843 . 2)) ((c def c (c (? . 0) q hash-copy)) q (122922 . 3)) ((c def c (c (? . 0) q exn:fail:network?)) c (? . 83)) ((c def c (c (? . 122) q prop:chaperone-unsafe-undefined)) q (516333 . 2)) ((c def c (c (? . 9) q equal<%>)) q (188356 . 2)) ((c def c (c (? . 6) q in-string)) q (125293 . 6)) ((c form c (c (? . 13) q define-custom-set-types)) q (156032 . 12)) ((c def c (c (? . 10) q vector-argmax)) q (110822 . 4)) ((c def c (c (? . 0) q null)) q (92249 . 2)) ((c form c (c (? . 31) q set)) q (267338 . 2)) ((c def c (c (? . 26) q continuation-mark-key/c)) q (205700 . 3)) ((c def c (c (? . 80) q date*->seconds)) q (483338 . 4)) ((c def c (c (? . 0) q ceiling)) q (24403 . 3)) ((c def c (c (? . 16) q extfl>=)) q (42334 . 4)) ((c form c (c (? . 9) q augment*)) q (178666 . 2)) ((c def c (c (? . 0) q port-display-handler)) q (368638 . 6)) ((c def c (c (? . 0) q regexp-match-peek-immediate)) q (82208 . 15)) ((c def c (c (? . 9) q object=?)) q (188980 . 4)) ((c def c (c (? . 0) q struct-type-make-predicate)) q (416797 . 3)) ((c form c (c (? . 6) q local-require)) q (5531 . 2)) ((c def c (c (? . 0) q current-library-collection-links)) q (518376 . 11)) ((c def c (c (? . 0) q current-locale)) q (319702 . 4)) ((c def c (c (? . 6) q in-values*-sequence)) q (131720 . 3)) ((c def c (c (? . 0) q write-char)) q (358316 . 4)) ((c def c (c (? . 0) q raise-result-error)) q (247779 . 13)) ((c def c (c (? . 24) q provide-transformer?)) q (310673 . 3)) ((c def c (c (? . 17) q get-preference)) q (456118 . 18)) ((c form c (c (? . 32) q redirect-generics)) q (170869 . 4)) ((c def c (c (? . 40) q flat-contract?)) q (236157 . 3)) ((c def c (c (? . 12) q sandbox-make-environment-variables)) q (425865 . 5)) ((c def c (c (? . 0) q internal-definition-context-add-scopes)) q (301630 . 5)) ((c def c (c (? . 1) q unsafe-cdr)) q (496541 . 3)) ((c def c (c (? . 17) q make-directory*)) q (453779 . 3)) ((c def c (c (? . 20) q tcp-addresses)) q (461773 . 7)) ((c def c (c (? . 0) q make-ephemeron)) q (489777 . 4)) ((c def c (c (? . 1) q unsafe-impersonate-vector)) q (515040 . 11)) ((c def c (c (? . 0) q string->list)) q (48042 . 3)) ((c def c (c (? . 0) q module->exports)) q (398279 . 7)) ((c def c (c (? . 16) q fx->extfl)) q (43818 . 3)) ((c def c (c (? . 13) q set-member?)) q (151547 . 4)) ((c form c (c (? . 9) q init-field)) q (177697 . 2)) ((c def c (c (? . 6) q make-exn:break)) c (? . 69)) ((c def c (c (? . 0) q semaphore-try-wait?)) q (275058 . 3)) ((c def c (c (? . 0) q open-input-bytes)) q (328312 . 4)) ((c def c (c (? . 11) q fxvector-ref)) q (40229 . 4)) ((c def c (c (? . 0) q regexp)) q (74416 . 6)) ((c form c (c (? . 6) q for/fold)) q (16132 . 6)) ((c form c (c (? . 48) q match-lambda**)) q (244720 . 2)) ((c def c (c (? . 122) q chaperone-struct-unsafe-undefined)) q (516257 . 3)) ((c def c (c (? . 0) q raise-arity-error*)) q (251618 . 13)) ((c def c (c (? . 37) q udp-send-ready-evt)) q (466947 . 3)) ((c def c (c (? . 0) q syntax?)) q (287709 . 3)) ((c def c (c (? . 23) q non-empty-listof)) q (202532 . 3)) ((c def c (c (? . 0) q rename-transformer-target)) q (298104 . 3)) ((c def c (c (? . 1) q unsafe-flexpt)) q (495069 . 4)) ((c def c (c (? . 135) q syntax-procedure-alias-property)) q (311173 . 8)) ((c def c (c (? . 8) q empty)) q (98557 . 2)) ((c form c (c (? . 41) q import)) q (193746 . 2)) ((c def c (c (? . 0) q make-pipe)) q (329246 . 6)) ((c def c (c (? . 14) q processor-count)) q (282451 . 2)) ((c def c (c (? . 0) q write)) q (365265 . 4)) ((c def c (c (? . 17) q display-to-file)) q (450186 . 11)) ((c def c (c (? . 1) q unsafe-fl<=)) q (493883 . 4)) ((c def c (c (? . 0) q read-byte-or-special)) q (355939 . 8)) ((c form c (c (? . 27) q letrec-syntax)) q (12302 . 2)) ((c def c (c (? . 0) q regexp-match-peek-positions)) q (81219 . 19)) ((c form c (c (? . 13) q for*/set)) q (149333 . 2)) ((c def c (c (? . 0) q module-predefined?)) q (398898 . 4)) ((c form c (c (? . 23) q ->d)) q (209874 . 34)) ((c def c (c (? . 0) q bytes?)) q (63514 . 3)) ((c def c (c (? . 15) q display-lines)) q (335704 . 7)) ((c def c (c (? . 0) q syntax-track-origin)) q (313363 . 7)) ((c def c (c (? . 82) q exact-ceiling)) q (33044 . 3)) ((c def c (c (? . 0) q primitive?)) q (162570 . 3)) ((c def c (c (? . 17) q other-permission-bits)) q (459978 . 2)) ((c def c (c (? . 57) q struct-type-property/c)) q (213078 . 3)) ((c def c (c (? . 43) q call-with-default-reading-parameterization)) q (364490 . 3)) ((c def c (c (? . 0) q current-error-port)) q (320476 . 4)) ((c def c (c (? . 0) q prop:expansion-contexts)) q (303549 . 2)) ((c def c (c (? . 16) q extfl->inexact)) q (43877 . 3)) ((c def c (c (? . 19) q impersonator-prop:collapsible)) q (240731 . 2)) ((c def c (c (? . 0) q load-extension)) q (387825 . 3)) ((c def c (c (? . 0) q vector->pseudo-random-generator)) q (28291 . 4)) ((c form c (c (? . 48) q match-let)) q (244758 . 2)) ((c def c (c (? . 0) q mpair?)) q (106230 . 3)) ((c def c (c (? . 0) q even?)) q (22724 . 3)) ((c def c (c (? . 6) q make-exn:fail:filesystem:exists)) c (? . 129)) ((c def c (c (? . 1) q unsafe-char<?)) q (496089 . 4)) ((c form c (c (? . 9) q define/augment)) q (179318 . 3)) ((c form c (c (? . 40) q contract-pos/neg-doubling)) q (223146 . 2)) ((c def c (c (? . 0) q hash-placeholder?)) q (105775 . 3)) ((c def c (c (? . 0) q struct:exn:fail:read)) c (? . 85)) ((c def c (c (? . 0) q impersonate-channel)) q (403748 . 13)) ((c def c (c (? . 0) q hash-eq?)) q (114625 . 3)) ((c def c (c (? . 1) q unsafe-box*-cas!)) q (497721 . 5)) ((c def c (c (? . 0) q sha256-bytes)) q (379875 . 5)) ((c def c (c (? . 0) q make-readtable)) q (374206 . 11)) ((c def c (c (? . 0) q file-stream-buffer-mode)) q (320957 . 6)) ((c def c (c (? . 0) q cdaar)) q (96629 . 3)) ((c form c (c (? . 40) q with-contract-continuation-mark)) q (223025 . 3)) ((c def c (c (? . 20) q tcp-connect)) q (460464 . 9)) ((c def c (c (? . 11) q fx*)) q (37864 . 3)) ((c def c (c (? . 26) q rename-contract)) q (237867 . 4)) ((c form c (c (? . 23) q flat-rec-contract)) q (205883 . 2)) ((c def c (c (? . 21) q instance-describe-variable!)) q (434695 . 7)) ((c form c (c (? . 53) q contract-first-order-okay-to-give-up?)) q (237972 . 2)) ((c def c (c (? . 0) q log-message)) q (477979 . 13)) ((c def c (c (? . 44) q flvector)) q (36272 . 3)) ((c def c (c (? . 1) q unsafe-list-ref)) q (496962 . 4)) ((c def c (c (? . 40) q coerce-chaperone-contract)) q (222377 . 4)) ((c def c (c (? . 0) q special-comment-value)) q (374976 . 3)) ((c def c (c (? . 24) q export)) c (? . 68)) ((c def c (c (? . 1) q unsafe-extflasin)) q (513301 . 3)) ((c def c (c (? . 6) q make-do-sequence)) q (132005 . 15)) ((c def c (c (? . 44) q flceiling)) q (34666 . 3)) ((c def c (c (? . 19) q collapsible-contract?)) q (238861 . 3)) ((c form c (c (? . 136) q define-syntax-parameter)) q (312088 . 2)) ((c def c (c (? . 57) q make-proj-contract)) q (241482 . 15)) ((c def c (c (? . 0) q current-evt-pseudo-random-generator)) q (274143 . 5)) ((c def c (c (? . 21) q linklet?)) q (428954 . 3)) ((c form c (c (? . 14) q place/context)) q (282412 . 2)) ((c form c (c (? . 6) q for/and)) q (15580 . 2)) ((c def c (c (? . 0) q current-security-guard)) q (413598 . 4)) ((c form c (c (? . 137) q filtered-out)) q (10819 . 2)) ((c def c (c (? . 44) q flasin)) q (34990 . 3)) ((c def c (c (? . 57) q contract-random-generate/choose)) q (243080 . 4)) ((c form c (c (? . 2) q gen:dict)) q (138339 . 2)) ((c def c (c (? . 0) q unbox*)) q (114012 . 3)) ((c def c (c (? . 23) q and/c)) q (200149 . 3)) ((c def c (c (? . 82) q nan?)) q (33284 . 3)) ((c def c (c (? . 17) q character-device-type-bits)) q (459507 . 2)) ((c def c (c (? . 15) q dup-output-port)) q (342409 . 4)) ((c def c (c (? . 0) q impersonate-vector*)) q (401580 . 15)) ((c def c (c (? . 15) q read-bytes-line-evt)) q (347595 . 5)) ((c def c (c (? . 27) q call/ec)) q (264758 . 3)) ((c def c (c (? . 0) q string->path-element)) q (437544 . 6)) ((c def c (c (? . 130) q hash-union!)) q (123497 . 11)) ((c def c (c (? . 1) q unsafe-extflvector-length)) q (513938 . 3)) ((c def c (c (? . 0) q thread-resume)) q (271579 . 4)) ((c def c (c (? . 13) q set-mutable?)) q (146639 . 3)) ((c def c (c (? . 10) q vector-copy)) q (110227 . 5)) ((c def c (c (? . 0) q port-counts-lines?)) q (321671 . 3)) ((c def c (c (? . 14) q place?)) q (280284 . 3)) ((c form c (c (? . 23) q contract-out)) q (213177 . 23)) ((c def c (c (? . 0) q complete-path?)) q (439480 . 3)) ((c def c (c (? . 6) q hash-empty?)) q (121443 . 3)) ((c def c (c (? . 66) q blame-original?)) q (224618 . 3)) ((c def c (c (? . 0) q chaperone-of?)) q (399286 . 4)) ((c def c (c (? . 0) q struct:exn:fail:contract:divide-by-zero)) c (? . 118)) ((c def c (c (? . 0) q path-element->string)) q (438091 . 3)) ((c def c (c (? . 0) q port-writes-special?)) q (361203 . 3)) ((c def c (c (? . 6) q in-inclusive-range)) q (124719 . 5)) ((c def c (c (? . 1) q unsafe-fxquotient)) q (491302 . 4)) ((c def c (c (? . 0) q current-write-relative-directory)) q (367913 . 11)) ((c form c (c (? . 9) q this%)) q (177621 . 2)) ((c def c (c (? . 82) q exact-round)) q (32910 . 3)) ((c def c (c (? . 1) q unsafe-cons-list)) q (496862 . 4)) ((c def c (c (? . 0) q struct:exn:fail:syntax:missing-module)) c (? . 52)) ((c form c (c (? . 27) q letrec)) q (12004 . 2)) ((c def c (c (? . 13) q subset?)) q (153612 . 4)) ((c def c (c (? . 66) q blame-add-context)) q (223841 . 9)) ((c def c (c (? . 0) q make-output-port)) q (331838 . 59)) ((c def c (c (? . 0) q module->imports)) q (398033 . 6)) ((c def c (c (? . 13) q set-equal?)) q (146363 . 3)) ((c form c (c (? . 136) q define-rename-transformer-parameter)) q (312196 . 2)) ((c form c (c (? . 6) q for*/vector)) q (16808 . 2)) ((c def c (c (? . 21) q recompile-linklet)) q (430226 . 28)) ((c def c (c (? . 8) q eighth)) q (99089 . 3)) ((c def c (c (? . 1) q unsafe-fxrshift)) q (491949 . 4)) ((c def c (c (? . 8) q split-at)) q (100548 . 4)) ((c def c (c (? . 6) q procedure-reduce-keyword-arity-mask)) q (160991 . 14)) ((c def c (c (? . 6) q in-hash-values)) q (126743 . 6)) ((c def c (c (? . 42) q remv)) q (93882 . 4)) ((c def c (c (? . 6) q make-exn:fail:syntax:unbound)) c (? . 138)) ((c def c (c (? . 6) q in-input-port-bytes)) q (125905 . 3)) ((c def c (c (? . 11) q fxremainder)) q (37997 . 4)) ((c def c (c (? . 0) q compiled-expression-recompile)) q (390474 . 3)) ((c def c (c (? . 0) q byte-regexp?)) q (74299 . 3)) ((c def c (c (? . 0) q substring)) q (47082 . 5)) ((c def c (c (? . 0) q make-weak-hashalw)) q (116138 . 4)) ((q def ((lib "racket/symbol.rkt") symbol->immutable-string)) q (74096 . 3)) ((c def c (c (? . 8) q indexes-where)) q (100225 . 4)) ((c def c (c (? . 0) q exn:fail:syntax:unbound?)) c (? . 138)) ((c def c (c (? . 0) q string-copy)) q (47261 . 3)) ((c def c (c (? . 12) q call-with-custodian-shutdown)) c (? . 139)) ((c def c (c (? . 6) q make-exn:fail:contract:non-fixnum-result)) c (? . 97)) ((c def c (c (? . 0) q bytes->path)) q (437264 . 4)) ((c def c (c (? . 6) q make-base-empty-namespace)) q (380179 . 2)) ((c form c (c (? . 41) q contracted)) q (193566 . 2)) ((c def c (c (? . 6) q call-with-output-file*)) q (325820 . 18)) ((c def c (c (? . 80) q date->julian/scaliger)) q (483991 . 3)) ((c def c (c (? . 19) q prop:collapsible-contract)) q (238803 . 2)) ((c def c (c (? . 0) q eval-jit-enabled)) q (391444 . 4)) ((c def c (c (? . 11) q fxvector)) q (39964 . 3)) ((c def c (c (? . 24) q make-provide-transformer)) q (309967 . 10)) ((c def c (c (? . 6) q make-exn:fail:filesystem:version)) c (? . 86)) ((c def c (c (? . 6) q in-cycle)) q (131508 . 3)) ((c form c (c (? . 13) q gen:set)) q (151532 . 2)) ((c def c (c (? . 44) q flatan)) q (35096 . 3)) ((c form c (c (? . 9) q override-final*)) q (178624 . 2)) ((c def c (c (? . 0) q identifier-remove-from-definition-context)) q (303255 . 7)) ((c def c (c (? . 0) q hash-clear)) q (120117 . 3)) ((c def c (c (? . 0) q open-output-string)) q (328690 . 3)) ((c def c (c (? . 23) q or/c)) q (199995 . 3)) ((c def c (c (? . 0) q current-seconds)) q (480810 . 2)) ((c form c (c (? . 6) q for/lists)) q (15831 . 7)) ((c def c (c (? . 11) q fxvector?)) q (39909 . 3)) ((c def c (c (? . 0) q struct:exn:fail:syntax:unbound)) c (? . 138)) ((c def c (c (? . 25) q pretty-print-handler)) q (370258 . 3)) ((c def c (c (? . 0) q current-get-interaction-evt)) q (389730 . 4)) ((c def c (c (? . 1) q unsafe-flmin)) q (494053 . 4)) ((c def c (c (? . 0) q make-ephemeron-hashalw)) q (116734 . 4)) ((c def c (c (? . 0) q subbytes)) q (64198 . 5)) ((c def c (c (? . 0) q identifier-prune-lexical-context)) q (291772 . 5)) ((c form c (c (? . 0) q unquote-splicing)) q (19288 . 2)) ((c def c (c (? . 9) q is-a?)) q (189493 . 4)) ((c def c (c (? . 0) q make-string)) q (46473 . 4)) ((c def c (c (? . 24) q export-orig-stx)) c (? . 68)) ((c form c (c (? . 9) q abstract)) q (178221 . 2)) ((q form ((lib "racket/help.rkt") help)) q (519363 . 6)) ((c def c (c (? . 0) q peek-bytes-avail!)) q (353665 . 14)) ((c def c (c (? . 40) q contract-custom-write-property-proc)) q (237617 . 7)) ((c def c (c (? . 1) q unsafe-set-box!)) q (497441 . 4)) ((c def c (c (? . 7) q stream-add-between)) q (136992 . 4)) ((c def c (c (? . 0) q string-ci=?)) q (48797 . 4)) ((c def c (c (? . 6) q in-weak-hash-values)) q (129507 . 3)) ((c def c (c (? . 6) q date*)) c (? . 63)) ((c def c (c (? . 0) q struct:exn:fail:filesystem)) c (? . 89)) ((c def c (c (? . 6) q sequence->stream)) q (133107 . 3)) ((c def c (c (? . 140) q syntax-local-require-introduce)) q (13954 . 3)) ((c def c (c (? . 66) q raise-blame-error)) q (223241 . 14)) ((c def c (c (? . 37) q udp-send-to)) q (462945 . 13)) ((c def c (c (? . 44) q flcos)) q (34886 . 3)) ((c def c (c (? . 11) q fixnum-for-every-system?)) q (39839 . 3)) ((c def c (c (? . 0) q call-in-nested-thread)) q (271386 . 4)) ((c def c (c (? . 0) q char<?)) q (71076 . 4)) ((c def c (c (? . 0) q current-preserved-thread-cell-values)) q (277933 . 4)) ((c def c (c (? . 11) q fxpopcount)) q (38579 . 3)) ((c def c (c (? . 44) q fl-)) q (33756 . 4)) ((c def c (c (? . 0) q make-immutable-hash)) q (117206 . 4)) ((c form c (c (? . 9) q define/public-final)) q (178970 . 3)) ((c def c (c (? . 11) q fx+)) q (37733 . 3)) ((c def c (c (? . 0) q bytes->string/locale)) q (65881 . 9)) ((c def c (c (? . 44) q fl+)) q (33701 . 3)) ((c form c (c (? . 41) q tag)) q (193855 . 3)) ((c def c (c (? . 0) q srcloc-line)) c (? . 59)) ((c def c (c (? . 9) q interface-extension?)) q (189760 . 4)) ((c def c (c (? . 1) q unsafe-extfl=)) q (512186 . 4)) ((c def c (c (? . 1) q unsafe-fxremainder)) q (491387 . 4)) ((c def c (c (? . 15) q dup-input-port)) q (342300 . 4)) ((c def c (c (? . 0) q datum-intern-literal)) q (291478 . 3)) ((c form c (c (? . 41) q open)) q (193491 . 2)) ((c def c (c (? . 31) q call/prompt)) q (265626 . 7)) ((c def c (c (? . 0) q special-comment?)) q (374914 . 3)) ((c def c (c (? . 0) q equal-always-secondary-hash-code)) q (20886 . 3)) ((c form c (c (? . 13) q for/weak-seteq)) q (150058 . 2)) ((c def c (c (? . 6) q in-immutable-hash-values)) q (128607 . 3)) ((c def c (c (? . 7) q stream-map)) q (136294 . 4)) ((c def c (c (? . 12) q default-language-readers)) q (426043 . 3)) ((c def c (c (? . 13) q set-intersect!)) q (152985 . 4)) ((c def c (c (? . 0) q delete-directory)) q (447744 . 3)) ((c def c (c (? . 0) q expand-to-top-form)) q (314724 . 4)) ((c def c (c (? . 0) q make-continuation-mark-key)) q (269800 . 4)) ((c form c (c (? . 27) q let*-values)) q (12117 . 2)) ((c def c (c (? . 0) q port-write-handler)) q (368421 . 6)) ((c def c (c (? . 0) q peek-bytes)) q (352450 . 5)) ((c def c (c (? . 0) q make-resolved-module-path)) q (391715 . 7)) ((c def c (c (? . 42) q remove)) q (93697 . 5)) ((c form c (c (? . 41) q unit)) q (191888 . 22)) ((c form c (c (? . 48) q match-lambda)) q (244649 . 2)) ((c def c (c (? . 0) q box)) q (113737 . 3)) ((c def c (c (? . 0) q memv)) q (95025 . 4)) ((c def c (c (? . 1) q unsafe-fllog)) q (494891 . 3)) ((c form c (c (? . 41) q compound-unit)) q (194161 . 12)) ((c def c (c (? . 1) q unsafe-extflatan)) q (513439 . 3)) ((c def c (c (? . 6) q with-input-from-file)) q (326768 . 7)) ((c def c (c (? . 17) q file->value)) q (449117 . 4)) ((c def c (c (? . 6) q in-list)) q (124939 . 3)) ((c def c (c (? . 0) q positive?)) q (22614 . 3)) ((c def c (c (? . 19) q collapsible-count-property)) c (? . 35)) ((c def c (c (? . 0) q raise-range-error)) q (249324 . 17)) ((c def c (c (? . 0) q make-hasheqv)) q (115712 . 4)) ((c def c (c (? . 5) q const*)) q (162880 . 3)) ((c form c (c (? . 9) q augride)) q (178115 . 2)) ((c def c (c (? . 0) q progress-evt?)) q (358169 . 6)) ((c def c (c (? . 73) q extract-struct-info)) q (173894 . 3)) ((c def c (c (? . 19) q struct:collapsible-ho/c)) c (? . 94)) ((c def c (c (? . 0) q string?)) q (46420 . 3)) ((c def c (c (? . 2) q dict-iterate-first)) q (139111 . 3)) ((c def c (c (? . 13) q set-eq?)) q (146536 . 3)) ((c def c (c (? . 1) q unsafe-mutable-hash-iterate-key)) q (503291 . 4)) ((c def c (c (? . 8) q cons?)) q (98579 . 3)) ((c def c (c (? . 6) q make-exn:fail:unsupported)) c (? . 119)) ((c def c (c (? . 40) q contract-val-first-projection)) q (236820 . 4)) ((c def c (c (? . 0) q hash-remove)) q (119902 . 4)) ((c def c (c (? . 0) q prefab-key->struct-type)) q (173032 . 4)) ((c def c (c (? . 0) q caadar)) q (97157 . 3)) ((c def c (c (? . 17) q make-temporary-directory)) q (454526 . 6)) ((c form c (c (? . 141) q define-provide-syntax)) q (14035 . 3)) ((c def c (c (? . 6) q make-exn:fail:syntax:missing-module)) c (? . 52)) ((c def c (c (? . 16) q floating-point-bytes->extfl)) q (45577 . 9)) ((c def c (c (? . 39) q trace-call)) q (520877 . 5)) ((c def c (c (? . 6) q impersonate-procedure*)) q (399886 . 11)) ((c def c (c (? . 0) q exn:fail:syntax?)) c (? . 104)) ((c def c (c (? . 0) q srcloc?)) c (? . 59)) ((c def c (c (? . 0) q thread-rewind-receive)) q (272651 . 3)) ((c def c (c (? . 1) q unsafe-fxvector-ref)) q (500100 . 4)) ((c def c (c (? . 17) q symbolic-link-type-bits)) q (459341 . 2)) ((c def c (c (? . 0) q bytes-converter?)) q (70290 . 3)) ((c def c (c (? . 48) q legacy-match-expander?)) q (245551 . 3)) ((c def c (c (? . 0) q nack-guard-evt)) q (273537 . 3)) ((c def c (c (? . 0) q symbol-interned?)) q (73492 . 3)) ((c def c (c (? . 0) q hash-iterate-value)) q (122008 . 4)) ((c def c (c (? . 17) q group-permission-bits)) q (459831 . 2)) ((c def c (c (? . 0) q cdaaar)) q (97757 . 3)) ((c form c (c (? . 13) q for*/mutable-set)) q (149769 . 2)) ((c form c (c (? . 13) q for*/weak-setalw)) q (150392 . 2)) ((c def c (c (? . 42) q build-string)) q (48184 . 4)) ((c def c (c (? . 0) q stencil-vector-mask-width)) q (112527 . 2)) ((c form c (c (? . 6) q define-struct)) q (165206 . 6)) ((c def c (c (? . 0) q string-normalize-nfc)) q (49720 . 3)) ((c def c (c (? . 6) q exn:fail:user)) c (? . 125)) ((c def c (c (? . 0) q cdaadr)) q (97857 . 3)) ((c def c (c (? . 0) q struct:exn:fail:contract:variable)) c (? . 120)) ((c def c (c (? . 0) q alarm-evt)) q (273937 . 4)) ((c def c (c (? . 0) q compile-allow-set!-undefined)) q (390772 . 4)) ((c def c (c (? . 0) q read-cdot)) q (363963 . 4)) ((c def c (c (? . 0) q procedure-extract-target)) q (161889 . 3)) ((c form c (c (? . 9) q member-name-key)) q (180033 . 2)) ((c def c (c (? . 8) q first)) q (98682 . 3)) ((c def c (c (? . 0) q make-known-char-range-list)) q (72884 . 5)) ((c def c (c (? . 0) q remainder)) q (23609 . 4)) ((c def c (c (? . 0) q sync/timeout)) q (272822 . 4)) ((c def c (c (? . 1) q unsafe-flreal-part)) q (495372 . 5)) ((c def c (c (? . 15) q read-bytes-avail!-evt)) q (347074 . 4)) ((c def c (c (? . 6) q make-exn:fail:syntax)) c (? . 104)) ((c def c (c (? . 66) q blame-swapped?)) q (224680 . 3)) ((c def c (c (? . 3) q import?)) c (? . 28)) ((c def c (c (? . 0) q banner)) q (486486 . 2)) ((c def c (c (? . 0) q char-ci<=?)) q (71636 . 4)) ((c def c (c (? . 0) q newline)) q (358550 . 3)) ((c def c (c (? . 10) q vector-empty?)) q (109028 . 3)) ((c def c (c (? . 0) q complex?)) q (21810 . 3)) ((c def c (c (? . 9) q dynamic-send)) q (181163 . 9)) ((c def c (c (? . 1) q unsafe-string->immutable-string!)) q (499124 . 4)) ((c def c (c (? . 0) q char-alphabetic?)) q (71923 . 3)) ((c def c (c (? . 1) q unsafe-chaperone-vector)) q (515467 . 11)) ((c def c (c (? . 0) q port-print-handler)) q (368859 . 7)) ((c def c (c (? . 37) q udp-multicast-join-group!)) q (468686 . 7)) ((c def c (c (? . 8) q takef-right)) q (101225 . 4)) ((c def c (c (? . 37) q udp-multicast-set-ttl!)) q (469721 . 4)) ((c def c (c (? . 20) q tcp-accept/enable-break)) q (461292 . 3)) ((c def c (c (? . 0) q read-square-bracket-with-tag)) q (362805 . 4)) ((c def c (c (? . 17) q group-read-bit)) q (459872 . 2)) ((c form c (c (? . 9) q override*)) q (178552 . 2)) ((c form c (c (? . 142) q define-module-boundary-contract)) q (215617 . 20)) ((c def c (c (? . 6) q make-exn:fail:network:errno)) c (? . 95)) ((c form c (c (? . 93) q in-generator)) q (137605 . 5)) ((c form c (c (? . 13) q for/mutable-seteqv)) q (149651 . 2)) ((c def c (c (? . 0) q struct-type?)) q (172362 . 3)) ((c def c (c (? . 8) q remove-duplicates)) q (103242 . 7)) ((c def c (c (? . 66) q blame-add-missing-party)) q (225072 . 5)) ((c def c (c (? . 0) q weak-box?)) q (489722 . 3)) ((c def c (c (? . 0) q magnitude)) q (26212 . 3)) ((c def c (c (? . 13) q list->weak-setalw)) q (148821 . 4)) ((c def c (c (? . 1) q unsafe-mcdr)) q (496649 . 3)) ((c def c (c (? . 143) q make-parameter-rename-transformer)) q (312326 . 3)) ((c def c (c (? . 57) q contract-random-generate-fail)) q (243218 . 2)) ((c def c (c (? . 16) q extfl->exact)) q (43682 . 3)) ((c def c (c (? . 19) q collapsible-wrapper-property-checking-wrapper)) c (? . 124)) ((c def c (c (? . 0) q current-output-port)) q (320363 . 4)) ((c def c (c (? . 0) q string-ci<?)) q (48894 . 4)) ((c def c (c (? . 0) q path-convention-type)) q (438343 . 3)) ((c form c (c (? . 93) q infinite-generator)) q (137565 . 2)) ((c def c (c (? . 6) q in-lines)) q (126053 . 5)) ((c form c (c (? . 7) q for*/stream)) q (137141 . 2)) ((c def c (c (? . 82) q infinite?)) q (33334 . 3)) ((c def c (c (? . 1) q unsafe-ephemeron-hash-iterate-first)) q (509144 . 3)) ((c def c (c (? . 6) q regexp-split)) q (88936 . 15)) ((c def c (c (? . 1) q unsafe-u16vector-set!)) q (501137 . 5)) ((c def c (c (? . 30) q call-with-break-parameterization)) q (270489 . 5)) ((c def c (c (? . 6) q in-directory)) q (130911 . 5)) ((c form c (c (? . 9) q define-serializable-class*)) q (188390 . 4)) ((c def c (c (? . 43) q path-string?)) q (437078 . 3)) ((c def c (c (? . 56) q futures-enabled?)) q (279371 . 2)) ((c def c (c (? . 19) q collapsible-leaf/c?)) c (? . 36)) ((c def c (c (? . 1) q unsafe-struct-ref)) q (502420 . 4)) ((c def c (c (? . 0) q equal?)) q (20104 . 4)) ((c def c (c (? . 0) q raise-type-error)) q (250732 . 10)) ((c def c (c (? . 6) q exn:fail:filesystem:exists)) c (? . 129)) ((c def c (c (? . 0) q wrap-evt)) q (273249 . 4)) ((c def c (c (? . 0) q current-compile-target-machine)) q (391034 . 5)) ((c def c (c (? . 3) q syntax-local-require-certifier)) q (309577 . 4))))
syntax
(iftest-exprthen-exprelse-expr)
syntax
(lambdaformalsbody...+)

formals=id
      |(id...)
      |(id...+. rest-id)
syntax
(init-restid)
(init-rest)
syntax
(parameterize([parameter-exprvalue-expr]...)
body...+)

parameter-expr:parameter?
procedure
(char->integerchar)->exact-integer?
char:char?
procedure
(argmaxproclst)->any
proc:(->any/creal?)
lst:(and/cpair?list?)
procedure
(read[in])->any
in:input-port?=(current-input-port)
procedure
(sort lst                         
     less-than?                  
    [#:keyextract-key           
     #:cache-keys?cache-keys?])->list?
lst:list?
less-than?:(any/cany/c. -> .any/c)
extract-key:(any/c. -> .any/c)=(lambda(x)x)
cache-keys?:boolean?=#f
struct
(struct color (red green blue alpha))
red:(and/cnatural-number/c(<=/c255))
green:(and/cnatural-number/c(<=/c255))
blue:(and/cnatural-number/c(<=/c255))
alpha:(and/cnatural-number/c(<=/c255))
struct
(structdata-source(connector args extensions)
#:mutable)
connector:(or/c'postgresql'mysql'sqlite3'odbc)
args:list?
extensions:(listof(list/csymbol?any/c))
parameter
(current-command-line-arguments)->(vectorofstring?)
(current-command-line-argumentsargv)->void?
argv:(vectorof(and/cstring?immutable?))
value
object%:class?

(somethingidthing-expr...)

thing-expr:number?
syntax
(moduleidmodule-pathform...)
syntax
(module*idmodule-pathform...)
(module*id#fform...)
syntax
(module+idform...)
syntax
(#%module-beginform...)
syntax
(#%printing-module-beginform...)
syntax
(#%plain-module-beginform...)
syntax
(#%declaredeclaration-keyword...)

declaration-keyword=#:cross-phase-persistent
                  |#:empty-namespace
                  |#:require=define
                  |#:unsafe
                  |#:realmidentifier
syntax
(requirerequire-spec...)

       require-spec=module-path
                  |(only-inrequire-specid-maybe-renamed...)
                  |(except-inrequire-specid...)
                  |(prefix-inprefix-idrequire-spec)
                  |(rename-inrequire-spec[orig-idbind-id]...)
                  |(combine-inrequire-spec...)
                  |(relative-inmodule-pathrequire-spec...)
                  |(only-meta-inphase-levelrequire-spec...)
                  |(only-space-inspacerequire-spec...)
                  |(for-syntaxrequire-spec...)
                  |(for-templaterequire-spec...)
                  |(for-labelrequire-spec...)
                  |(for-metaphase-levelrequire-spec...)
                  |(for-spacespacerequire-spec...)
                  |derived-require-spec
                  
        module-path=root-module-path
                  |(submodroot-module-pathsubmod-path-element...)
                  |(submod"."submod-path-element...)
                  |(submod".."submod-path-element...)
                  
   root-module-path=(quoteid)
                  |rel-string
                  |(librel-string...+)
                  |id
                  |(filestring)
                  |(planetid)
                  |(planetstring)
                  |(planetrel-string
                      (user-stringpkg-stringvers)
                      rel-string...)
                  
submod-path-element=id
                  |".."
                  
   id-maybe-renamed=id
                  |[orig-idbind-id]
                  
        phase-level=exact-integer
                  |#f
                  
              space=id
                  |#f
                  
               vers=
                  |nat
                  |natminor-vers
                  
         minor-vers=nat
                  |(natnat)
                  |(=nat)
                  |(+nat)
                  |(-nat)

module-path
syntax
(only-inrequire-specid-maybe-renamed...)
syntax
(except-inrequire-specid...)
syntax
(prefix-inprefix-idrequire-spec)
syntax
(rename-inrequire-spec[orig-idbind-id]...)
syntax
(combine-inrequire-spec...)
syntax
(relative-inmodule-pathrequire-spec...)
syntax
(only-meta-inphase-levelrequire-spec...)
syntax
(only-space-inspacerequire-spec...)

(for-metaphase-levelrequire-spec...)

(for-syntaxrequire-spec...)

(for-templaterequire-spec...)

(for-labelrequire-spec...)

(for-spacespacerequire-spec...)

derived-require-spec

(quoteid)

rel-string
syntax
(librel-string...+)

id
syntax
(filestring)
syntax
(planetid)
(planetstring)
(planetrel-string(user-stringpkg-stringvers)
rel-string...)
syntax
(submodroot-module-pathsubmod-path-element...)
(submod"."submod-path-element...)
(submod".."submod-path-element...)
syntax
(local-requirerequire-spec...)
syntax
(provideprovide-spec...)

provide-spec=id
           |(all-defined-out)
           |(all-from-outmodule-path...)
           |(rename-out[orig-idexport-id]...)
           |(except-outprovide-specprovide-spec...)
           |(prefix-outprefix-idprovide-spec)
           |(struct-outid)
           |(combine-outprovide-spec...)
           |(protect-outprovide-spec...)
           |(for-metaphase-levelprovide-spec...)
           |(for-syntaxprovide-spec...)
           |(for-templateprovide-spec...)
           |(for-labelprovide-spec...)
           |(for-spacespaceprovide-spec...)
           |derived-provide-spec
           
 phase-level=exact-integer
           |#f
           
       space=id
           |#f

id
syntax
(all-defined-out)
syntax
(all-from-outmodule-path...)
syntax
(rename-out[orig-idexport-id]...)
syntax
(except-outprovide-specprovide-spec...)
syntax
(prefix-outprefix-idprovide-spec)
syntax
(struct-outid)
syntax
(combine-outprovide-spec...)
syntax
(protect-outprovide-spec...)

(for-metaphase-levelprovide-spec...)

(for-syntaxprovide-spec...)

(for-templateprovide-spec...)

(for-labelprovide-spec...)

(for-spacespaceprovide-spec...)

derived-provide-spec
syntax
(for-metaphase-levelrequire-spec...)
syntax
(for-syntaxrequire-spec...)
syntax
(for-templaterequire-spec...)
syntax
(for-labelrequire-spec...)
syntax
(for-spacespacerequire-spec...)
syntax
(#%requireraw-require-spec...)

    raw-require-spec=phaseless-spec
                   |(for-metaphase-levelraw-require-spec...)
                   |(for-syntaxraw-require-spec...)
                   |(for-templateraw-require-spec...)
                   |(for-labelraw-require-spec...)
                   |(just-metaphase-levelraw-require-spec...)
                   |(portalportal-idcontent)
                   
         phase-level=exact-integer
                   |#f
                   
      phaseless-spec=spaceless-spec
                   |(for-spacespacephaseless-spec...)
                   |(just-spacespacespaceless-spec...)
                   
               space=id
                   |#f
                   
      spaceless-spec=raw-module-path
                   |(onlyraw-module-pathid...)
                   |(prefixprefix-idraw-module-path)
                   |(all-exceptraw-module-pathid...)
                   |(prefix-all-exceptprefix-id
                       raw-module-pathid...)
                   |(renameraw-module-pathlocal-idexported-id)
                   
     raw-module-path=raw-root-module-path
                   |(submodraw-root-module-pathid...+)
                   |(submod"."id...+)
                   
raw-root-module-path=(quoteid)
                   |rel-string
                   |(librel-string...)
                   |id
                   |(filestring)
                   |(planetrel-string
                       (user-stringpkg-stringvers...))
                   |literal-path
syntax
(#%provideraw-provide-spec...)

raw-provide-spec=phaseless-spec
               |(for-metaphase-levelphaseless-spec...)
               |(for-syntaxphaseless-spec...)
               |(for-labelphaseless-spec...)
               |(protectraw-provide-spec...)
               
     phase-level=exact-integer
               |#f
               
  phaseless-spec=spaceless-spec
               |(for-spacespacespaceless-spec...)
               |(protectphaseless-spec...)
               
           space=id
               |#f
               
  spaceless-spec=id
               |(renamelocal-idexport-id)
               |(structstruct-id(field-id...))
               |(all-fromraw-module-path)
               |(all-from-exceptraw-module-pathid...)
               |(all-defined)
               |(all-defined-exceptid...)
               |(prefix-all-definedprefix-id)
               |(prefix-all-defined-exceptprefix-idid...)
               |(protectspaceless-spec...)
               |(expand(id. datum))
               |(expand(id. datum)orig-form)
syntax
(matching-identifiers-inregexprequire-spec)
syntax
(subtract-inrequire-specsubtracted-spec...)
syntax
(filtered-inproc-exprrequire-spec)
syntax
(path-uprel-string...)
syntax
(multi-insubs...+)

    subs=sub-path
       |(sub-path...)
       
sub-path=rel-string
       |id
syntax
(matching-identifiers-outregexpprovide-spec)
syntax
(filtered-outproc-exprprovide-spec)
syntax
(quotedatum)
syntax
(#%datum. datum)
syntax
(#%expressionexpr)
syntax
id
syntax
(#%top. id)
syntax
(#%variable-referenceid)
(#%variable-reference(#%top. id))
(#%variable-reference)
syntax
(proc-exprarg...)
syntax
(#%appproc-exprarg...)

arg-expr

keywordarg-expr
syntax
(#%plain-appproc-exprarg-expr...)
(#%plain-app)
syntax
(lambdakw-formalsbody...+)
syntax
(kw-formalsbody...+)

kw-formals=(arg...)
         |(arg...+. rest-id)
         |rest-id
         
       arg=id
         |[iddefault-expr]
         |keywordid
         |keyword[iddefault-expr]

(id...)

(id...+. rest-id)

rest-id

(arg...)

id

[iddefault-expr]

keywordid

keyword[iddefault-expr]

(arg...+. rest-id)
syntax
(case-lambda[formalsbody...+]...)

formals=(id...)
      |(id...+. rest-id)
      |rest-id
syntax
(#%plain-lambdaformalsbody...+)
syntax
(let([idval-expr]...)body...+)
(letproc-id([idinit-expr]...)body...+)
syntax
(let*([idval-expr]...)body...+)
syntax
(letrec([idval-expr]...)body...+)
syntax
(let-values([(id...)val-expr]...)body...+)
syntax
(let*-values([(id...)val-expr]...)body...+)
syntax
(letrec-values([(id...)val-expr]...)body...+)
syntax
(let-syntax([idtrans-expr]...)body...+)
syntax
(letrec-syntax([idtrans-expr]...)body...+)
syntax
(let-syntaxes([(id...)trans-expr]...)body...+)
syntax
(letrec-syntaxes([(id...)trans-expr]...)body...+)
syntax
(letrec-syntaxes+values([(trans-id...)trans-expr]...)
([(val-id...)val-expr]...)
body...+)
syntax
(local[definition...]body...+)
syntax
(shared([idexpr]...)body...+)
syntax
(iftest-exprthen-exprelse-expr)
syntax
(condcond-clause...)

cond-clause=[test-exprthen-body...+]
          |[elsethen-body...+]
          |[test-expr=>proc-expr]
          |[test-expr]

[test-exprthen-body...+]

[test-expr=>proc-expr]

[test-expr]
syntax
else
syntax
=>
syntax
(andexpr...)
syntax
(orexpr...)
syntax
(caseval-exprcase-clause...)

case-clause=[(datum...)then-body...+]
          |[elsethen-body...+]
syntax
(defineidexpr)
(define(headargs)body...+)

head=id
   |(headargs)
   
args=arg...
   |arg....rest-id
   
 arg=arg-id
   |[arg-iddefault-expr]
   |keywordarg-id
   |keyword[arg-iddefault-expr]
syntax
(define-values(id...)expr)
syntax
(define-syntaxidexpr)
(define-syntax(headargs)body...+)
syntax
(define-syntaxes(id...)expr)
syntax
(define-for-syntaxidexpr)
(define-for-syntax(headargs)body...+)
syntax
(define-values-for-syntax(id...)expr)
syntax
(define-require-syntaxidproc-expr)
(define-require-syntax(idargs...)body...+)
procedure
(syntax-local-require-introducestx)->syntax?
stx:syntax?
syntax
(define-provide-syntaxidproc-expr)
(define-provide-syntax(idargs...)body...+)
procedure
(syntax-local-provide-introducestx)->syntax?
stx:syntax?
syntax
(beginform...)
(beginexpr...+)
syntax
(begin0expr...+)
syntax
(begin-for-syntaxform...)
syntax
(whentest-exprbody...+)
syntax
(unlesstest-exprbody...+)
syntax
(set!idexpr)
syntax
(set!-values(id...)expr)
syntax
(for(for-clause...)body-or-break...body)

   for-clause=[idseq-expr]
            |[(id...)seq-expr]
            |#:whenguard-expr
            |#:unlessguard-expr
            |#:do[do-body...]
            |break-clause
            |#:splice(splicing-id. form)
            
 break-clause=#:breakguard-expr
            |#:finalguard-expr
            
body-or-break=body
            |break-clause

seq-expr:sequence?
syntax
(for/list(for-clause...)body-or-break...body)
syntax
(for/vectormaybe-length(for-clause...)body-or-break...body)

maybe-length=
           |#:lengthlength-expr
           |#:lengthlength-expr#:fillfill-expr

length-expr:exact-nonnegative-integer?
syntax
(for/hash(for-clause...)body-or-break...body)
syntax
(for/hasheq(for-clause...)body-or-break...body)
syntax
(for/hasheqv(for-clause...)body-or-break...body)
syntax
(for/hashalw(for-clause...)body-or-break...body)
syntax
(for/and(for-clause...)body-or-break...body)
syntax
(for/or(for-clause...)body-or-break...body)
syntax
(for/sum(for-clause...)body-or-break...body)
syntax
(for/product(for-clause...)body-or-break...body)
syntax
(for/lists(id...maybe-result)
(for-clause...)
body-or-break...body)

maybe-result=
           |#:resultresult-expr
syntax
(for/first(for-clause...)body-or-break...body)
syntax
(for/last(for-clause...)body-or-break...body)
syntax
(for/fold([accum-idinit-expr]...maybe-result)(for-clause...)
body-or-break...body)

maybe-result=
           |#:resultresult-expr
syntax
(for/foldr([accum-idinit-expr]...accum-option...)
(for-clause...)
body-or-break...body)

accum-option=#:resultresult-expr
           |#:delay
           |#:delay-asdelayed-id
           |#:delay-withdelayer-id
syntax
(for*(for-clause...)body-or-break...body)
syntax
(for*/list(for-clause...)body-or-break...body)
syntax
(for*/lists(id...maybe-result)(for-clause...)
body-or-break...body)
syntax
(for*/vectormaybe-length(for-clause...)body-or-break...body)
syntax
(for*/hash(for-clause...)body-or-break...body)
syntax
(for*/hasheq(for-clause...)body-or-break...body)
syntax
(for*/hasheqv(for-clause...)body-or-break...body)
syntax
(for*/hashalw(for-clause...)body-or-break...body)
syntax
(for*/and(for-clause...)body-or-break...body)
syntax
(for*/or(for-clause...)body-or-break...body)
syntax
(for*/sum(for-clause...)body-or-break...body)
syntax
(for*/product(for-clause...)body-or-break...body)
syntax
(for*/first(for-clause...)body-or-break...body)
syntax
(for*/last(for-clause...)body-or-break...body)
syntax
(for*/fold([accum-idinit-expr]...maybe-result)(for-clause...)
body-or-break...body)
syntax
(for*/foldr([accum-idinit-expr]...accum-option...)
(for-clause...)
body-or-break...body)
syntax
(for/fold/derivedorig-datum
([accum-idinit-expr]...maybe-result)(for-clause...)
body-or-break...body)
syntax
(for*/fold/derivedorig-datum
([accum-idinit-expr]...maybe-result)(for-clause...)
body-or-break...body)
syntax
(for/foldr/derivedorig-datum
([accum-idinit-expr]...accum-option...)(for-clause...)
body-or-break...body)
syntax
(for*/foldr/derivedorig-datum
([accum-idinit-expr]...accum-option...)(for-clause...)
body-or-break...body)
syntax
(define-sequence-syntaxid
expr-transform-expr
clause-transform-expr)

expr-transform-expr:(or/c(->identifier?)
                        (syntax?. -> .syntax?))
clause-transform-expr:(syntax?. -> .syntax?)
syntax
(:do-in([(outer-id...)outer-expr]...)
outer-check
([loop-idloop-expr]...)
pos-guard
([(inner-id...)inner-expr]...)
pre-guard
post-guard
(loop-arg...))
procedure
(for-clause-syntax-protectstx)->syntax?
stx:syntax?
syntax
(define-splicing-for-clause-syntaxidproc-expr)
syntax
(do([idinit-exprstep-expr-maybe]...)
(stop?-exprfinish-expr...)
expr...)

step-expr-maybe=
              |step-expr
syntax
(with-continuation-markkey-exprval-exprresult-expr)
syntax
(quasiquotedatum)
syntax
unquote
syntax
unquote-splicing
syntax
(quote-syntaxdatum)
(quote-syntaxdatum#:local)
syntax
(#%top-interaction. form)
syntax
(blockdefn-or-expr...)
syntax
(#%stratified-bodydefn-or-expr...)
syntax
(begin-encourage-inlineform...)
syntax
(define-inlineidexpr)
(define-inline(headargs)body...+)

head=id
   |(headargs)
   
args=arg...
   |arg....rest-id
   
 arg=arg-id
   |[arg-iddefault-expr]
   |keywordarg-id
   |keyword[arg-iddefault-expr]
syntax
(lazy-require[module-path(fun-import...)]...)

fun-import=fun-id
         |(orig-fun-idfun-id)
syntax
(lazy-require-syntax[module-path(macro-import...)]...)

macro-import=macro-id
           |(orig-macro-idmacro-id)
procedure
(equal?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(equal-always?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(eqv?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(eq?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(equal?/recurv1v2recur-proc)->boolean?
v1:any/c
v2:any/c
recur-proc:(any/cany/c->any/c)
procedure
(equal-always?/recurv1v2recur-proc)->boolean?
v1:any/c
v2:any/c
recur-proc:(any/cany/c->any/c)
procedure
(equal-hash-codev)->fixnum?
v:any/c
procedure
(equal-secondary-hash-codev)->fixnum?
v:any/c
procedure
(equal-always-hash-codev)->fixnum?
v:any/c
procedure
(equal-always-secondary-hash-codev)->fixnum?
v:any/c
procedure
(eq-hash-codev)->fixnum?
v:any/c
procedure
(eqv-hash-codev)->fixnum?
v:any/c
value
gen:equal+hash:any/c
value
gen:equal-mode+hash:any/c
value
prop:equal+hash:struct-type-property?
procedure
(boolean?v)->boolean?
v:any/c
procedure
(notv)->boolean?
v:any/c
procedure
(immutable?v)->boolean?
v:any/c
value
true:boolean?
value
false:boolean?
procedure
(symbol=?ab)->boolean?
a:symbol?
b:symbol?
procedure
(boolean=?ab)->boolean?
a:boolean?
b:boolean?
procedure
(false?v)->boolean?
v:any/c
syntax
(nandexpr...)
syntax
(norexpr...)
syntax
(impliesexpr1expr2)
procedure
(xorb1b2)->any
b1:any/c
b2:any/c
procedure
(number?v)->boolean?
v:any/c
procedure
(complex?v)->boolean?
v:any/c
procedure
(real?v)->boolean?
v:any/c
procedure
(rational?v)->boolean?
v:any/c
procedure
(integer?v)->boolean?
v:any/c
procedure
(exact-integer?v)->boolean?
v:any/c
procedure
(exact-nonnegative-integer?v)->boolean?
v:any/c
procedure
(exact-positive-integer?v)->boolean?
v:any/c
procedure
(inexact-real?v)->boolean?
v:any/c
procedure
(fixnum?v)->boolean?
v:any/c
procedure
(flonum?v)->boolean?
v:any/c
procedure
(double-flonum?v)->boolean?
v:any/c
procedure
(single-flonum?v)->boolean?
v:any/c
procedure
(single-flonum-available?)->boolean?
procedure
(zero?z)->boolean?
z:number?
procedure
(positive?x)->boolean?
x:real?
procedure
(negative?x)->boolean?
x:real?
procedure
(even?n)->boolean?
n:integer?
procedure
(odd?n)->boolean?
n:integer?
procedure
(exact?z)->boolean?
z:number?
procedure
(inexact?z)->boolean?
z:number?
procedure
(inexact->exactz)->exact?
z:number?
procedure
(exact->inexactz)->inexact?
z:number?
procedure
(real->single-flonumx)->single-flonum?
x:real?
procedure
(real->double-flonumx)->flonum?
x:real?
procedure
(+z...)->number?
z:number?
procedure
(-z)->number?
z:number?
(-zw...+)->number?
z:number?
w:number?
procedure
(*z...)->number?
z:number?
procedure
(/z)->number?
z:number?
(/zw...+)->number?
z:number?
w:number?
procedure
(quotientnm)->integer?
n:integer?
m:integer?
procedure
(remaindernm)->integer?
n:integer?
m:integer?
procedure
(quotient/remaindernm)->integer?integer?
n:integer?
m:integer?
procedure
(modulonm)->integer?
n:integer?
m:integer?
procedure
(add1z)->number?
z:number?
procedure
(sub1z)->number?
z:number?
procedure
(absx)->number?
x:real?
procedure
(maxx...+)->real?
x:real?
procedure
(minx...+)->real?
x:real?
procedure
(gcdn...)->rational?
n:rational?
procedure
(lcmn...)->rational?
n:rational?
procedure
(roundx)->(or/cinteger?+inf.0-inf.0+nan.0)
x:real?
procedure
(floorx)->(or/cinteger?+inf.0-inf.0+nan.0)
x:real?
procedure
(ceilingx)->(or/cinteger?+inf.0-inf.0+nan.0)
x:real?
procedure
(truncatex)->(or/cinteger?+inf.0-inf.0+nan.0)
x:real?
procedure
(numeratorq)->integer?
q:rational?
procedure
(denominatorq)->(and/cinteger?positive?)
q:rational?
procedure
(rationalizextolerance)->real?
x:real?
tolerance:real?
procedure
(=zw...)->boolean?
z:number?
w:number?
procedure
(<xy...)->boolean?
x:real?
y:real?
procedure
(<=xy...)->boolean?
x:real?
y:real?
procedure
(>xy...)->boolean?
x:real?
y:real?
procedure
(>=xy...)->boolean?
x:real?
y:real?
procedure
(sqrtz)->number?
z:number?
procedure
(integer-sqrtn)->complex?
n:integer?
procedure
(integer-sqrt/remaindern)->complex?integer?
n:integer?
procedure
(exptzw)->number?
z:number?
w:number?
procedure
(expz)->number?
z:number?
procedure
(logz[b])->number?
z:number?
b:number?=(exp1)
procedure
(sinz)->number?
z:number?
procedure
(cosz)->number?
z:number?
procedure
(tanz)->number?
z:number?
procedure
(asinz)->number?
z:number?
procedure
(acosz)->number?
z:number?
procedure
(atanz)->number?
z:number?
(atanyx)->number?
y:real?
x:real?
procedure
(make-rectangularxy)->number?
x:real?
y:real?
procedure
(make-polarmagnitudeangle)->number?
magnitude:real?
angle:real?
procedure
(real-partz)->real?
z:number?
procedure
(imag-partz)->real?
z:number?
procedure
(magnitudez)->(and/creal?(not/cnegative?))
z:number?
procedure
(anglez)->real?
z:number?
procedure
(bitwise-iorn...)->exact-integer?
n:exact-integer?
procedure
(bitwise-andn...)->exact-integer?
n:exact-integer?
procedure
(bitwise-xorn...)->exact-integer?
n:exact-integer?
procedure
(bitwise-notn)->exact-integer?
n:exact-integer?
procedure
(bitwise-bit-set?nm)->boolean?
n:exact-integer?
m:exact-nonnegative-integer?
procedure
(bitwise-bit-fieldnstartend)->exact-integer?
n:exact-integer?
start:exact-nonnegative-integer?
end:(and/cexact-nonnegative-integer?
        (>=/cstart))
procedure
(arithmetic-shiftnm)->exact-integer?
n:exact-integer?
m:exact-integer?
procedure
(integer-lengthn)->exact-integer?
n:exact-integer?
procedure
(randomk[rand-gen])->exact-nonnegative-integer?
k:(integer-in14294967087)
rand-gen:pseudo-random-generator?
        =(current-pseudo-random-generator)
(randomminmax[rand-gen])->exact-nonnegative-integer?
min:exact-integer?
max:(integer-in(+1min)(+4294967087min))
rand-gen:pseudo-random-generator?
        =(current-pseudo-random-generator)
(random[rand-gen])->(and/creal?inexact?(>/c0)(</c1))
rand-gen:pseudo-random-generator?
        =(current-pseudo-random-generator)
procedure
(random-seedk)->void?
k:(integer-in0(sub1(expt231)))
procedure
(make-pseudo-random-generator)->pseudo-random-generator?
procedure
(pseudo-random-generator?v)->boolean?
v:any/c
parameter
(current-pseudo-random-generator)->pseudo-random-generator?
(current-pseudo-random-generatorrand-gen)->void?
rand-gen:pseudo-random-generator?
procedure
(pseudo-random-generator->vectorrand-gen)
->pseudo-random-generator-vector?
rand-gen:pseudo-random-generator?
procedure
(vector->pseudo-random-generatorvec)
->pseudo-random-generator?
vec:pseudo-random-generator-vector?
procedure
(vector->pseudo-random-generator!rand-gen 
                                vec)    ->void?
rand-gen:pseudo-random-generator?
vec:pseudo-random-generator-vector?
procedure
(pseudo-random-generator-vector?v)->boolean?
v:any/c
procedure
(crypto-random-bytesn)->bytes?
n:exact-positive-integer?
procedure
(random-refseq[rand-gen])->any/c
seq:sequence?
rand-gen:pseudo-random-generator?
        =(current-pseudo-random-generator)
procedure
(random-sample seq                           
              n                             
             [rand-gen                      
              #:replacement?replacement?])->(listofany/c)
seq:sequence?
n:exact-positive-integer?
rand-gen:pseudo-random-generator?
        =(current-pseudo-random-generator)
replacement?:any/c=#t
procedure
(number->stringz[radix])->string?
z:number?
radix:(or/c281016)=10
procedure
(string->number s            
              [radix        
               convert-mode 
               decimal-mode 
               single-mode])
->(or/cnumber?#fstring?extflonum?)
s:string?
radix:(integer-in216)=10
convert-mode:(or/c'number-or-false'read)
            ='number-or-false
decimal-mode:(or/c'decimal-as-inexact'decimal-as-exact)
            =(if(read-decimal-as-inexact)
                 'decimal-as-inexact
                 'decimal-as-exact)
single-mode:(or/c'single'double)
           =(if(read-single-flonum)
                'single
                'double)
procedure
(real->decimal-stringn[decimal-digits])->string?
n:rational?
decimal-digits:exact-nonnegative-integer?=2
procedure
(integer-bytes->integer bstr        
                       signed?     
                      [big-endian? 
                       start       
                       end])      ->exact-integer?
bstr:bytes?
signed?:any/c
big-endian?:any/c=(system-big-endian?)
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(integer->integer-bytes n           
                       size-n      
                       signed?     
                      [big-endian? 
                       dest-bstr   
                       start])    ->bytes?
n:exact-integer?
size-n:(or/c1248)
signed?:any/c
big-endian?:any/c=(system-big-endian?)
dest-bstr:(and/cbytes?(not/cimmutable?))
         =(make-bytessize-n)
start:exact-nonnegative-integer?=0
procedure
(floating-point-bytes->real bstr        
                          [big-endian? 
                           start       
                           end])      ->flonum?
bstr:bytes?
big-endian?:any/c=(system-big-endian?)
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(real->floating-point-bytes x           
                           size-n      
                          [big-endian? 
                           dest-bstr   
                           start])    ->bytes?
x:real?
size-n:(or/c48)
big-endian?:any/c=(system-big-endian?)
dest-bstr:(and/cbytes?(not/cimmutable?))
         =(make-bytessize-n)
start:exact-nonnegative-integer?=0
procedure
(system-big-endian?)->boolean?
value
pi:flonum?
value
pi.f:(or/csingle-flonum?flonum?)
procedure
(degrees->radiansx)->real?
x:real?
procedure
(radians->degreesx)->real?
x:real?
procedure
(sqrz)->number?
z:number?
procedure
(sgnx)->(or/c(=/c-1)(=/c0)(=/c1)+nan.0+nan.f)
x:real?
procedure
(conjugatez)->number?
z:number?
procedure
(sinhz)->number?
z:number?
procedure
(coshz)->number?
z:number?
procedure
(tanhz)->number?
z:number?
procedure
(exact-roundx)->exact-integer?
x:rational?
procedure
(exact-floorx)->exact-integer?
x:rational?
procedure
(exact-ceilingx)->exact-integer?
x:rational?
procedure
(exact-truncatex)->exact-integer?
x:rational?
procedure
(order-of-magnituder)->(and/cexact?integer?)
r:(and/creal?positive?)
procedure
(nan?x)->boolean?
x:real?
procedure
(infinite?x)->boolean?
x:real?
procedure
(positive-integer?x)->boolean?
x:any/c
procedure
(negative-integer?x)->boolean?
x:any/c
procedure
(nonpositive-integer?x)->boolean?
x:any/c
procedure
(nonnegative-integer?x)->boolean?
x:any/c
procedure
(natural?x)->boolean?
x:any/c
procedure
(fl+a...)->flonum?
a:flonum?
procedure
(fl-ab...)->flonum?
a:flonum?
b:flonum?
procedure
(fl*a...)->flonum?
a:flonum?
procedure
(fl/ab...)->flonum?
a:flonum?
b:flonum?
procedure
(flabsa)->flonum?
a:flonum?
procedure
(fl=ab...)->boolean?
a:flonum?
b:flonum?
procedure
(fl<ab...)->boolean?
a:flonum?
b:flonum?
procedure
(fl>ab...)->boolean?
a:flonum?
b:flonum?
procedure
(fl<=ab...)->boolean?
a:flonum?
b:flonum?
procedure
(fl>=ab...)->boolean?
a:flonum?
b:flonum?
procedure
(flminab...)->flonum?
a:flonum?
b:flonum?
procedure
(flmaxab...)->flonum?
a:flonum?
b:flonum?
procedure
(flrounda)->flonum?
a:flonum?
procedure
(flfloora)->flonum?
a:flonum?
procedure
(flceilinga)->flonum?
a:flonum?
procedure
(fltruncatea)->flonum?
a:flonum?
procedure
(flsinglea)->flonum?
a:flonum?
procedure
(flsina)->flonum?
a:flonum?
procedure
(flcosa)->flonum?
a:flonum?
procedure
(fltana)->flonum?
a:flonum?
procedure
(flasina)->flonum?
a:flonum?
procedure
(flacosa)->flonum?
a:flonum?
procedure
(flatana)->flonum?
a:flonum?
procedure
(flloga)->flonum?
a:flonum?
procedure
(flexpa)->flonum?
a:flonum?
procedure
(flsqrta)->flonum?
a:flonum?
procedure
(flexptab)->flonum?
a:flonum?
b:flonum?
procedure
(->fla)->flonum?
a:exact-integer?
procedure
(fl->exact-integera)->exact-integer?
a:flonum?
procedure
(make-flrectangularab)
->(and/ccomplex?
    (lambda(c)(flonum?(real-partc)))
    (lambda(c)(flonum?(imag-partc))))
a:flonum?
b:flonum?
procedure
(flreal-parta)->flonum?
a:(and/ccomplex?
      (lambda(c)(flonum?(real-partc)))
      (lambda(c)(flonum?(imag-partc))))
procedure
(flimag-parta)->flonum?
a:(and/ccomplex?
      (lambda(c)(flonum?(real-partc)))
      (lambda(c)(flonum?(imag-partc))))
procedure
(flrandomrand-gen)->(andflonum?(>/c0)(</c1))
rand-gen:pseudo-random-generator?
procedure
(flvector?v)->boolean?
v:any/c
procedure
(flvectorx...)->flvector?
x:flonum?
procedure
(make-flvectorsize[x])->flvector?
size:exact-nonnegative-integer?
x:flonum?=0.0
procedure
(flvector-lengthvec)->exact-nonnegative-integer?
vec:flvector?
procedure
(flvector-refvecpos)->flonum?
vec:flvector?
pos:exact-nonnegative-integer?
procedure
(flvector-set!vecposx)->flonum?
vec:flvector?
pos:exact-nonnegative-integer?
x:flonum?
procedure
(flvector-copyvec[startend])->flvector?
vec:flvector?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthv)
procedure
(in-flvectorvec[startstopstep])->sequence?
vec:flvector?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
syntax
(for/flvectormaybe-length(for-clause...)body...)
syntax
(for*/flvectormaybe-length(for-clause...)body...)

maybe-length=
           |#:lengthlength-expr
           |#:lengthlength-expr#:fillfill-expr

length-expr:exact-nonnegative-integer?
fill-expr:flonum?
procedure
(shared-flvectorx...)->flvector?
x:flonum?
procedure
(make-shared-flvectorsize[x])->flvector?
size:exact-nonnegative-integer?
x:flonum?=0.0
procedure
(fx+a...)->fixnum?
a:fixnum?
procedure
(fx-ab...)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx*a...)->fixnum?
a:fixnum?
procedure
(fxquotientab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxremainderab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxmoduloab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxabsa)->fixnum?
a:fixnum?
procedure
(fxanda...)->fixnum?
a:fixnum?
procedure
(fxiora...)->fixnum?
a:fixnum?
procedure
(fxxora...)->fixnum?
a:fixnum?
procedure
(fxnota)->fixnum?
a:fixnum?
procedure
(fxlshiftab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxrshiftab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxpopcounta)->fixnum?
a:(and/cfixnum?(not/cnegative?))
procedure
(fxpopcount32a)->fixnum?
a:(and/cfixnum?(integer-in0#xFFFFFFFF))
procedure
(fxpopcount16a)->fixnum?
a:(and/cfixnum?(integer-in0#xFFFF))
procedure
(fx+/wraparoundab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx-/wraparoundab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx*/wraparoundab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxlshift/wraparoundab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx=ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(fx<ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(fx>ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(fx<=ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(fx>=ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(fxminab...)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fxmaxab...)->fixnum?
a:fixnum?
b:fixnum?
procedure
(fx->fla)->flonum?
a:fixnum?
procedure
(fl->fxfl)->fixnum?
fl:flonum?
procedure
(fixnum-for-every-system?v)->boolean?
v:any/c
procedure
(fxvector?v)->boolean?
v:any/c
procedure
(fxvectorx...)->fxvector?
x:fixnum?
procedure
(make-fxvectorsize[x])->fxvector?
size:exact-nonnegative-integer?
x:fixnum?=0
procedure
(fxvector-lengthvec)->exact-nonnegative-integer?
vec:fxvector?
procedure
(fxvector-refvecpos)->fixnum?
vec:fxvector?
pos:exact-nonnegative-integer?
procedure
(fxvector-set!vecposx)->fixnum?
vec:fxvector?
pos:exact-nonnegative-integer?
x:fixnum?
procedure
(fxvector-copyvec[startend])->fxvector?
vec:fxvector?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthv)
procedure
(in-fxvectorvec[startstopstep])->sequence?
vec:fxvector?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
syntax
(for/fxvectormaybe-length(for-clause...)body...)
syntax
(for*/fxvectormaybe-length(for-clause...)body...)

maybe-length=
           |#:lengthlength-expr
           |#:lengthlength-expr#:fillfill-expr

length-expr:exact-nonnegative-integer?
fill-expr:fixnum?
procedure
(shared-fxvectorx...)->fxvector?
x:fixnum?
procedure
(make-shared-fxvectorsize[x])->fxvector?
size:exact-nonnegative-integer?
x:fixnum?=0
procedure
(most-positive-fixnum)->fixnum?
procedure
(most-negative-fixnum)->fixnum?
procedure
(extflonum?v)->boolean?
v:any/c
procedure
(extflonum-available?)->boolean?
procedure
(extfl+ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extfl-ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extfl*ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extfl/ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extflabsa)->extflonum?
a:extflonum?
procedure
(extfl=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extfl<ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extfl>ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extfl<=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extfl>=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(extflminab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extflmaxab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(extflrounda)->extflonum?
a:extflonum?
procedure
(extflfloora)->extflonum?
a:extflonum?
procedure
(extflceilinga)->extflonum?
a:extflonum?
procedure
(extfltruncatea)->extflonum?
a:extflonum?
procedure
(extflsina)->extflonum?
a:extflonum?
procedure
(extflcosa)->extflonum?
a:extflonum?
procedure
(extfltana)->extflonum?
a:extflonum?
procedure
(extflasina)->extflonum?
a:extflonum?
procedure
(extflacosa)->extflonum?
a:extflonum?
procedure
(extflatana)->extflonum?
a:extflonum?
procedure
(extflloga)->extflonum?
a:extflonum?
procedure
(extflexpa)->extflonum?
a:extflonum?
procedure
(extflsqrta)->extflonum?
a:extflonum?
procedure
(extflexptab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(->extfla)->extflonum?
a:exact-integer?
procedure
(extfl->exact-integera)->exact-integer?
a:extflonum?
procedure
(real->extfla)->extflonum?
a:real?
procedure
(extfl->exacta)->(and/creal?exact?)
a:extflonum?
procedure
(extfl->fxa)->fixnum?
a:extflonum?
procedure
(fx->extfla)->extflonum?
a:fixnum?
procedure
(extfl->inexacta)->flonum?
a:extflonum?
value
pi.t:extflonum?
procedure
(extflvector?v)->boolean?
v:any/c
procedure
(extflvectorx...)->extflvector?
x:extflonum?
procedure
(make-extflvectorsize[x])->extflvector?
size:exact-nonnegative-integer?
x:extflonum?=0.0t0
procedure
(extflvector-lengthvec)->exact-nonnegative-integer?
vec:extflvector?
procedure
(extflvector-refvecpos)->extflonum?
vec:extflvector?
pos:exact-nonnegative-integer?
procedure
(extflvector-set!vecposx)->extflonum?
vec:extflvector?
pos:exact-nonnegative-integer?
x:extflonum?
procedure
(extflvector-copyvec[startend])->extflvector?
vec:extflvector?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthv)
procedure
(in-extflvectorvec[startstopstep])->sequence?
vec:extflvector?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
syntax
(for/extflvectormaybe-length(for-clause...)body...)
syntax
(for*/extflvectormaybe-length(for-clause...)body...)

maybe-length=
           |#:lengthlength-expr
           |#:lengthlength-expr#:fillfill-expr

length-expr:exact-nonnegative-integer?
fill-expr:extflonum?
procedure
(shared-extflvectorx...)->extflvector?
x:extflonum?
procedure
(make-shared-extflvectorsize[x])->extflvector?
size:exact-nonnegative-integer?
x:extflonum?=0.0t0
procedure
(floating-point-bytes->extfl bstr        
                           [big-endian? 
                            start       
                            end])      ->extflonum?
bstr:bytes?
big-endian?:any/c=(system-big-endian?)
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(extfl->floating-point-bytes x           
                           [big-endian? 
                            dest-bstr   
                            start])    ->bytes?
x:extflonum?
big-endian?:any/c=(system-big-endian?)
dest-bstr:(and/cbytes?(not/cimmutable?))
         =(make-bytes10)
start:exact-nonnegative-integer?=0
procedure
(string?v)->boolean?
v:any/c
procedure
(make-stringk[char])->string?
k:exact-nonnegative-integer?
char:char?=#\nul
procedure
(stringchar...)->string?
char:char?
procedure
(string->immutable-stringstr)->(and/cstring?immutable?)
str:string?
procedure
(string-lengthstr)->exact-nonnegative-integer?
str:string?
procedure
(string-refstrk)->char?
str:string?
k:exact-nonnegative-integer?
procedure
(string-set!strkchar)->void?
str:(and/cstring?(not/cimmutable?))
k:exact-nonnegative-integer?
char:char?
procedure
(substringstrstart[end])->string?
str:string?
start:exact-nonnegative-integer?
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string-copystr)->string?
str:string?
procedure
(string-copy! dest       
             dest-start 
             src        
            [src-start  
             src-end]) ->void?
dest:(and/cstring?(not/cimmutable?))
dest-start:exact-nonnegative-integer?
src:string?
src-start:exact-nonnegative-integer?=0
src-end:exact-nonnegative-integer?=(string-lengthsrc)
procedure
(string-fill!destchar)->void?
dest:(and/cstring?(not/cimmutable?))
char:char?
procedure
(string-appendstr...)->string?
str:string?
procedure
(string-append-immutablestr...)->(and/cstring?immutable?)
str:string?
procedure
(string->liststr)->(listofchar?)
str:string?
procedure
(list->stringlst)->string?
lst:(listofchar?)
procedure
(build-stringnproc)->string?
n:exact-nonnegative-integer?
proc:(exact-nonnegative-integer?. -> .char?)
procedure
(string=?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string<?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string<=?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string>?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string>=?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-ci=?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-ci<?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-ci<=?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-ci>?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-ci>=?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-upcasestr)->string?
str:string?
procedure
(string-downcasestring)->string?
string:string?
procedure
(string-titlecasestring)->string?
string:string?
procedure
(string-foldcasestring)->string?
string:string?
procedure
(string-normalize-nfdstring)->string?
string:string?
procedure
(string-normalize-nfkdstring)->string?
string:string?
procedure
(string-normalize-nfcstring)->string?
string:string?
procedure
(string-normalize-nfkcstring)->string?
string:string?
procedure
(string-locale=?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-locale<?str1str2...+)->boolean?
str1:string?
str2:string?
procedure
(string-locale>?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-locale-ci=?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-locale-ci<?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-locale-ci>?str1str2...)->boolean?
str1:string?
str2:string?
procedure
(string-locale-upcasestring)->string?
string:string?
procedure
(string-locale-downcasestring)->string?
string:string?
procedure
(string-grapheme-spanstrstart[end])->exact-nonnegative-integer?
str:string?
start:exact-nonnegative-integer?
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string-grapheme-countstrstart[end])
->exact-nonnegative-integer?
str:string?
start:exact-nonnegative-integer?
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string-append*str...strs)->string?
str:string?
strs:(listofstring?)
procedure
(string-join strs                        
           [sep                         
            #:before-firstbefore-first 
            #:before-lastbefore-last   
            #:after-lastafter-last])  ->string?
strs:(listofstring?)
sep:string?=" "
before-first:string?=""
before-last:string?=sep
after-last:string?=""
procedure
(string-normalize-spaces str                 
                       [sep                 
                        space               
                        #:trim?trim?       
                        #:repeat?repeat?])->string?
str:string?
sep:(or/cstring?regexp?)=#px"\\s+"
space:string?=" "
trim?:any/c=#t
repeat?:any/c=#f
procedure
(string-replacestrfromto[#:all?all?])->string?
str:string?
from:(or/cstring?regexp?)
to:string?
all?:any/c=#t
procedure
(string-split str                 
            [sep                 
             #:trim?trim?       
             #:repeat?repeat?])->(listofstring?)
str:string?
sep:(or/cstring?regexp?)=#px"\\s+"
trim?:any/c=#t
repeat?:any/c=#f
procedure
(string-trim str                 
           [sep                 
            #:left?left?       
            #:right?right?     
            #:repeat?repeat?])->string?
str:string?
sep:(or/cstring?regexp?)=#px"\\s+"
left?:any/c=#t
right?:any/c=#t
repeat?:any/c=#f
procedure
(non-empty-string?x)->boolean?
x:any/c
procedure
(string-contains?scontained)->boolean?
s:string?
contained:string?
procedure
(string-prefix?sprefix)->boolean?
s:string?
prefix:string?
procedure
(string-suffix?ssuffix)->boolean?
s:string?
suffix:string?
procedure
(~a v                                     
   ...                                   
  [#:separatorseparator                 
   #:widthwidth                         
   #:max-widthmax-width                 
   #:min-widthmin-width                 
   #:limit-markerlimit-marker           
   #:limit-prefix?limit-prefix?         
   #:alignalign                         
   #:pad-stringpad-string               
   #:left-pad-stringleft-pad-string     
   #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=""
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?=""
limit-prefix?:boolean?=#f
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~v v                                     
   ...                                   
  [#:separatorseparator                 
   #:widthwidth                         
   #:max-widthmax-width                 
   #:min-widthmin-width                 
   #:limit-markerlimit-marker           
   #:limit-prefix?limit-prefix?         
   #:alignalign                         
   #:pad-stringpad-string               
   #:left-pad-stringleft-pad-string     
   #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
limit-prefix?:boolean?=#f
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~s v                                     
   ...                                   
  [#:separatorseparator                 
   #:widthwidth                         
   #:max-widthmax-width                 
   #:min-widthmin-width                 
   #:limit-markerlimit-marker           
   #:limit-prefix?limit-prefix?         
   #:alignalign                         
   #:pad-stringpad-string               
   #:left-pad-stringleft-pad-string     
   #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
limit-prefix?:boolean?=#f
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~e v                                     
   ...                                   
  [#:separatorseparator                 
   #:widthwidth                         
   #:max-widthmax-width                 
   #:min-widthmin-width                 
   #:limit-markerlimit-marker           
   #:limit-prefix?limit-prefix?         
   #:alignalign                         
   #:pad-stringpad-string               
   #:left-pad-stringleft-pad-string     
   #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
limit-prefix?:boolean?=#f
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~r x                                 
  [#:signsign                       
   #:basebase                       
   #:precisionprecision             
   #:notationnotation               
   #:format-exponentformat-exponent 
   #:min-widthmin-width             
   #:pad-stringpad-string           
   #:groupsgroups                   
   #:group-sepgroup-sep             
   #:decimal-sepdecimal-sep])      ->string?
x:rational?
sign:(or/c#f'+'++'parens
         (let([ind(or/cstring?(list/cstring?string?))])
         (list/cindindind)))
    =#f
base:(or/c(integer-in236)(list/c'up(integer-in236)))
    =10
precision:(or/cexact-nonnegative-integer?             =6
              (list/c'=exact-nonnegative-integer?))
notation:(or/c'positional'exponential
             (->rational?(or/c'positional'exponential)))
        ='positional
format-exponent:(or/c#fstring?(->exact-integer?string?))
               =#f
min-width:exact-positive-integer?=1
pad-string:non-empty-string?=" "
groups:(non-empty-listofexact-positive-integer?)='(3)
group-sep:string?=""
decimal-sep:string?="."
procedure
(~.a v                                     
    ...                                   
   [#:separatorseparator                 
    #:widthwidth                         
    #:max-widthmax-width                 
    #:min-widthmin-width                 
    #:limit-markerlimit-marker           
    #:limit-prefix?limit-prefix?         
    #:alignalign                         
    #:pad-stringpad-string               
    #:left-pad-stringleft-pad-string     
    #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=""
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?=""
limit-prefix?:boolean?=#f
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~.v v                                     
    ...                                   
   [#:separatorseparator                 
    #:widthwidth                         
    #:max-widthmax-width                 
    #:min-widthmin-width                 
    #:limit-markerlimit-marker           
    #:limit-prefix?limit-prefix?         
    #:alignalign                         
    #:pad-stringpad-string               
    #:left-pad-stringleft-pad-string     
    #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
limit-prefix?:boolean?=#f
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(~.s v                                     
    ...                                   
   [#:separatorseparator                 
    #:widthwidth                         
    #:max-widthmax-width                 
    #:min-widthmin-width                 
    #:limit-markerlimit-marker           
    #:limit-prefix?limit-prefix?         
    #:alignalign                         
    #:pad-stringpad-string               
    #:left-pad-stringleft-pad-string     
    #:right-pad-stringright-pad-string])->string?
v:any/c
separator:string?=" "
width:(or/cexact-nonnegative-integer?#f)=#f
max-width:(or/cexact-nonnegative-integer?+inf.0)
         =(orwidth+inf.0)
min-width:exact-nonnegative-integer?=(orwidth0)
limit-marker:string?="..."
limit-prefix?:boolean?=#f
align:(or/c'left'center'right)='left
pad-string:non-empty-string?=" "
left-pad-string:non-empty-string?=pad-string
right-pad-string:non-empty-string?=pad-string
procedure
(bytes?v)->boolean?
v:any/c
procedure
(make-bytesk[b])->bytes?
k:exact-nonnegative-integer?
b:byte?=0
procedure
(bytesb...)->bytes?
b:byte?
procedure
(bytes->immutable-bytesbstr)->(and/cbytes?immutable?)
bstr:bytes?
procedure
(byte?v)->boolean?
v:any/c
procedure
(bytes-lengthbstr)->exact-nonnegative-integer?
bstr:bytes?
procedure
(bytes-refbstrk)->byte?
bstr:bytes?
k:exact-nonnegative-integer?
procedure
(bytes-set!bstrkb)->void?
bstr:(and/cbytes?(not/cimmutable?))
k:exact-nonnegative-integer?
b:byte?
procedure
(subbytesbstrstart[end])->bytes?
bstr:bytes?
start:exact-nonnegative-integer?
end:exact-nonnegative-integer?=(bytes-lengthstr)
procedure
(bytes-copybstr)->bytes?
bstr:bytes?
procedure
(bytes-copy! dest       
            dest-start 
            src        
           [src-start  
            src-end]) ->void?
dest:(and/cbytes?(not/cimmutable?))
dest-start:exact-nonnegative-integer?
src:bytes?
src-start:exact-nonnegative-integer?=0
src-end:exact-nonnegative-integer?=(bytes-lengthsrc)
procedure
(bytes-fill!destb)->void?
dest:(and/cbytes?(not/cimmutable?))
b:byte?
procedure
(bytes-appendbstr...)->bytes?
bstr:bytes?
procedure
(bytes->listbstr)->(listofbyte?)
bstr:bytes?
procedure
(list->byteslst)->bytes?
lst:(listofbyte?)
procedure
(make-shared-bytesk[b])->bytes?
k:exact-nonnegative-integer?
b:byte?=0
procedure
(shared-bytesb...)->bytes?
b:byte?
procedure
(bytes=?bstr1bstr2...)->boolean?
bstr1:bytes?
bstr2:bytes?
procedure
(bytes<?bstr1bstr2...)->boolean?
bstr1:bytes?
bstr2:bytes?
procedure
(bytes>?bstr1bstr2...)->boolean?
bstr1:bytes?
bstr2:bytes?
procedure
(bytes->string/utf-8bstr[err-charstartend])->string?
bstr:bytes?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes->string/locale bstr     
                    [err-char 
                     start    
                     end])   ->string?
bstr:bytes?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes->string/latin-1 bstr     
                     [err-char 
                      start    
                      end])   ->string?
bstr:bytes?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(string->bytes/utf-8str[err-bytestartend])->bytes?
str:string?
err-byte:(or/c#fbyte?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string->bytes/localestr[err-bytestartend])->bytes?
str:string?
err-byte:(or/c#fbyte?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string->bytes/latin-1 str      
                     [err-byte 
                      start    
                      end])   ->bytes?
str:string?
err-byte:(or/c#fbyte?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(string-utf-8-lengthstr[startend])->exact-nonnegative-integer?
str:string?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(string-lengthstr)
procedure
(bytes-utf-8-lengthbstr[err-charstartend])
->(or/cexact-nonnegative-integer?#f)
bstr:bytes?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes-utf-8-refbstr[skiperr-charstartend])->(or/cchar?#f)
bstr:bytes?
skip:exact-nonnegative-integer?=0
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes-utf-8-index bstr    
                  skip    
                 [err-char
                  start   
                  end])   
->(or/cexact-nonnegative-integer?#f)
bstr:bytes?
skip:exact-nonnegative-integer?
err-char:(or/c#fchar?)=#f
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(bytes-open-converterfrom-nameto-name)
->(or/cbytes-converter?#f)
from-name:string?
to-name:string?
procedure
(bytes-close-converterconverter)->void
converter:bytes-converter?
procedure
(bytes-convert converter     
              src-bstr      
             [src-start-pos 
              src-end-pos   
              dest-bstr     
              dest-start-pos
              dest-end-pos])
->(or/cbytes?exact-nonnegative-integer?)
    exact-nonnegative-integer?
    (or/c'complete'continues'aborts'error)
converter:bytes-converter?
src-bstr:bytes?
src-start-pos:exact-nonnegative-integer?=0
src-end-pos:exact-nonnegative-integer?
           =(bytes-lengthsrc-bstr)
dest-bstr:(or/cbytes?#f)=#f
dest-start-pos:exact-nonnegative-integer?=0
dest-end-pos:(or/cexact-nonnegative-integer?#f)
            =(anddest-bstr
                 (bytes-lengthdest-bstr))
procedure
(bytes-convert-end converter     
                 [dest-bstr     
                  dest-start-pos
                  dest-end-pos])
->(or/cbytes?exact-nonnegative-integer?)
    (or/c'complete'continues)
converter:bytes-converter?
dest-bstr:(or/cbytes?#f)=#f
dest-start-pos:exact-nonnegative-integer?=0
dest-end-pos:(or/cexact-nonnegative-integer?#f)
            =(anddest-bstr
                 (bytes-lengthdest-bstr))
procedure
(bytes-converter?v)->boolean?
v:any/c
procedure
(locale-string-encoding)->any
procedure
(bytes-append*str...strs)->bytes?
str:bytes?
strs:(listofbytes?)
procedure
(bytes-joinstrssep)->bytes?
strs:(listofbytes?)
sep:bytes?
procedure
(char?v)->boolean?
v:any/c
procedure
(char->integerchar)->exact-integer?
char:char?
procedure
(integer->chark)->char?
k:(and/cexact-integer?
      (or/c(integer-in0#xD7FF)
      (integer-in#xE000#x10FFFF)))
procedure
(char-utf-8-lengthchar)->(integer-in16)
char:char?
procedure
(char=?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char<?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char<=?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char>?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char>=?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char-ci=?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char-ci<?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char-ci<=?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char-ci>?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char-ci>=?char1char2...)->boolean?
char1:char?
char2:char?
procedure
(char-alphabetic?char)->boolean?
char:char?
procedure
(char-lower-case?char)->boolean?
char:char?
procedure
(char-upper-case?char)->boolean?
char:char?
procedure
(char-title-case?char)->boolean?
char:char?
procedure
(char-numeric?char)->boolean?
char:char?
procedure
(char-symbolic?char)->boolean?
char:char?
procedure
(char-punctuation?char)->boolean?
char:char?
procedure
(char-graphic?char)->boolean?
char:char?
procedure
(char-whitespace?char)->boolean?
char:char?
procedure
(char-blank?char)->boolean?
char:char?
procedure
(char-iso-control?char)->boolean?
char:char?
procedure
(char-extended-pictographic?char)->boolean?
char:char?
procedure
(char-general-categorychar)->symbol?
char:char?
procedure
(char-grapheme-break-propertychar)->?
char:char?
procedure
(make-known-char-range-list)
->(listof(list/cexact-nonnegative-integer?
    exact-nonnegative-integer?
    boolean?))
procedure
(char-upcasechar)->char?
char:char?
procedure
(char-downcasechar)->char?
char:char?
procedure
(char-titlecasechar)->char?
char:char?
procedure
(char-foldcasechar)->char?
char:char?
procedure
(char-grapheme-stepcharstate)->boolean?fixnum?
char:char?
state:fixnum?
procedure
(symbol?v)->boolean?
v:any/c
procedure
(symbol-interned?sym)->boolean?
sym:symbol?
procedure
(symbol-unreadable?sym)->boolean?
sym:symbol?
procedure
(symbol->stringsym)->string?
sym:symbol?
procedure
(string->symbolstr)->symbol?
str:string?
procedure
(string->uninterned-symbolstr)->symbol?
str:string?
procedure
(string->unreadable-symbolstr)->symbol?
str:string?
procedure
(gensym[base])->symbol?
base:(or/cstring?symbol?)="g"
procedure
(symbol<?a-symb-sym...)->boolean?
a-sym:symbol?
b-sym:symbol?
procedure
(symbol->immutable-stringsym)->(and/cstring?immutable?)
sym:symbol?
procedure
(regexp?v)->boolean?
v:any/c
procedure
(pregexp?v)->boolean?
v:any/c
procedure
(byte-regexp?v)->boolean?
v:any/c
procedure
(byte-pregexp?v)->boolean?
v:any/c
procedure
(regexpstr)->regexp?
str:string?
(regexpstrhandler)->any
str:string?
handler:(or/c#f(string?->any))
procedure
(pregexpstr)->pregexp?
str:string?
(pregexpstrhandler)->any
str:string?
handler:(or/c#f(string?->any))
procedure
(byte-regexpbstr)->byte-regexp?
bstr:bytes?
(byte-regexpbstrhandler)->any
bstr:bytes?
handler:(or/c#f(bytes?->any))
procedure
(byte-pregexpbstr)->byte-pregexp?
bstr:bytes?
(byte-pregexpbstrhandler)->any
bstr:bytes?
handler:(or/c#f(bytes?->any))
procedure
(regexp-quotestr[case-sensitive?])->string?
str:string?
case-sensitive?:any/c=#t
(regexp-quotebstr[case-sensitive?])->bytes?
bstr:bytes?
case-sensitive?:any/c=#t
procedure
(regexp-max-lookbehindpattern)->exact-nonnegative-integer?
pattern:(or/cregexp?byte-regexp?)
procedure
(regexp-match pattern       
             input         
            [start-pos     
             end-pos       
             output-port   
             input-prefix])
->(if(and(or(string?pattern)(regexp?pattern))
    (or(string?input)(path?input)))
    (or/c#f(cons/cstring?(listof(or/cstring?#f))))
    (or/c#f(cons/cbytes?(listof(or/cbytes?#f)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match* pattern                    
              input                      
             [start-pos                  
              end-pos                    
              input-prefix               
              #:match-selectmatch-select
              #:gap-select?gap-select]) 
->(if(and(or(string?pattern)(regexp?pattern))
    (or(string?input)(path?input)))
    (listof(or/cstring?(listof(or/c#fstring?))))
    (listof(or/cbytes?(listof(or/c#fbytes?)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
match-select:(or/c(list?. -> .(or/cany/clist?))=car
                 #f)
gap-select:any/c=#f
procedure
(regexp-try-match pattern       
                 input         
                [start-pos     
                 end-pos       
                 output-port   
                 input-prefix])
->(or/c#f(cons/cbytes?(listof(or/cbytes?#f))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-positions pattern       
                       input         
                      [start-pos     
                       end-pos       
                       output-port   
                       input-prefix])
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-integer?
    exact-integer?)
    #f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-positions* pattern                      
                        input                        
                       [start-pos                    
                        end-pos                      
                        input-prefix                 
                        #:match-selectmatch-select])
->(or/c(listof(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?))
    (listof(listof(or/c#f(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
match-select:(list?. -> .(or/cany/clist?))=car
procedure
(regexp-match? pattern        
              input          
             [start-pos      
              end-pos        
              output-port    
              input-prefix])->boolean?
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-exact?patterninput)->boolean?
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?)
procedure
(regexp-match-peek pattern       
                  input         
                 [start-pos     
                  end-pos       
                  progress      
                  input-prefix])
->(or/c(cons/cbytes?(listof(or/cbytes?#f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-peek-positions pattern       
                            input         
                           [start-pos     
                            end-pos       
                            progress      
                            input-prefix])
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-peek-immediate pattern       
                            input         
                           [start-pos     
                            end-pos       
                            progress      
                            input-prefix])
->(or/c(cons/cbytes?(listof(or/cbytes?#f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-peek-positions-immediate pattern       
                                      input         
                                     [start-pos     
                                      end-pos       
                                      progress      
                                      input-prefix])
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-match-peek-positions* pattern                      
                             input                        
                            [start-pos                    
                             end-pos                      
                             input-prefix                 
                             #:match-selectmatch-select])
->(or/c(listof(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?))
    (listof(listof(or/c#f(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)))))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
match-select:(list?. -> .(or/cany/clist?))=car
procedure
(regexp-match/end pattern     
                 input       
                [start-pos   
                 end-pos     
                 output-port 
                 input-prefix
                 count])     
->(if(and(or(string?pattern)(regexp?pattern))
    (or/c(string?input)(path?input)))
    (or/c#f(cons/cstring?(listof(or/cstring?#f))))
    (or/c#f(cons/cbytes?(listof(or/cbytes?#f)))))
    (or/c#fbytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
output-port:(or/coutput-port?#f)=#f
input-prefix:bytes?=#""
count:exact-nonnegative-integer?=1
procedure
(regexp-match-positions/end pattern     
                           input       
                          [start-pos   
                           end-pos     
                           input-prefix
                           count])     
->(listof(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?))
    (or/c#fbytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?path?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
count:exact-nonnegative-integer?=1
procedure
(regexp-match-peek-positions/end pattern     
                                input       
                               [start-pos   
                                end-pos     
                                progress    
                                input-prefix
                                count])     
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
    (or/c#fbytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
count:exact-nonnegative-integer?=1
procedure
(regexp-match-peek-positions-immediate/end pattern     
                                          input       
                                         [start-pos   
                                          end-pos     
                                          progress    
                                          input-prefix
                                          count])     
->(or/c(cons/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    (listof(or/c(cons/cexact-nonnegative-integer?
    exact-nonnegative-integer?)
    #f)))
    #f)
    (or/c#fbytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:input-port?
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
progress:(or/cevt#f)=#f
input-prefix:bytes?=#""
count:exact-nonnegative-integer?=1
procedure
(regexp-split pattern       
             input         
            [start-pos     
             end-pos       
             input-prefix])
->(if(and(or(string?pattern)(regexp?pattern))
    (string?input))
    (cons/cstring?(listofstring?))
    (cons/cbytes?(listofbytes?)))
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?input-port?)
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-replace pattern       
               input         
               insert        
              [input-prefix])
->(if(and(or(string?pattern)(regexp?pattern))
    (string?input))
    string?
    bytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?)
insert:(or/cstring?bytes?
           ((string?)()#:rest(listofstring?). ->* .string?)
           ((bytes?)()#:rest(listofbytes?). ->* .bytes?))
input-prefix:bytes?=#""
procedure
(regexp-replace* pattern        
                input          
                insert         
               [start-pos      
                end-pos        
                input-prefix])->(or/cstring?bytes?)
pattern:(or/cstring?bytes?regexp?byte-regexp?)
input:(or/cstring?bytes?)
insert:(or/cstring?bytes?
           ((string?)()#:rest(listofstring?). ->* .string?)
           ((bytes?)()#:rest(listofbytes?). ->* .bytes?))
start-pos:exact-nonnegative-integer?=0
end-pos:(or/cexact-nonnegative-integer?#f)=#f
input-prefix:bytes?=#""
procedure
(regexp-replacesinputreplacements)->(or/cstring?bytes?)
input:(or/cstring?bytes?)
replacements:(listof
                 (list/c(or/cstring?bytes?regexp?byte-regexp?)
                 (or/cstring?bytes?
                 ((string?)()#:rest(listofstring?). ->* .string?)
                 ((bytes?)()#:rest(listofbytes?). ->* .bytes?))))
procedure
(regexp-replace-quotestr)->string?
str:string?
(regexp-replace-quotebstr)->bytes?
bstr:bytes?
procedure
(keyword?v)->boolean?
v:any/c
procedure
(keyword->stringkeyword)->string?
keyword:keyword?
procedure
(string->keywordstr)->keyword?
str:string?
procedure
(keyword<?a-keywordb-keyword...)->boolean?
a-keyword:keyword?
b-keyword:keyword?
procedure
(keyword->immutable-stringsym)->(and/cstring?immutable?)
sym:keyword?
procedure
(pair?v)->boolean?
v:any/c
procedure
(null?v)->boolean?
v:any/c
procedure
(consad)->pair?
a:any/c
d:any/c
procedure
(carp)->any/c
p:pair?
procedure
(cdrp)->any/c
p:pair?
value
null:null?
procedure
(list?v)->boolean?
v:any/c
procedure
(listv...)->list?
v:any/c
procedure
(list*v...tail)->any/c
v:any/c
tail:any/c
procedure
(build-listnproc)->list?
n:exact-nonnegative-integer?
proc:(exact-nonnegative-integer?. -> .any)
procedure
(lengthlst)->exact-nonnegative-integer?
lst:list?
procedure
(list-reflstpos)->any/c
lst:pair?
pos:exact-nonnegative-integer?
procedure
(list-taillstpos)->any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(appendlst...)->list?
lst:list?
(appendlst...v)->any/c
lst:list?
v:any/c
procedure
(reverselst)->list?
lst:list?
procedure
(mapproclst...+)->list?
proc:procedure?
lst:list?
procedure
(andmapproclst...+)->any
proc:procedure?
lst:list?
procedure
(ormapproclst...+)->any
proc:procedure?
lst:list?
procedure
(for-eachproclst...+)->void?
proc:procedure?
lst:list?
procedure
(foldlprocinitlst...+)->any/c
proc:procedure?
init:any/c
lst:list?
procedure
(foldrprocinitlst...+)->any/c
proc:procedure?
init:any/c
lst:list?
procedure
(filterpredlst)->list?
pred:procedure?
lst:list?
procedure
(removevlst[proc])->list?
v:any/c
lst:list?
proc:procedure?=equal?
procedure
(remqvlst)->list?
v:any/c
lst:list?
procedure
(remvvlst)->list?
v:any/c
lst:list?
procedure
(remwvlst)->list?
v:any/c
lst:list?
procedure
(remove*v-lstlst[proc])->list?
v-lst:list?
lst:list?
proc:procedure?=equal?
procedure
(remq*v-lstlst)->list?
v-lst:list?
lst:list?
procedure
(remv*v-lstlst)->list?
v-lst:list?
lst:list?
procedure
(remw*v-lstlst)->list?
v-lst:list?
lst:list?
procedure
(sort lst                         
     less-than?                  
    [#:keyextract-key           
     #:cache-keys?cache-keys?])->list?
lst:list?
less-than?:(any/cany/c. -> .any/c)
extract-key:(any/c. -> .any/c)=(lambda(x)x)
cache-keys?:boolean?=#f
procedure
(membervlst[is-equal?])->(or/c#flist?any/c)
v:any/c
lst:(or/clist?any/c)
is-equal?:(any/cany/c->any/c)=equal?
procedure
(memwvlst)->(or/c#flist?any/c)
v:any/c
lst:(or/clist?any/c)
procedure
(memvvlst)->(or/c#flist?any/c)
v:any/c
lst:(or/clist?any/c)
procedure
(memqvlst)->(or/c#flist?any/c)
v:any/c
lst:(or/clist?any/c)
procedure
(memfproclst)->(or/c#flist?any/c)
proc:procedure?
lst:(or/clist?any/c)
procedure
(findfproclst)->any/c
proc:procedure?
lst:list?
procedure
(assocvlst[is-equal?])->(or/cpair?#f)
v:any/c
lst:(or/c(listofpair?)any/c)
is-equal?:(any/cany/c->any/c)=equal?
procedure
(asswvlst)->(or/cpair?#f)
v:any/c
lst:(or/c(listofpair?)any/c)
procedure
(assvvlst)->(or/cpair?#f)
v:any/c
lst:(or/c(listofpair?)any/c)
procedure
(assqvlst)->(or/cpair?#f)
v:any/c
lst:(or/c(listofpair?)any/c)
procedure
(assfproclst)->(or/cpair?#f)
proc:procedure?
lst:(or/c(listofpair?)any/c)
procedure
(caarv)->any/c
v:(cons/cpair?any/c)
procedure
(cadrv)->any/c
v:(cons/cany/cpair?)
procedure
(cdarv)->any/c
v:(cons/cpair?any/c)
procedure
(cddrv)->any/c
v:(cons/cany/cpair?)
procedure
(caaarv)->any/c
v:(cons/c(cons/cpair?any/c)any/c)
procedure
(caadrv)->any/c
v:(cons/cany/c(cons/cpair?any/c))
procedure
(cadarv)->any/c
v:(cons/c(cons/cany/cpair?)any/c)
procedure
(caddrv)->any/c
v:(cons/cany/c(cons/cany/cpair?))
procedure
(cdaarv)->any/c
v:(cons/c(cons/cpair?any/c)any/c)
procedure
(cdadrv)->any/c
v:(cons/cany/c(cons/cpair?any/c))
procedure
(cddarv)->any/c
v:(cons/c(cons/cany/cpair?)any/c)
procedure
(cdddrv)->any/c
v:(cons/cany/c(cons/cany/cpair?))
procedure
(caaaarv)->any/c
v:(cons/c(cons/c(cons/cpair?any/c)any/c)any/c)
procedure
(caaadrv)->any/c
v:(cons/cany/c(cons/c(cons/cpair?any/c)any/c))
procedure
(caadarv)->any/c
v:(cons/c(cons/cany/c(cons/cpair?any/c))any/c)
procedure
(caaddrv)->any/c
v:(cons/cany/c(cons/cany/c(cons/cpair?any/c)))
procedure
(cadaarv)->any/c
v:(cons/c(cons/c(cons/cany/cpair?)any/c)any/c)
procedure
(cadadrv)->any/c
v:(cons/cany/c(cons/c(cons/cany/cpair?)any/c))
procedure
(caddarv)->any/c
v:(cons/c(cons/cany/c(cons/cany/cpair?))any/c)
procedure
(cadddrv)->any/c
v:(cons/cany/c(cons/cany/c(cons/cany/cpair?)))
procedure
(cdaaarv)->any/c
v:(cons/c(cons/c(cons/cpair?any/c)any/c)any/c)
procedure
(cdaadrv)->any/c
v:(cons/cany/c(cons/c(cons/cpair?any/c)any/c))
procedure
(cdadarv)->any/c
v:(cons/c(cons/cany/c(cons/cpair?any/c))any/c)
procedure
(cdaddrv)->any/c
v:(cons/cany/c(cons/cany/c(cons/cpair?any/c)))
procedure
(cddaarv)->any/c
v:(cons/c(cons/c(cons/cany/cpair?)any/c)any/c)
procedure
(cddadrv)->any/c
v:(cons/cany/c(cons/c(cons/cany/cpair?)any/c))
procedure
(cdddarv)->any/c
v:(cons/c(cons/cany/c(cons/cany/cpair?))any/c)
procedure
(cddddrv)->any/c
v:(cons/cany/c(cons/cany/c(cons/cany/cpair?)))
value
empty:null?
procedure
(cons?v)->boolean?
v:any/c
procedure
(empty?v)->boolean?
v:any/c
procedure
(firstlst)->any/c
lst:list?
procedure
(restlst)->list?
lst:list?
procedure
(secondlst)->any
lst:list?
procedure
(thirdlst)->any
lst:list?
procedure
(fourthlst)->any
lst:list?
procedure
(fifthlst)->any
lst:list?
procedure
(sixthlst)->any
lst:list?
procedure
(seventhlst)->any
lst:list?
procedure
(eighthlst)->any
lst:list?
procedure
(ninthlst)->any
lst:list?
procedure
(tenthlst)->any
lst:list?
procedure
(lastlst)->any
lst:list?
procedure
(last-pairp)->pair?
p:pair?
procedure
(make-listkv)->list?
k:exact-nonnegative-integer?
v:any/c
procedure
(list-updatelstposupdater)->list?
lst:list?
pos:(and/c(>=/c0)(</c(lengthlst)))
updater:(->any/cany/c)
procedure
(list-setlstposvalue)->list?
lst:list?
pos:(and/c(>=/c0)(</c(lengthlst)))
value:any/c
procedure
(index-oflstv[is-equal?])->(or/cexact-nonnegative-integer?#f)
lst:list?
v:any/c
is-equal?:(any/cany/c. -> .any/c)=equal?
procedure
(index-wherelstproc)->(or/cexact-nonnegative-integer?#f)
lst:list?
proc:(any/c. -> .any/c)
procedure
(indexes-oflstv[is-equal?])
->(listofexact-nonnegative-integer?)
lst:list?
v:any/c
is-equal?:(any/cany/c. -> .any/c)=equal?
procedure
(indexes-wherelstproc)->(listofexact-nonnegative-integer?)
lst:list?
proc:(any/c. -> .any/c)
procedure
(takelstpos)->list?
lst:any/c
pos:exact-nonnegative-integer?
procedure
(droplstpos)->any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(split-atlstpos)->list?any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(takeflstpred)->list?
lst:any/c
pred:procedure?
procedure
(dropflstpred)->any/c
lst:any/c
pred:procedure?
procedure
(splitf-atlstpred)->list?any/c
lst:any/c
pred:procedure?
procedure
(take-rightlstpos)->any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(drop-rightlstpos)->list?
lst:any/c
pos:exact-nonnegative-integer?
procedure
(split-at-rightlstpos)->list?any/c
lst:any/c
pos:exact-nonnegative-integer?
procedure
(takef-rightlstpred)->any/c
lst:any/c
pred:procedure?
procedure
(dropf-rightlstpred)->list?
lst:any/c
pred:procedure?
procedure
(splitf-at-rightlstpred)->list?any/c
lst:any/c
pred:procedure?
procedure
(list-prefix?lr[same?])->boolean?
l:list?
r:list?
same?:(any/cany/c. -> .any/c)=equal?
procedure
(take-common-prefixlr[same?])->list?
l:list?
r:list?
same?:(any/cany/c. -> .any/c)=equal?
procedure
(drop-common-prefixlr[same?])->list?list?
l:list?
r:list?
same?:(any/cany/c. -> .any/c)=equal?
procedure
(split-common-prefixlr[same?])->list?list?list?
l:list?
r:list?
same?:(any/cany/c. -> .any/c)=equal?
procedure
(add-between lst                         
            v                           
           [#:before-firstbefore-first 
            #:before-lastbefore-last   
            #:after-lastafter-last     
            #:splice?splice?])        ->list?
lst:list?
v:any/c
before-first:list?='()
before-last:any/c=v
after-last:list?='()
splice?:any/c=#f
procedure
(append*lst...lsts)->list?
lst:list?
lsts:(listoflist?)
(append*lst...lsts)->any/c
lst:list?
lsts:list?
procedure
(flattenv)->list?
v:any/c
procedure
(check-duplicates lst                        
                [same?                      
                 #:keyextract-key          
                 #:defaultfailure-result])->any
lst:list?
same?:(any/cany/c. -> .any/c)=equal?
extract-key:(->any/cany/c)=(lambda(x)x)
failure-result:failure-result/c=(lambda()#f)
procedure
(remove-duplicates lst                 
                 [same?               
                  #:keyextract-key])->list?
lst:list?
same?:(any/cany/c. -> .any/c)=equal?
extract-key:(any/c. -> .any/c)=(lambda(x)x)
procedure
(filter-mapproclst...+)->list?
proc:procedure?
lst:list?
procedure
(countproclst...+)->exact-nonnegative-integer?
proc:procedure?
lst:list?
procedure
(partitionpredlst)->list?list?
pred:procedure?
lst:list?
procedure
(rangeend)->list?
end:real?
(rangestartend[step])->list?
start:real?
end:real?
step:real?=1
procedure
(inclusive-rangestartend[step])->list?
start:real?
end:real?
step:real?=1
procedure
(append-mapproclst...+)->list?
proc:procedure?
lst:list?
procedure
(filter-notpredlst)->list?
pred:(any/c. -> .any/c)
lst:list?
procedure
(shufflelst)->list?
lst:list?
procedure
(combinationslst)->list?
lst:list?
(combinationslstsize)->list?
lst:list?
size:exact-nonnegative-integer?
procedure
(in-combinationslst)->sequence?
lst:list?
(in-combinationslstsize)->sequence?
lst:list?
size:exact-nonnegative-integer?
procedure
(permutationslst)->list?
lst:list?
procedure
(in-permutationslst)->sequence?
lst:list?
procedure
(argminproclst)->any/c
proc:(->any/creal?)
lst:(and/cpair?list?)
procedure
(argmaxproclst)->any/c
proc:(->any/creal?)
lst:(and/cpair?list?)
procedure
(group-bykeylst[same?])->(listoflist?)
key:(->any/cany/c)
lst:list?
same?:(any/cany/c. -> .any/c)=equal?
procedure
(cartesian-productlst...)->(listoflist?)
lst:list?
procedure
(remfpredlst)->list?
pred:procedure?
lst:list?
procedure
(remf*predlst)->list?
pred:procedure?
lst:list?
procedure
(make-reader-graphv)->any/c
v:any/c
procedure
(placeholder?v)->boolean?
v:any/c
procedure
(make-placeholderv)->placeholder?
v:any/c
procedure
(placeholder-set!phdatum)->void?
ph:placeholder?
datum:any/c
procedure
(placeholder-getph)->any/c
ph:placeholder?
procedure
(hash-placeholder?v)->boolean?
v:any/c
procedure
(make-hash-placeholderassocs)->hash-placeholder?
assocs:(listofpair?)
procedure
(make-hasheq-placeholderassocs)->hash-placeholder?
assocs:(listofpair?)
procedure
(make-hasheqv-placeholderassocs)->hash-placeholder?
assocs:(listofpair?)
procedure
(make-hashalw-placeholderassocs)->hash-placeholder?
assocs:(listofpair?)
procedure
(mpair?v)->boolean?
v:any/c
procedure
(mconsad)->mpair?
a:any/c
d:any/c
procedure
(mcarp)->any/c
p:mpair?
procedure
(mcdrp)->any/c
p:mpair?
procedure
(set-mcar!pv)->void?
p:mpair?
v:any/c
procedure
(set-mcdr!pv)->void?
p:mpair?
v:any/c
procedure
(vector?v)->boolean?
v:any/c
procedure
(make-vectorsize[v])->vector?
size:exact-nonnegative-integer?
v:any/c=0
procedure
(vectorv...)->vector?
v:any/c
procedure
(vector-immutablev...)->(and/cvector?
                            immutable?)
v:any/c
procedure
(vector-lengthvec)->exact-nonnegative-integer?
vec:vector?
procedure
(vector-refvecpos)->any/c
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-set!vecposv)->void?
vec:(and/cvector?(not/cimmutable?))
pos:exact-nonnegative-integer?
v:any/c
procedure
(vector*-lengthvec)->exact-nonnegative-integer?
vec:(and/cvector?(not/cimpersonator?))
procedure
(vector*-refvecpos)->any/c
vec:(and/cvector?(not/cimpersonator?))
pos:exact-nonnegative-integer?
procedure
(vector*-set!vecposv)->void?
vec:(and/cvector?(not/cimmutable?)(not/cimpersonator?))
pos:exact-nonnegative-integer?
v:any/c
procedure
(vector-cas!vecposold-vnew-v)->boolean?
vec:(and/cvector?(not/cimmutable?)(not/cimpersonator?))
pos:exact-nonnegative-integer?
old-v:any/c
new-v:any/c
procedure
(vector->listvec)->list?
vec:vector?
procedure
(list->vectorlst)->vector?
lst:list?
procedure
(vector->immutable-vectorvec)->(and/cvector?immutable?)
vec:vector?
procedure
(vector-fill!vecv)->void?
vec:(and/cvector?(not/cimmutable?))
v:any/c
procedure
(vector-copy! dest       
             dest-start 
             src        
            [src-start  
             src-end]) ->void?
dest:(and/cvector?(not/cimmutable?))
dest-start:exact-nonnegative-integer?
src:vector?
src-start:exact-nonnegative-integer?=0
src-end:exact-nonnegative-integer?=(vector-lengthsrc)
procedure
(vector->valuesvec[start-posend-pos])->any
vec:vector?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(vector-lengthvec)
procedure
(build-vectornproc)->vector?
n:exact-nonnegative-integer?
proc:(exact-nonnegative-integer?. -> .any/c)
procedure
(vector-empty?v)->boolean?
v:vector?
procedure
(vector-set*!vecposv......)->void?
vec:(and/cvector?(not/cimmutable?))
pos:exact-nonnegative-integer?
v:any/c
procedure
(vector-mapprocvec...+)->vector?
proc:procedure?
vec:vector?
procedure
(vector-map!procvec...+)->vector?
proc:procedure?
vec:(and/cvector?(not/cimmutable?))
procedure
(vector-appendvec...)->vector?
vec:vector?
procedure
(vector-takevecpos)->vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-take-rightvecpos)->vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-dropvecpos)->vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-drop-rightvecpos)->vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-split-atvecpos)->vector?vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-split-at-rightvecpos)->vector?vector?
vec:vector?
pos:exact-nonnegative-integer?
procedure
(vector-copyvec[startend])->vector?
vec:vector?
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthv)
procedure
(vector-filterpredvec)->vector?
pred:procedure?
vec:vector?
procedure
(vector-filter-notpredvec)->vector?
pred:procedure?
vec:vector?
procedure
(vector-countprocvec...+)->exact-nonnegative-integer?
proc:procedure?
vec:vector?
procedure
(vector-argminprocvec)->any/c
proc:(->any/creal?)
vec:vector?
procedure
(vector-argmaxprocvec)->any/c
proc:(->any/creal?)
vec:vector?
procedure
(vector-membervvec)->(or/cnatural-number/c#f)
v:any/c
vec:vector?
procedure
(vector-memvvvec)->(or/cnatural-number/c#f)
v:any/c
vec:vector?
procedure
(vector-memqvvec)->(or/cnatural-number/c#f)
v:any/c
vec:vector?
procedure
(vector-sort vec                         
            less-than?                  
           [start                       
            end                         
            #:keykey                   
            #:cache-keys?cache-keys?])->vector?
vec:vector?
less-than?:(any/cany/c. -> .any/c)
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthvec)
key:(any/c. -> .any/c)=((x)x)
cache-keys?:boolean?=#f
procedure
(vector-sort! vec                         
             less-than?                  
            [start                       
             end                         
             #:keykey                   
             #:cache-keys?cache-keys?])->void?
vec:(and/cvector?(not/cimmutable?))
less-than?:(any/cany/c. -> .any/c)
start:exact-nonnegative-integer?=0
end:exact-nonnegative-integer?=(vector-lengthvec)
key:(any/c. -> .any/c)=((x)x)
cache-keys?:boolean?=#f
procedure
(stencil-vector?v)->boolean?
v:any/c
procedure
(stencil-vector-mask-width)->exact-nonnegative-integer?
procedure
(stencil-vectormaskv...)->stencil-vector?
mask:(integer-in0(sub1(expt2(stencil-vector-mask-width))))
v:any/c
procedure
(stencil-vector-maskvec)
->(integer-in0(sub1(expt2(stencil-vector-mask-width))))
vec:stencil-vector?
procedure
(stencil-vector-lengthvec)
->(integer-in0(sub1(stencil-vector-mask-width)))
vec:stencil-vector?
procedure
(stencil-vector-refvecpos)->any/c
vec:stencil-vector?
pos:exact-nonnegative-integer?
procedure
(stencil-vector-set!vecposv)->avoid?
vec:stencil-vector?
pos:exact-nonnegative-integer?
v:any/c
procedure
(stencil-vector-updatevec         
                     remove-mask 
                     add-mask    
                     v...)     ->stencil-vector?
vec:stencil-vector?
remove-mask:(integer-in0(sub1(expt2(stencil-vector-mask-width))))
add-mask:(integer-in0(sub1(expt2(stencil-vector-mask-width))))
v:any/c
procedure
(box?v)->boolean?
v:any/c
procedure
(boxv)->box?
v:any/c
procedure
(box-immutablev)->(and/cbox?immutable?)
v:any/c
procedure
(unboxbox)->any/c
box:box?
procedure
(set-box!boxv)->void?
box:(and/cbox?(not/cimmutable?))
v:any/c
procedure
(unbox*box)->any/c
box:(andbox?(not/cimpersonator?))
procedure
(set-box*!boxv)->void?
box:(and/cbox?(not/cimmutable?)(not/cimpersonator?))
v:any/c
procedure
(box-cas!boxoldnew)->boolean?
box:(and/cbox?(not/cimmutable?)(not/cimpersonator?))
old:any/c
new:any/c
procedure
(hash?v)->boolean?
v:any/c
procedure
(hash-equal?hash)->boolean?
hash:hash?
procedure
(hash-equal-always?hash)->boolean?
hash:hash?
procedure
(hash-eqv?hash)->boolean?
hash:hash?
procedure
(hash-eq?hash)->boolean?
hash:hash?
procedure
(hash-strong?hash)->boolean?
hash:hash?
procedure
(hash-weak?hash)->boolean?
hash:hash?
procedure
(hash-ephemeron?hash)->boolean?
hash:hash?
procedure
(hashkeyval......)
->(and/chash?hash-equal?immutable?hash-strong?)
key:any/c
val:any/c
procedure
(hashalwkeyval......)
->(and/chash?hash-equal-always?immutable?hash-strong?)
key:any/c
val:any/c
procedure
(hasheqkeyval......)
->(and/chash?hash-eq?immutable?hash-strong?)
key:any/c
val:any/c
procedure
(hasheqvkeyval......)
->(and/chash?hash-eqv?immutable?hash-strong?)
key:any/c
val:any/c
procedure
(make-hash[assocs])
->(and/chash?hash-equal?(not/cimmutable?)hash-strong?)
assocs:(listofpair?)=null
procedure
(make-hashalw[assocs])
->(and/chash?hash-equal-always?(not/cimmutable?)hash-strong?)
assocs:(listofpair?)=null
procedure
(make-hasheqv[assocs])
->(and/chash?hash-eqv?(not/cimmutable?)hash-strong?)
assocs:(listofpair?)=null
procedure
(make-hasheq[assocs])
->(and/chash?hash-eq?(not/cimmutable?)hash-strong?)
assocs:(listofpair?)=null
procedure
(make-weak-hash[assocs])
->(and/chash?hash-equal?(not/cimmutable?)hash-weak?)
assocs:(listofpair?)=null
procedure
(make-weak-hashalw[assocs])
->(and/chash?hash-equal-always?(not/cimmutable?)hash-weak?)
assocs:(listofpair?)=null
procedure
(make-weak-hasheqv[assocs])
->(and/chash?hash-eqv?(not/cimmutable?)hash-weak?)
assocs:(listofpair?)=null
procedure
(make-weak-hasheq[assocs])
->(and/chash?hash-eq?(not/cimmutable?)hash-weak?)
assocs:(listofpair?)=null
procedure
(make-ephemeron-hash[assocs])
->(and/chash?hash-equal?(not/cimmutable?)hash-ephemeron?)
assocs:(listofpair?)=null
procedure
(make-ephemeron-hashalw[assocs])
->(and/chash?hash-equal-always?(not/cimmutable?)hash-ephemeron?)
assocs:(listofpair?)=null
procedure
(make-ephemeron-hasheqv[assocs])
->(and/chash?hash-eqv?(not/cimmutable?)hash-ephemeron?)
assocs:(listofpair?)=null
procedure
(make-ephemeron-hasheq[assocs])
->(and/chash?hash-eq?(not/cimmutable?)hash-ephemeron?)
assocs:(listofpair?)=null
procedure
(make-immutable-hash[assocs])
->(and/chash?hash-equal?immutable?hash-strong?)
assocs:(listofpair?)=null
procedure
(make-immutable-hashalw[assocs])
->(and/chash?hash-equal-always?immutable?hash-strong?)
assocs:(listofpair?)=null
procedure
(make-immutable-hasheqv[assocs])
->(and/chash?hash-eqv?immutable?hash-strong?)
assocs:(listofpair?)=null
procedure
(make-immutable-hasheq[assocs])
->(and/chash?hash-eq?immutable?hash-strong?)
assocs:(listofpair?)=null
procedure
(hash-set!hashkeyv)->void?
hash:(and/chash?(not/cimmutable?))
key:any/c
v:any/c
procedure
(hash-set*!hashkeyv......)->void?
hash:(and/chash?(not/cimmutable?))
key:any/c
v:any/c
procedure
(hash-sethashkeyv)->(and/chash?immutable?)
hash:(and/chash?immutable?)
key:any/c
v:any/c
procedure
(hash-set*hashkeyv......)->(and/chash?immutable?)
hash:(and/chash?immutable?)
key:any/c
v:any/c
procedure
(hash-refhashkey[failure-result])->any
hash:hash?
key:any/c
failure-result:failure-result/c
              =(lambda()
                   (raise(make-exn:fail:contract....)))
procedure
(hash-ref-keyhashkey[failure-result])->any
hash:hash?
key:any/c
failure-result:failure-result/c
              =(lambda()
                   (raise(make-exn:fail:contract....)))
procedure
(hash-ref!hashkeyto-set)->any
hash:hash?
key:any/c
to-set:failure-result/c
procedure
(hash-has-key?hashkey)->boolean?
hash:hash?
key:any/c
procedure
(hash-update! hash             
             key              
             updater          
            [failure-result])->void?
hash:(and/chash?(not/cimmutable?))
key:any/c
updater:(any/c. -> .any/c)
failure-result:failure-result/c
              =(lambda()
                   (raise(make-exn:fail:contract....)))
procedure
(hash-updatehashkeyupdater[failure-result])
->(and/chash?immutable?)
hash:(and/chash?immutable?)
key:any/c
updater:(any/c. -> .any/c)
failure-result:failure-result/c
              =(lambda()
                   (raise(make-exn:fail:contract....)))
procedure
(hash-remove!hashkey)->void?
hash:(and/chash?(not/cimmutable?))
key:any/c
procedure
(hash-removehashkey)->(and/chash?immutable?)
hash:(and/chash?immutable?)
key:any/c
procedure
(hash-clear!hash)->void?
hash:(and/chash?(not/cimmutable?))
procedure
(hash-clearhash)->(and/chash?immutable?)
hash:(and/chash?immutable?)
procedure
(hash-copy-clearhash[#:kindkind])->hash?
hash:hash?
kind:(or/c#f'immutable'mutable'weak'ephemeron)=#f
procedure
(hash-maphashproc[try-order?])->(listofany/c)
hash:hash?
proc:(any/cany/c. -> .any/c)
try-order?:any/c=#f
procedure
(hash-map/copyhashproc[#:kindkind])->hash?
hash:hash?
proc:(any/cany/c. -> .(valuesany/cany/c))
kind:(or/c#f'immutable'mutable'weak'ephemeron)=#f
procedure
(hash-keyshash[try-order?])->(listofany/c)
hash:hash?
try-order?:any/c=#f
procedure
(hash-valueshash[try-order?])->(listofany/c)
hash:hash?
try-order?:any/c=#f
procedure
(hash->listhash[try-order?])->(listof(cons/cany/cany/c))
hash:hash?
try-order?:any/c=#f
procedure
(hash-keys-subset?hash1hash2)->boolean?
hash1:hash?
hash2:hash?
procedure
(hash-for-eachhashproc[try-order?])->void?
hash:hash?
proc:(any/cany/c. -> .any)
try-order?:any/c=#f
procedure
(hash-counthash)->exact-nonnegative-integer?
hash:hash?
procedure
(hash-empty?hash)->boolean?
hash:hash?
procedure
(hash-iterate-firsthash)
->(or/c#fexact-nonnegative-integer?)
hash:hash?
procedure
(hash-iterate-nexthashpos)
->(or/c#fexact-nonnegative-integer?)
hash:hash?
pos:exact-nonnegative-integer?
procedure
(hash-iterate-keyhashpos)->any/c
hash:hash?
pos:exact-nonnegative-integer?
procedure
(hash-iterate-keyhashposbad-index-v)->any/c
hash:hash?
pos:exact-nonnegative-integer?
bad-index-v:any/c
procedure
(hash-iterate-valuehashpos)->any
hash:hash?
pos:exact-nonnegative-integer?
procedure
(hash-iterate-valuehashposbad-index-v)->any
hash:hash?
pos:exact-nonnegative-integer?
bad-index-v:any/c
procedure
(hash-iterate-pairhashpos)->(consany/cany/c)
hash:hash?
pos:exact-nonnegative-integer?
procedure
(hash-iterate-pairhashposbad-index-v)->(consany/cany/c)
hash:hash?
pos:exact-nonnegative-integer?
bad-index-v:any/c
procedure
(hash-iterate-key+valuehashpos)->any/cany/c
hash:hash?
pos:exact-nonnegative-integer?
procedure
(hash-iterate-key+valuehash         
                      pos          
                      bad-index-v)->any/cany/c
hash:hash?
pos:exact-nonnegative-integer?
bad-index-v:any/c
procedure
(hash-copyhash)->(and/chash?(not/cimmutable?))
hash:hash?
procedure
(hash-union h0                         
           h...                      
          [#:combinecombine          
           #:combine/keycombine/key])
->(and/chash?immutable?)
h0:(and/chash?immutable?)
h:hash?
combine:(->any/cany/cany/c)
       =(lambda_(error'hash-union....))
combine/key:(->any/cany/cany/cany/c)
           =(lambda(kab)(combineab))
procedure
(hash-union! h0                          
            h...                       
           [#:combinecombine           
            #:combine/keycombine/key])->void?
h0:(and/chash?(not/cimmutable?))
h:hash?
combine:(->any/cany/cany/c)
       =(lambda_(error'hash-union....))
combine/key:(->any/cany/cany/cany/c)
           =(lambda(kab)(combineab))
procedure
(hash-intersect h0                         
               h...                      
              [#:combinecombine          
               #:combine/keycombine/key])
->(and/chash?immutable?)
h0:(and/chash?immutable?)
h:hash?
combine:(->any/cany/cany/c)
       =(lambda_(error'hash-intersect...))
combine/key:(->any/cany/cany/cany/c)
           =(lambda(kab)(combineab))
procedure
(sequence?v)->boolean?
v:any/c
procedure
(in-rangeend)->stream?
end:real?
(in-rangestartend[step])->stream?
start:real?
end:real?
step:real?=1
procedure
(in-inclusive-rangestartend[step])->stream?
start:real?
end:real?
step:real?=1
procedure
(in-naturals[start])->stream?
start:exact-nonnegative-integer?=0
procedure
(in-listlst)->stream?
lst:list?
procedure
(in-mlistmlst)->sequence?
mlst:mlist?
procedure
(in-vectorvec[startstopstep])->sequence?
vec:vector?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
procedure
(in-stringstr[startstopstep])->sequence?
str:string?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
procedure
(in-bytesbstr[startstopstep])->sequence?
bstr:bytes?
start:exact-nonnegative-integer?=0
stop:(or/cexact-integer?#f)=#f
step:(and/cexact-integer?(not/czero?))=1
procedure
(in-port[rin])->sequence?
r:(input-port?. -> .any/c)=read
in:input-port?=(current-input-port)
procedure
(in-input-port-bytesin)->sequence?
in:input-port?
procedure
(in-input-port-charsin)->sequence?
in:input-port?
procedure
(in-lines[inmode])->sequence?
in:input-port?=(current-input-port)
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='any
procedure
(in-bytes-lines[inmode])->sequence?
in:input-port?=(current-input-port)
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='any
procedure
(in-hashhash)->sequence?
hash:hash?
(in-hashhashbad-index-v)->sequence?
hash:hash?
bad-index-v:any/c
procedure
(in-hash-keyshash)->sequence?
hash:hash?
(in-hash-keyshashbad-index-v)->sequence?
hash:hash?
bad-index-v:any/c
procedure
(in-hash-valueshash)->sequence?
hash:hash?
(in-hash-valueshashbad-index-v)->sequence?
hash:hash?
bad-index-v:any/c
procedure
(in-hash-pairshash)->sequence?
hash:hash?
(in-hash-pairshashbad-index-v)->sequence?
hash:hash?
bad-index-v:any/c
procedure
(in-mutable-hashhash)->sequence?
hash:(and/chash?(not/cimmutable?)hash-strong?)
procedure
(in-mutable-hashhashbad-index-v)->sequence?
hash:(and/chash?(not/cimmutable?)hash-strong?)
bad-index-v:any/c
procedure
(in-mutable-hash-keyshash)->sequence?
hash:(and/chash?(not/cimmutable?)hash-strong?)
procedure
(in-mutable-hash-keyshashbad-index-v)->sequence?
hash:(and/chash?(not/cimmutable?)hash-strong?)
bad-index-v:any/c
procedure
(in-mutable-hash-valueshash)->sequence?
hash:(and/chash?(not/cimmutable?)hash-strong?)
procedure
(in-mutable-hash-valueshashbad-index-v)->sequence?
hash:(and/chash?(not/cimmutable?)hash-strong?)
bad-index-v:any/c
procedure
(in-mutable-hash-pairshash)->sequence?
hash:(and/chash?(not/cimmutable?)hash-strong?)
procedure
(in-mutable-hash-pairshashbad-index-v)->sequence?
hash:(and/chash?(not/cimmutable?)hash-strong?)
bad-index-v:any/c
procedure
(in-immutable-hashhash)->sequence?
hash:(and/chash?immutable?)
procedure
(in-immutable-hashhashbad-index-v)->sequence?
hash:(and/chash?immutable?)
bad-index-v:any/c
procedure
(in-immutable-hash-keyshash)->sequence?
hash:(and/chash?immutable?)
procedure
(in-immutable-hash-keyshashbad-index-v)->sequence?
hash:(and/chash?immutable?)
bad-index-v:any/c
procedure
(in-immutable-hash-valueshash)->sequence?
hash:(and/chash?immutable?)
procedure
(in-immutable-hash-valueshashbad-index-v)->sequence?
hash:(and/chash?immutable?)
bad-index-v:any/c
procedure
(in-immutable-hash-pairshash)->sequence?
hash:(and/chash?immutable?)
procedure
(in-immutable-hash-pairshashbad-index-v)->sequence?
hash:(and/chash?immutable?)
bad-index-v:any/c
procedure
(in-weak-hashhash)->sequence?
hash:(and/chash?hash-weak?)
procedure
(in-weak-hashhashbad-index-v)->sequence?
hash:(and/chash?hash-weak?)
bad-index-v:any/c
procedure
(in-weak-hash-keyshash)->sequence?
hash:(and/chash?hash-weak?)
procedure
(in-weak-hash-keyshashbad-index-v)->sequence?
hash:(and/chash?hash-weak?)
bad-index-v:any/c
procedure
(in-weak-hash-valueshash)->sequence?
hash:(and/chash?hash-weak?)
procedure
(in-weak-hash-keyshashbad-index-v)->sequence?
hash:(and/chash?hash-weak?)
bad-index-v:any/c
procedure
(in-weak-hash-pairshash)->sequence?
hash:(and/chash?hash-weak?)
procedure
(in-weak-hash-pairshashbad-index-v)->sequence?
hash:(and/chash?hash-weak?)
bad-index-v:any/c
procedure
(in-ephemeron-hashhash)->sequence?
hash:(and/chash?hash-ephemeron?)
procedure
(in-ephemeron-hashhashbad-index-v)->sequence?
hash:(and/chash?hash-ephemeron?)
bad-index-v:any/c
procedure
(in-ephemeron-hash-keyshash)->sequence?
hash:(and/chash?hash-ephemeron?)
procedure
(in-ephemeron-hash-keyshashbad-index-v)->sequence?
hash:(and/chash?hash-ephemeron?)
bad-index-v:any/c
procedure
(in-ephemeron-hash-valueshash)->sequence?
hash:(and/chash?hash-ephemeron?)
procedure
(in-ephemeron-hash-keyshashbad-index-v)->sequence?
hash:(and/chash?hash-ephemeron?)
bad-index-v:any/c
procedure
(in-ephemeron-hash-pairshash)->sequence?
hash:(and/chash?hash-ephemeron?)
procedure
(in-ephemeron-hash-pairshashbad-index-v)->sequence?
hash:(and/chash?hash-ephemeron?)
bad-index-v:any/c
procedure
(in-directory[diruse-dir?])->sequence?
dir:(or/c#fpath-string?)=#f
use-dir?:((and/cpath?complete-path?). -> .any/c)
        =(lambda(dir-path)#t)
procedure
(in-producerproducer)->sequence?
producer:procedure?
(in-producerproducerstoparg...)->sequence?
producer:procedure?
stop:any/c
arg:any/c
procedure
(in-valuev)->sequence?
v:any/c
procedure
(in-indexedseq)->sequence?
seq:sequence?
procedure
(in-sequencesseq...)->sequence?
seq:sequence?
procedure
(in-cycleseq...)->sequence?
seq:sequence?
procedure
(in-parallelseq...)->sequence?
seq:sequence?
procedure
(in-values-sequenceseq)->sequence?
seq:sequence?
procedure
(in-values*-sequenceseq)->sequence?
seq:sequence?
procedure
(stop-beforeseqpred)->sequence?
seq:sequence?
pred:(any/c. -> .any)
procedure
(stop-afterseqpred)->sequence?
seq:sequence?
pred:(any/c. -> .any)
procedure
(make-do-sequencethunk)->sequence?
thunk:(or/c(->(values(any/c. -> .any)
          (any/c. -> .any/c)
          any/c
          (or/c(any/c. -> .any/c)#f)
          (or/c(()()#:restlist?. ->* .any/c)#f)
          (or/c((any/c)()#:restlist?. ->* .any/c)#f)))
          (->(values(any/c. -> .any)
          (or/c(any/c. -> .any/c)#f)
          (any/c. -> .any/c)
          any/c
          (or/c(any/c. -> .any/c)#f)
          (or/c(()()#:restlist?. ->* .any/c)#f)
          (or/c((any/c)()#:restlist?. ->* .any/c)#f))))
value
prop:sequence:struct-type-property?
procedure
(sequence->streamseq)->stream?
seq:sequence?
procedure
(sequence-generateseq)->(->boolean?)(->any)
seq:sequence?
procedure
(sequence-generate*seq)
->(or/clist?#f)
    (->(values(or/clist?#f)procedure?))
seq:sequence?
value
empty-sequence:sequence?
procedure
(sequence->lists)->list?
s:sequence?
procedure
(sequence-lengths)->exact-nonnegative-integer?
s:sequence?
procedure
(sequence-refsi)->any
s:sequence?
i:exact-nonnegative-integer?
procedure
(sequence-tailsi)->sequence?
s:sequence?
i:exact-nonnegative-integer?
procedure
(sequence-appends...)->sequence?
s:sequence?
procedure
(sequence-mapfs)->sequence?
f:procedure?
s:sequence?
procedure
(sequence-andmapfs)->boolean?
f:(->any/c...boolean?)
s:sequence?
procedure
(sequence-ormapfs)->boolean?
f:(->any/c...boolean?)
s:sequence?
procedure
(sequence-for-eachfs)->void?
f:(->any/c...any)
s:sequence?
procedure
(sequence-foldfis)->any/c
f:(->any/cany/c...any/c)
i:any/c
s:sequence?
procedure
(sequence-countfs)->exact-nonnegative-integer?
f:procedure?
s:sequence?
procedure
(sequence-filterfs)->sequence?
f:(->any/c...boolean?)
s:sequence?
procedure
(sequence-add-betweense)->sequence?
s:sequence?
e:any/c
procedure
(sequence/c[#:min-countmin-count] 
           elem/c...)           ->contract?
min-count:(or/c#fexact-nonnegative-integer?)=#f
elem/c:contract?
procedure
(in-syntaxstx)->sequence?
stx:syntax?
procedure
(in-slicelengthseq)->sequence?
length:exact-positive-integer?
seq:sequence?
procedure
(stream?v)->boolean?
v:any/c
procedure
(stream-empty?s)->boolean?
s:stream?
procedure
(stream-firsts)->any
s:(and/cstream?(not/cstream-empty?))
procedure
(stream-rests)->stream?
s:(and/cstream?(not/cstream-empty?))
syntax
(stream-consfirst-exprrest-expr)
(stream-cons#:eagerfirst-exprrest-expr)
(stream-consfirst-expr#:eagerrest-expr)
(stream-cons#:eagerfirst-expr#:eagerrest-expr)
syntax
(stream-lazystream-expr)
(stream-lazy#:whowho-exprstream-expr)
procedure
(stream-forces)->stream?
s:stream?
syntax
(streame...)
syntax
(stream*e...tail)
procedure
(in-streams)->sequence?
s:stream?
value
empty-stream:stream?
procedure
(stream->lists)->list?
s:stream?
procedure
(stream-lengths)->exact-nonnegative-integer?
s:stream?
procedure
(stream-refsi)->any
s:stream?
i:exact-nonnegative-integer?
procedure
(stream-tailsi)->stream?
s:stream?
i:exact-nonnegative-integer?
procedure
(stream-takesi)->stream?
s:stream?
i:exact-nonnegative-integer?
procedure
(stream-appends...)->stream?
s:stream?
procedure
(stream-mapfs)->stream?
f:procedure?
s:stream?
procedure
(stream-andmapfs)->boolean?
f:(->any/c...boolean?)
s:stream?
procedure
(stream-ormapfs)->boolean?
f:(->any/c...boolean?)
s:stream?
procedure
(stream-for-eachfs)->void?
f:(->any/c...any)
s:stream?
procedure
(stream-foldfis)->any/c
f:(->any/cany/c...any/c)
i:any/c
s:stream?
procedure
(stream-countfs)->exact-nonnegative-integer?
f:procedure?
s:stream?
procedure
(stream-filterfs)->stream?
f:(->any/c...boolean?)
s:stream?
procedure
(stream-add-betweense)->stream?
s:stream?
e:any/c
syntax
(for/stream(for-clause...)body-or-break...body)
syntax
(for*/stream(for-clause...)body-or-break...body)
value
gen:stream:any/c
value
prop:stream:struct-type-property?
procedure
(stream/cc)->contract?
c:contract?
procedure
(generator?v)->boolean?
v:any/c
syntax
(generatorformalsbody...+)

formals=(id...)
      |(id...+. rest-id)
      |rest-id
procedure
(yieldv...)->any
v:any/c
syntax
(infinite-generatorbody...+)
syntax
(in-generatormaybe-aritybody...+)

maybe-arity=
          |#:arityarity-k
procedure
(generator-stateg)->symbol?
g:generator?
procedure
(sequence->generators)->(->any)
s:sequence?
procedure
(sequence->repeated-generators)->(->any)
s:sequence?
procedure
(dict?v)->boolean?
v:any/c
procedure
(dict-implements?dsym...)->boolean?
d:dict?
sym:symbol?
procedure
(dict-implements/csym...)->flat-contract?
sym:symbol?
procedure
(dict-mutable?d)->boolean?
d:dict?
procedure
(dict-can-remove-keys?d)->boolean?
d:dict?
procedure
(dict-can-functional-set?d)->boolean?
d:dict?
syntax
gen:dict
value
prop:dict:struct-type-property?
procedure
(dict-refdictkey[failure-result])->any
dict:dict?
key:any/c
failure-result:failure-result/c
              =(lambda()(raise(make-exn:fail....)))
procedure
(dict-set!dictkeyv)->void?
dict:(and/cdict?(not/cimmutable?))
key:any/c
v:any/c
procedure
(dict-setdictkeyv)->(and/cdict?immutable?)
dict:(and/cdict?immutable?)
key:any/c
v:any/c
procedure
(dict-remove!dictkey)->void?
dict:(and/cdict?(not/cimmutable?))
key:any/c
procedure
(dict-removedictkey)->(and/cdict?immutable?)
dict:(and/cdict?immutable?)
key:any/c
procedure
(dict-iterate-firstdict)->any/c
dict:dict?
procedure
(dict-iterate-nextdictpos)->any/c
dict:dict?
pos:any/c
procedure
(dict-iterate-keydictpos)->any
dict:dict?
pos:any/c
procedure
(dict-iterate-valuedictpos)->any
dict:dict?
pos:any/c
procedure
(dict-has-key?dictkey)->boolean?
dict:dict?
key:any/c
procedure
(dict-set*!dictkeyv......)->void?
dict:(and/cdict?(not/cimmutable?))
key:any/c
v:any/c
procedure
(dict-set*dictkeyv......)->(and/cdict?immutable?)
dict:(and/cdict?immutable?)
key:any/c
v:any/c
procedure
(dict-ref!dictkeyto-set)->any
dict:dict?
key:any/c
to-set:any/c
procedure
(dict-update! dict             
             key              
             updater          
            [failure-result])->void?
dict:(and/cdict?(not/cimmutable?))
key:any/c
updater:(any/c. -> .any/c)
failure-result:failure-result/c
              =(lambda()(raise(make-exn:fail....)))
procedure
(dict-updatedictkeyupdater[failure-result])
->(and/cdict?immutable?)
dict:dict?
key:any/c
updater:(any/c. -> .any/c)
failure-result:failure-result/c
              =(lambda()(raise(make-exn:fail....)))
procedure
(dict-mapdictproc)->(listofany/c)
dict:dict?
proc:(any/cany/c. -> .any/c)
procedure
(dict-map/copydictproc)->dict?
dict:dict?
proc:(any/cany/c. -> .(valuesany/cany/c))
procedure
(dict-for-eachdictproc)->void?
dict:dict?
proc:(any/cany/c. -> .any)
procedure
(dict-empty?dict)->boolean?
dict:dict?
procedure
(dict-countdict)->exact-nonnegative-integer?
dict:dict?
procedure
(dict-copydict)->dict?
dict:dict?
procedure
(dict-cleardict)->dict?
dict:dict?
procedure
(dict-clear!dict)->void?
dict:dict?
procedure
(dict-keysdict)->list?
dict:dict?
procedure
(dict-valuesdict)->list?
dict:dict?
procedure
(dict->listdict)->list?
dict:dict?
procedure
(in-dictdict)->sequence?
dict:dict?
procedure
(in-dict-keysdict)->sequence?
dict:dict?
procedure
(in-dict-valuesdict)->sequence?
dict:dict?
procedure
(in-dict-pairsdict)->sequence?
dict:dict?
value
prop:dict/contract:struct-type-property?
procedure
(dict-key-contractd)->contract?
d:dict?
procedure
(dict-value-contractd)->contract?
d:dict?
procedure
(dict-iter-contractd)->contract?
d:dict?
syntax
(define-custom-hash-typesname
optional-predicate
comparison-expr
optional-hash-functions)

     optional-predicate=
                      |#:key?predicate-expr
                      
optional-hash-functions=
                      |hash1-expr
                      |hash1-exprhash2-expr
procedure
(make-custom-hash-types eql?        
                      [hash1       
                       hash2       
                       #:key?key? 
                       #:namename 
                       #:forwho])->(any/c. -> .boolean?)
                                        (any/c. -> .boolean?)
                                        (any/c. -> .boolean?)
                                        (any/c. -> .boolean?)
                                        (->*[][dict?]dict?)
                                        (->*[][dict?]dict?)
                                        (->*[][dict?]dict?)
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
key?:(any/c. -> .boolean?)=(const#true)
name:symbol?='custom-hash
who:symbol?='make-custom-hash-types
procedure
(make-custom-hash eql?          
                [hash1         
                 hash2         
                 #:key?key?])->dict?
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
key?:(any/c. -> .boolean?)=((x)#true)
procedure
(make-weak-custom-hash eql?          
                     [hash1         
                      hash2         
                      #:key?key?])->dict?
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
key?:(any/c. -> .boolean?)=((x)#true)
procedure
(make-immutable-custom-hash eql?          
                          [hash1         
                           hash2         
                           #:key?key?])->dict?
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
key?:(any/c. -> .boolean?)=((x)#true)
procedure
(keyword-apply/dictproc               
                  kw-dict            
                  pos-arg...        
                  pos-args           
                  #:<kw>kw-arg...)->any
proc:procedure?
kw-dict:dict?
pos-arg:any/c
pos-args:(listofany/c)
kw-arg:any/c
procedure
(set-equal?x)->boolean?
x:any/c
procedure
(set-equal-always?x)->boolean?
x:any/c
procedure
(set-eqv?x)->boolean?
x:any/c
procedure
(set-eq?x)->boolean?
x:any/c
procedure
(set?x)->boolean?
x:any/c
procedure
(set-mutable?x)->boolean?
x:any/c
procedure
(set-weak?x)->boolean?
x:any/c
procedure
(setv...)->(and/cgeneric-set?set-equal?set?)
v:any/c
procedure
(setalwv...)->(and/cgeneric-set?set-equal-always?set?)
v:any/c
procedure
(seteqvv...)->(and/cgeneric-set?set-eqv?set?)
v:any/c
procedure
(seteqv...)->(and/cgeneric-set?set-eq?set?)
v:any/c
procedure
(mutable-setv...)
->(and/cgeneric-set?set-equal?set-mutable?)
v:any/c
procedure
(mutable-setalwv...)
->(and/cgeneric-set?set-equal-always?set-mutable?)
v:any/c
procedure
(mutable-seteqvv...)
->(and/cgeneric-set?set-eqv?set-mutable?)
v:any/c
procedure
(mutable-seteqv...)
->(and/cgeneric-set?set-eq?set-mutable?)
v:any/c
procedure
(weak-setv...)->(and/cgeneric-set?set-equal?set-weak?)
v:any/c
procedure
(weak-setalwv...)
->(and/cgeneric-set?set-equal-always?set-weak?)
v:any/c
procedure
(weak-seteqvv...)->(and/cgeneric-set?set-eqv?set-weak?)
v:any/c
procedure
(weak-seteqv...)->(and/cgeneric-set?set-eq?set-weak?)
v:any/c
procedure
(list->setlst)->(and/cgeneric-set?set-equal?set?)
lst:list?
procedure
(list->setalwlst)
->(and/cgeneric-set?set-equal-always?set?)
lst:list?
procedure
(list->seteqvlst)->(and/cgeneric-set?set-eqv?set?)
lst:list?
procedure
(list->seteqlst)->(and/cgeneric-set?set-eq?set?)
lst:list?
procedure
(list->mutable-setlst)
->(and/cgeneric-set?set-equal?set-mutable?)
lst:list?
procedure
(list->mutable-setalwlst)
->(and/cgeneric-set?set-equal-always?set-mutable?)
lst:list?
procedure
(list->mutable-seteqvlst)
->(and/cgeneric-set?set-eqv?set-mutable?)
lst:list?
procedure
(list->mutable-seteqlst)
->(and/cgeneric-set?set-eq?set-mutable?)
lst:list?
procedure
(list->weak-setlst)
->(and/cgeneric-set?set-equal?set-weak?)
lst:list?
procedure
(list->weak-setalwlst)
->(and/cgeneric-set?set-equal-always?set-weak?)
lst:list?
procedure
(list->weak-seteqvlst)
->(and/cgeneric-set?set-eqv?set-weak?)
lst:list?
procedure
(list->weak-seteqlst)->(and/cgeneric-set?set-eq?set-weak?)
lst:list?
syntax
(for/set(for-clause...)body...+)
syntax
(for/seteq(for-clause...)body...+)
syntax
(for/seteqv(for-clause...)body...+)
syntax
(for/setalw(for-clause...)body...+)
syntax
(for*/set(for-clause...)body...+)
syntax
(for*/seteq(for-clause...)body...+)
syntax
(for*/seteqv(for-clause...)body...+)
syntax
(for*/setalw(for-clause...)body...+)
syntax
(for/mutable-set(for-clause...)body...+)
syntax
(for/mutable-seteq(for-clause...)body...+)
syntax
(for/mutable-seteqv(for-clause...)body...+)
syntax
(for/mutable-setalw(for-clause...)body...+)
syntax
(for*/mutable-set(for-clause...)body...+)
syntax
(for*/mutable-seteq(for-clause...)body...+)
syntax
(for*/mutable-seteqv(for-clause...)body...+)
syntax
(for*/mutable-setalw(for-clause...)body...+)
syntax
(for/weak-set(for-clause...)body...+)
syntax
(for/weak-seteq(for-clause...)body...+)
syntax
(for/weak-seteqv(for-clause...)body...+)
syntax
(for/weak-setalw(for-clause...)body...+)
syntax
(for*/weak-set(for-clause...)body...+)
syntax
(for*/weak-seteq(for-clause...)body...+)
syntax
(for*/weak-seteqv(for-clause...)body...+)
syntax
(for*/weak-setalw(for-clause...)body...+)
procedure
(in-immutable-setst)->sequence?
st:set?
procedure
(in-mutable-setst)->sequence?
st:set-mutable?
procedure
(in-weak-setst)->sequence?
st:set-weak?
procedure
(generic-set?v)->boolean?
v:any/c
procedure
(set-implements?stsym...)->boolean?
st:generic-set?
sym:symbol?
procedure
(set-implements/csym...)->flat-contract?
sym:symbol?
procedure
(set/c elem/c                      
     [#:cmpcmp                   
      #:kindkind                 
      #:lazy?lazy?               
      #:equal-key/cequal-key/c])->contract?
elem/c:chaperone-contract?
cmp:(or/c'dont-care'equal'equal-always'eqv'eq)
   ='dont-care
kind:(or/c'dont-care'immutable'mutable'weak'mutable-or-weak)
    ='immutable
lazy?:any/c=(not(and(equal?kind'immutable)
                  (flat-contract?elem/c)))
equal-key/c:contract?=any/c
syntax
gen:set
procedure
(set-member?stv)->boolean?
st:generic-set?
v:any/c
procedure
(set-addstv)->generic-set?
st:generic-set?
v:any/c
procedure
(set-add!stv)->void?
st:generic-set?
v:any/c
procedure
(set-removestv)->generic-set?
st:generic-set?
v:any/c
procedure
(set-remove!stv)->void?
st:generic-set?
v:any/c
procedure
(set-empty?st)->boolean?
st:generic-set?
procedure
(set-countst)->exact-nonnegative-integer?
st:generic-set?
procedure
(set-firstst)->any/c
st:(and/cgeneric-set?(not/cset-empty?))
procedure
(set-restst)->generic-set?
st:(and/cgeneric-set?(not/cset-empty?))
procedure
(set->streamst)->stream?
st:generic-set?
procedure
(set-copyst)->generic-set?
st:generic-set?
procedure
(set-copy-clearst)->(and/cgeneric-set?set-empty?)
st:generic-set?
procedure
(set-clearst)->(and/cgeneric-set?set-empty?)
st:generic-set?
procedure
(set-clear!st)->void?
st:generic-set?
procedure
(set-unionst0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-union!st0st...)->void?
st0:generic-set?
st:generic-set?
procedure
(set-intersectst0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-intersect!st0st...)->void?
st0:generic-set?
st:generic-set?
procedure
(set-subtractst0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-subtract!st0st...)->void?
st0:generic-set?
st:generic-set?
procedure
(set-symmetric-differencest0st...)->generic-set?
st0:generic-set?
st:generic-set?
procedure
(set-symmetric-difference!st0st...)->void?
st0:generic-set?
st:generic-set?
procedure
(set=?stst2)->boolean?
st:generic-set?
st2:generic-set?
procedure
(subset?stst2)->boolean?
st:generic-set?
st2:generic-set?
procedure
(proper-subset?stst2)->boolean?
st:generic-set?
st2:generic-set?
procedure
(set->listst)->list?
st:generic-set?
procedure
(set-mapstproc)->(listofany/c)
st:generic-set?
proc:(any/c. -> .any/c)
procedure
(set-for-eachstproc)->void?
st:generic-set?
proc:(any/c. -> .any)
procedure
(in-setst)->sequence?
st:generic-set?
procedure
(impersonate-hash-set st             
                     inject-proc    
                     add-proc       
                     shrink-proc    
                     extract-proc   
                    [clear-proc     
                     equal-key-proc]
                     prop           
                     prop-val...   
                     ...)           
->(and/c(or/cset-mutable?set-weak?)impersonator?)
st:(or/cset-mutable?set-weak?)
inject-proc:(or/c#f(->set?any/cany/c))
add-proc:(or/c#f(->set?any/cany/c))
shrink-proc:(or/c#f(->set?any/cany/c))
extract-proc:(or/c#f(->set?any/cany/c))
clear-proc:(or/c#f(->set?any))=#f
equal-key-proc:(or/c#f(->set?any/cany/c))=#f
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-hash-set st             
                   inject-proc    
                   add-proc       
                   shrink-proc    
                   extract-proc   
                  [clear-proc     
                   equal-key-proc]
                   prop           
                   prop-val...   
                   ...)           
->(and/c(or/cset?set-mutable?set-weak?)chaperone?)
st:(or/cset?set-mutable?set-weak?)
inject-proc:(or/c#f(->set?any/cany/c))
add-proc:(or/c#f(->set?any/cany/c))
shrink-proc:(or/c#f(->set?any/cany/c))
extract-proc:(or/c#f(->set?any/cany/c))
clear-proc:(or/c#f(->set?any))=#f
equal-key-proc:(or/c#f(->set?any/cany/c))=#f
prop:impersonator-property?
prop-val:any/c
syntax
(define-custom-set-typesname
optional-predicate
comparison-expr
optional-hash-functions)

     optional-predicate=
                      |#:elem?predicate-expr
                      
optional-hash-functions=
                      |hash1-expr
                      |hash1-exprhash2-expr
procedure
(make-custom-set-types eql?         
                     [hash1        
                      hash2        
                      #:elem?elem?
                      #:namename  
                      #:forwho])  
->(any/c. -> .boolean?)
    (any/c. -> .boolean?)
    (any/c. -> .boolean?)
    (any/c. -> .boolean?)
    (->*[][stream?]generic-set?)
    (->*[][stream?]generic-set?)
    (->*[][stream?]generic-set?)
eql?:(or/c(any/cany/c. -> .any/c)
         (any/cany/c(any/cany/c. -> .any/c). -> .any/c))
hash1:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
hash2:(or/c(any/c. -> .exact-integer?)
          (any/c(any/c. -> .exact-integer?). -> .exact-integer?))
     =(const1)
elem?:(any/c. -> .boolean?)=(const#true)
name:symbol?='custom-set
who:symbol?='make-custom-set-types
procedure
(procedure?v)->boolean?
v:any/c
procedure
(applyprocv...lst#:<kw>kw-arg...)->any
proc:procedure?
v:any/c
lst:list?
kw-arg:any/c
procedure
(composeproc...)->procedure?
proc:procedure?
procedure
(compose1proc...)->procedure?
proc:procedure?
procedure
(procedure-renameprocname[realm])->procedure?
proc:procedure?
name:symbol?
realm:symbol?='racket
procedure
(procedure-realmproc)->symbol?
proc:procedure?
procedure
(procedure->methodproc)->procedure?
proc:procedure?
procedure
(procedure-closure-contents-eq?proc1  
                              proc2)->boolean?
proc1:procedure?
proc2:procedure?
procedure
(keyword-applyproc               
             kw-lst             
             kw-val-lst         
             v...              
             lst                
             #:<kw>kw-arg...)->any
proc:procedure?
kw-lst:(listofkeyword?)
kw-val-lst:list?
v:any/c
lst:list?
kw-arg:any/c
procedure
(procedure-arityproc)->normalized-arity?
proc:procedure?
procedure
(procedure-arity?v)->boolean?
v:any/c
procedure
(procedure-arity-maskproc)->exact-integer?
proc:procedure?
procedure
(procedure-arity-includes?prock[kws-ok?])->boolean?
proc:procedure?
k:exact-nonnegative-integer?
kws-ok?:any/c=#f
procedure
(procedure-reduce-arity proc    
                       arity   
                      [name    
                       realm])->procedure?
proc:procedure?
arity:procedure-arity?
name:(or/csymbol?#f)=#f
realm:symbol?='racket
procedure
(procedure-reduce-arity-mask proc    
                            mask    
                           [name    
                            realm])->procedure?
proc:procedure?
mask:exact-integer?
name:(or/csymbol?#f)=#f
realm:symbol?='racket
procedure
(procedure-keywordsproc)->(listofkeyword?)
                             (or/c(listofkeyword?)#f)
proc:procedure?
procedure
(procedure-result-arityproc)->(or/c#fprocedure-arity?)
proc:procedure?
procedure
(make-keyword-procedureproc[plain-proc])->procedure?
proc:(((listofkeyword?)list?)()#:restlist?. ->* .any)
plain-proc:procedure?
          =(lambdaargs(applyprocnullnullargs))
procedure
(procedure-reduce-keyword-arity proc         
                               arity        
                               required-kws 
                               allowed-kws  
                              [name         
                               realm])     ->procedure?
proc:procedure?
arity:procedure-arity?
required-kws:(listofkeyword?)
allowed-kws:(or/c(listofkeyword?)
                #f)
name:(or/csymbol?#f)=#f
realm:symbol?='racket
procedure
(procedure-reduce-keyword-arity-mask proc         
                                    mask         
                                    required-kws 
                                    allowed-kws  
                                   [name         
                                    realm])     ->procedure?
proc:procedure?
mask:exact-integer?
required-kws:(listofkeyword?)
allowed-kws:(or/c(listofkeyword?)
                #f)
name:(or/csymbol?#f)=#f
realm:symbol?='racket
struct
(structarity-at-least(value)
#:extra-constructor-namemake-arity-at-least)
value:exact-nonnegative-integer?
value
prop:procedure:struct-type-property?
procedure
(procedure-struct-type?type)->boolean?
type:struct-type?
procedure
(procedure-extract-targetproc)->(or/c#fprocedure?)
proc:procedure?
value
prop:arity-string:struct-type-property?
value
prop:checked-procedure:struct-type-property?
procedure
(checked-procedure-check-and-extracttype 
                                   v    
                                   proc 
                                   v1   
                                   v2) ->any/c
type:struct-type?
v:any/c
proc:(any/cany/cany/c. -> .any/c)
v1:any/c
v2:any/c
procedure
(procedure-specializeproc)->procedure?
proc:procedure?
procedure
(primitive?v)->boolean?
v:any/c
procedure
(primitive-closure?v)->boolean
v:any/c
procedure
(primitive-result-arityprim)->procedure-arity?
prim:primitive?
procedure
(identityv)->any/c
v:any/c
procedure
(constv)->procedure?
v:any/c
procedure
(const*v...)->procedure?
v:any/c
syntax
(thunkbody...+)
syntax
(thunk*body...+)
procedure
(negateproc)->procedure?
proc:procedure?
procedure
((conjoinf...)x...)->any
f:procedure?
x:any/c
procedure
((disjoinf...)x...)->any
f:procedure?
x:any/c
procedure
(curryproc)->procedure?
proc:procedure?
(curryprocv...+)->any
proc:procedure?
v:any/c
procedure
(curryrproc)->procedure?
proc:procedure?
(curryrprocv...+)->any
proc:procedure?
v:any/c
procedure
(normalized-arity?arity)->boolean?
arity:any/c
procedure
(normalize-arityarity)
->(and/cnormalized-arity?(lambda(x)(arity=?xarity)))
arity:procedure-arity?
procedure
(arity=?ab)->boolean?
a:procedure-arity?
b:procedure-arity?
procedure
(arity-includes?ab)->boolean?
a:procedure-arity?
b:procedure-arity?
procedure
(void?v)->boolean?
v:any/c
procedure
(voidv...)->void?
v:any/c
value
undefined:any/c
syntax
(structidmaybe-super(field...)
struct-option...)

  maybe-super=
            |super-id
            
        field=field-id
            |[field-idfield-option...]
            
struct-option=#:mutable
            |#:supersuper-expr
            |#:inspectorinspector-expr
            |#:auto-valueauto-expr
            |#:guardguard-expr
            |#:propertyprop-exprval-expr
            |#:transparent
            |#:prefab
            |#:sealed
            |#:authentic
            |#:namename-id
            |#:extra-namename-id
            |#:constructor-nameconstructor-id
            |#:extra-constructor-nameconstructor-id
            |#:reflection-namesymbol-expr
            |#:methodsgen:name-idmethod-defs
            |#:omit-define-syntaxes
            |#:omit-define-values
            
 field-option=#:mutable
            |#:auto
            
  method-defs=(definition...)
syntax
(struct-field-indexfield-id)
syntax
(define-structid-maybe-super(field...)
struct-option...)

id-maybe-super=id
             |(idsuper-id)
syntax
(struct/derived(id. rest-form)
id(field...)struct-option...)
(struct/derived(id. rest-form)
idsuper-id(field...)struct-option...)
syntax
(define-struct/derived(id. rest-form)
id-maybe-super(field...)struct-option...)
procedure
(make-struct-type name              
                 super-type        
                 init-field-cnt    
                 auto-field-cnt    
                [auto-v            
                 props             
                 inspector         
                 proc-spec         
                 immutables        
                 guard             
                 constructor-name])
->struct-type?
    struct-constructor-procedure?
    struct-predicate-procedure?
    struct-accessor-procedure?
    struct-mutator-procedure?
name:symbol?
super-type:(or/cstruct-type?#f)
init-field-cnt:exact-nonnegative-integer?
auto-field-cnt:exact-nonnegative-integer?
auto-v:any/c=#f
props:(listof(cons/cstruct-type-property?=null
          any/c))
inspector:(or/cinspector?#f'prefab)=(current-inspector)
proc-spec:(or/cprocedure?                =#f
              exact-nonnegative-integer?
              #f)
immutables:(listofexact-nonnegative-integer?)=null
guard:(or/cprocedure?#f)=#f
constructor-name:(or/csymbol?#f)=#f
procedure
(make-struct-field-accessor accessor-proc    
                           field-pos        
                          [field/proc-name  
                           arg-contract-str 
                           realm])         ->procedure?
accessor-proc:struct-accessor-procedure?
field-pos:exact-nonnegative-integer?
field/proc-name:(or/csymbol?#f)
               =(symbol->string(format"field~a"field-pos))
arg-contract-str:(or/cstring?symbol?#f)=#f
realm:symbol?='racket
procedure
(make-struct-field-mutator mutator-proc     
                          field-pos        
                         [field/proc-name  
                          arg-contract-str 
                          realm])         ->procedure?
mutator-proc:struct-mutator-procedure?
field-pos:exact-nonnegative-integer?
field/proc-name:(or/csymbol?#f)
               =(symbol->string(format"field~a"field-pos))
arg-contract-str:(or/cstring?symbol?#f)=#f
realm:symbol?='racket
value
prop:sealed:struct-type-property?
procedure
(make-struct-type-property name            
                         [guard           
                          supers          
                          can-impersonate?
                          accessor-name   
                          contract-str    
                          realm])         
->struct-type-property?
    (any/c. -> .boolean?)
    procedure?
name:symbol?
guard:(or/cprocedure?#f'can-impersonate)=#f
supers:(listof(cons/cstruct-type-property? =null
           (any/c. -> .any/c)))
can-impersonate?:any/c=#f
accessor-name:(or/csymbol?#f)=#f
contract-str:(or/cstring?symbol?#f)=#f
realm:symbol?='racket
procedure
(struct-type-property?v)->boolean?
v:any/c
procedure
(struct-type-property-accessor-procedure?v)->boolean?
v:any/c
procedure
(struct-type-property-predicate-procedure? v      
                                         [prop])->boolean?
v:any/c
prop:(or/cstruct-type-property?#f)=#f
syntax
(define-genericsid
generics-opt...
[method-id. kw-formals*]...
generics-opt...)

generics-opt=#:defaults([default-pred?default-impl...]...)
           |#:fast-defaults([fast-pred?fast-impl...]...)
           |#:fallbacks[fallback-impl...]
           |#:defined-predicatedefined-pred-id
           |#:defined-tabledefined-table-id
           |#:derive-propertyprop-exprprop-value-expr
           |#:requires[required-method-id...]
           
 kw-formals*=(arg*...)
           |(arg*...+. rest-id)
           |rest-id
           
        arg*=arg-id
           |[arg-id]
           |keywordarg-id
           |keyword[arg-id]
procedure
(raise-support-errornamev)->none/c
name:symbol?
v:any/c
struct
(structexn:fail:supportexn:fail()
#:transparent)
syntax
(define/genericlocal-idmethod-id)
syntax
(generic-instance/cgen-id[method-idmethod-ctc]...)

method-ctc:contract?
syntax
(impersonate-genericsgen-idval-expr
[method-idmethod-proc-expr]...
maybe-properties)

maybe-properties=
               |#:propertiesprops-expr

method-proc-expr:(any/c. -> .any/c)
props-expr:(list/cimpersonator-property?any/c......)
syntax
(chaperone-genericsgen-idval-expr
[method-idmethod-proc-expr]...
maybe-properties)
syntax
(redirect-genericsmodegen-idval-expr
[method-idmethod-proc-expr]...
maybe-properties)
syntax
(make-struct-type-property/generic
name-expr
maybe-guard-expr
maybe-supers-expr
maybe-can-impersonate?-expr
property-option
...)

           maybe-guard-expr=
                          |guard-expr
                          
          maybe-supers-expr=
                          |supers-expr
                          
maybe-can-impersonate?-expr=
                          |can-impersonate?-expr
                          
            property-option=#:propertyprop-exprval-expr
                          |#:methodsgen:name-idmethod-defs
                          
                method-defs=(definition...)

name-expr:symbol?
guard-expr:(or/cprocedure?#f'can-impersonate)
supers-expr:(listof(cons/cstruct-type-property?(->any/cany/c)))
can-impersonate?-expr:any/c
prop-expr:struct-type-property?
val-expr:any/c
syntax
(make-generic-struct-type-property
gen:name-id
method-def
...)
syntax
(struct-copyidstruct-exprfld-id...)

fld-id=[field-idexpr]
     |[field-id#:parentparent-idexpr]
procedure
(struct->vectorv[opaque-v])->vector?
v:any/c
opaque-v:any/c='...
procedure
(struct?v)->any
v:any/c
procedure
(struct-type?v)->boolean?
v:any/c
procedure
(struct-constructor-procedure?v)->boolean?
v:any/c
procedure
(struct-predicate-procedure?v)->boolean?
v:any/c
procedure
(struct-accessor-procedure?v)->boolean?
v:any/c
procedure
(struct-mutator-procedure?v)->boolean?
v:any/c
procedure
(prefab-struct-keyv)->(or/c#fsymbol?list?)
v:any/c
procedure
(make-prefab-structkeyv...)->struct?
key:prefab-key?
v:any/c
procedure
(prefab-struct-type-key+field-counttype)
->(or/c#f(cons/cprefab-key?(integer-in032768)))
type:struct-type?
procedure
(prefab-key->struct-typekeyfield-count)->struct-type?
key:prefab-key?
field-count:(integer-in032768)
procedure
(prefab-key?v)->boolean?
v:any/c
procedure
(make-constructor-style-printerget-constructor
                              get-contents)  
->(->any/coutput-port?(or/c#t#f01)void?)
get-constructor:(->any/c(or/csymbol?string?))
get-contents:(->any/csequence?)
procedure
(struct->listv[#:on-opaqueon-opaque])->(or/clist?#f)
v:any/c
on-opaque:(or/c'error'return-false'skip)='error
procedure
(struct-info?v)->boolean?
v:any/c
procedure
(checked-struct-info?v)->boolean?
v:any/c
procedure
(make-struct-infothunk)->struct-info?
thunk:(->(and/cstruct-info?list?))
procedure
(extract-struct-infov)->(and/cstruct-info?list?)
v:struct-info?
value
struct:struct-info:struct-type?
value
prop:struct-info:struct-type-property?
value
prop:struct-auto-info:struct-type-property?
procedure
(struct-auto-info?v)->boolean?
v:any/c
procedure
(struct-auto-info-listssai)
->(list/c(listofidentifier?)(listofidentifier?))
sai:struct-auto-info?
value
prop:struct-field-info:struct-type-property?
procedure
(struct-field-info?v)->boolean?
v:any/c
procedure
(struct-field-info-listsfi)->(listofsymbol?)
sfi:struct-field-info?
syntax
(interface(super-interface-expr...)name-clause...)

name-clause=id
          |(idcontract-expr)
syntax
(interface*(super-interface-expr...)
([property-exprval-expr]...)
name-clause...)

name-clause=id
          |(idcontract-expr)
value
object%:class?
syntax
(class*superclass-expr(interface-expr...)
class-clause
...)

     class-clause=(inspectinspector-expr)
                |(initinit-decl...)
                |(init-fieldinit-decl...)
                |(fieldfield-decl...)
                |(inherit-fieldmaybe-renamed...)
                |(init-restid)
                |(init-rest)
                |(publicmaybe-renamed...)
                |(pubmentmaybe-renamed...)
                |(public-finalmaybe-renamed...)
                |(overridemaybe-renamed...)
                |(overmentmaybe-renamed...)
                |(override-finalmaybe-renamed...)
                |(augmentmaybe-renamed...)
                |(augridemaybe-renamed...)
                |(augment-finalmaybe-renamed...)
                |(privateid...)
                |(abstractid...)
                |(inheritmaybe-renamed...)
                |(inherit/supermaybe-renamed...)
                |(inherit/innermaybe-renamed...)
                |(rename-superrenamed...)
                |(rename-innerrenamed...)
                |method-definition
                |definition
                |expr
                |(beginclass-clause...)
                
        init-decl=id
                |(renamed)
                |(maybe-renameddefault-value-expr)
                
       field-decl=(maybe-renameddefault-value-expr)
                
    maybe-renamed=id
                |renamed
                
          renamed=(internal-idexternal-id)
                
method-definition=(define-values(id)method-procedure)
                
 method-procedure=(lambdakw-formalsexpr...+)
                |(case-lambda(formalsexpr...+)...)
                |(#%plain-lambdaformalsexpr...+)
                |(let-values([(id)method-procedure]...)
                    method-procedure)
                |(letrec-values([(id)method-procedure]...)
                    method-procedure)
                |(let-values([(id)method-procedure]...+)
                    id)
                |(letrec-values([(id)method-procedure]...+)
                    id)
                |(chaperone-proceduremethod-procedurewrapper-proc
                    other-arg-expr...)
syntax
(classsuperclass-exprclass-clause...)
syntax
this
syntax
this%
syntax
(inspectinspector-expr)
syntax
(initinit-decl...)
syntax
(init-fieldinit-decl...)
syntax
(fieldfield-decl...)
syntax
(inherit-fieldmaybe-renamed...)
syntax
(init-restid)
(init-rest)
syntax
(publicmaybe-renamed...)
syntax
(pubmentmaybe-renamed...)
syntax
(public-finalmaybe-renamed...)
syntax
(overridemaybe-renamed...)
syntax
(overmentmaybe-renamed...)
syntax
(override-finalmaybe-renamed...)
syntax
(augmentmaybe-renamed...)
syntax
(augridemaybe-renamed...)
syntax
(augment-finalmaybe-renamed...)
syntax
(privateid...)
syntax
(abstractid...)
syntax
(inheritmaybe-renamed...)
syntax
(inherit/supermaybe-renamed...)
syntax
(inherit/innermaybe-renamed...)
syntax
(rename-superrenamed...)
syntax
(rename-innerrenamed...)
syntax
(public*(idexpr)...)
syntax
(pubment*(idexpr)...)
syntax
(public-final*(idexpr)...)
syntax
(override*(idexpr)...)
syntax
(overment*(idexpr)...)
syntax
(override-final*(idexpr)...)
syntax
(augment*(idexpr)...)
syntax
(augride*(idexpr)...)
syntax
(augment-final*(idexpr)...)
syntax
(private*(idexpr)...)
syntax
(define/publicidexpr)
(define/public(id. formals)body...+)
syntax
(define/pubmentidexpr)
(define/pubment(id. formals)body...+)
syntax
(define/public-finalidexpr)
(define/public-final(id. formals)body...+)
syntax
(define/overrideidexpr)
(define/override(id. formals)body...+)
syntax
(define/overmentidexpr)
(define/overment(id. formals)body...+)
syntax
(define/override-finalidexpr)
(define/override-final(id. formals)body...+)
syntax
(define/augmentidexpr)
(define/augment(id. formals)body...+)
syntax
(define/augrideidexpr)
(define/augride(id. formals)body...+)
syntax
(define/augment-finalidexpr)
(define/augment-final(id. formals)body...+)
syntax
(define/privateidexpr)
(define/private(id. formals)body...+)
syntax
(class/derivedoriginal-datum
(name-idsuper-expr(interface-expr...)deserialize-id-expr)
class-clause
...)
syntax
(superidarg...)
(superidarg.... arg-list-expr)
syntax
(innerdefault-expridarg...)
(innerdefault-expridarg.... arg-list-expr)
syntax
(define-local-member-nameid...)
syntax
(define-member-nameidkey-expr)
syntax
(member-name-keyidentifier)
procedure
(generate-member-key)->member-name-key?
procedure
(member-name-key?v)->boolean?
v:any/c
procedure
(member-name-key=?a-keyb-key)->boolean?
a-key:member-name-key?
b-key:member-name-key?
procedure
(member-name-key-hash-codea-key)->integer?
a-key:member-name-key?
procedure
(make-objectclassinit-v...)->object?
class:class?
init-v:any/c
syntax
(newclass-expr(idby-name-expr)...)
syntax
(instantiateclass-expr(by-pos-expr...)(idby-name-expr)...)
syntax
super-make-object
syntax
(super-instantiate(by-pos-expr...)(idby-expr...)...)
syntax
(super-new(idby-name-expr...)...)

(method-idarg.... arg-list-expr)
syntax
(sendobj-exprmethod-idarg...)
(sendobj-exprmethod-idarg.... arg-list-expr)
syntax
(send/applyobj-exprmethod-idarg...arg-list-expr)
syntax
(send/keyword-applyobj-exprmethod-id
keyword-list-exprvalue-list-expr
arg...arg-list-expr)
procedure
(dynamic-sendobj                
            method-name        
            v...              
            #:<kw>kw-arg...)->any
obj:object?
method-name:symbol?
v:any/c
kw-arg:any/c
syntax
(send*obj-exprmsg...+)

msg=(method-idarg...)
  |(method-idarg.... arg-list-expr)
syntax
(send+obj-exprmsg...)

msg=(method-idarg...)
  |(method-idarg.... arg-list-expr)
syntax
(with-method([id(obj-exprmethod-id)]...)
body...+)
syntax
(get-fieldidobj-expr)
procedure
(dynamic-get-fieldfield-nameobj)->any/c
field-name:symbol?
obj:object?
syntax
(set-field!idobj-exprexpr)
procedure
(dynamic-set-field!field-nameobjv)->void?
field-name:symbol?
obj:object?
v:any/c
syntax
(field-bound?idobj-expr)
syntax
(class-field-accessorclass-exprfield-id)
syntax
(class-field-mutatorclass-exprfield-id)
syntax
(genericclass-or-interface-exprid)
syntax
(send-genericobj-exprgeneric-exprarg...)
(send-genericobj-exprgeneric-exprarg.... arg-list-expr)
procedure
(make-generictypemethod-name)->generic?
type:(or/cclass?interface?)
method-name:symbol?
syntax
(mixin(interface-expr...)(interface-expr...)
class-clause...)
syntax
(traittrait-clause...)

trait-clause=(publicmaybe-renamed...)
           |(pubmentmaybe-renamed...)
           |(public-finalmaybe-renamed...)
           |(overridemaybe-renamed...)
           |(overmentmaybe-renamed...)
           |(override-finalmaybe-renamed...)
           |(augmentmaybe-renamed...)
           |(augridemaybe-renamed...)
           |(augment-finalmaybe-renamed...)
           |(inheritmaybe-renamed...)
           |(inherit/supermaybe-renamed...)
           |(inherit/innermaybe-renamed...)
           |method-definition
           |(fieldfield-declaration...)
           |(inherit-fieldmaybe-renamed...)
procedure
(trait?v)->boolean?
v:any/c
procedure
(trait->mixintr)->(class?. -> .class?)
tr:trait?
procedure
(trait-sumtr...+)->trait?
tr:trait?
syntax
(trait-excludetrait-exprid)
syntax
(trait-exclude-fieldtrait-exprid)
syntax
(trait-aliastrait-expridnew-id)
syntax
(trait-renametrait-expridnew-id)
syntax
(trait-rename-fieldtrait-expridnew-id)
syntax
(class/cmaybe-opaquemember-spec...)

maybe-opaque=
           |#:opaque
           |#:opaque#:ignore-local-member-names
           
 member-spec=method-spec
           |(fieldfield-spec...)
           |(initfield-spec...)
           |(init-fieldfield-spec...)
           |(inheritmethod-spec...)
           |(inherit-fieldfield-spec...)
           |(supermethod-spec...)
           |(innermethod-spec...)
           |(overridemethod-spec...)
           |(augmentmethod-spec...)
           |(augridemethod-spec...)
           |(absentabsent-spec...)
           
 method-spec=method-id
           |(method-idmethod-contract-expr)
           
  field-spec=field-id
           |(field-idcontract-expr)
           
 absent-spec=method-id
           |(fieldfield-id...)
syntax
(absentabsent-spec...)
syntax
(->mdom...range)
syntax
(->*m(mandatory-dom...)(optional-dom...)restrange)
syntax
(case->m(->dom...restrange)...)
syntax
(->dm(mandatory-dependent-dom...)
(optional-dependent-dom...)
dependent-rest
pre-cond
dep-range)
syntax
(object/cmember-spec...)

member-spec=method-spec
          |(fieldfield-spec...)
          
method-spec=method-id
          |(method-idmethod-contract)
          
 field-spec=field-id
          |(field-idcontract-expr)
procedure
(instanceof/cclass-contract)->contract?
class-contract:contract?
procedure
(dynamic-object/cmethod-names     
                method-contracts 
                field-names      
                field-contracts)->contract?
method-names:(listofsymbol?)
method-contracts:(listofcontract?)
field-names:(listofsymbol?)
field-contracts:(listofcontract?)
syntax
(object-contractmember-spec...)

            member-spec=(method-idmethod-contract)
                      |(fieldfield-idcontract-expr)
                      
        method-contract=(->dom...range)
                      |(->*(mandatory-dom...)
                          (optional-dom...)
                          rest
                          range)
                      |(->d(mandatory-dependent-dom...)
                          (optional-dependent-dom...)
                          dependent-rest
                          pre-cond
                          dep-range)
                      
                    dom=dom-expr
                      |keyworddom-expr
                      
                  range=range-expr
                      |(valuesrange-expr...)
                      |any
                      
          mandatory-dom=dom-expr
                      |keyworddom-expr
                      
           optional-dom=dom-expr
                      |keyworddom-expr
                      
                   rest=
                      |#:restrest-expr
                      
mandatory-dependent-dom=[iddom-expr]
                      |keyword[iddom-expr]
                      
 optional-dependent-dom=[iddom-expr]
                      |keyword[iddom-expr]
                      
         dependent-rest=
                      |#:restidrest-expr
                      
               pre-cond=
                      |#:pre-condboolean-expr
                      
              dep-range=any
                      |[idrange-expr]post-cond
                      |(values[idrange-expr]...)post-cond
                      
              post-cond=
                      |#:post-condboolean-expr
value
mixin-contract:contract?
procedure
(make-mixin-contracttype...)->contract?
type:(or/cclass?interface?)
procedure
(is-a?/ctype)->flat-contract?
type:(or/cclass?interface?)
procedure
(implementation?/cinterface)->flat-contract?
interface:interface?
procedure
(subclass?/cclass)->flat-contract?
class:class?
interface
equal<%>:interface?
syntax
(define-serializable-class*class-idsuperclass-expr
(interface-expr...)
class-clause...)
syntax
(define-serializable-classclass-idsuperclass-expr
class-clause...)
interface
externalizable<%>:interface?
value
printable<%>:interface?
value
writable<%>:interface?
procedure
(object?v)->boolean?
v:any/c
procedure
(class?v)->boolean?
v:any/c
procedure
(interface?v)->boolean?
v:any/c
procedure
(generic?v)->boolean?
v:any/c
procedure
(object=?ab)->boolean?
a:object?
b:object?
procedure
(object-or-false=?ab)->boolean?
a:(or/cobject?#f)
b:(or/cobject?#f)
procedure
(object=-hash-codeo)->fixnum?
o:object?
procedure
(object->vectorobject[opaque-v])->vector?
object:object?
opaque-v:any/c=#f
procedure
(class->interfaceclass)->interface?
class:class?
procedure
(object-interfaceobject)->interface?
object:object?
procedure
(is-a?vtype)->boolean?
v:any/c
type:(or/cinterface?class?)
procedure
(subclass?vcls)->boolean?
v:any/c
cls:class?
procedure
(implementation?vintf)->boolean?
v:any/c
intf:interface?
procedure
(interface-extension?vintf)->boolean?
v:any/c
intf:interface?
procedure
(method-in-interface?symintf)->boolean?
sym:symbol?
intf:interface?
procedure
(interface->method-namesintf)->(listofsymbol?)
intf:interface?
procedure
(object-method-arity-includes?object 
                             sym    
                             cnt)  ->boolean?
object:object?
sym:symbol?
cnt:exact-nonnegative-integer?
procedure
(field-namesobject)->(listofsymbol?)
object:object?
procedure
(object-infoobject)->(or/cclass?#f)boolean?
object:object?
procedure
(class-infoclass)
->symbol?
    exact-nonnegative-integer?
    (listofsymbol?)
    (any/cexact-nonnegative-integer?. -> .any/c)
    (any/cexact-nonnegative-integer?any/c. -> .any/c)
    (or/cclass?#f)
    boolean?
class:class?
struct
(structexn:fail:objectexn:fail()
#:extra-constructor-namemake-exn:fail:object)
procedure
(class-sealclass            
          key              
          unsealed-inits   
          unsealed-fields  
          unsealed-methods 
          inst-proc        
          member-proc)    ->class?
class:class?
key:symbol?
unsealed-inits:(listofsymbol?)
unsealed-fields:(listofsymbol?)
unsealed-methods:(listofsymbol?)
inst-proc:(->class?any)
member-proc:(->class?(listofsymbol?)any)
procedure
(class-unsealclasskeywrong-key-proc)->class?
class:class?
key:symbol?
wrong-key-proc:(->class?any)
syntax
(surrogateuse-wrapper-procmethod-spec...)

use-wrapper-proc=#:use-wrapper-proc
               |
               
     method-spec=(augmentdefault-exprmethod-idarg-spec...)
               |(overridemethod-idarg-spec...)
               
        arg-spec=(id...)
               |id
syntax
(unit
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
unit-body-expr-or-defn
...)

  tagged-sig-spec=sig-spec
                |(tagidsig-spec)
                
         sig-spec=sig-id
                |(prefixidsig-spec)
                |(renamesig-spec(idid)...)
                |(onlysig-specid...)
                |(exceptsig-specid...)
                
init-depends-decl=
                |(init-dependtagged-sig-id...)
                
    tagged-sig-id=sig-id
                |(tagidsig-id)
syntax
(define-signaturesig-idextension-decl
(sig-elem...))

extension-decl=
             |extendssig-id
             
      sig-elem=id
             |(define-syntaxes(id...)expr)
             |(define-values(id...)expr)
             |(define-values-for-export(id...)expr)
             |(contracted[idcontract]...)
             |(opensig-spec)
             |(structid(field...)struct-option...)
             |(sig-form-id. datum)
             
         field=id
             |[id#:mutable]
             
 struct-option=#:mutable
             |#:constructor-nameconstructor-id
             |#:extra-constructor-nameconstructor-id
             |#:omit-constructor
             |#:omit-define-syntaxes
             |#:omit-define-values
syntax
(opensig-spec)
syntax
(define-values-for-export(id...)expr)
syntax
(contracted[idcontract]...)
syntax
(onlysig-specid...)
syntax
(exceptsig-specid...)
syntax
(renamesig-spec(idid)...)
syntax
(prefixidsig-spec)
syntax
(importtagged-sig-spec...)
syntax
(exporttagged-sig-spec...)
syntax
(linklinkage-decl...)
syntax
(tagidsig-spec)
(tagidsig-id)
syntax
(init-dependtagged-sig-id...)
syntax
extends
syntax
(invoke-unitunit-expr)
(invoke-unitunit-expr(importtagged-sig-spec...))
syntax
(define-values/invoke-unitunit-expr
(importtagged-sig-spec...)
(exporttagged-sig-spec...))
syntax
(compound-unit
(importlink-binding...)
(exporttagged-link-id...)
(linklinkage-decl...))

  link-binding=(link-id:tagged-sig-id)
             
tagged-link-id=(tagidlink-id)
             |link-id
             
  linkage-decl=((link-binding...)unit-exprtagged-link-id...)
syntax
(define-unitunit-id
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
unit-body-expr-or-defn
...)
syntax
(compound-unit/infer
(importtagged-infer-link-import...)
(exporttagged-infer-link-export...)
(linkinfer-linkage-decl...))

tagged-infer-link-import=tagged-sig-id
                       |(link-id:tagged-sig-id)
                       
tagged-infer-link-export=(tagidinfer-link-export)
                       |infer-link-export
                       
       infer-link-export=link-id
                       |sig-id
                       
      infer-linkage-decl=((link-binding...)unit-id
                           tagged-link-id...)
                       |unit-id
syntax
(define-compound-unitid
(importlink-binding...)
(exporttagged-link-id...)
(linklinkage-decl...))
syntax
(define-compound-unit/inferid
(importlink-binding...)
(exporttagged-infer-link-export...)
(linkinfer-linkage-decl...))
syntax
(define-unit-bindingunit-id
unit-expr
(importtagged-sig-spec...+)
(exporttagged-sig-spec...+)
init-depends-decl)
syntax
(invoke-unit/inferunit-spec)

unit-spec=unit-id
        |(linklink-unit-id...)
syntax
(define-values/invoke-unit/infermaybe-exportsunit-spec)

maybe-exports=
            |(exporttagged-sig-spec...)
            
    unit-spec=unit-id
            |(linklink-unit-id...)
syntax
(unit-from-contexttagged-sig-spec)
syntax
(define-unit-from-contextidtagged-sig-spec)
syntax
(unit/new-import-export
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
((tagged-sig-spec...)unit-exprtagged-sig-spec))
syntax
(define-unit/new-import-exportunit-id
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
((tagged-sig-spec...)unit-exprtagged-sig-spec))
syntax
(unit/s
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
unit-id)
syntax
(define-unit/sname-id
(importtagged-sig-spec...)
(exporttagged-sig-spec...)
init-depends-decl
unit-id)
syntax
(define-signature-formsig-form-idexpr)
(define-signature-form(sig-form-idid)body...+)
(define-signature-form(sig-form-ididintro-id)body...+)
syntax
(struct/ctcid([fieldcontract-expr]...)struct-option...)

        field=id
            |[id#:mutable]
            
struct-option=#:mutable
            |#:omit-constructor
            |#:omit-define-syntaxes
            |#:omit-define-values
procedure
(unit?v)->boolean?
v:any/c
syntax
(provide-signature-elementssig-spec...)
syntax
(unit/c
(importsig-block...)
(exportsig-block...)
init-depends-decl
optional-body-ctc)

        sig-block=(tagged-sig-id[idcontract]...)
                |tagged-sig-id
                
init-depends-decl=
                |(init-dependtagged-sig-id...)
                
optional-body-ctc=
                |contract
                |(valuescontract...)
syntax
(define-unit/contractunit-id
(importsig-spec-block...)
(exportsig-spec-block...)
init-depends-decl
optional-body-ctc
unit-body-expr-or-defn
...)

   sig-spec-block=(tagged-sig-spec[idcontract]...)
                |tagged-sig-spec
                
optional-body-ctc=
                |#:invoke/contractcontract
                |#:invoke/contract(valuescontract...)
procedure
(unit-static-signaturesunit-identifier
                      err-syntax)    
->(list/c(cons/c(or/csymbol?#f)
    identifier?))
    (list/c(cons/c(or/csymbol?#f)
    identifier?))
unit-identifier:identifier?
err-syntax:syntax?
procedure
(signature-memberssig-identifier 
                 err-syntax)   ->(or/cidentifier?#f)
                                     (listofidentifier?)
                                     (listofidentifier?)
                                     (listofidentifier?)
sig-identifier:identifier?
err-syntax:syntax?
procedure
(unit-static-init-dependenciesunit-identifier
                             err-syntax)    
->(list/c(cons/c(or/csymbol?#f)
    identifier?))
unit-identifier:identifier?
err-syntax:syntax?
procedure
(flat-contract-with-explanation get-explanation
                              [#:namename])  
->flat-contract?
get-explanation:(->any/c(or/cboolean?(->blame?any)))
name:any/c=(object-nameget-explanation)
procedure
(flat-named-contract name          
                    flat-contract 
                   [generator])  ->flat-contract?
name:any/c
flat-contract:flat-contract?
generator:(or/c#f(->exact-nonnegative-integer?(->any/c)))
         =#f
value
any/c:flat-contract?
value
none/c:flat-contract?
procedure
(or/ccontract...)->contract?
contract:contract?
procedure
(first-or/ccontract...)->contract?
contract:contract?
procedure
(and/ccontract...)->contract?
contract:contract?
procedure
(not/cflat-contract)->flat-contract?
flat-contract:flat-contract?
procedure
(=/cz)->flat-contract?
z:real?
procedure
(</cn)->flat-contract?
n:real?
procedure
(>/cn)->flat-contract?
n:real?
procedure
(<=/cn)->flat-contract?
n:real?
procedure
(>=/cn)->flat-contract?
n:real?
procedure
(between/cnm)->flat-contract?
n:real?
m:real?
procedure
(real-innm)->flat-contract?
n:real?
m:real?
procedure
(integer-injk)->flat-contract?
j:(or/cexact-integer?#f)
k:(or/cexact-integer?#f)
procedure
(char-inab)->flat-contract?
a:char?
b:char?
value
natural-number/c:flat-contract?
procedure
(string-len/clen)->flat-contract?
len:real?
value
false/c:flat-contract?
value
printable/c:flat-contract?
procedure
(one-of/cv...+)->flat-contract?
v:any/c
procedure
(symbolssym...+)->flat-contract?
sym:symbol?
procedure
(vectorof c                     
        [#:immutableimmutable 
         #:flat?flat?         
         #:eagereager])      ->contract?
c:contract?
immutable:(or/c#t#f'dont-care)='dont-care
flat?:boolean?=#f
eager:(or/c#t#fexact-nonnegative-integer?)=#t
procedure
(vector-immutableofc)->contract?
c:contract?
procedure
(vector/c c                     
         ...                   
        [#:immutableimmutable 
         #:flat?flat?])      ->contract?
c:contract?
immutable:(or/c#t#f'dont-care)='dont-care
flat?:boolean?=#f
procedure
(vector-immutable/cc...)->contract?
c:contract?
procedure
(box/c in-c                  
     [c                     
      #:immutableimmutable 
      #:flat?flat?])      ->contract?
in-c:contract?
c:contract?=in-c
immutable:(or/c#t#f'dont-care)='dont-care
flat?:boolean?=#f
procedure
(box-immutable/cc)->contract?
c:contract?
procedure
(listofc)->list-contract?
c:contract?
procedure
(non-empty-listofc)->list-contract?
c:contract?
procedure
(list*ofele-c[last-c])->contract?
ele-c:contract?
last-c:contract?=ele-c
procedure
(cons/ccar-ccdr-c)->contract?
car-c:contract?
cdr-c:contract?
syntax
(cons/dc[car-idcontract-expr][cdr-id(car-id)contract-expr]cons/dc-option)
(cons/dc[car-id(cdr-id)contract-expr][cdr-idcontract-expr]cons/dc-option)

cons/dc-option=
             |#:flat
             |#:chaperone
             |#:impersonator
procedure
(list/cc...)->list-contract?
c:contract?
procedure
(*list/cprefixsuffix...)->list-contract?
prefix:contract?
suffix:contract?
procedure
(syntax/cc)->flat-contract?
c:flat-contract?
syntax
(struct/cstruct-idcontract-expr...)
syntax
(struct/dcstruct-idfield-spec...maybe-inv)

         field-spec=[field-namemaybe-lazycontract-expr]
                  |[field-name(dep-field-name...)
                      maybe-lazy
                      maybe-contract-type
                      maybe-dep-state
                      contract-expr]
                  
         field-name=field-id
                  |(#:selectorselector-id)
                  |(field-id#:parentstruct-id)
                  
         maybe-lazy=
                  |#:lazy
                  
maybe-contract-type=
                  |#:flat
                  |#:chaperone
                  |#:impersonator
                  
    maybe-dep-state=
                  |#:depends-on-state
                  
          maybe-inv=
                  |#:inv(dep-field-name...)invariant-expr
procedure
(parameter/c in                              
           [out                             
            #:impersonator?impersonator?])->contract?
in:contract?
out:contract?=in
impersonator?:any/c=#t
procedure
(procedure-arity-includes/cn)->flat-contract?
n:exact-nonnegative-integer?
procedure
(hash/c key                   
       val                   
      [#:immutableimmutable 
       #:flat?flat?])      ->contract?
key:chaperone-contract?
val:contract?
immutable:(or/c#t#f'dont-care)='dont-care
flat?:boolean?=#f
syntax
(hash/dc[key-idkey-contract-expr][value-id(key-id)value-contract-expr]
hash/dc-option)

hash/dc-option=
             |#:immutableimmutable?-exprhash/dc-option
             |#:kindkind-exprhash/dc-option
procedure
(channel/cval)->contract?
val:contract?
syntax
(prompt-tag/ccontract...maybe-call/cc)

maybe-call/cc=
            |#:call/cccontract
            |#:call/cc(valuescontract...)

contract:contract?
procedure
(continuation-mark-key/ccontract)->contract?
contract:contract?
procedure
(evt/ccontract...)->chaperone-contract?
contract:chaperone-contract?
syntax
(flat-rec-contractidflat-contract-expr...)
syntax
(flat-murec-contract([idflat-contract-expr...]...)body...+)
syntax
any
procedure
(promise/cc)->contract?
c:contract?
procedure
(flat-contractpredicate)->flat-contract?
predicate:(->any/cany/c)
procedure
(flat-contract-predicatev)->(->any/cany/c)
v:flat-contract?
procedure
(property/caccessorctc[#:namename])->flat-contract?
accessor:(->any/cany/c)
ctc:flat-contract?
name:any/c=(object-nameaccessor)
procedure
(suggest/ccfieldmessage)->contract?
c:contract?
field:string?
message:string?
syntax
(->dom...range)
(->dom...ellipsisdom-expr...range)

     dom=dom-expr
       |keyworddom-expr
       
   range=range-expr
       |(valuesrange-expr...)
       |any
       
ellipsis=...
syntax
(->*(mandatory-dom...)optional-domsrestprerangepost)

mandatory-dom=dom-expr
            |keyworddom-expr
            
optional-doms=
            |(optional-dom...)
            
 optional-dom=dom-expr
            |keyworddom-expr
            
         rest=
            |#:restrest-expr
            
          pre=
            |#:prepre-cond-expr
            |#:pre/descpre-cond-expr
            
        range=range-expr
            |(valuesrange-expr...)
            |any
            
         post=
            |#:postpost-cond-expr
            |#:post/descpost-cond-expr
syntax
(->imaybe-chaperone
(mandatory-dependent-dom...)
dependent-rest
pre-condition
param-value
dependent-range
post-condition)
(->imaybe-chaperone
(mandatory-dependent-dom...)
(optional-dependent-dom...)
dependent-rest
pre-condition
param-value
dependent-range
post-condition)

        maybe-chaperone=#:chaperone
                      |
                      
mandatory-dependent-dom=id+ctc
                      |keywordid+ctc
                      
 optional-dependent-dom=id+ctc
                      |keywordid+ctc
                      
         dependent-rest=
                      |#:restid+ctc
                      
          pre-condition=
                      |#:pre(id...)
                          boolean-exprpre-condition
                      |#:pre/desc(id...)
                          exprpre-condition
                      |#:pre/name(id...)
                          stringboolean-exprpre-condition
                      
            param-value=
                      |#:param(id...)
                          param-exprval-exprparam-value
                      
        dependent-range=any
                      |id+ctc
                      |un+ctc
                      |(valuesid+ctc...)
                      |(valuesun+ctc...)
                      
         post-condition=
                      |#:post(id...)
                          boolean-exprpost-condition
                      |#:post/desc(id...)
                          exprpost-condition
                      |#:post/name(id...)
                          stringboolean-exprpost-condition
                      
                 id+ctc=[idcontract-expr]
                      |[id(id...)contract-expr]
                      
                 un+ctc=[_contract-expr]
                      |[_(id...)contract-expr]
syntax
(->d(mandatory-dependent-dom...)
dependent-rest
pre-condition
dependent-range
post-condition)
(->d(mandatory-dependent-dom...)
(optional-dependent-dom...)
dependent-rest
pre-condition
dependent-range
post-condition)

mandatory-dependent-dom=[iddom-expr]
                      |keyword[iddom-expr]
                      
 optional-dependent-dom=[iddom-expr]
                      |keyword[iddom-expr]
                      
         dependent-rest=
                      |#:restidrest-expr
                      
          pre-condition=
                      |#:preboolean-expr
                      |#:pre-condboolean-expr
                      
        dependent-range=any
                      |[_range-expr]
                      |(values[_range-expr]...)
                      |[idrange-expr]
                      |(values[idrange-expr]...)
                      
         post-condition=
                      |#:post-condboolean-expr
syntax
(case->(->dom-expr...restrange)...)

 rest=
    |#:restrest-expr
    
range=range-expr
    |(valuesrange-expr...)
    |any
procedure
(dynamic->*                                                           
          [#:mandatory-domain-contractsmandatory-domain-contracts  
           #:optional-domain-contractsoptional-domain-contracts    
           #:mandatory-keywordsmandatory-keywords                  
           #:mandatory-keyword-contractsmandatory-keyword-contracts
           #:optional-keywordsoptional-keywords                    
           #:optional-keyword-contractsoptional-keyword-contracts  
           #:rest-contractrest-contract]                           
           #:range-contractsrange-contracts)                       
->contract?
mandatory-domain-contracts:(listofcontract?)='()
optional-domain-contracts:(listofcontract?)='()
mandatory-keywords:(listofkeyword?)='()
mandatory-keyword-contracts:(listofcontract?)='()
optional-keywords:(listofkeyword?)='()
optional-keyword-contracts:(listofcontract?)='()
rest-contract:(or/c#fcontract?)=#f
range-contracts:(or/c#f(listofcontract?))
syntax
(unconstrained-domain->range-expr...)
value
predicate/c:contract?
value
the-unsupplied-arg:unsupplied-arg?
procedure
(unsupplied-arg?v)->boolean?
v:any/c
syntax
(parametric->/c(x...)c)
procedure
(new-/c[name])->contract?
name:(or/csymbol?#f)=#f
procedure
(new-/c[name])->contract?
name:(or/csymbol?#f)=#f
syntax
(contract-structid(field-id...))

(id/dcfield-spec...)

field-spec=[field-idcontract-expr]
         |[field-id(field-id...)contract-expr]
syntax
(define-contract-structid(field-id...))
procedure
(struct-type-property/cvalue-contract)->contract?
value-contract:contract?
syntax
(contract-outunprotected-submodulecontract-out-item...)

unprotected-submodule=
                    |#:unprotected-submodulesubmodule-name
                    
    contract-out-item=(structid/ignored((idcontract-expr)...)
                        struct-option)
                    |(renameorig-ididcontract-expr)
                    |(idcontract-expr)
                    |#:poly-variables
                    |#:existspoly-variables
                    |#:poly-variables
                    |#:forallpoly-variables
                    
       poly-variables=id
                    |(id...)
                    
           id/ignored=id
                    |(idignored-id)
                    
        struct-option=
                    |#:omit-constructor
syntax
(recontract-outid...)
syntax
(provide/contractunprotected-submodulecontract-out-item...)
syntax
(struct-guard/ccontract-expr...)
syntax
(with-contractblame-id(wc-export...)free-var-list...body...+)
(with-contractblame-idresults-specfree-var-list...body...+)

    wc-export=(idcontract-expr)
            
  result-spec=#:resultcontract-expr
            |#:results(contract-expr...)
            
free-var-list=
            |#:freevaridcontract-expr
            |#:freevars([idcontract-expr]...)
syntax
(define/contractidcontract-exprfree-var-listinit-value-expr)
(define/contract(headargs)contract-exprfree-var-listbody...+)
syntax
(struct/contractstruct-id([fieldcontract-expr]...)
struct-option...)
(struct/contractstruct-idsuper-struct-id
([fieldcontract-expr]...)
struct-option...)
syntax
(define-struct/contractstruct-id([fieldcontract-expr]...)
struct-option...)
(define-struct/contract(struct-idsuper-struct-id)
([fieldcontract-expr]...)
struct-option...)
syntax
(invariant-assertioninvariant-exprexpr)
syntax
current-contract-region
syntax
(define-module-boundary-contractid
orig-id
contract-expr
pos-blame-party
source-loc
name-for-blame
context-limit)

pos-blame-party=
              |#:pos-sourcepos-source-expr
              
     source-loc=
              |#:srclocsrcloc-expr
              
 name-for-blame=
              |#:name-for-blameblame-id
              
  context-limit=
              |#:context-limitlimit-expr
syntax
(contractcontract-exprto-protect-expr
positive-blame-exprnegative-blame-expr)
(contractcontract-exprto-protect-expr
positive-blame-exprnegative-blame-expr
#:context-limitlimit-expr)
(contractcontract-exprto-protect-expr
positive-blame-exprnegative-blame-expr
value-name-exprsource-location-expr)
procedure
(make-contract                                                             
             [#:namename                                                
              #:first-orderfirst-order                                  
              #:late-neg-projectionlate-neg-proj                        
              #:collapsible-late-neg-projectioncollapsible-late-neg-proj
              #:val-first-projectionval-first-proj                      
              #:projectionproj                                          
              #:strongerstronger                                        
              #:equivalentequivalent                                    
              #:list-contract?is-list-contract?])                       
->contract?
name:any/c='anonymous-contract
first-order:(->any/cany/c)=((x)#t)
late-neg-proj:(or/c#f(->blame?(->any/cany/cany/c)))
             =#f
collapsible-late-neg-proj:(or/c#f(->blame?(values(->any/cany/cany/c)collapsible-contract?)))
                         =#f
val-first-proj:(or/c#f(->blame?(->any/c(->any/cany/c))))
              =#f
proj:(->blame?(->any/cany/c))
    =((b)
         ((x)
         (if(first-orderx)
         x
         (raise-blame-error
         bx
         '(expected:"~a"given:"~e")
         namex))))
stronger:(or/c#f(->contract?contract?boolean?))=#f
equivalent:(or/c#f(->contract?contract?boolean?))=#f
is-list-contract?:boolean?=#f
procedure
(make-chaperone-contract                                                             
                       [#:namename                                                
                        #:first-orderfirst-order                                  
                        #:late-neg-projectionlate-neg-proj                        
                        #:collapsible-late-neg-projectioncollapsible-late-neg-proj
                        #:val-first-projectionval-first-proj                      
                        #:projectionproj                                          
                        #:strongerstronger                                        
                        #:equivalentequivalent                                    
                        #:list-contract?is-list-contract?])                       
->chaperone-contract?
name:any/c='anonymous-chaperone-contract
first-order:(->any/cany/c)=((x)#t)
late-neg-proj:(or/c#f(->blame?(->any/cany/cany/c)))
             =#f
collapsible-late-neg-proj:(or/c#f(->blame?(values(->any/cany/cany/c)collapsible-contract?)))
                         =#f
val-first-proj:(or/c#f(->blame?(->any/c(->any/cany/c))))
              =#f
proj:(->blame?(->any/cany/c))
    =((b)
         ((x)
         (if(first-orderx)
         x
         (raise-blame-error
         bx
         '(expected:"~a"given:"~e")
         namex))))
stronger:(or/c#f(->contract?contract?boolean?))=#f
equivalent:(or/c#f(->contract?contract?boolean?))=#f
is-list-contract?:boolean?=#f
procedure
(make-flat-contract                                                             
                  [#:namename                                                
                   #:first-orderfirst-order                                  
                   #:late-neg-projectionlate-neg-proj                        
                   #:collapsible-late-neg-projectioncollapsible-late-neg-proj
                   #:val-first-projectionval-first-proj                      
                   #:projectionproj                                          
                   #:strongerstronger                                        
                   #:equivalentequivalent                                    
                   #:list-contract?is-list-contract?])                       
->flat-contract?
name:any/c='anonymous-flat-contract
first-order:(->any/cany/c)=((x)#t)
late-neg-proj:(or/c#f(->blame?(->any/cany/cany/c)))
             =#f
collapsible-late-neg-proj:(or/c#f(->blame?(values(->any/cany/cany/c)collapsible-contract?)))
                         =#f
val-first-proj:(or/c#f(->blame?(->any/c(->any/cany/c))))
              =#f
proj:(->blame?(->any/cany/c))
    =((b)
         ((x)
         (if(first-orderx)
         x
         (raise-blame-error
         bx
         '(expected:"~a"given:"~e")
         namex))))
stronger:(or/c#f(->contract?contract?boolean?))=#f
equivalent:(or/c#f(->contract?contract?boolean?))=#f
is-list-contract?:boolean?=#f
procedure
(build-compound-type-namec/s...)->any
c/s:any/c
procedure
(coerce-contractidv)->contract?
id:symbol?
v:any/c
procedure
(coerce-contractsidvs)->(listofcontract?)
id:symbol?
vs:(listofany/c)
procedure
(coerce-chaperone-contractidv)->chaperone-contract?
id:symbol?
v:any/c
procedure
(coerce-chaperone-contractsidvs)
->(listofchaperone-contract?)
id:symbol?
vs:(listofany/c)
procedure
(coerce-flat-contractidv)->flat-contract?
id:symbol?
v:any/c
procedure
(coerce-flat-contractsidv)->(listofflat-contract?)
id:symbol?
v:(listofany/c)
procedure
(coerce-contract/fv)->(or/ccontract?#f)
v:any/c
parameter
(skip-projection-wrapper?)->boolean?
(skip-projection-wrapper?wrap?)->void?
wrap?:boolean?
=#f
syntax
(with-contract-continuation-markblamebody...)
(with-contract-continuation-markblame+neg-partybody...)
syntax
(contract-pos/neg-doublinge1e2)
procedure
(blame?v)->boolean?
v:any/c
procedure
(raise-blame-errorb                             
                 #:missing-partymissing-party 
                 v                             
                 fmt                           
                 v-fmt...)                   ->none/c
b:blame?
missing-party:#f
v:any/c
fmt:(or/cstring?
        (listof(or/cstring?
        'given'given:
        'expected'expected:)))
v-fmt:any/c
procedure
(blame-add-context blame                 
                  context               
                 [#:importantimportant 
                  #:swap?swap?])      ->blame?
blame:blame?
context:(or/cstring?#f)
important:(or/cstring?#f)=#f
swap?:boolean?=#f
procedure
(blame-contextblame)->(listofstring?)
blame:blame?
procedure
(blame-positiveb)->any/c
b:blame?
procedure
(blame-negativeb)->any/c
b:blame?
procedure
(blame-contractb)->any/c
b:blame?
procedure
(blame-valueb)->any/c
b:blame?
procedure
(blame-sourceb)->srcloc?
b:blame?
procedure
(blame-swapb)->blame?
b:blame?
procedure
(blame-original?b)->boolean?
b:blame?
procedure
(blame-swapped?b)->boolean?
b:blame?
procedure
(blame-replace-negativebneg)->blame?
b:blame?
neg:any/c
procedure
(blame-replaced-negative?b)->boolean?
b:blame?
procedure
(blame-updatebposneg)->blame?
b:blame?
pos:any/c
neg:any/c
procedure
(blame-missing-party?b)->boolean?
b:blame?
procedure
(blame-add-missing-partybmissing-party)
->(and/cblame?(not/cblame-missing-party?))
b:(and/cblame?blame-missing-party?)
missing-party:any/c
struct
(structexn:fail:contract:blameexn:fail:contract(object)
#:extra-constructor-namemake-exn:fail:contract:blame)
object:blame?
parameter
(current-blame-format)->(->blame?any/cstring?string?)
(current-blame-formatproc)->void?
proc:(->blame?any/cstring?string?)
value
prop:contract:struct-type-property?
value
prop:chaperone-contract:struct-type-property?
value
prop:flat-contract:struct-type-property?
value
prop:contracted:struct-type-property?
value
impersonator-prop:contracted:impersonator-property?
value
prop:blame:struct-type-property?
value
impersonator-prop:blame:impersonator-property?
procedure
(build-flat-contract-property                                                             
                            [#:nameget-name                                            
                             #:first-orderget-first-order                              
                             #:late-neg-projectionlate-neg-proj                        
                             #:collapsible-late-neg-projectioncollapsible-late-neg-proj
                             #:val-first-projectionval-first-proj                      
                             #:projectionget-projection                                
                             #:strongerstronger                                        
                             #:equivalentequivalent                                    
                             #:generategenerate                                        
                             #:list-contract?is-list-contract?])                       
->flat-contract-property?
get-name:(->contract?any/c)
        =((c)'anonymous-flat-contract)
get-first-order:(->contract?(->any/cboolean?))
               =((c)((x)#t))
late-neg-proj:(or/c#f(->contract?(->blame?(->any/cany/cany/c))))
             =#f
collapsible-late-neg-proj:(or/c#f(->contract?(->blame?(values(->any/cany/cany/c)collapsible-contract?))))
                         =#f
val-first-proj:(or/c#f(->contract?blame?(->any/c(->any/cany/c))))
              =#f
get-projection:(->contract?(->blame?(->any/cany/c)))
              =((c)
                   ((b)
                   ((x)
                   (if((get-first-orderc)x)
                   x
                   (raise-blame-error
                   bx'(expected:"~a"given:"~e")
                   (get-namec)x)))))
stronger:(or/c(->contract?contract?boolean?)#f)=#f
equivalent:(or/c#f(->contract?contract?boolean?))=#f
generate:(->i([ccontract?])
             [generator
             (c)
             (->exact-nonnegative-integer?
             (or/c(->(or/ccontract-random-generate-fail?c))
             #f))])
        =((c)((fuel)#f))
is-list-contract?:(->contract?boolean?)=((c)#f)
procedure
(build-chaperone-contract-property                                                             
                                 [#:nameget-name                                            
                                  #:first-orderget-first-order                              
                                  #:late-neg-projectionlate-neg-proj                        
                                  #:collapsible-late-neg-projectioncollapsible-late-neg-proj
                                  #:val-first-projectionval-first-proj                      
                                  #:projectionget-projection                                
                                  #:strongerstronger                                        
                                  #:equivalentequivalent                                    
                                  #:generategenerate                                        
                                  #:exerciseexercise                                        
                                  #:list-contract?is-list-contract?])                       
->chaperone-contract-property?
get-name:(->contract?any/c)
        =((c)'anonymous-chaperone-contract)
get-first-order:(->contract?(->any/cboolean?))
               =((c)((x)#t))
late-neg-proj:(or/c#f(->contract?(->blame?(->any/cany/cany/c))))
             =#f
collapsible-late-neg-proj:(or/c#f(->contract?(->blame?(values(->any/cany/cany/c)collapsible-contract?))))
                         =#f
val-first-proj:(or/c#f(->contract?blame?(->any/c(->any/cany/c))))
              =#f
get-projection:(->contract?(->blame?(->any/cany/c)))
              =((c)
                   ((b)
                   ((x)
                   (if((get-first-orderc)x)
                   x
                   (raise-blame-error
                   bx'(expected:"~a"given:"~e")
                   (get-namec)x)))))
stronger:(or/c(->contract?contract?boolean?)#f)=#f
equivalent:(or/c#f(->contract?contract?boolean?))=#f
generate:(->i([ccontract?])
             [generator
             (c)
             (->exact-nonnegative-integer?
             (or/c(->(or/ccontract-random-generate-fail?c))
             #f))])
        =((c)((fuel)#f))
exercise:(->i([ccontract?])
             [result
             (c)
             (->exact-nonnegative-integer?
             (values
             (->cvoid?)
             (listofcontract?)))])
        =((c)((fuel)(valuesvoid'())))
is-list-contract?:(->contract?boolean?)=((c)#f)
procedure
(build-contract-property                                                             
                       [#:nameget-name                                            
                        #:first-orderget-first-order                              
                        #:late-neg-projectionlate-neg-proj                        
                        #:collapsible-late-neg-projectioncollapsible-late-neg-proj
                        #:val-first-projectionval-first-proj                      
                        #:projectionget-projection                                
                        #:strongerstronger                                        
                        #:equivalentequivalent                                    
                        #:generategenerate                                        
                        #:exerciseexercise                                        
                        #:list-contract?is-list-contract?])                       
->contract-property?
get-name:(->contract?any/c)=((c)'anonymous-contract)
get-first-order:(->contract?(->any/cboolean?))
               =((c)((x)#t))
late-neg-proj:(or/c#f(->contract?(->blame?(->any/cany/cany/c))))
             =#f
collapsible-late-neg-proj:(or/c#f(->contract?(->blame?(values(->any/cany/cany/c)collapsible-contract?))))
                         =#f
val-first-proj:(or/c#f(->contract?blame?(->any/c(->any/cany/c))))
              =#f
get-projection:(->contract?(->blame?(->any/cany/c)))
              =((c)
                   ((b)
                   ((x)
                   (if((get-first-orderc)x)
                   x
                   (raise-blame-error
                   bx'(expected:"~a"given:"~e")
                   (get-namec)x)))))
stronger:(or/c(->contract?contract?boolean?)#f)=#f
equivalent:(or/c#f(->contract?contract?boolean?))=#f
generate:(->i([ccontract?])
             [generator
             (c)
             (->exact-nonnegative-integer?
             (or/c(->(or/ccontract-random-generate-fail?c))
             #f))])
        =((c)((fuel)#f))
exercise:(->i([ccontract?])
             [result
             (c)
             (->exact-nonnegative-integer?
             (values
             (->cvoid?)
             (listofcontract?)))])
        =((c)((fuel)(valuesvoid'())))
is-list-contract?:(->contract?boolean?)=((c)#f)
procedure
(contract-property?v)->boolean?
v:any/c
procedure
(chaperone-contract-property?v)->boolean?
v:any/c
procedure
(flat-contract-property?v)->boolean?
v:any/c
syntax
(define/final-propheaderbody...)

header=main-id
     |(main-idid...)
     |(main-idid.... id)
syntax
(define/subexpression-pos-propheaderbody...)

header=main-id
     |(main-idid...)
     |(main-idid.... id)
procedure
(contract-stronger?c1c2)->boolean?
c1:contract?
c2:contract?
procedure
(contract-equivalent?c1c2)->boolean?
c1:contract?
c2:contract?
procedure
(contract-first-order-passes?contractv)->boolean?
contract:contract?
v:any/c
procedure
(contract-first-orderc)->(->any/cboolean?)
c:contract?
procedure
(contract?v)->boolean?
v:any/c
procedure
(chaperone-contract?v)->boolean?
v:any/c
procedure
(impersonator-contract?v)->boolean?
v:any/c
procedure
(flat-contract?v)->boolean?
v:any/c
procedure
(list-contract?v)->boolean?
v:any/c
procedure
(contract-namec)->any/c
c:contract?
procedure
(value-contractv)->(or/ccontract?#f)
v:has-contract?
procedure
(has-contract?v)->boolean?
v:any/c
procedure
(value-blamev)->(or/cblame?#f)
v:has-blame?
procedure
(has-blame?v)->boolean?
v:any/c
procedure
(contract-late-neg-projectionc)
->(->blame?(->any/c(or/c#fany/c)any/c))
c:contract?
procedure
(contract-projectionc)->(->blame?(->any/cany/c))
c:contract?
procedure
(contract-val-first-projectionc)
->(->blame?(->any/c(->any/cany/c)))
c:contract?
procedure
(make-none/csexp-name)->contract?
sexp-name:any/c
syntax
(recursive-contractcontract-exprrecursive-contract-option...)
(recursive-contractcontract-exprtyperecursive-contract-option...)

recursive-contract-option=#:list-contract?
                        |#:extra-delay
                        
                     type=#:impersonator
                        |#:chaperone
                        |#:flat
syntax
(opt/ccontract-exprmaybe-name)

maybe-name=
         |#:error-nameid
syntax
(define-opt/c(idid...)expr)
value
contract-continuation-mark-key:continuation-mark-key?
procedure
(contract-custom-write-property-procc     
                                   p     
                                   mode)->void?
c:contract?
p:output-port?
mode:(or/c#f#t01)
procedure
(rename-contractcontractname)->contract?
contract:contract?
name:any/c
syntax
(contract-first-order-okay-to-give-up?)
syntax
(contract-first-order-try-less-harde)
procedure
(if/cpredicatethen-contractelse-contract)->contract?
predicate:(->any/cany/c)
then-contract:contract?
else-contract:contract?
value
failure-result/c:contract?
procedure
(get/build-val-first-projectionc)
->(->blame?(->any/c(->any/cany/c)))
c:contract?
procedure
(get/build-late-neg-projectionc)
->(->blame?(->any/cany/cany/c))
c:contract?
procedure
(get/build-collapsible-late-neg-projectionc)
->(->blame?(values(->any/cany/cany/c)collapsible-contract?))
c:contract?
value
collapsible-contract-continuation-mark-key
:continuation-mark-key?
syntax
(with-collapsible-contract-continuation-markbody...)
value
prop:collapsible-contract:struct-type-property?
procedure
(collapsible-contract?v)->boolean?
v:any/c
procedure
(mergenew-ccnew-negold-ccold-neg)->collapsible-contract?
new-cc:collapsible-contract?
new-neg:any/c
old-cc:collapsible-contract?
old-neg:any/c
procedure
(collapsible-guardccvalneg-party)->any/c
cc:collapsible-contract?
val:any/c
neg-party:any/c
procedure
(collapsible-contract-property?v)->boolean?
v:any/c
procedure
(build-collapsible-contract-property                                         
                                   [#:try-mergetry-merge                  
                                    #:collapsible-guardcollapsible-guard])
->collapsible-contract-property?
try-merge:(or/c#f                                   =#f
              (->collapsible-contract?
              any/c
              collapsible-contract?
              any/c
              (or/c#fcollapsible-contract?)))
collapsible-guard:(->collapsible-contract?any/cany/cany/c)
                 =((ccvneg)
                      (error
                      "internal error: contract does not support `collapsible-guard`"cc))
struct
(struct collapsible-ho/c (latest-blame missing-party latest-ctc))
latest-blame:blame?
missing-party:any/c
latest-ctc:contract?
struct
(structcollapsible-leaf/c(proj-list
                        contract-list
                        blame-list
                        missing-party-list))
proj-list:(listof(->any/cany/cany/c))
contract-list:(listofcontract?)
blame-list:(listofblame?)
missing-party-list:(listofany/c)
value
impersonator-prop:collapsible:impersonator-property?
procedure
(has-impersonator-prop:collapsible?v)->boolean?
v:any/c
procedure
(get-impersonator-prop:collapsiblev)->collapsible-property?
v:any/c
struct
(struct collapsible-property (c-c neg-party ref))
c-c:collapsible-contract?
neg-party:any/c
ref:(or/c#fimpersonator?)
struct
(structcollapsible-count-propertycollapsible-property(count
                                                     prev))
count:natural-number/c
prev:(or/ccollapsible-count-property?any/c)
struct
(structcollapsible-wrapper-propertycollapsible-property
      (checking-wrapper)
checking-wrapper:impersonator?
procedure
(make-proj-contractnameprojfirst-order)->contract?
name:any/c
proj:(or/c(->any/c
         any/c
         (list/cany/cany/c)
         contact?
         (->any/cany/c))
         (->any/c
         any/c
         (list/cany/cany/c)
         contact?
         boolean?
         (->any/cany/c)))
first-order:(->any/cboolean?)
procedure
(raise-contract-errorval      
                    src      
                    pos      
                    name     
                    fmt      
                    arg...)->any/c
val:any/c
src:any/c
pos:any/c
name:any/c
fmt:string?
arg:any/c
procedure
(contract-procc)
->(->*(symbol?symbol?(or/csyntax?(list/cany/cany/c)))
    (boolean?)
    (->any/cany))
c:contract?
procedure
(contract-random-generatectc[fuelfail])->any/c
ctc:contract?
fuel:5=exact-nonnegative-integer?
fail:(or/c#f(->any)(->boolean?any))=#f
procedure
(contract-exercise[#:fuelfuel          
                  #:shuffle?shuffle?] 
                  val...+)           ->void?
fuel:exact-nonnegative-integer?=10
shuffle?:any/c=#f
val:any/c
procedure
(contract-random-generate/choosecfuel)->(or/c#f(->c))
c:contract?
fuel:exact-nonnegative-integer?
value
contract-random-generate-fail:contract-random-generate-fail?
procedure
(contract-random-generate-fail?v)->boolean?
v:any/c
procedure
(contract-random-generate-env?v)->boolean?
v:any/c
procedure
(contract-random-generate-stashenvcv)->void?
env:contract-random-generate-env?
c:contract?
v:c
procedure
(contract-random-generate-get-current-environment)
->contract-random-generate-env?
syntax
(matchval-exprclause...)

clause=[patbody...+]
     |[pat(=>id)body...+]
     |[pat#:whencond-exprbody...+]
syntax
(match*(val-expr...+)clause*...)

clause*=[(pat...+)body...+]
      |[(pat...+)(=>id)body...+]
      |[(pat...+)#:whencond-exprbody...+]
syntax
(match/valuesexprclause*clause*...)
syntax
(define/match(headargs)
match*-clause...)

         head=id
            |(headargs)
            
         args=arg...
            |arg....rest-id
            
          arg=arg-id
            |[arg-iddefault-expr]
            |keywordarg-id
            |keyword[arg-iddefault-expr]
            
match*-clause=[(pat...+)body...+]
            |[(pat...+)(=>id)body...+]
            |[(pat...+)#:whencond-exprbody...+]
syntax
(match-lambdaclause...)
syntax
(match-lambda*clause...)
syntax
(match-lambda**clause*...)
syntax
(match-let([patexpr]...)body...+)
syntax
(match-let*([patexpr]...)body...+)
syntax
(match-let-values([(pat...)expr]...)body...+)
syntax
(match-let*-values([(pat...)expr]...)body...+)
syntax
(match-letrec([patexpr]...)body...+)
syntax
(match-letrec-values([(pat...)expr]...)body...+)
syntax
(match-definepatexpr)
syntax
(match-define-values(patpats...)expr)
procedure
(exn:misc:match?v)->boolean?
v:any/c
syntax
(failure-cont)
syntax
(define-match-expanderidproc-expr)
(define-match-expanderidproc-exprproc-expr)
value
prop:match-expander:struct-type-property?
value
prop:legacy-match-expander:struct-type-property?
procedure
(match-expander?v)->boolean?
v:any/c
procedure
(legacy-match-expander?v)->boolean?
v:any/c
procedure
(syntax-local-match-introducestx)->syntax?
stx:syntax?
parameter
(match-equality-test)->(any/cany/c. -> .any)
(match-equality-testcomp-proc)->void?
comp-proc:(any/cany/c. -> .any)
syntax
(match/derivedval-exproriginal-datumclause...)
syntax
(match*/derived(val-expr...)original-datumclause*...)
syntax
(==valcomparator)
(==val)
syntax
(struct*struct-id([fieldpat]...))
procedure
(valuesv...)->any
v:any/c
procedure
(call-with-valuesgeneratorreceiver)->any
generator:(->any)
receiver:procedure?
procedure
(raisev[barrier?])->any
v:any/c
barrier?:any/c=#t
procedure
(errormessage-sym)->any
message-sym:symbol?
(errormessage-strv...)->any
message-str:string?
v:any/c
(errorwho-symformat-strv...)->any
who-sym:symbol?
format-str:string?
v:any/c
procedure
(raise-user-errormessage-sym)->any
message-sym:symbol?
(raise-user-errormessage-strv...)->any
message-str:string?
v:any/c
(raise-user-errorwho-symformat-strv...)->any
who-sym:symbol?
format-str:string?
v:any/c
procedure
(raise-argument-errornameexpectedv)->any
name:symbol?
expected:string?
v:any/c
(raise-argument-errorname     
                    expected 
                    bad-pos  
                    v...)  ->any
name:symbol?
expected:string?
bad-pos:exact-nonnegative-integer?
v:any/c
procedure
(raise-argument-error*namerealmexpectedv)->any
name:symbol?
realm:symbol?
expected:string?
v:any/c
(raise-argument-error*name     
                     realm    
                     expected 
                     bad-pos  
                     v...)  ->any
name:symbol?
realm:symbol?
expected:string?
bad-pos:exact-nonnegative-integer?
v:any/c
procedure
(raise-result-errornameexpectedv)->any
name:symbol?
expected:string?
v:any/c
(raise-result-errorname     
                  expected 
                  bad-pos  
                  v...)  ->any
name:symbol?
expected:string?
bad-pos:exact-nonnegative-integer?
v:any/c
procedure
(raise-result-error*namerealmexpectedv)->any
name:symbol?
realm:symbol?
expected:string?
v:any/c
(raise-result-error*name     
                   realm    
                   expected 
                   bad-pos  
                   v...)  ->any
name:symbol?
realm:symbol?
expected:string?
bad-pos:exact-nonnegative-integer?
v:any/c
procedure
(raise-arguments-errorname    
                     message 
                     field   
                     v...   
                     ...)   ->any
name:symbol?
message:string?
field:string?
v:any/c
procedure
(raise-arguments-error*name    
                      realm   
                      message 
                      field   
                      v...   
                      ...)   ->any
name:symbol?
realm:symbol?
message:string?
field:string?
v:any/c
procedure
(raise-range-error name              
                  type-description  
                  index-prefix      
                  index             
                  in-value          
                  lower-bound       
                  upper-bound       
                 [alt-lower-bound])->any
name:symbol?
type-description:string?
index-prefix:string?
index:exact-integer?
in-value:any/c
lower-bound:exact-integer?
upper-bound:exact-integer?
alt-lower-bound:(or/c#fexact-integer?)=#f
procedure
(raise-range-error* name              
                   realm             
                   type-description  
                   index-prefix      
                   index             
                   in-value          
                   lower-bound       
                   upper-bound       
                  [alt-lower-bound])->any
name:symbol?
realm:symbol?
type-description:string?
index-prefix:string?
index:exact-integer?
in-value:any/c
lower-bound:exact-integer?
upper-bound:exact-integer?
alt-lower-bound:(or/c#fexact-integer?)=#f
procedure
(raise-type-errornameexpectedv)->any
name:symbol?
expected:string?
v:any/c
(raise-type-errornameexpectedbad-posv...)->any
name:symbol?
expected:string?
bad-pos:exact-nonnegative-integer?
v:any/c
procedure
(raise-mismatch-errorname    
                    message 
                    v...+  
                    ...+)  ->any
name:symbol?
message:string?
v:any/c
procedure
(raise-arity-errornamearity-varg-v...)->any
name:(or/csymbol?procedure?)
arity-v:(or/cexact-nonnegative-integer?
            arity-at-least?
            (listof
            (or/cexact-nonnegative-integer?
            arity-at-least?)))
arg-v:any/c
procedure
(raise-arity-error*name       
                  realm      
                  arity-v    
                  arg-v...)->any
name:(or/csymbol?procedure?)
realm:symbol?
arity-v:(or/cexact-nonnegative-integer?
            arity-at-least?
            (listof
            (or/cexact-nonnegative-integer?
            arity-at-least?)))
arg-v:any/c
procedure
(raise-arity-mask-errornamemaskarg-v...)->any
name:(or/csymbol?procedure?)
mask:exact-integer?
arg-v:any/c
procedure
(raise-arity-mask-error*name       
                       realm      
                       mask       
                       arg-v...)->any
name:(or/csymbol?procedure?)
realm:symbol?
mask:exact-integer?
arg-v:any/c
procedure
(raise-result-arity-errorname          
                        arity-v       
                        detail-str    
                        result-v...)->any
name:(or/csymbol?#f)
arity-v:exact-nonnegative-integer?
detail-str:(or/cstring?#f)
result-v:any/c
procedure
(raise-result-arity-error*name          
                         realm         
                         arity-v       
                         detail-str    
                         result-v...)->any
name:(or/csymbol?#f)
realm:symbol?
arity-v:exact-nonnegative-integer?
detail-str:(or/cstring?#f)
result-v:any/c
procedure
(raise-syntax-error name           
                   message        
                  [expr           
                   sub-expr       
                   extra-sources  
                   message-suffix 
                   #:exnexn])   ->any
name:(or/csymbol?#f)
message:string?
expr:any/c=#f
sub-expr:any/c=#f
extra-sources:(listofsyntax?)=null
message-suffix:string?=""
exn:(->string?               =exn:fail:syntax
        continuation-mark-set?
        (listofsyntax?)
        exn:fail:syntax?)
procedure
(unquoted-printing-string?v)->boolean?
v:any/c
procedure
(unquoted-printing-strings)->unquoted-printing-string?
s:string?
procedure
(unquoted-printing-string-valueups)->string?
ups:unquoted-printing-string?
procedure
(call-with-exception-handlerfthunk)->any
f:(any/c. -> .any)
thunk:(->any)
parameter
(uncaught-exception-handler)->(any/c. -> .any)
(uncaught-exception-handlerf)->void?
f:(any/c. -> .any)
syntax
(with-handlers([pred-exprhandler-expr]...)
body...+)
syntax
(with-handlers*([pred-exprhandler-expr]...)
body...+)
parameter
(error-escape-handler)->(->any)
(error-escape-handlerproc)->void?
proc:(->any)
parameter
(error-display-handler)->(string?any/c. -> .any)
(error-display-handlerproc)->void?
proc:(string?any/c. -> .any)
parameter
(error-print-width)->(and/cexact-integer?(>=/c3))
(error-print-widthwidth)->void?
width:(and/cexact-integer?(>=/c3))
parameter
(error-print-context-length)->exact-nonnegative-integer?
(error-print-context-lengthcnt)->void?
cnt:exact-nonnegative-integer?
parameter
(error-print-source-location)->boolean?
(error-print-source-locationinclude?)->void?
include?:any/c
parameter
(error-value->string-handler)
->(any/cexact-nonnegative-integer?
    . -> .
    string?)
(error-value->string-handlerproc)->void?
proc:(any/cexact-nonnegative-integer?
         . -> .
         string?)
parameter
(error-syntax->string-handler)
->(any/c(or/cexact-nonnegative-integer?#f)
    . -> .
    string?)
(error-syntax->string-handlerproc)->void?
proc:(any/c(or/cexact-nonnegative-integer?#f)
         . -> .
         string?)
struct
(structexn(message continuation-marks)
#:extra-constructor-namemake-exn
#:transparent)
message:string?
continuation-marks:continuation-mark-set?
struct
(structexn:failexn()
#:extra-constructor-namemake-exn:fail
#:transparent)
struct
(structexn:fail:contractexn:fail()
#:extra-constructor-namemake-exn:fail:contract
#:transparent)
struct
(structexn:fail:contract:arityexn:fail:contract()
#:extra-constructor-namemake-exn:fail:contract:arity
#:transparent)
struct
(structexn:fail:contract:divide-by-zeroexn:fail:contract()
#:extra-constructor-name
make-exn:fail:contract:divide-by-zero
#:transparent)
struct
(structexn:fail:contract:non-fixnum-resultexn:fail:contract()
#:extra-constructor-name
make-exn:fail:contract:non-fixnum-result
#:transparent)
struct
(structexn:fail:contract:continuationexn:fail:contract()
#:extra-constructor-namemake-exn:fail:contract:continuation
#:transparent)
struct
(structexn:fail:contract:variableexn:fail:contract(id)
#:extra-constructor-namemake-exn:fail:contract:variable
#:transparent)
id:symbol?
struct
(structexn:fail:syntaxexn:fail(exprs)
#:extra-constructor-namemake-exn:fail:syntax
#:transparent)
exprs:(listofsyntax?)
struct
(structexn:fail:syntax:unboundexn:fail:syntax()
#:extra-constructor-namemake-exn:fail:syntax:unbound
#:transparent)
struct
(structexn:fail:syntax:missing-moduleexn:fail:syntax(path)
#:extra-constructor-namemake-exn:fail:syntax:missing-module
#:transparent)
path:module-path?
struct
(structexn:fail:readexn:fail(srclocs)
#:extra-constructor-namemake-exn:fail:read
#:transparent)
srclocs:(listofsrcloc?)
struct
(structexn:fail:read:eofexn:fail:read()
#:extra-constructor-namemake-exn:fail:read:eof
#:transparent)
struct
(structexn:fail:read:non-charexn:fail:read()
#:extra-constructor-namemake-exn:fail:read:non-char
#:transparent)
struct
(structexn:fail:filesystemexn:fail()
#:extra-constructor-namemake-exn:fail:filesystem
#:transparent)
struct
(structexn:fail:filesystem:existsexn:fail:filesystem()
#:extra-constructor-namemake-exn:fail:filesystem:exists
#:transparent)
struct
(structexn:fail:filesystem:versionexn:fail:filesystem()
#:extra-constructor-namemake-exn:fail:filesystem:version
#:transparent)
struct
(structexn:fail:filesystem:errnoexn:fail:filesystem(errno)
#:extra-constructor-namemake-exn:fail:filesystem:errno
#:transparent)
errno:(cons/cexact-integer?(or/c'posix'windows'gai))
struct
(structexn:fail:filesystem:missing-moduleexn:fail:filesystem
      (path)
#:extra-constructor-name
make-exn:fail:filesystem:missing-module
#:transparent)
path:module-path?
struct
(structexn:fail:networkexn:fail()
#:extra-constructor-namemake-exn:fail:network
#:transparent)
struct
(structexn:fail:network:errnoexn:fail:network(errno)
#:extra-constructor-namemake-exn:fail:network:errno
#:transparent)
errno:(cons/cexact-integer?(or/c'posix'windows'gai))
struct
(structexn:fail:out-of-memoryexn:fail()
#:extra-constructor-namemake-exn:fail:out-of-memory
#:transparent)
struct
(structexn:fail:unsupportedexn:fail()
#:extra-constructor-namemake-exn:fail:unsupported
#:transparent)
struct
(structexn:fail:userexn:fail()
#:extra-constructor-namemake-exn:fail:user
#:transparent)
struct
(structexn:breakexn(continuation)
#:extra-constructor-namemake-exn:break
#:transparent)
continuation:continuation?
struct
(structexn:break:hang-upexn:break()
#:extra-constructor-namemake-exn:break:hang-up
#:transparent)
struct
(structexn:break:terminateexn:break()
#:extra-constructor-namemake-exn:break:terminate
#:transparent)
value
prop:exn:srclocs:struct-type-property?
procedure
(exn:srclocs?v)->boolean?
v:any/c
procedure
(exn:srclocs-accessorv)
->(exn:srclocs?. -> .(listofsrcloc))
v:exn:srclocs?
struct
(structsrcloc(source line column position span)
#:extra-constructor-namemake-srcloc
#:transparent)
source:any/c
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:(or/cexact-positive-integer?#f)
span:(or/cexact-nonnegative-integer?#f)
procedure
(srcloc->stringsrcloc)->(or/cstring?#f)
srcloc:srcloc?
value
prop:exn:missing-module:struct-type-property?
procedure
(exn:missing-module?v)->boolean?
v:any/c
procedure
(exn:missing-module-accessorv)
->(exn:missing-module?. -> .module-path?)
v:exn:srclocs?
procedure
(exn->stringexn)->string?
exn:(or/cexn?any/c)
procedure
(error-message->adjusted-stringname           
                              name-realm     
                              message        
                              message-realm)->string?
name:(or/csymbol?#f)
name-realm:symbol?
message:string?
message-realm:symbol?
procedure
(error-contract->adjusted-stringcontract-str    
                               contract-realm)->string?
contract-str:string?
contract-realm:symbol?
parameter
(current-error-message-adjuster)
->(symbol?. -> .(or/cprocedure?#f))
(current-error-message-adjusterproc)->void?
proc:(symbol?. -> .(or/cprocedure?#f))
value
error-message-adjuster-key:symbol?
procedure
(promise?v)->boolean?
v:any/c
syntax
(delaybody...+)
syntax
(lazybody...+)
procedure
(forcev)->any
v:any/c
procedure
(promise-forced?promise)->boolean?
promise:promise?
procedure
(promise-running?promise)->boolean?
promise:promise?
syntax
(delay/namebody...+)
procedure
(promise/name?promise)->boolean?
promise:any/c
syntax
(delay/strictbody...+)
syntax
(delay/syncbody...+)
syntax
(delay/threadbody/option...+)

body/option=body
          |#:groupthread-group-expr
syntax
(delay/idlebody/option...+)

body/option=body
          |#:wait-forwait-evt-expr
          |#:work-whilewhile-evt-expr
          |#:ticktick-secs-expr
          |#:useuse-ratio-expr
syntax
(for/list/concurrentmaybe-group(for-clause...)
body-or-break...body)

maybe-group=
          |#:groupthread-group-expr

thread-group-expr:thread-group?
syntax
(for*/list/concurrentmaybe-group(for-clause...)
body-or-break...body)
procedure
(call-with-continuation-prompt proc       
                             [prompt-tag 
                              handler]   
                              arg...)  ->any
proc:procedure?
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
handler:(or/cprocedure?#f)=#f
arg:any/c
procedure
(abort-current-continuationprompt-tag 
                          v...)    ->any
prompt-tag:any/c
v:any/c
procedure
(make-continuation-prompt-tag)->continuation-prompt-tag?
(make-continuation-prompt-tagname)->continuation-prompt-tag?
name:symbol?
procedure
(default-continuation-prompt-tag)->continuation-prompt-tag?
procedure
(call-with-current-continuation proc         
                              [prompt-tag])->any
proc:(continuation?. -> .any)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(call/ccproc[prompt-tag])->any
proc:(continuation?. -> .any)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(call-with-composable-continuation proc         
                                 [prompt-tag])->any
proc:(continuation?. -> .any)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(call-with-escape-continuationproc)->any
proc:(continuation?. -> .any)
procedure
(call/ecproc)->any
proc:(continuation?. -> .any)
procedure
(call-in-continuationkproc)->any
k:continuation?
proc:(->any)
syntax
(let/cckbody...+)
syntax
(let/eckbody...+)
procedure
(call-with-continuation-barrierthunk)->any
thunk:(->any)
procedure
(continuation-prompt-available? prompt-tag 
                              [cont])    ->any
prompt-tag:continuation-prompt-tag?
cont:continuation?=(call/ccvalues)
procedure
(continuation?v)->boolean?
v:any/c
procedure
(continuation-prompt-tag?v)->boolean?
v:any/c
procedure
(dynamic-windpre-thunk   
            value-thunk 
            post-thunk)->any
pre-thunk:(->any)
value-thunk:(->any)
post-thunk:(->any)
procedure
(call/promptproc[prompt-taghandler]arg...)->any
proc:procedure?
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
handler:(or/cprocedure?#f)=#f
arg:any/c
procedure
(abort/ccprompt-tagv...)->any
prompt-tag:any/c
v:any/c
procedure
(call/compproc[prompt-tag])->any
proc:(continuation?. -> .any)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(abortv...)->any
v:any/c
syntax
(%expr)
(%exprhandler-expr)
(%exprhandler-expr#:tagtag-expr)
procedure
(fcontrolv#:tagprompt-tag)->any
v:any/c
prompt-tag:(default-continuation-prompt-tag)
syntax
(promptexpr...+)
syntax
(controlidexpr...+)
syntax
(prompt-atprompt-tag-exprexpr...+)
syntax
(control-atprompt-tag-expridexpr...+)
syntax
(resetexpr...+)
syntax
(shiftidexpr...+)
syntax
(reset-atprompt-tag-exprexpr...+)
syntax
(shift-atprompt-tag-expridentifierexpr...+)
syntax
(prompt0expr...+)
syntax
(reset0expr...+)
syntax
(control0idexpr...+)
syntax
(shift0idexpr...+)
syntax
(prompt0-atprompt-tag-exprexpr...+)
syntax
(reset0-atprompt-tag-exprexpr...+)
syntax
(control0-atprompt-tag-expridexpr...+)
syntax
(shift0-atprompt-tag-expridexpr...+)
procedure
(spawnproc)->any
proc:((any/c. -> .any). -> .any)
procedure
(splitterproc)->any
proc:(((->any). -> .any)
         ((continuation?. -> .any). -> .any)
         . -> .any)
procedure
(new-prompt)->any
syntax
(setprompt-exprexpr...+)
syntax
(cuptoprompt-expridexpr...+)
procedure
(continuation-markscont[prompt-tag])->continuation-mark-set?
cont:(or/ccontinuation?thread?#f)
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(current-continuation-marks[prompt-tag])
->continuation-mark-set?
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(continuation-mark-set->list mark-set     
                            key-v        
                           [prompt-tag])->list?
mark-set:(or/ccontinuation-mark-set?#f)
key-v:any/c
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(continuation-mark-set->list* mark-set     
                             key-list     
                            [none-v       
                             prompt-tag])->(listofvector?)
mark-set:(or/ccontinuation-mark-set?#f)
key-list:(listofany/c)
none-v:any/c=#f
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(continuation-mark-set->iterator mark-set    
                                key-list    
                               [none-v      
                                prompt-tag])
->(->(values(or/cvector?#f)procedure?))
mark-set:(or/ccontinuation-mark-set?#f)
key-list:(listofany/c)
none-v:any/c=#f
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(continuation-mark-set-first mark-set     
                            key-v        
                           [none-v       
                            prompt-tag])->any
mark-set:(or/ccontinuation-mark-set?#f)
key-v:any/c
none-v:any/c=#f
prompt-tag:continuation-prompt-tag?
          =(default-continuation-prompt-tag)
procedure
(call-with-immediate-continuation-mark key-v       
                                      proc        
                                     [default-v])->any
key-v:any/c
proc:(any/c. -> .any)
default-v:any/c=#f
procedure
(make-continuation-mark-key)->continuation-mark-key?
(make-continuation-mark-keysym)->continuation-mark-key?
sym:symbol?
procedure
(continuation-mark-key?v)->boolean?
v:any/c
procedure
(continuation-mark-set?v)->boolean?
v:any/c
procedure
(continuation-mark-set->context mark-set  
                              [realms?])->list?
mark-set:continuation-mark-set?
realms?:any/c=#f
procedure
(break-enabled)->boolean?
(break-enabledon?)->void?
on?:any/c
syntax
(parameterize-breakboolean-exprbody...+)
procedure
(current-break-parameterization)->break-parameterization?
procedure
(call-with-break-parameterizationbreak-param 
                                thunk)     ->any
break-param:break-parameterization?
thunk:(->any)
procedure
(break-parameterization?v)->boolean?
v:any/c
procedure
(exit[v])->any
v:any/c=#t
parameter
(exit-handler)->(any/c. -> .any)
(exit-handlerproc)->void?
proc:(any/c. -> .any)
parameter
(executable-yield-handler)->(byte?. -> .any)
(executable-yield-handlerproc)->void?
proc:(byte?. -> .any)
procedure
(assert-unreachable)->none/c
syntax
(with-assert-unreachable
body...+)
procedure
(threadthunk)->thread?
thunk:(->any)
procedure
(thread?v)->thread?
v:any/c
procedure
(current-thread)->thread?
procedure
(thread/suspend-to-killthunk)->thread?
thunk:(->any)
procedure
(call-in-nested-threadthunk[cust])->any
thunk:(->any)
cust:custodian?=(current-custodian)
procedure
(thread-suspendthd)->void?
thd:thread?
procedure
(thread-resumethd[benefactor])->void?
thd:thread?
benefactor:(or/cthread?custodian?#f)=#f
procedure
(kill-threadthd)->void?
thd:thread?
procedure
(break-threadthd[kind])->void?
thd:thread?
kind:(or/c#f'hang-up'terminate)=#f
procedure
(sleep[secs])->void?
secs:(>=/c0)=0
procedure
(thread-running?thd)->any
thd:thread?
procedure
(thread-dead?thd)->any
thd:thread?
procedure
(thread-waitthd)->void?
thd:thread?
procedure
(thread-dead-evtthd)->evt?
thd:thread?
procedure
(thread-resume-evtthd)->evt?
thd:thread?
procedure
(thread-suspend-evtthd)->evt?
thd:thread?
procedure
(thread-sendthdv[fail-thunk])->any
thd:thread?
v:any/c
fail-thunk:(or/c(->any)#f)
          =(lambda()(raise-mismatch-error....))
procedure
(thread-receive)->any/c
procedure
(thread-try-receive)->any/c
procedure
(thread-receive-evt)->evt?
procedure
(thread-rewind-receivelst)->void?
lst:list?
procedure
(evt?v)->boolean?
v:any/c
procedure
(syncevt...)->any
evt:evt?
procedure
(sync/timeouttimeoutevt...)->any
timeout:(or/c#f(and/creal?(not/cnegative?))(->any))
evt:evt?
procedure
(sync/enable-breakevt...)->any
evt:evt?
procedure
(sync/timeout/enable-breaktimeoutevt...)->any
timeout:(or/c#f(and/creal?(not/cnegative?))(->any))
evt:evt?
procedure
(choice-evtevt...)->evt?
evt:evt?
procedure
(wrap-evtevtwrap)->evt?
evt:evt?
wrap:(any/c.... -> .any)
procedure
(handle-evtevthandle)->handle-evt?
evt:evt?
handle:(any/c.... -> .any)
procedure
(guard-evtmaker)->evt?
maker:(->(or/cevt?any/c))
procedure
(nack-guard-evtmaker)->evt?
maker:(evt?. -> .(or/cevt?any/c))
procedure
(poll-guard-evtmaker)->evt?
maker:(boolean?. -> .(or/cevt?any/c))
procedure
(replace-evtevtmaker)->evt?
evt:evt?
maker:(any/c.... -> .(or/cevt?any/c))
value
always-evt:evt?
value
never-evt:evt?
procedure
(system-idle-evt)->evt?
procedure
(alarm-evtmsecs[monotonic?])->evt?
msecs:real?
monotonic?:any/c=#f
procedure
(handle-evt?evt)->boolean?
evt:evt?
value
prop:evt:struct-type-property?
parameter
(current-evt-pseudo-random-generator)
->pseudo-random-generator?
(current-evt-pseudo-random-generatorgenerator)->void?
generator:pseudo-random-generator?
procedure
(channel?v)->boolean?
v:any/c
procedure
(make-channel)->channel?
procedure
(channel-getch)->any
ch:channel?
procedure
(channel-try-getch)->any
ch:channel?
procedure
(channel-putchv)->void?
ch:channel?
v:any/c
procedure
(channel-put-evtchv)->channel-put-evt?
ch:channel?
v:any/c
procedure
(channel-put-evt?v)->boolean?
v:any/c
procedure
(semaphore?v)->boolean?
v:any/c
procedure
(make-semaphore[init])->semaphore?
init:exact-nonnegative-integer?=0
procedure
(semaphore-postsema)->void?
sema:semaphore?
procedure
(semaphore-waitsema)->void?
sema:semaphore?
procedure
(semaphore-try-wait?sema)->boolean?
sema:semaphore?
procedure
(semaphore-wait/enable-breaksema)->void?
sema:semaphore?
procedure
(semaphore-peek-evtsema)->semaphore-peek-evt?
sema:semaphore?
procedure
(semaphore-peek-evt?v)->boolean?
v:any/c
procedure
(call-with-semaphore sema            
                    proc            
                   [try-fail-thunk] 
                    arg...)       ->any
sema:semaphore?
proc:procedure?
try-fail-thunk:(or/c(->any)#f)=#f
arg:any/c
procedure
(call-with-semaphore/enable-break sema            
                                 proc            
                                [try-fail-thunk] 
                                 arg...)       ->any
sema:semaphore?
proc:procedure?
try-fail-thunk:(or/c(->any)#f)=#f
arg:any/c
procedure
(async-channel?v)->boolean?
v:any/c
procedure
(make-async-channel[limit])->async-channel?
limit:(or/cexact-positive-integer?#f)=#f
procedure
(async-channel-getach)->any/c
ach:async-channel?
procedure
(async-channel-try-getach)->any/c
ach:async-channel?
procedure
(async-channel-putachv)->void?
ach:async-channel?
v:any/c
procedure
(async-channel-put-evtachv)->evt?
ach:async-channel?
v:any/c
procedure
(async-channel/cc)->contract?
c:contract?
procedure
(impersonate-async-channelchannel     
                         get-proc    
                         put-proc    
                         prop        
                         prop-val...
                         ...)        
->(and/casync-channel?impersonator?)
channel:async-channel?
get-proc:(any/c. -> .any/c)
put-proc:(any/c. -> .any/c)
prop:impersonator-property?
prop-val:any
procedure
(chaperone-async-channelchannel     
                       get-proc    
                       put-proc    
                       prop        
                       prop-val...
                       ...)        
->(and/casync-channel?chaperone?)
channel:async-channel?
get-proc:(any/c. -> .any/c)
put-proc:(any/c. -> .any/c)
prop:impersonator-property?
prop-val:any
procedure
(thread-cell?v)->boolean?
v:any/c
procedure
(make-thread-cellv[preserved?])->thread-cell?
v:any/c
preserved?:any/c=#f
procedure
(thread-cell-refcell)->any
cell:thread-cell?
procedure
(thread-cell-set!cellv)->any
cell:thread-cell?
v:any/c
procedure
(current-preserved-thread-cell-values)->thread-cell-values?
(current-preserved-thread-cell-valuesthread-cell-vals)->void?
thread-cell-vals:thread-cell-values?
procedure
(thread-cell-values?v)->boolean?
v:any/c
procedure
(make-parameterv[guardname])->parameter?
v:any/c
guard:(or/c(any/c. -> .any)#f)=#f
name:symbol?='parameter-procedure
syntax
(parameterize([parameter-exprvalue-expr]...)
body...+)

parameter-expr:parameter?
syntax
(parameterize*((parameter-exprvalue-expr)...)
body...+)
procedure
(make-derived-parameterparameter 
                      guard     
                      wrap)    ->parameter?
parameter:parameter?
guard:(any/c. -> .any)
wrap:(any/c. -> .any)
procedure
(parameter?v)->boolean?
v:any/c
procedure
(parameter-procedure=?ab)->boolean?
a:parameter?
b:parameter?
procedure
(current-parameterization)->parameterization?
procedure
(call-with-parameterizationparameterization 
                          thunk)          ->any
parameterization:parameterization?
thunk:(->any)
procedure
(parameterization?v)->boolean?
v:any/c
procedure
(futurethunk)->future?
thunk:(->any)
procedure
(touchf)->any
f:future?
procedure
(futures-enabled?)->boolean?
procedure
(current-future)->(or/c#ffuture?)
procedure
(future?v)->boolean?
v:any/c
procedure
(would-be-futurethunk)->future?
thunk:(->any)
procedure
(processor-count)->exact-positive-integer?
syntax
(for/async(for-clause...)body-or-break...body)
syntax
(for*/async(for-clause...)body-or-break...body)
procedure
(make-fsemaphoreinit)->fsemaphore?
init:exact-nonnegative-integer?
procedure
(fsemaphore?v)->boolean?
v:any/c
procedure
(fsemaphore-postfsema)->void?
fsema:fsemaphore?
procedure
(fsemaphore-waitfsema)->void?
fsema:fsemaphore?
procedure
(fsemaphore-try-wait?fsema)->boolean?
fsema:fsemaphore?
procedure
(fsemaphore-countfsema)->exact-nonnegative-integer?
fsema:fsemaphore?
procedure
(place-enabled?)->boolean?
procedure
(place?v)->boolean?
v:any/c
procedure
(place-channel?v)->boolean?
v:any/c
procedure
(dynamic-place module-path     
              start-name      
             [#:atlocation   
              #:namednamed])->place?
module-path:(or/cmodule-path?path?)
start-name:symbol?
location:(or/c#fplace-location?)=#f
named:any/c=#f
procedure
(dynamic-place* module-path 
               start-name  
              [#:inin     
               #:outout   
               #:errerr])->place?
                                (or/coutput-port?#f)
                                (or/cinput-port?#f)
                                (or/cinput-port?#f)
module-path:(or/cmodule-path?path?)
start-name:symbol?
in:(or/cinput-port?#f)=#f
out:(or/coutput-port?#f)=(current-output-port)
err:(or/coutput-port?#f)=(current-error-port)
procedure
(place-waitp)->exact-integer?
p:place?
procedure
(place-dead-evtp)->evt?
p:place?
procedure
(place-killp)->void?
p:place?
procedure
(place-breakp[kind])->void?
p:place?
kind:(or/c#f'hang-up'terminate)=#f
procedure
(place-channel)->place-channel?place-channel?
procedure
(place-channel-putpchv)->void
pch:place-channel?
v:place-message-allowed?
procedure
(place-channel-getpch)->place-message-allowed?
pch:place-channel?
procedure
(place-channel-put/getpchv)->any/c
pch:place-channel?
v:any/c
procedure
(place-message-allowed?v)->boolean?
v:any/c
value
prop:place-location:struct-type-property?
procedure
(place-location?v)->boolean?
v:any/c
syntax
(placeidbody...+)
syntax
(place*maybe-port...
id
body...+)

maybe-port=
         |#:inin-expr
         |#:outout-expr
         |#:errerr-expr
syntax
(place/contextidbody...+)
procedure
(processor-count)->exact-positive-integer?
procedure
(engineproc)->engine?
proc:((any/c. -> .void?). -> .any/c)
procedure
(engine?v)->any
v:any/c
procedure
(engine-rununtilengine)->boolean?
until:(or/cevt?real?)
engine:engine?
procedure
(engine-resultengine)->any
engine:engine?
procedure
(engine-killengine)->void?
engine:engine?
procedure
(memory-order-acquire)->void?
procedure
(memory-order-release)->void?
syntax
(syntax-casestx-expr(literal-id...)
clause...)

      clause=[patternresult-expr]
           |[patternfender-exprresult-expr]
           
     pattern=np-pattern
           |(pattern...)
           |(pattern...+. np-pattern)
           |(pattern...patternellipsispattern.... np-pattern)
           
  np-pattern=_
           |id
           |#(pattern...)
           |#(pattern...patternellipsispattern...)
           |#&pattern
           |#s(key-datumpattern...)
           |#s(key-datumpattern...patternellipsispattern...)
           |(ellipsisstat-pattern)
           |const
           
stat-pattern=id
           |(stat-pattern...)
           |(stat-pattern...+. stat-pattern)
           |#(stat-pattern...)
           |#&stat-pattern
           |#s(key-datumstat-pattern...)
           |const
           
    ellipsis=...

_

id

(pattern...)

(pattern...+. np-pattern)

(pattern...patternellipsispattern...)

(pattern...patternellipsispattern.... np-pattern)

#(pattern...)

#(pattern...patternellipsispattern...)

#&pattern

#s(key-datumpattern...)

#s(key-datumpattern...patternellipsispattern...)

(ellipsisstat-pattern)

const
syntax
(syntax-case*stx-expr(literal-id...)id-compare-expr
clause...)
syntax
(with-syntax([patternstx-expr]...)
body...+)
syntax
(syntaxtemplate)

     template=id
            |(head-template...)
            |(head-template...+. template)
            |#(head-template...)
            |#&template
            |#s(key-datumhead-template...)
            |(~?templatetemplate)
            |(ellipsisstat-template)
            |const
            
head-template=template
            |head-templateellipsis...+
            |(~@. template)
            |(~?head-templatehead-template)
            |(~?head-template)
            
stat-template=like template, but without ..., ~?, and ~@
            
     ellipsis=...

id

(head-template...)

(head-template.... template)

#(head-template...)

#&template

#s(key-datumhead-template...)

(~?template1template2)

(ellipsisstat-template)

const

template

head-templateellipsis...+
syntax
(~@. template)
syntax
(~?head-template1head-template2)

(~?head-template)
syntax
(quasisyntaxtemplate)
syntax
(unsyntaxexpr)
syntax
(unsyntax-splicingexpr)
syntax
(syntax/locloc-exprtemplate)

loc-expr:(or/c#fsrcloc?syntax?
             (list/cany/c
             (or/cexact-positive-integer?#f)
             (or/cexact-nonnegative-integer?#f)
             (or/cexact-positive-integer?#f)
             (or/cexact-nonnegative-integer?#f))
             (vector/cany/c
             (or/cexact-positive-integer?#f)
             (or/cexact-nonnegative-integer?#f)
             (or/cexact-positive-integer?#f)
             (or/cexact-nonnegative-integer?#f)))
syntax
(quasisyntax/locloc-exprtemplate)

loc-expr:(or/c#fsrcloc?syntax?
             (list/cany/c
             (or/cexact-positive-integer?#f)
             (or/cexact-nonnegative-integer?#f)
             (or/cexact-positive-integer?#f)
             (or/cexact-nonnegative-integer?#f))
             (vector/cany/c
             (or/cexact-positive-integer?#f)
             (or/cexact-nonnegative-integer?#f)
             (or/cexact-positive-integer?#f)
             (or/cexact-nonnegative-integer?#f)))
syntax
(quote-syntax/pruneid)
syntax
(syntax-rules(literal-id...)
[(id. pattern)template]...)
syntax
(syntax-id-rules(literal-id...)
[patterntemplate]...)
syntax
(define-syntax-rule(id. pattern)template)
syntax
...
syntax
_
syntax
~?
syntax
~@
procedure
(syntax-pattern-variable?v)->boolean?
v:any/c
procedure
(syntax?v)->boolean?
v:any/c
procedure
(identifier?v)->boolean?
v:any/c
procedure
(syntax-sourcestx)->any/c
stx:syntax?
procedure
(syntax-linestx)->(or/cexact-positive-integer?#f)
stx:syntax?
procedure
(syntax-columnstx)->(or/cexact-nonnegative-integer?#f)
stx:syntax?
procedure
(syntax-positionstx)->(or/cexact-positive-integer?#f)
stx:syntax?
procedure
(syntax-spanstx)->(or/cexact-nonnegative-integer?#f)
stx:syntax?
procedure
(syntax-original?stx)->boolean?
stx:syntax?
procedure
(syntax-source-modulestx[source?])
->(or/cmodule-path-index?symbol?path?resolved-module-path?#f)
stx:syntax?
source?:any/c=#f
procedure
(syntax-estx)->any/c
stx:syntax?
procedure
(syntax->liststx)->(or/clist?#f)
stx:syntax?
procedure
(syntax->datumstx)->any/c
stx:syntax?
procedure
(datum->syntaxctxtv[srclocpropignored])->syntax?
ctxt:(or/csyntax?#f)
v:any/c
srcloc:(or/c#f
           syntax?
           srcloc?
           (list/cany/c
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f))
           (vector/cany/c
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)))
      =#f
prop:(or/csyntax?#f)=#f
ignored:(or/csyntax?#f)=#f
procedure
(syntax-binding-set?v)->boolean?
v:any/c
procedure
(syntax-binding-set)->syntax-binding-set?
procedure
(syntax-binding-set->syntaxbinding-set 
                          datum)     ->syntax?
binding-set:syntax-binding-set?
datum:any/c
procedure
(syntax-binding-set-extend                                               
                          binding-set                                  
                          symbol                                       
                          phase                                        
                          mpi                                          
                         [#:source-symbolsource-symbol                
                          #:source-phasesource-phase                  
                          #:nominal-modulenominal-mpi                 
                          #:nominal-phasenominal-phase                
                          #:nominal-symbolnominal-symbol              
                          #:nominal-require-phasenominal-require-phase
                          #:inspectorinspector])                      
->syntax-binding-set?
binding-set:syntax-binding-set?
symbol:symbol?
phase:(or/cexact-integer?#f)
mpi:module-path-index?
source-symbol:symbol?=symbol
source-phase:(or/cexact-integer?#f)=phase
nominal-mpi:module-path-index?=mpi
nominal-phase:(or/cexact-integer?#f)=source-phase
nominal-symbol:symbol?=source-symbol
nominal-require-phase:(or/cexact-integer?#f)=0
inspector:(or/cinspector?#f)=#f
procedure
(datum-intern-literalv)->any/c
v:any/c
procedure
(syntax-shift-phase-levelstxshift)->syntax?
stx:syntax?
shift:(or/cexact-integer?#f)
procedure
(generate-temporariesstx-pair)->(listofidentifier?)
stx-pair:(orsyntax?list?)
procedure
(identifier-prune-lexical-context id-stx 
                                [syms])->identifier?
id-stx:identifier?
syms:(listofsymbol?)=(list(syntax-eid-stx))
procedure
(identifier-prune-to-source-moduleid-stx)->identifier?
id-stx:identifier?
procedure
(syntax-recertifynew-stx   
                old-stx   
                inspector 
                key)     ->syntax?
new-stx:syntax?
old-stx:syntax?
inspector:inspector?
key:any/c
procedure
(syntax-debug-infostx[phaseall-bindings?])->hash?
stx:syntax?
phase:(or/cexact-integer?#f)=(syntax-local-phase-level)
all-bindings?:any/c=#f
procedure
(syntax-srclocstx)->(or/c#fsrcloc?)
stx:syntax?
procedure
(bound-identifier=?a-idb-id[phase-level])->boolean?
a-id:syntax?
b-id:syntax?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
procedure
(free-identifier=? a-id            
                  b-id            
                 [a-phase-level   
                  b-phase-level])->boolean?
a-id:identifier?
b-id:identifier?
a-phase-level:(or/cexact-integer?#f)
             =(syntax-local-phase-level)
b-phase-level:(or/cexact-integer?#f)=a-phase-level
procedure
(free-transformer-identifier=?a-idb-id)->boolean?
a-id:identifier?
b-id:identifier?
procedure
(free-template-identifier=?a-idb-id)->boolean?
a-id:identifier?
b-id:identifier?
procedure
(free-label-identifier=?a-idb-id)->boolean?
a-id:identifier?
b-id:identifier?
procedure
(check-duplicate-identifierids)->(or/cidentifier?#f)
ids:(listofidentifier?)
procedure
(identifier-binding id-stx           
                  [phase-level      
                   top-level-symbol?
                   exact-scopes?])  
->(or/c'lexical
    #f
    (list/cmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    exact-nonnegative-integer?
    phase+space-shift?
    phase+space?)
    (list/csymbol?))
id-stx:identifier?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
top-level-symbol?:any/c=#f
exact-scopes?:any/c=#f
procedure
(identifier-transformer-binding id-stx          
                              [rt-phase-level])
->(or/c'lexical
    #f
    (listofmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    exact-nonnegative-integer?
    phase+space-shift?
    phase+space?))
id-stx:identifier?
rt-phase-level:(or/cexact-integer?#f)
              =(syntax-local-phase-level)
procedure
(identifier-template-bindingid-stx)
->(or/c'lexical
    #f
    (listofmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    phase+space?
    phase+space-shift?
    phase+space?))
id-stx:identifier?
procedure
(identifier-label-bindingid-stx)
->(or/c'lexical
    #f
    (listofmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    exact-nonnegative-integer?
    phase+space-shift?
    phase+space?))
id-stx:identifier?
procedure
(identifier-distinct-binding id-stx       
                            wrt-id-stx   
                           [phase-level])
->(or/c'lexical
    #f
    (list/cmodule-path-index?
    symbol?
    module-path-index?
    symbol?
    exact-nonnegative-integer?
    phase+space-shift?
    phase+space?)
    (list/csymbol?))
id-stx:identifier?
wrt-id-stx:identifier?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
procedure
(identifier-binding-symbol id-stx        
                         [phase-level])->symbol?
id-stx:identifier?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
procedure
(identifier-binding-portal-syntax id-stx       
                                [phase-level])
->(or/c#fsyntax?)
id-stx:identifier?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
procedure
(syntax-bound-symbols stx             
                    [phase-level     
                     exact-scopes?])->(listofsymbol?)
stx:stx?
phase-level:(or/cexact-integer?#f)
           =(syntax-local-phase-level)
exact-scopes?:any/c=#f
procedure
(syntax-bound-phasesstx)->(listof(or/cexact-integer?#f))
stx:stx?
procedure
(set!-transformer?v)->boolean?
v:any/c
procedure
(make-set!-transformerproc)->set!-transformer?
proc:(syntax?. -> .syntax?)
procedure
(set!-transformer-proceduretransformer)
->(syntax?. -> .syntax?)
transformer:set!-transformer?
value
prop:set!-transformer:struct-type-property?
procedure
(rename-transformer?v)->boolean?
v:any/c
procedure
(make-rename-transformerid-stx)->rename-transformer?
id-stx:syntax?
procedure
(rename-transformer-targettransformer)->identifier?
transformer:rename-transformer?
value
prop:rename-transformer:struct-type-property?
procedure
(local-expand stx          
             context-v    
             stop-ids     
            [intdef-ctx])->syntax?
stx:any/c
context-v:(or/c'expression'top-level'module'module-beginlist?)
stop-ids:(or/c(listofidentifier?)empty#f)
intdef-ctx:(or/cinternal-definition-context?          =#f
               #f
               (listofinternal-definition-context?))
procedure
(syntax-local-expand-expression stx           
                              [opaque-only?])
->(ifopaque-only?#fsyntax?)syntax?
stx:any/c
opaque-only?:any/c=#f
procedure
(local-transformer-expand stx          
                         context-v    
                         stop-ids     
                        [intdef-ctx])->syntax?
stx:any/c
context-v:(or/c'expression'top-levellist?)
stop-ids:(or/c(listofidentifier?)#f)
intdef-ctx:(or/cinternal-definition-context?          =#f
               #f
               (listofinternal-definition-context?))
procedure
(local-expand/capture-lifts stx        
                           context-v  
                           stop-ids   
                          [intdef-ctx 
                           lift-ctx])->syntax?
stx:any/c
context-v:(or/c'expression'top-level'module'module-beginlist?)
stop-ids:(or/c(listofidentifier?)#f)
intdef-ctx:(or/cinternal-definition-context?          =#f
               #f
               (listofinternal-definition-context?))
lift-ctx:any/c=(gensym'lifts)
procedure
(local-transformer-expand/capture-lifts stx        
                                       context-v  
                                       stop-ids   
                                      [intdef-ctx 
                                       lift-ctx])->syntax?
stx:any/c
context-v:(or/c'expression'top-levellist?)
stop-ids:(or/c(listofidentifier?)#f)
intdef-ctx:(or/cinternal-definition-context?          =#f
               #f
               (listofinternal-definition-context?))
lift-ctx:any/c=(gensym'lifts)
procedure
(syntax-local-apply-transformertransformer 
                              binding-id  
                              context-v   
                              intdef-ctx  
                              v...)     ->any
transformer:procedure?
binding-id:(or/cidentifier?#f)
context-v:(or/c'expression'top-level'module'module-beginlist?)
intdef-ctx:(or/cinternal-definition-context?#f)
v:any/c
procedure
(internal-definition-context?v)->boolean?
v:any/c
procedure
(syntax-local-make-definition-context[parent-ctx  
                                     add-scope?])
->internal-definition-context?
parent-ctx:(or/cinternal-definition-context?#f)=#f
add-scope?:any/c=#t
procedure
(internal-definition-context-add-scopesintdef-ctx 
                                      stx)      ->syntax?
intdef-ctx:internal-definition-context?
stx:syntax?
procedure
(internal-definition-context-splice-binding-identifier           
                                                     intdef-ctx
                                                     id)       
->syntax?
intdef-ctx:internal-definition-context?
id:identifier?
procedure
(syntax-local-bind-syntaxes id-list            
                           expr               
                           intdef-ctx         
                          [extra-intdef-ctxs])
->(listofidentifier?)
id-list:(listofidentifier?)
expr:(or/csyntax?#f)
intdef-ctx:internal-definition-context?
extra-intdef-ctxs:(or/cinternal-definition-context?
                      (listofinternal-definition-context?))
                 ='()
procedure
(internal-definition-context-binding-identifiersintdef-ctx)
->(listofidentifier?)
intdef-ctx:internal-definition-context?
procedure
(internal-definition-context-introduce intdef-ctx 
                                      stx        
                                     [mode])    ->syntax?
intdef-ctx:internal-definition-context?
stx:syntax?
mode:(or/c'flip'add'remove)='flip
procedure
(internal-definition-context-sealintdef-ctx)->void?
intdef-ctx:internal-definition-context?
procedure
(identifier-remove-from-definition-contextid-stx     
                                         intdef-ctx)
->identifier?
id-stx:identifier?
intdef-ctx:(or/cinternal-definition-context?
               (listofinternal-definition-context?))
value
prop:expansion-contexts:struct-type-property?
procedure
(syntax-local-value id-stx        
                  [failure-thunk 
                   intdef-ctx]) ->any
id-stx:identifier?
failure-thunk:(or/c(->any)#f)=#f
intdef-ctx:(or/cinternal-definition-context?          =#f
               #f
               (listofinternal-definition-context?))
procedure
(syntax-local-value/immediate id-stx        
                            [failure-thunk 
                             intdef-ctx]) ->any
id-stx:syntax?
failure-thunk:(or/c(->any)#f)=#f
intdef-ctx:(or/cinternal-definition-context?          =#f
               #f
               (listofinternal-definition-context?))
procedure
(syntax-local-lift-expressionstx)->identifier?
stx:syntax?
procedure
(syntax-local-lift-values-expressionnstx)
->(listofidentifier?)
n:exact-nonnegative-integer?
stx:syntax?
procedure
(syntax-local-lift-context)->any/c
procedure
(syntax-local-lift-modulestx)->void?
stx:syntax?
procedure
(syntax-local-lift-module-end-declarationstx)->void?
stx:syntax?
procedure
(syntax-local-lift-requireraw-require-spec 
                         stx              
                         new-scope?)     ->syntax?
raw-require-spec:any/c
stx:syntax?
new-scope?:#t
procedure
(syntax-local-lift-provideraw-provide-spec-stx)->void?
raw-provide-spec-stx:syntax?
procedure
(syntax-local-name)->any/c
procedure
(syntax-local-context)
->(or/c'expression'top-level'module'module-beginlist?)
procedure
(syntax-local-phase-level)->exact-integer?
procedure
(syntax-local-module-exportsmod-path)
->(listof(cons/cphase+space?(listofsymbol?)))
mod-path:(or/cmodule-path?
             (syntax/cmodule-path?))
procedure
(syntax-local-submodules)->(listofsymbol?)
procedure
(syntax-local-module-interned-scope-symbols)
->(listofsymbol?)
procedure
(syntax-local-get-shadower id-stx            
                         [only-generated?])->identifier?
id-stx:identifier?
only-generated?:any/c=#f
procedure
(syntax-local-make-delta-introducerid-stx)->procedure?
id-stx:identifier?
procedure
(syntax-local-certifier[active?])
->((syntax?)(any/c(or/cprocedure?#f))
    . ->* .syntax?)
active?:boolean?=#f
procedure
(syntax-transforming?)->boolean?
procedure
(syntax-transforming-with-lifts?)->boolean?
procedure
(syntax-transforming-module-expression?)->boolean?
procedure
(syntax-local-identifier-as-binding id-stx       
                                  [intdef-ctx])->identifier?
id-stx:identifier?
intdef-ctx:(or/cinternal-definition-context?#f)=#f
procedure
(syntax-local-introducestx)->syntax?
stx:syntax?
procedure
(make-syntax-introducer[as-use-site?])
->((syntax?)((or/c'flip'add'remove)). ->* .syntax?)
as-use-site?:any/c=#f
procedure
(make-interned-syntax-introducerkey)
->((syntax?)((or/c'flip'add'remove)). ->* .syntax?)
key:(and/csymbol?symbol-interned?)
procedure
(make-syntax-delta-introducer ext-stx      
                             base-stx     
                            [phase-level])
->((syntax?)((or/c'flip'add'remove)). ->* .syntax?)
ext-stx:identifier?
base-stx:(or/csyntax?#f)
phase-level:(or/c#fexact-integer?)
           =(syntax-local-phase-level)
procedure
(syntax-local-transforming-module-provides?)->boolean?
procedure
(syntax-local-module-defined-identifiers)
->(and/chash?immutable?)
procedure
(syntax-local-module-required-identifiersmod-path
                                        shift)  
->(or/c(listof(cons/cphase+space?
    (listofidentifier?)))
    #f)
mod-path:(or/cmodule-path?#f)
shift:(or/c#tphase+space-shift?)
value
prop:liberal-define-context:struct-type-property?
procedure
(liberal-define-context?v)->boolean?
v:any/c
procedure
(expand-importrequire-spec)
->(listofimport?)(listofimport-source?)
require-spec:syntax?
procedure
(make-require-transformerproc)->require-transformer?
proc:(syntax?. -> .(values
         (listofimport?)
         (listofimport-source?)))
value
prop:require-transformer:struct-type-property?
procedure
(require-transformer?v)->boolean?
v:any/c
struct
(structimport(local-id
            src-sym
            src-mod-path
            mode
            req-mode
            orig-mode
            orig-stx)
#:extra-constructor-namemake-import)
local-id:identifier?
src-sym:symbol?
src-mod-path:(or/cmodule-path?
                 (syntax/cmodule-path?))
mode:phase+space?
req-mode:phase+space-shift?
orig-mode:phase+space?
orig-stx:syntax?
struct
(structimport-source(mod-path-stx mode)
#:extra-constructor-namemake-import-source)
mod-path-stx:(syntax/cmodule-path?)
mode:phase+space-shift?
parameter
(current-require-module-path)->(or/c#fmodule-path-index?)
(current-require-module-pathmodule-path)->void?
module-path:(or/c#fmodule-path-index?)
procedure
(convert-relative-module-pathmodule-path)
->(or/cmodule-path?
    (syntax/cmodule-path?))
module-path:(or/cmodule-path?
                (syntax/cmodule-path?))
procedure
(syntax-local-require-certifier)
->((syntax?)(or/c#f(syntax?. -> .syntax?))
    . ->* .syntax?)
procedure
(expand-exportprovide-specmodes)->(listofexport?)
provide-spec:syntax?
modes:(listofphase+space?)
procedure
(pre-expand-exportprovide-specmodes)->syntax?
provide-spec:syntax?
modes:(listofphase+space?)
procedure
(make-provide-transformerproc)->provide-transformer?
proc:(syntax?(listofphase+space?)
         . -> .(listofexport?))
(make-provide-transformerprocpre-proc)
->(and/cprovide-transformer?provide-pre-transformer?)
proc:(syntax?(listofphase+space?)
         . -> .(listofexport?))
pre-proc:(syntax?(listofphase+space?)
             . -> .syntax?)
procedure
(make-provide-pre-transformerpre-proc)
->provide-pre-transformer?
pre-proc:(syntax?(listofphase+space?)
             . -> .syntax?)
value
prop:provide-transformer:struct-type-property?
value
prop:provide-pre-transformer:struct-type-property?
procedure
(provide-transformer?v)->boolean?
v:any/c
procedure
(provide-pre-transformer?v)->boolean?
v:any/c
struct
(structexport(local-id out-sym mode protect? orig-stx)
#:extra-constructor-namemake-export)
local-id:identifier?
out-sym:symbol?
mode:phase+space?
protect?:any/c
orig-stx:syntax?
procedure
(syntax-local-provide-certifier)
->((syntax?)(or/c#f(syntax?. -> .syntax?))
    . ->* .syntax?)
procedure
(syntax-procedure-alias-propertystx)
->(or/c#f
    (letrec([val?(recursive-contract
    (or/c(cons/cidentifier?identifier?)
    (cons/cval?val?)))])
    val?))
stx:syntax?
procedure
(syntax-procedure-converted-arguments-propertystx)
->(or/c#f
    (letrec([val?(recursive-contract
    (or/c(cons/cidentifier?identifier?)
    (cons/cval?val?)))])
    val?))
stx:syntax?
procedure
(portal-syntax?v)->boolean?
v:any/c
procedure
(make-portal-syntaxstx)->portal-syntax?
stx:syntax?
procedure
(portal-syntax-contentportal)->syntax?
portal:portal-syntax?
syntax
(define-syntax-parameteridexpr)
syntax
(syntax-parameterize([idexpr]...)body-expr...+)
syntax
(define-rename-transformer-parameteridexpr)
procedure
(syntax-parameter-valueid-stx)->any
id-stx:syntax?
procedure
(make-parameter-rename-transformerid-stx)->any
id-stx:syntax?
syntax
splicing-let
syntax
splicing-letrec
syntax
splicing-let-values
syntax
splicing-letrec-values
syntax
splicing-let-syntax
syntax
splicing-letrec-syntax
syntax
splicing-let-syntaxes
syntax
splicing-letrec-syntaxes
syntax
splicing-letrec-syntaxes+values
syntax
splicing-local
syntax
splicing-parameterize
syntax
splicing-syntax-parameterize
procedure
(syntax-propertystxkeyv[preserved?])->syntax?
stx:syntax?
key:(ifpreserved?(and/csymbol?symbol-interned?)any/c)
v:any/c
preserved?:any/c=(eq?key'paren-shape)
(syntax-propertystxkey)->any
stx:syntax?
key:any/c
procedure
(syntax-property-removestxkey)->syntax?
stx:syntax?
key:any/c
procedure
(syntax-property-preserved?stxkey)->boolean?
stx:syntax?
key:(and/csymbol?symbol-interned?)
procedure
(syntax-property-symbol-keysstx)->list?
stx:syntax?
procedure
(syntax-track-originnew-stx  
                   orig-stx 
                   id-stx) ->any
new-stx:syntax?
orig-stx:syntax?
id-stx:identifier?
procedure
(syntax-tainted?stx)->boolean?
stx:syntax?
procedure
(syntax-armstx[inspectoruse-mode?])->syntax?
stx:syntax?
inspector:(or/cinspector?#f)=#f
use-mode?:any/c=#f
procedure
(syntax-protectstx)->syntax?
stx:syntax?
procedure
(syntax-disarmstxinspector)->syntax?
stx:syntax?
inspector:(or/cinspector?#f)
procedure
(syntax-rearmstxfrom-stx[use-mode?])->syntax?
stx:syntax?
from-stx:syntax?
use-mode?:any/c=#f
procedure
(syntax-taintstx)->syntax?
stx:syntax?
procedure
(expandtop-level-form[insp])->syntax?
top-level-form:any/c
insp:inspector?=(current-code-inspector)
procedure
(expand-syntaxstx[insp])->syntax?
stx:syntax?
insp:inspector?=(current-code-inspector)
procedure
(expand-oncetop-level-form[insp])->syntax?
top-level-form:any/c
insp:inspector?=(current-code-inspector)
procedure
(expand-syntax-oncestx[insp])->syntax?
stx:syntax?
insp:inspector?=(current-code-inspector)
procedure
(expand-to-top-formtop-level-form[insp])->syntax?
top-level-form:any/c
insp:inspector?=(current-code-inspector)
procedure
(expand-syntax-to-top-formstx[insp])->syntax?
stx:syntax?
insp:inspector?=(current-code-inspector)
procedure
(syntax-serialize                                                   
                 stx                                              
                 #:preserve-property-keyspreserve-property-keys  
                [#:provides-namespaceprovides-namespace          
                 #:base-module-path-indexbase-module-path-index])
->any/c
stx:syntax?
preserve-property-keys:(listofsymbol?)
provides-namespace:(or/cnamespace?#f)
                  =(current-namespace)
base-module-path-index:(or/cmodule-path-index?#f)=#f
procedure
(syntax-deserialize                                                   
                   v                                                
                  [#:base-module-path-indexbase-module-path-index])
->syntax?
v:any/c
base-module-path-index:(or/cmodule-path-index?#f)=#f
syntax
(includepath-spec)

path-spec=string
        |(filestring)
        |(libstring...+)
syntax
(include-at/relative-tocontextsourcepath-spec)
syntax
(include/readerpath-specreader-expr)
syntax
(include-at/relative-to/readercontextsourcepath-specreader-expr)
procedure
(format-id lctx                           
          fmt                            
          v...                          
         [#:sourcesrc                   
          #:propsprops                  
          #:certignored                 
          #:subs?subs?                  
          #:subs-introsubs-introducer])->identifier?
lctx:(or/csyntax?#f)
fmt:string?
v:(or/cstring?symbol?keyword?char?number?
      (syntax/c(or/cstring?symbol?keyword?char?number?)))
src:(or/csyntax?#f)=#f
props:(or/csyntax?#f)=#f
ignored:(or/csyntax?#f)=#f
subs?:boolean?=#f
subs-introducer:(->syntax?syntax?)
               =(if(syntax-transforming?)syntax-local-introducevalues)
procedure
(format-symbolfmtv...)->symbol?
fmt:string?
v:(or/cstring?symbol?keyword?char?number?
      (syntax/c(or/cstring?symbol?keyword?char?number?)))
syntax
(define/with-syntaxpatternstx-expr)

stx-expr:syntax?
parameter
(current-syntax-context)->(or/csyntax?false/c)
(current-syntax-contextstx)->void?
stx:(or/csyntax?false/c)
procedure
(wrong-syntaxstxformat-stringv...)->any
stx:syntax?
format-string:string?
v:any/c
parameter
(current-recorded-disappeared-uses)
->(or/c(listofidentifier?)false/c)
(current-recorded-disappeared-usesids)->void?
ids:(or/c(listofidentifier?)false/c)
syntax
(with-disappeared-usesbody-expr...stx-expr)

stx-expr:syntax?
procedure
(syntax-local-value/recordidpredicate)->any/c
id:identifier?
predicate:(->any/cboolean?)
procedure
(record-disappeared-usesid[intro?])->void?
id:(or/cidentifier?(listofidentifier?))
intro?:boolean?=(syntax-transforming?)
procedure
(generate-temporary[name-base])->identifier?
name-base:any/c='g
procedure
(internal-definition-context-applyintdef-ctx 
                                 stx)      ->syntax?
intdef-ctx:internal-definition-context?
stx:syntax?
procedure
(syntax-local-evalstx[intdef-ctx])->any
stx:any/c
intdef-ctx:(or/cinternal-definition-context?
               #f
               (listofinternal-definition-context?))
          ='()
syntax
(with-syntax*([patternstx-expr]...)
body...+)

stx-expr:syntax?
procedure
(phase?v)->boolean?
v:any/c
procedure
(space?v)->boolean?
v:any/c
procedure
(phase+space?v)->boolean?
v:any/c
procedure
(phase+spacephasespace)->phase+space?
phase:phase?
space:space?
procedure
(phase+space-phasep+s)->phase?
p+s:phase+space?
procedure
(phase+space-spacep+s)->phase?
p+s:phase+space?
procedure
(phase+space-shift?v)->boolean?
v:any/c
procedure
(phase+space+p+sshift)->phase+space?
p+s:phase+space?
shift:phase+space-shift?
procedure
(phase+space-shift+shiftadditional-shift)->phase+space-shift?
shift:phase+space?
additional-shift:phase+space-shift?
parameter
(current-locale)->(or/cstring?#f)
(current-localelocale)->void?
locale:(or/cstring?#f)
procedure
(input-port?v)->boolean?
v:any/c
procedure
(output-port?v)->boolean?
v:any/c
procedure
(port?v)->boolean?
v:any/c
procedure
(close-input-portin)->void?
in:input-port?
procedure
(close-output-portout)->void?
out:output-port?
procedure
(port-closed?port)->boolean?
port:port?
procedure
(port-closed-evtport)->evt?
port:port?
parameter
(current-input-port)->input-port?
(current-input-portin)->void?
in:input-port?
parameter
(current-output-port)->output-port?
(current-output-portout)->void?
out:output-port?
parameter
(current-error-port)->output-port?
(current-error-portout)->void?
out:output-port?
procedure
(file-stream-port?v)->boolean?
v:any/c
procedure
(terminal-port?v)->boolean?
v:any/c
procedure
(port-waiting-peer?port)->boolean?
port:port?
value
eof:eof-object?
procedure
(eof-object?v)->boolean?
v:any/c
procedure
(flush-output[out])->void?
out:output-port?=(current-output-port)
procedure
(file-stream-buffer-modeport)->(or/c'none'line'block#f)
port:port?
(file-stream-buffer-modeportmode)->void?
port:port?
mode:(or/c'none'line'block)
procedure
(file-positionport)->exact-nonnegative-integer?
port:port?
(file-positionportpos)->void?
port:port?
pos:(or/cexact-nonnegative-integer?eof-object?)
procedure
(file-position*port)->(or/cexact-nonnegative-integer?#f)
port:port?
procedure
(file-truncateportsize)->void?
port:(and/coutput-port?file-stream-port?)
size:exact-nonnegative-integer?
procedure
(port-count-lines!port)->void?
port:port?
procedure
(port-counts-lines?port)->boolean?
port:port?
procedure
(port-next-locationport)
->(or/cexact-positive-integer?#f)
    (or/cexact-nonnegative-integer?#f)
    (or/cexact-positive-integer?#f)
port:port?
procedure
(set-port-next-location!port      
                       line      
                       column    
                       position)->void?
port:port?
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:(or/cexact-positive-integer?#f)
parameter
(port-count-lines-enabled)->boolean?
(port-count-lines-enabledon?)->void?
on?:any/c
procedure
(open-input-file path                        
               [#:modemode-flag            
                #:for-module?for-module?])->input-port?
path:path-string?
mode-flag:(or/c'binary'text)='binary
for-module?:any/c=#f
procedure
(open-output-file path                                        
                [#:modemode-flag                            
                 #:existsexists-flag                        
                 #:permissionspermissions]                  
                 #:replace-permissions?replace-permissions?)
->output-port?
path:path-string?
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update'can-update
                'replace'truncate
                'must-truncate'truncate/replace)
           ='error
permissions:(integer-in065535)=#o666
replace-permissions?:#f
procedure
(open-input-output-file                                              
                       path                                        
                      [#:modemode-flag                            
                       #:existsexists-flag                        
                       #:permissionspermissions]                  
                       #:replace-permissions?replace-permissions?)
->input-port?output-port?
path:path-string?
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update'can-update
                'replace'truncate
                'must-truncate'truncate/replace)
           ='error
permissions:(integer-in065535)=#o666
replace-permissions?:#f
procedure
(call-with-input-file path               
                     proc               
                    [#:modemode-flag])->any
path:path-string?
proc:(input-port?. -> .any)
mode-flag:(or/c'binary'text)='binary
procedure
(call-with-output-file                                              
                      path                                        
                      proc                                        
                     [#:modemode-flag                            
                      #:existsexists-flag                        
                      #:permissionspermissions]                  
                      #:replace-permissions?replace-permissions?)
->any
path:path-string?
proc:(output-port?. -> .any)
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update'can-update
                'replace'truncate
                'must-truncate'truncate/replace)
           ='error
permissions:(integer-in065535)=#o666
replace-permissions?:#f
procedure
(call-with-input-file* path               
                      proc               
                     [#:modemode-flag])->any
path:path-string?
proc:(input-port?. -> .any)
mode-flag:(or/c'binary'text)='binary
procedure
(call-with-output-file*                                              
                       path                                        
                       proc                                        
                      [#:modemode-flag                            
                       #:existsexists-flag                        
                       #:permissionspermissions]                  
                       #:replace-permissions?replace-permissions?)
->any
path:path-string?
proc:(output-port?. -> .any)
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update'can-update
                'replace'truncate
                'must-truncate'truncate/replace)
           ='error
permissions:(integer-in065535)=#o666
replace-permissions?:#f
procedure
(with-input-from-file path               
                     thunk              
                    [#:modemode-flag])->any
path:path-string?
thunk:(->any)
mode-flag:(or/c'binary'text)='binary
procedure
(with-output-to-file                                              
                    path                                        
                    thunk                                       
                   [#:modemode-flag                            
                    #:existsexists-flag                        
                    #:permissionspermissions]                  
                    #:replace-permissions?replace-permissions?)
->any
path:path-string?
thunk:(->any)
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update'can-update
                'replace'truncate
                'must-truncate'truncate/replace)
           ='error
permissions:(integer-in065535)=#o666
replace-permissions?:#f
procedure
(port-try-file-lock?portmode)->boolean?
port:file-stream-port?
mode:(or/c'shared'exclusive)
procedure
(port-file-unlockport)->void?
port:file-stream-port?
procedure
(port-file-identityport)->exact-positive-integer?
port:file-stream-port?
procedure
(string-port?p)->boolean?
p:port?
procedure
(open-input-bytesbstr[name])->(and/cinput-port?string-port?)
bstr:bytes?
name:any/c='string
procedure
(open-input-stringstr[name])->(and/cinput-port?string-port?)
str:string?
name:any/c='string
procedure
(open-output-bytes[name])->(and/coutput-port?string-port?)
name:any/c='string
procedure
(open-output-string[name])->(and/coutput-port?string-port?)
name:any/c='string
procedure
(get-output-bytes out       
                [reset?    
                 start-pos 
                 end-pos])->bytes?
out:(and/coutput-port?string-port?)
reset?:any/c=#f
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=#f
procedure
(get-output-stringout)->string?
out:(and/coutput-port?string-port?)
procedure
(make-pipe[limitinput-nameoutput-name])
->input-port?output-port?
limit:exact-positive-integer?=#f
input-name:any/c='pipe
output-name:any/c='pipe
procedure
(pipe-content-lengthpipe-port)->exact-nonnegative-integer?
pipe-port:port?
value
prop:input-port:struct-type-property?
value
prop:output-port:struct-type-property?
procedure
(make-input-port name             
                read-in          
                peek             
                close            
               [get-progress-evt 
                commit           
                get-location     
                count-lines!     
                init-position    
                buffer-mode])   ->input-port?
name:any/c
read-in:(or/c
            (bytes?
            . -> .(or/cexact-nonnegative-integer?
            eof-object?
            procedure?
            evt?))
            input-port?)
peek:(or/c
         (bytes?exact-nonnegative-integer?(or/cevt?#f)
         . -> .(or/cexact-nonnegative-integer?
         eof-object?
         procedure?
         evt?
         #f))
         input-port?
         #f)
close:(->any)
get-progress-evt:(or/c(->evt?)#f)=#f
commit:(or/c(exact-positive-integer?evt?evt?. -> .any)
           #f)
      =#f
get-location:(or/c
                 (->
                 (values(or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
            =#f
count-lines!:(->any)=void
init-position:(or/cexact-positive-integer?
                  port?
                  #f
                  (->(or/cexact-positive-integer?#f)))
             =1
buffer-mode:(or/c(case->((or/c'block'none). -> .any)
                (->(or/c'block'none#f)))
                #f)
           =#f
procedure
(make-output-port name                  
                 evt                   
                 write-out             
                 close                 
                [write-out-special     
                 get-write-evt         
                 get-write-special-evt 
                 get-location          
                 count-lines!          
                 init-position         
                 buffer-mode])        ->output-port?
name:any/c
evt:evt?
write-out:(or/c
              (bytes?exact-nonnegative-integer?
              exact-nonnegative-integer?
              boolean?
              boolean?
              . -> .
              (or/cexact-nonnegative-integer?
              #f
              evt?))
              output-port?)
close:(->any)
write-out-special:(or/c(any/cboolean?boolean?=#f
                      . -> .
                      (or/cany/c
                      #f
                      evt?))
                      output-port?
                      #f)
get-write-evt:(or/c                              =#f
                  (bytes?exact-nonnegative-integer?
                  exact-nonnegative-integer?
                  . -> .
                  evt?)
                  #f)
get-write-special-evt:(or/c               =#f
                          (any/c. -> .evt?)
                          #f)
get-location:(or/c
                 (->
                 (values(or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
            =#f
count-lines!:(->any)=void
init-position:(or/cexact-positive-integer?
                  port?
                  #f
                  (->(or/cexact-positive-integer?#f)))
             =1
buffer-mode:(or/c(case->
                ((or/c'block'line'none). -> .any)
                (->(or/c'block'line'none#f)))
                #f)
           =#f
procedure
(port->list[rin])->(listofany/c)
r:(input-port?. -> .any/c)=read
in:input-port?=(current-input-port)
procedure
(port->string[in#:close?close?])->string?
in:input-port?=(current-input-port)
close?:any/c=#f
procedure
(port->bytes[in#:close?close?])->bytes?
in:input-port?=(current-input-port)
close?:any/c=#f
procedure
(port->lines[in                    
            #:line-modeline-mode 
            #:close?close?])    ->(listofstring?)
in:input-port?=(current-input-port)
line-mode:(or/c'linefeed'return'return-linefeed'any'any-one)
         ='any
close?:any/c=#f
procedure
(port->bytes-lines[in                    
                  #:line-modeline-mode 
                  #:close?close?])    ->(listofbytes?)
in:input-port?=(current-input-port)
line-mode:(or/c'linefeed'return'return-linefeed'any'any-one)
         ='any
close?:any/c=#f
procedure
(display-lines lst                     
             [out                     
              #:separatorseparator])->void?
lst:list?
out:output-port?=(current-output-port)
separator:any/c=#"\n"
procedure
(call-with-output-stringproc)->string?
proc:(output-port?. -> .any)
procedure
(call-with-output-bytesproc)->bytes?
proc:(output-port?. -> .any)
procedure
(with-output-to-stringproc)->string?
proc:(->any)
procedure
(with-output-to-bytesproc)->bytes?
proc:(->any)
procedure
(call-with-input-stringstrproc)->any
str:string?
proc:(input-port?. -> .any)
procedure
(call-with-input-bytesbstrproc)->any
bstr:bytes?
proc:(input-port?. -> .any)
procedure
(with-input-from-stringstrproc)->any
str:string?
proc:(->any)
procedure
(with-input-from-bytesbstrproc)->any
bstr:bytes?
proc:(->any)
procedure
(input-port-append close-at-eof? 
                  in...        
                 [#:namename])->input-port?
close-at-eof?:any/c
in:input-port?
name:any/c=(mapobject-namein)
procedure
(make-input-port/read-to-peek name          
                             read-in       
                             fast-peek     
                             close         
                            [get-location  
                             count-lines!  
                             init-position 
                             buffer-mode   
                             buffering?    
                             on-consumed])->input-port?
name:any/c
read-in:(bytes?
            . -> .(or/cexact-nonnegative-integer?
            eof-object?
            procedure?
            evt?))
fast-peek:(or/c#f
              (bytes?exact-nonnegative-integer?
              (bytes?exact-nonnegative-integer?
              . -> .(or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?
              #f))
              . -> .(or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?
              #f)))
close:(->any)
get-location:(or/c                                  =#f
                 (->
                 (values
                 (or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
count-lines!:(->any)=void
init-position:exact-positive-integer?=1
buffer-mode:(or/c(case->((or/c'block'none). -> .any)
                (->(or/c'block'none#f)))
                #f)
           =#f
buffering?:any/c=#f
on-consumed:(or/c((or/cexact-nonnegative-integer?eof-object?
                procedure?evt?)
                . -> .any)
                #f)
           =#f
procedure
(make-limited-input-port in            
                        limit         
                       [close-orig?])->input-port?
in:input-port?
limit:exact-nonnegative-integer?
close-orig?:any/c=#t
procedure
(make-pipe-with-specials[limit      
                        in-name    
                        out-name])->input-port?output-port?
limit:exact-nonnegative-integer?=#f
in-name:any/c='pipe
out-name:any/c='pipe
procedure
(combine-outputa-outb-out)->output-port?
a-out:output-port?
b-out:output-port?
procedure
(merge-inputa-inb-in[buffer-limit])->input-port?
a-in:input-port?
b-in:input-port?
buffer-limit:(or/cexact-nonnegative-integer?#f)=4096
procedure
(open-output-nowhere[namespecial-ok?])->output-port?
name:any/c='nowhere
special-ok?:any/c=#t
procedure
(peeking-input-port in                             
                  [name                           
                   skip                           
                   #:init-positioninit-position])
->input-port?
in:input-port?
name:any/c=(object-namein)
skip:exact-nonnegative-integer?=0
init-position:exact-positive-integer?=1
procedure
(reencode-input-port in                
                    encoding          
                   [error-bytes       
                    close?            
                    name              
                    convert-newlines? 
                    enc-error])      ->input-port?
in:input-port?
encoding:string?
error-bytes:(or/c#fbytes?)=#f
close?:any/c=#f
name:any/c=(object-namein)
convert-newlines?:any/c=#f
enc-error:(string?input-port?. -> .any)
         =(lambda(msgport)(error...))
procedure
(reencode-output-port out           
                     encoding      
                    [error-bytes   
                     close?        
                     name          
                     newline-bytes 
                     enc-error])  ->output-port?
out:output-port?
encoding:string?
error-bytes:(or/c#fbytes?)=#f
close?:any/c=#f
name:any/c=(object-nameout)
newline-bytes:(or/c#fbytes?)=#f
enc-error:(string?output-port?. -> .any)
         =(lambda(msgport)(error...))
procedure
(dup-input-portin[close?])->input-port?
in:input-port?
close?:any/c=#f
procedure
(dup-output-portout[close?])->output-port?
out:output-port?
close?:any/c=#f
procedure
(relocate-input-port in           
                    line         
                    column       
                    position     
                   [close?]      
                    #:namename)->input-port?
in:input-port?
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:exact-positive-integer?
close?:any/c=#t
name:(object-namein)
procedure
(relocate-output-port out          
                     line         
                     column       
                     position     
                    [close?]      
                     #:namename)->output-port?
out:output-port?
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:exact-positive-integer?
close?:any/c=#t
name:(object-nameout)
procedure
(transplant-input-port in            
                      get-location  
                      init-pos      
                     [close?        
                      count-lines!] 
                      #:namename) ->input-port?
in:input-port?
get-location:(or/c
                 (->
                 (values
                 (or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
init-pos:exact-positive-integer?
close?:any/c=#t
count-lines!:(->any)=void
name:(object-namein)
procedure
(transplant-output-port out           
                       get-location  
                       init-pos      
                      [close?        
                       count-lines!] 
                       #:namename) ->output-port?
out:output-port?
get-location:(or/c
                 (->
                 (values
                 (or/cexact-positive-integer?#f)
                 (or/cexact-nonnegative-integer?#f)
                 (or/cexact-positive-integer?#f)))
                 #f)
init-pos:exact-positive-integer?
close?:any/c=#t
count-lines!:(->any)=void
name:(object-nameout)
procedure
(filter-read-input-port in        
                       read-wrap 
                       peek-wrap 
                      [close?]) ->input-port?
in:input-port?
read-wrap:(bytes?(or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?)
              . -> .
              (or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?))
peek-wrap:(bytes?exact-nonnegative-integer?(or/cevt?#f)
              (or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?
              #f)
              . -> .(or/cexact-nonnegative-integer?
              eof-object?
              procedure?
              evt?
              #f))
close?:any/c=#t
procedure
(special-filter-input-portinproc[close?])->input-port?
in:input-port?
proc:(procedure?bytes?. -> .(or/cexact-nonnegative-integer?
         eof-object?
         procedure?
         evt?))
close?:any/c=#t
procedure
(eof-evtin)->evt?
in:input-port?
procedure
(read-bytes-evtkin)->evt?
k:exact-nonnegative-integer?
in:input-port?
procedure
(read-bytes!-evtbstrin)->evt?
bstr:(and/cbytes?(not/cimmutable?))
in:input-port?
procedure
(read-bytes-avail!-evtbstrin)->evt?
bstr:(and/cbytes?(not/cimmutable?))
in:input-port?
procedure
(read-string-evtkin)->evt?
k:exact-nonnegative-integer?
in:input-port?
procedure
(read-string!-evtstrin)->evt?
str:(and/cstring?(not/cimmutable?))
in:input-port?
procedure
(read-line-evtin[mode])->evt?
in:input-port?
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='linefeed
procedure
(read-bytes-line-evtin[mode])->evt?
in:input-port?
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='linefeed
procedure
(peek-bytes-evtkskipprogress-evtin)->evt?
k:exact-nonnegative-integer?
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
(peek-bytes!-evtbstrskipprogress-evtin)->evt?
bstr:(and/cbytes?(not/cimmutable?))
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
(peek-bytes-avail!-evtbstr         
                     skip         
                     progress-evt 
                     in)         ->evt?
bstr:(and/cbytes?(not/cimmutable?))
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
(peek-string-evtkskipprogress-evtin)->evt?
k:exact-nonnegative-integer?
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
(peek-string!-evtstrskipprogress-evtin)->evt?
str:(and/cstring?(not/cimmutable?))
skip:exact-nonnegative-integer?
progress-evt:(or/cprogress-evt?#f)
in:input-port?
procedure
(regexp-match-evtpatternin)->any
pattern:(or/cstring?bytes?regexp?byte-regexp?)
in:input-port?
procedure
(convert-streamfrom-encoding 
              in            
              to-encoding   
              out)         ->void?
from-encoding:string?
in:input-port?
to-encoding:string?
out:output-port?
procedure
(copy-portinout...+)->void?
in:input-port?
out:output-port?
procedure
(read-char[in])->(or/cchar?eof-object?)
in:input-port?=(current-input-port)
procedure
(read-byte[in])->(or/cbyte?eof-object?)
in:input-port?=(current-input-port)
procedure
(read-line[inmode])->(or/cstring?eof-object?)
in:input-port?=(current-input-port)
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='linefeed
procedure
(read-bytes-line[inmode])->(or/cbytes?eof-object?)
in:input-port?=(current-input-port)
mode:(or/c'linefeed'return'return-linefeed'any'any-one)
    ='linefeed
procedure
(read-stringamt[in])->(or/cstring?eof-object?)
amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
procedure
(read-bytesamt[in])->(or/cbytes?eof-object?)
amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
procedure
(read-string!str[instart-posend-pos])
->(or/cexact-nonnegative-integer?eof-object?)
str:(and/cstring?(not/cimmutable?))
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(string-lengthstr)
procedure
(read-bytes!bstr[instart-posend-pos])
->(or/cexact-nonnegative-integer?eof-object?)
bstr:bytes?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(read-bytes-avail!bstr[instart-posend-pos])
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:bytes?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(read-bytes-avail!* bstr     
                  [in       
                   start-pos
                   end-pos])
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:bytes?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(read-bytes-avail!/enable-break bstr     
                              [in       
                               start-pos
                               end-pos])
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:bytes?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(peek-stringamtskip-bytes-amt[in])->(or/cstring?eof-object?)
amt:exact-nonnegative-integer?
skip-bytes-amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
procedure
(peek-bytesamtskip-bytes-amt[in])->(or/cbytes?eof-object?)
amt:exact-nonnegative-integer?
skip-bytes-amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
procedure
(peek-string! str           
             skip-bytes-amt
            [in            
             start-pos     
             end-pos])     
->(or/cexact-nonnegative-integer?eof-object?)
str:(and/cstring?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(string-lengthstr)
procedure
(peek-bytes! bstr          
            skip-bytes-amt
           [in            
            start-pos     
            end-pos])     
->(or/cexact-nonnegative-integer?eof-object?)
bstr:(and/cbytes?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(peek-bytes-avail! bstr          
                  skip-bytes-amt
                 [progress      
                  in            
                  start-pos     
                  end-pos])     
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:(and/cbytes?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
progress:(or/cprogress-evt?#f)=#f
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(peek-bytes-avail!* bstr          
                   skip-bytes-amt
                  [progress      
                   in            
                   start-pos     
                   end-pos])     
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:(and/cbytes?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
progress:(or/cprogress-evt?#f)=#f
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(peek-bytes-avail!/enable-break bstr          
                               skip-bytes-amt
                              [progress      
                               in            
                               start-pos     
                               end-pos])     
->(or/cexact-nonnegative-integer?eof-object?procedure?)
bstr:(and/cbytes?(not/cimmutable?))
skip-bytes-amt:exact-nonnegative-integer?
progress:(or/cprogress-evt?#f)=#f
in:input-port?=(current-input-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(read-char-or-special[in           
                     special-wrap 
                     source-name])
->(or/cchar?eof-object?any/c)
in:input-port?=(current-input-port)
special-wrap:(or/c(any/c->any/c)#f)=#f
source-name:any/c=#f
procedure
(read-byte-or-special[in           
                     special-wrap 
                     source-name])
->(or/cbyte?eof-object?any/c)
in:input-port?=(current-input-port)
special-wrap:(or/c(any/c->any/c)#f)=#f
source-name:any/c=#f
procedure
(peek-char[inskip-bytes-amt])->(or/cchar?eof-object?)
in:input-port?=(current-input-port)
skip-bytes-amt:exact-nonnegative-integer?=0
procedure
(peek-byte[inskip-bytes-amt])->(or/cbyte?eof-object?)
in:input-port?=(current-input-port)
skip-bytes-amt:exact-nonnegative-integer?=0
procedure
(peek-char-or-special[in            
                     skip-bytes-amt
                     special-wrap  
                     source-name]) 
->(or/cchar?eof-object?any/c)
in:input-port?=(current-input-port)
skip-bytes-amt:exact-nonnegative-integer?=0
special-wrap:(or/c(any/c->any/c)#f'special)=#f
source-name:any/c=#f
procedure
(peek-byte-or-special[in            
                     skip-bytes-amt
                     progress      
                     special-wrap  
                     source-name]) 
->(or/cbyte?eof-object?any/c)
in:input-port?=(current-input-port)
skip-bytes-amt:exact-nonnegative-integer?=0
progress:(or/cprogress-evt?#f)=#f
special-wrap:(or/c(any/c->any/c)#f'special)=#f
source-name:any/c=#f
procedure
(port-progress-evt[in])->progress-evt?
in:(and/cinput-port?port-provides-progress-evts?)
  =(current-input-port)
procedure
(port-provides-progress-evts?in)->boolean
in:input-port?
procedure
(port-commit-peekedamtprogressevt[in])->boolean?
amt:exact-nonnegative-integer?
progress:progress-evt?
evt:evt?
in:input-port?=(current-input-port)
procedure
(byte-ready?[in])->boolean?
in:input-port?=(current-input-port)
procedure
(char-ready?[in])->boolean?
in:input-port?=(current-input-port)
procedure
(progress-evt?v)->boolean?
v:any/c
(progress-evt?evtin)->boolean?
evt:progress-evt?
in:input-port?
procedure
(write-charchar[out])->void?
char:char?
out:output-port?=(current-output-port)
procedure
(write-bytebyte[out])->void?
byte:byte?
out:output-port?=(current-output-port)
procedure
(newline[out])->void?
out:output-port?=(current-output-port)
procedure
(write-stringstr[outstart-posend-pos])
->exact-nonnegative-integer?
str:string?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(string-lengthstr)
procedure
(write-bytesbstr[outstart-posend-pos])
->exact-nonnegative-integer?
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-bytes-avail bstr      
                 [out       
                  start-pos 
                  end-pos])->exact-nonnegative-integer?
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-bytes-avail* bstr     
                  [out      
                   start-pos
                   end-pos])
->(or/cexact-nonnegative-integer?#f)
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-bytes-avail/enable-break bstr     
                              [out      
                               start-pos
                               end-pos])
->exact-nonnegative-integer?
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-specialv[out])->boolean?
v:any/c
out:output-port?=(current-output-port)
procedure
(write-special-avail*v[out])->boolean?
v:any/c
out:output-port?=(current-output-port)
procedure
(write-bytes-avail-evt bstr      
                     [out       
                      start-pos 
                      end-pos])->evt?
bstr:bytes?
out:output-port?=(current-output-port)
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(write-special-evtv[out])->evt?
v:any/c
out:output-port?=(current-output-port)
procedure
(port-writes-atomic?out)->boolean?
out:output-port?
procedure
(port-writes-special?out)->boolean?
out:output-port?
procedure
(read[in])->any
in:input-port?=(current-input-port)
procedure
(read-syntax[source-namein])->(or/csyntax?eof-object?)
source-name:any/c=(object-name(current-input-port))
in:input-port?=(current-input-port)
procedure
(read/recursive[instartreadtablegraph?])->any
in:input-port?=(current-input-port)
start:(or/cchar?#f)=#f
readtable:(or/creadtable?#f)=(current-readtable)
graph?:any/c=#t
procedure
(read-syntax/recursive[source-name 
                      in          
                      start       
                      readtable   
                      graph?])   ->any
source-name:any/c=(object-namein)
in:input-port?=(current-input-port)
start:(or/cchar?#f)=#f
readtable:(or/creadtable?#f)=(current-readtable)
graph?:any/c=#t
procedure
(read-language[infail-thunk])
->(or/c(any/cany/c. -> .any)#f)
in:input-port?=(current-input-port)
fail-thunk:(->any)=(lambda()(error...))
parameter
(read-case-sensitive)->boolean?
(read-case-sensitiveon?)->void?
on?:any/c
parameter
(read-square-bracket-as-paren)->boolean?
(read-square-bracket-as-parenon?)->void?
on?:any/c
parameter
(read-curly-brace-as-paren)->boolean?
(read-curly-brace-as-parenon?)->void?
on?:any/c
parameter
(read-square-bracket-with-tag)->boolean?
(read-square-bracket-with-tagon?)->void?
on?:any/c
parameter
(read-curly-brace-with-tag)->boolean?
(read-curly-brace-with-tagon?)->void?
on?:any/c
parameter
(read-accept-box)->boolean?
(read-accept-boxon?)->void?
on?:any/c
parameter
(read-accept-compiled)->boolean?
(read-accept-compiledon?)->void?
on?:any/c
parameter
(read-accept-bar-quote)->boolean?
(read-accept-bar-quoteon?)->void?
on?:any/c
parameter
(read-accept-graph)->boolean?
(read-accept-graphon?)->void?
on?:any/c
parameter
(read-syntax-accept-graph)->boolean?
(read-syntax-accept-graphon?)->void?
on?:any/c
parameter
(read-decimal-as-inexact)->boolean?
(read-decimal-as-inexacton?)->void?
on?:any/c
parameter
(read-single-flonum)->boolean?
(read-single-flonumon?)->void?
on?:any/c
parameter
(read-accept-dot)->boolean?
(read-accept-doton?)->void?
on?:any/c
parameter
(read-accept-infix-dot)->boolean?
(read-accept-infix-doton?)->void?
on?:any/c
parameter
(read-cdot)->boolean?
(read-cdoton?)->void?
on?:any/c
parameter
(read-accept-quasiquote)->boolean?
(read-accept-quasiquoteon?)->void?
on?:any/c
parameter
(read-accept-reader)->boolean?
(read-accept-readeron?)->void?
on?:any/c
parameter
(read-accept-lang)->boolean?
(read-accept-langon?)->void?
on?:any/c
parameter
(current-readtable)->(or/creadtable?#f)
(current-readtablereadtable)->void?
readtable:(or/creadtable?#f)
procedure
(call-with-default-reading-parameterizationthunk)->any
thunk:(->any)
parameter
(current-reader-guard)->(any/c. -> .any)
(current-reader-guardproc)->void?
proc:(any/c. -> .any)
parameter
(read-on-demand-source)
->(or/c#f#t(and/cpath?complete-path?))
(read-on-demand-sourcemode)->void?
mode:(or/c#f#t(and/cpath?complete-path?))
procedure
(port-read-handlerin)->(case->
                          (input-port?. -> .any)
                          (input-port?any/c. -> .any))
in:input-port?
(port-read-handlerinproc)->void?
in:input-port?
proc:(case->
         (input-port?. -> .any)
         (input-port?any/c. -> .any))
procedure
(writedatum[out])->void?
datum:any/c
out:output-port?=(current-output-port)
procedure
(displaydatum[out])->void?
datum:any/c
out:output-port?=(current-output-port)
procedure
(printdatum[outquote-depth])->void?
datum:any/c
out:output-port?=(current-output-port)
quote-depth:(or/c01)=0
procedure
(writelndatum[out])->void?
datum:any/c
out:output-port?=(current-output-port)
procedure
(displaylndatum[out])->void?
datum:any/c
out:output-port?=(current-output-port)
procedure
(printlndatum[outquote-depth])->void?
datum:any/c
out:output-port?=(current-output-port)
quote-depth:(or/c01)=0
procedure
(fprintfoutformv...)->void?
out:output-port?
form:string?
v:any/c
procedure
(printfformv...)->void?
form:string?
v:any/c
procedure
(eprintfformv...)->void?
form:string?
v:any/c
procedure
(formatformv...)->string?
form:string?
v:any/c
parameter
(print-pair-curly-braces)->boolean?
(print-pair-curly-braceson?)->void?
on?:any/c
parameter
(print-mpair-curly-braces)->boolean?
(print-mpair-curly-braceson?)->void?
on?:any/c
parameter
(print-unreadable)->boolean?
(print-unreadableon?)->void?
on?:any/c
parameter
(print-graph)->boolean?
(print-graphon?)->void?
on?:any/c
parameter
(print-struct)->boolean?
(print-structon?)->void?
on?:any/c
parameter
(print-box)->boolean?
(print-boxon?)->void?
on?:any/c
parameter
(print-vector-length)->boolean?
(print-vector-lengthon?)->void?
on?:any/c
parameter
(print-hash-table)->boolean?
(print-hash-tableon?)->void?
on?:any/c
parameter
(print-boolean-long-form)->boolean?
(print-boolean-long-formon?)->void?
on?:any/c
parameter
(print-reader-abbreviations)->boolean?
(print-reader-abbreviationson?)->void?
on?:any/c
parameter
(print-as-expression)->boolean?
(print-as-expressionon?)->void?
on?:any/c
parameter
(print-syntax-width)
->(or/c+inf.00(and/cexact-integer?(>/c3)))
(print-syntax-widthwidth)->void?
width:(or/c+inf.00(and/cexact-integer?(>/c3)))
parameter
(print-value-columns)
->(or/c+inf.0(and/cexact-integer?(>/c5)))
(print-value-columnscolumns)->void?
columns:(or/c+inf.0(and/cexact-integer?(>/c5)))
parameter
(current-write-relative-directory)
->(or/c(and/cpath?complete-path?)
    (cons/c(and/cpath?complete-path?)
    (and/cpath?complete-path?))
    #f)
(current-write-relative-directorypath)->void?
path:(or/c(and/cpath-string?complete-path?)
         (cons/c(and/cpath-string?complete-path?)
         (and/cpath-string?complete-path?))
         #f)
procedure
(port-write-handlerout)->(any/coutput-port?. -> .any)
out:output-port?
(port-write-handleroutproc)->void?
out:output-port?
proc:(any/coutput-port?. -> .any)
procedure
(port-display-handlerout)->(any/coutput-port?. -> .any)
out:output-port?
(port-display-handleroutproc)->void?
out:output-port?
proc:(any/coutput-port?. -> .any)
procedure
(port-print-handlerout)
->((any/coutput-port?)((or/c01)). ->* .any)
out:output-port?
(port-print-handleroutproc)->void?
out:output-port?
proc:(any/coutput-port?. -> .any)
procedure
(global-port-print-handler)
->(->*(any/coutput-port?)((or/c01))any)
(global-port-print-handlerproc)->void?
proc:(or/c(->*(any/coutput-port?)((or/c01))any)
         (any/coutput-port?. -> .any))
procedure
(pretty-print v                     
            [port                  
             quote-depth           
             #:newline?newline?])->void?
v:any/c
port:output-port?=(current-output-port)
quote-depth:(or/c01)=0
newline?:boolean?=#t
procedure
(pretty-writev[port#:newline?newline?])->void?
v:any/c
port:output-port?=(current-output-port)
newline?:boolean?=#t
procedure
(pretty-displayv[port#:newline?newline?])->void?
v:any/c
port:output-port?=(current-output-port)
newline?:boolean?=#t
procedure
(pretty-formatv[columns#:modemode])->string?
v:any/c
columns:exact-nonnegative-integer?=(pretty-print-columns)
mode:(or/c'print'write'display)='print
procedure
(pretty-print-handlerv)->void?
v:any/c
parameter
(pretty-print-columns)
->(or/cexact-positive-integer?'infinity)
(pretty-print-columnswidth)->void?
width:(or/cexact-positive-integer?'infinity)
parameter
(pretty-print-depth)->(or/cexact-nonnegative-integer?#f)
(pretty-print-depthdepth)->void?
depth:(or/cexact-nonnegative-integer?#f)
parameter
(pretty-print-exact-as-decimal)->boolean?
(pretty-print-exact-as-decimalas-decimal?)->void?
as-decimal?:any/c
parameter
(pretty-print-.-symbol-without-bars)->boolean?
(pretty-print-.-symbol-without-barson?)->void?
on?:any/c
parameter
(pretty-print-show-inexactness)->boolean?
(pretty-print-show-inexactnessshow?)->void?
show?:any/c
parameter
(pretty-print-abbreviate-read-macros)->boolean?
(pretty-print-abbreviate-read-macrosabbrev?)->void?
abbrev?:any/c
procedure
(pretty-print-style-table?v)->boolean?
v:any/c
parameter
(pretty-print-current-style-table)->pretty-print-style-table?
(pretty-print-current-style-tablestyle-table)->void?
style-table:pretty-print-style-table?
procedure
(pretty-print-extend-style-tablestyle-table      
                               symbol-list      
                               like-symbol-list)
->pretty-print-style-table?
style-table:pretty-print-style-table?
symbol-list:(listofsymbol?)
like-symbol-list:(listofsymbol?)
parameter
(pretty-print-remap-stylable)
->(any/c. -> .(or/csymbol?#f))
(pretty-print-remap-stylableproc)->void?
proc:(any/c. -> .(or/csymbol?#f))
procedure
(pretty-print-newlineportwidth)->void?
port:output-port?
width:exact-nonnegative-integer?
parameter
(pretty-print-print-line)
->((or/cexact-nonnegative-integer?#f)
    output-port?
    exact-nonnegative-integer?
    (or/cexact-nonnegative-integer?'infinity)
    . -> .
    exact-nonnegative-integer?)
(pretty-print-print-lineproc)->void?
proc:((or/cexact-nonnegative-integer?#f)
         output-port?
         exact-nonnegative-integer?
         (or/cexact-nonnegative-integer?'infinity)
         . -> .
         exact-nonnegative-integer?)
parameter
(pretty-print-size-hook)
->(any/cboolean?output-port?
    . -> .
    (or/c#fexact-nonnegative-integer?))
(pretty-print-size-hookproc)->void?
proc:(any/cboolean?output-port?
         . -> .
         (or/c#fexact-nonnegative-integer?))
parameter
(pretty-print-print-hook)
->(any/cboolean?output-port?. -> .void?)
(pretty-print-print-hookproc)->void?
proc:(any/cboolean?output-port?. -> .void?)
parameter
(pretty-print-pre-print-hook)
->(any/coutput-port?. -> .void)
(pretty-print-pre-print-hookproc)->void?
proc:(any/coutput-port?. -> .void)
parameter
(pretty-print-post-print-hook)
->(any/coutput-port?. -> .void)
(pretty-print-post-print-hookproc)->void?
proc:(any/coutput-port?. -> .void)
parameter
(pretty-printing)->boolean?
(pretty-printingon?)->void?
on?:any/c
procedure
(make-tentative-pretty-print-output-portout            
                                       width          
                                       overflow-thunk)
->output-port?
out:output-port?
width:exact-nonnegative-integer?
overflow-thunk:(->any)
procedure
(tentative-pretty-print-port-transfertentative-out 
                                    orig-out)    ->void?
tentative-out:output-port?
orig-out:output-port?
procedure
(tentative-pretty-print-port-canceltentative-out)->void?
tentative-out:output-port?
procedure
(readtable?v)->boolean?
v:any/c
procedure
(make-readtablereadtablekeymodeaction...)->readtable?
readtable:(or/creadtable?#f)
key:(or/cchar?#f)
mode:(or/c'terminating-macro
         'non-terminating-macro
         'dispatch-macro
         char?)
action:(or/cprocedure?
           readtable?
           #f)
procedure
(readtable-mappingreadtablechar)
->(or/cchar?
    'terminating-macro
    'non-terminating-macro)
    (or/c#fprocedure?)
    (or/c#fprocedure?)
readtable:readtable?
char:char?
procedure
(make-special-commentv)->special-comment?
v:any/c
procedure
(special-comment?v)->boolean?
v:any/c
procedure
(special-comment-valuesc)->any
sc:special-comment?
value
gen:custom-write:any/c
value
prop:custom-write:struct-type-property?
procedure
(custom-write?v)->boolean?
v:any/c
procedure
(custom-write-accessorv)
->(custom-write?output-port?(or/c#t#f01). -> .any)
v:custom-write?
value
prop:custom-print-quotable:struct-type-property?
value
custom-print-quotable?:struct-type-property?
value
custom-print-quotable-accessor:struct-type-property?
procedure
(serializable?v)->boolean?
v:any/c
procedure
(serialize                                                            
          v                                                         
         [#:relative-directoryrelative-to                          
          #:deserialize-relative-directorydeserialize-relative-to])
->any
v:serializable?
relative-to:(or/c(and/cpath?complete-path?)         =#f
                (cons/c(and/cpath?complete-path?)
                (and/cpath?complete-path?))
                #f)
deserialize-relative-to:(or/c(and/cpath?complete-path?)
                            (cons/c(and/cpath?complete-path?)
                            (and/cpath?complete-path?))
                            #f)
                       =relative-to
procedure
(deserializev)->any
v:any/c
procedure
(serialized=?v1v2)->boolean?
v1:any/c
v2:any/c
parameter
(deserialize-module-guard)
->(->module-path?symbol?
    (or/cvoid?(cons/cmodule-path?symbol?)))
(deserialize-module-guardguard)->void?
guard:(->module-path?symbol?
          (or/cvoid?(cons/cmodule-path?symbol?)))
syntax
(serializable-structidmaybe-super(field...)
struct-option...)
syntax
(define-serializable-structid-maybe-super(field...)
struct-option...)
syntax
(serializable-struct/versionsidmaybe-supervers(field...)
(other-version-clause...)
struct-option...)

other-version-clause=(other-versmake-proc-expr
                       cycle-make-proc-expr)
syntax
(define-serializable-struct/versionsid-maybe-supervers(field...)
(other-version-clause...)
struct-option...)
procedure
(make-deserialize-infomakecycle-make)->any
make:procedure?
cycle-make:(->(valuesany/cprocedure?))
value
prop:serializable:property?
procedure
(make-serialize-infoto-vector      
                   deserialize-id 
                   can-cycle?     
                   dir)          ->any
to-vector:(any/c. -> .vector?)
deserialize-id:(oridentifier?
                   symbol?
                   (cons/csymbol?
                   module-path-index?)
                   (->any/c))
can-cycle?:any/c
dir:path-string?
procedure
(s-exp->fasl v                              
           [out                            
            #:keep-mutable?keep-mutable?  
            #:handle-failhandle-fail      
            #:external-lift?external-lift?
            #:skip-prefix?skip-prefix?])  
->(or/c(void)bytes?)
v:any/c
out:(or/coutput-port?#f)=#f
keep-mutable?:any/c=#f
handle-fail:(or/c#f(any/c. -> .any/c))=#f
external-lift?:(or/c#f(any/c. -> .any/c))=#f
skip-prefix?:any/c=#f
procedure
(fasl->s-exp in                              
           [#:datum-intern?datum-intern?   
            #:external-liftsexternal-lifts 
            #:skip-prefix?skip-prefix?])  ->any/c
in:(or/cinput-port?bytes?)
datum-intern?:any/c=#t
external-lifts:vector?='#()
skip-prefix?:any/c=#f
procedure
(sha1-bytesin[startend])->bytes?
in:(or/cbytes?input-port?)
start:exact-nonnegative-integer?=0
end:(or/c#fexact-nonnegative-integer?)=#f
procedure
(sha224-bytesin[startend])->bytes?
in:(or/cbytes?input-port?)
start:exact-nonnegative-integer?=0
end:(or/c#fexact-nonnegative-integer?)=#f
procedure
(sha256-bytesin[startend])->bytes?
in:(or/cbytes?input-port?)
start:exact-nonnegative-integer?=0
end:(or/c#fexact-nonnegative-integer?)=#f
procedure
(namespace?v)->boolean?
v:any/c
procedure
(make-empty-namespace)->namespace?
procedure
(make-base-empty-namespace)->namespace?
procedure
(make-base-namespace)->namespace?
syntax
(define-namespace-anchorid)
procedure
(namespace-anchor?v)->boolean?
v:any/c
procedure
(namespace-anchor->empty-namespacea)->namespace?
a:namespace-anchor?
procedure
(namespace-anchor->namespacea)->namespace?
a:namespace-anchor?
parameter
(current-namespace)->namespace?
(current-namespacen)->void?
n:namespace?
procedure
(namespace-symbol->identifiersym)->identifier?
sym:symbol?
procedure
(namespace-base-phase[namespace])->exact-integer?
namespace:namespace?=(current-namespace)
procedure
(namespace-module-identifier[where])->identifier?
where:(or/cnamespace?exact-integer?#f)
     =(current-namespace)
procedure
(namespace-variable-value sym           
                        [use-mapping?  
                         failure-thunk 
                         namespace])  ->any
sym:symbol?
use-mapping?:any/c=#t
failure-thunk:(or/c(->any)#f)=#f
namespace:namespace?=(current-namespace)
procedure
(namespace-set-variable-value! sym            
                              v              
                             [map?           
                              namespace      
                              as-constant?])->void?
sym:symbol?
v:any/c
map?:any/c=#f
namespace:namespace?=(current-namespace)
as-constant?:any/c=#f
procedure
(namespace-undefine-variable! sym         
                            [namespace])->void?
sym:symbol?
namespace:namespace?=(current-namespace)
procedure
(namespace-mapped-symbols[namespace])->(listofsymbol?)
namespace:namespace?=(current-namespace)
procedure
(namespace-require quoted-raw-require-spec 
                 [namespace])            ->void?
quoted-raw-require-spec:any/c
namespace:namespace?=(current-namespace)
procedure
(namespace-require/copy quoted-raw-require-spec 
                      [namespace])            ->void?
quoted-raw-require-spec:any/c
namespace:namespace?=(current-namespace)
procedure
(namespace-require/constant quoted-raw-require-spec 
                          [namespace])            ->void?
quoted-raw-require-spec:any/c
namespace:namespace?=(current-namespace)
procedure
(namespace-require/expansion-time quoted-raw-require-spec
                                [namespace])            
->void?
quoted-raw-require-spec:any/c
namespace:namespace?=(current-namespace)
procedure
(namespace-attach-module src-namespace    
                        modname          
                       [dest-namespace])->void?
src-namespace:namespace?
modname:(ormodule-path?resolved-module-path?)
dest-namespace:namespace?=(current-namespace)
procedure
(namespace-attach-module-declaration src-namespace    
                                    modname          
                                   [dest-namespace])->void?
src-namespace:namespace?
modname:module-path?
dest-namespace:namespace?=(current-namespace)
procedure
(namespace-unprotect-module inspector   
                           modname     
                          [namespace])->void?
inspector:inspector?
modname:module-path?
namespace:namespace?=(current-namespace)
procedure
(namespace-module-registrynamespace)->any
namespace:namespace?
procedure
(namespace-call-with-registry-locknamespace 
                                 thunk)   ->any
namespace:namespace?
thunk:(->any)
procedure
(module->namespacemod[src-namespace])->namespace?
mod:(or/cmodule-path?
        resolved-module-path?
        module-path-index?)
src-namespace:namespace?=(current-namespace)
procedure
(namespace-syntax-introducestx[namespace])->syntax?
stx:syntax?
namespace:namespace?=(current-namespace)
procedure
(module-provide-protected?module-path-index 
                         sym)             ->boolean?
module-path-index:(or/csymbol?module-path-index?)
sym:symbol?
procedure
(variable-reference?v)->boolean?
v:any/c
procedure
(variable-reference-constant?varref)->boolean?
varref:variable-reference?
procedure
(variable-reference->empty-namespacevarref)->namespace?
varref:variable-reference?
procedure
(variable-reference->namespacevarref)->namespace?
varref:variable-reference?
procedure
(variable-reference->resolved-module-pathvarref)
->(or/cresolved-module-path?#f)
varref:variable-reference?
procedure
(variable-reference->module-path-indexvarref)
->(or/cmodule-path-index?#f)
varref:variable-reference?
procedure
(variable-reference->module-sourcevarref)
->(or/csymbol?(and/cpath?complete-path?)#f)
varref:variable-reference?
procedure
(variable-reference->phasevarref)->exact-nonnegative-integer?
varref:variable-reference?
procedure
(variable-reference->module-base-phasevarref)->exact-integer?
varref:variable-reference?
procedure
(variable-reference->module-declaration-inspectorvarref)
->inspector?
varref:variable-reference?
procedure
(variable-reference-from-unsafe?varref)->boolean?
varref:variable-reference?
parameter
(current-eval)->(any/c. -> .any)
(current-evalproc)->void?
proc:(any/c. -> .any)
procedure
(evaltop-level-form)->any
top-level-form:any/c
(evaltop-level-formnamespace)->any
top-level-form:any/c
namespace:namespace?
procedure
(eval-syntaxstx)->any
stx:syntax?
(eval-syntaxstxnamespace)->any
stx:syntax?
namespace:namespace?
parameter
(current-load)
->(path?(or/c#f
    symbol?
    (cons/c(or/c#fsymbol?)
    (non-empty-listofsymbol?)))
    . -> .
    any)
(current-loadproc)->void?
proc:(path?(or/c#f
         symbol?
         (cons/c(or/c#fsymbol?)
         (non-empty-listofsymbol?)))
         . -> .
         any)
procedure
(loadfile)->any
file:path-string?
procedure
(load-relativefile)->any
file:path-string?
procedure
(load/cdfile)->any
file:path-string?
parameter
(current-load-extension)
->(path?(or/c#f
    symbol?
    (cons/c(or/c#fsymbol?)
    (non-empty-listofsymbol?)))
    . -> .
    any)
(current-load-extensionproc)->void?
proc:(path?(or/c#f
         symbol?
         (cons/c(or/c#fsymbol?)
         (non-empty-listofsymbol?)))
         . -> .
         any)
procedure
(load-extensionfile)->any
file:path-string?
procedure
(load-relative-extensionfile)->any
file:path-string?
parameter
(current-load/use-compiled)
->(path?(or/c#f
    symbol?
    (cons/c(or/c#fsymbol?)
    (non-empty-listofsymbol?)))
    . -> .any)
(current-load/use-compiledproc)->void?
proc:(path?(or/c#f
         symbol?
         (cons/c(or/c#fsymbol?)
         (non-empty-listofsymbol?)))
         . -> .any)
procedure
(load/use-compiledfile)->any
file:path-string?
parameter
(current-load-relative-directory)
->(or/c(and/cpath-string?complete-path?)#f)
(current-load-relative-directorypath)->void?
path:(or/c(and/cpath-string?complete-path?)#f)
parameter
(use-compiled-file-paths)
->(listof(and/cpath?relative-path?))
(use-compiled-file-pathspaths)->void?
paths:(listof(and/cpath-string?relative-path?))
parameter
(current-compiled-file-roots)->(listof(or/cpath?'same))
(current-compiled-file-rootspaths)->void?
paths:(listof(or/cpath-string?'same))
procedure
(find-compiled-file-roots)->(listof(or/cpath?'same))
parameter
(use-compiled-file-check)->(or/c'modify-seconds'exists)
(use-compiled-file-checkcheck)->void?
check:(or/c'modify-seconds'exists)
procedure
(read-eval-print-loop)->any
parameter
(current-prompt-read)->(->any)
(current-prompt-readproc)->void?
proc:(->any)
parameter
(current-get-interaction-input-port)->(->input-port?)
(current-get-interaction-input-portproc)->void?
proc:(->input-port?)
parameter
(current-get-interaction-evt)->(->evt?)
(current-get-interaction-evtproc)->void?
proc:(->evt?)
parameter
(current-read-interaction)->(any/cinput-port?->any)
(current-read-interactionproc)->void?
proc:(any/cinput-port?->any)
parameter
(current-print)->(any/c->any)
(current-printproc)->void?
proc:(any/c->any)
parameter
(current-compile)
->(any/cboolean?. -> .compiled-expression?)
(current-compileproc)->void?
proc:(any/cboolean?. -> .compiled-expression?)
procedure
(compiletop-level-form)->compiled-expression?
top-level-form:any/c
procedure
(compile-syntaxstx)->compiled-expression?
stx:syntax?
procedure
(compiled-expression-recompilece)->compiled-expression?
ce:compiled-expression?
procedure
(compiled-expression?v)->boolean?
v:any/c
parameter
(compile-enforce-module-constants)->boolean?
(compile-enforce-module-constantson?)->void?
on?:any/c
parameter
(compile-allow-set!-undefined)->boolean?
(compile-allow-set!-undefinedallow?)->void?
allow?:any/c
parameter
(compile-context-preservation-enabled)->boolean?
(compile-context-preservation-enabledon?)->void?
on?:any/c
parameter
(current-compile-target-machine)
->(or/c#f(and/csymbol?compile-target-machine?))
(current-compile-target-machinetarget)->void?
target:(or/c#f(and/csymbol?compile-target-machine?))
procedure
(compile-target-machine?sym)->boolean?
sym:symbol?
parameter
(current-compile-realm)->symbol?
(current-compile-realmrealm)->void?
realm:symbol?
parameter
(eval-jit-enabled)->boolean?
(eval-jit-enabledon?)->void?
on?:any/c
parameter
(load-on-demand-enabled)->boolean?
(load-on-demand-enabledon?)->void?
on?:any/c
procedure
(resolved-module-path?v)->boolean?
v:any/c
procedure
(make-resolved-module-pathpath)->resolved-module-path?
path:(or/csymbol?
         (and/cpath?complete-path?)
         (cons/c(or/csymbol?
         (and/cpath?complete-path?))
         (non-empty-listofsymbol?)))
procedure
(resolved-module-path-namemodule-path)
->(or/csymbol?
    (and/cpath?complete-path?)
    (cons/c(or/csymbol?
    (and/cpath?complete-path?))
    (non-empty-listofsymbol?)))
module-path:resolved-module-path?
procedure
(module-path?v)->boolean?
v:any/c
parameter
(current-module-name-resolver)
->(case->
    (resolved-module-path?(or/c#fnamespace?). -> .any)
    (module-path?
    (or/c#fresolved-module-path?)
    (or/c#fsyntax?)
    boolean?
    . -> .
    resolved-module-path?))
(current-module-name-resolverproc)->void?
proc:(case->
         (resolved-module-path?(or/c#fnamespace?). -> .any)
         (module-path?
         (or/c#fresolved-module-path?)
         (or/c#fsyntax?)
         boolean?
         . -> .
         resolved-module-path?))
parameter
(current-module-declare-name)
->(or/cresolved-module-path?#f)
(current-module-declare-namename)->void?
name:(or/cresolved-module-path?#f)
parameter
(current-module-declare-source)
->(or/csymbol?(and/cpath?complete-path?)#f)
(current-module-declare-sourcesrc)->void?
src:(or/csymbol?(and/cpath?complete-path?)#f)
parameter
(current-module-path-for-load)
->(or/c#fmodule-path?
    (and/csyntax?
    (lambda(stx)
    (module-path?(syntax->datums)))))
(current-module-path-for-loadpath)->void?
path:(or/c#fmodule-path?
         (and/csyntax?
         (lambda(stx)
         (module-path?(syntax->datums)))))
procedure
(module-path-index?v)->boolean?
v:any/c
procedure
(module-path-index-resolve mpi       
                         [load?     
                          src-stx])->resolved-module-path?
mpi:module-path-index?
load?:any/c=#f
src-stx:(or/csyntax?#f)=#f
procedure
(module-path-index-splitmpi)
->(or/cmodule-path?#f)
    (or/cmodule-path-index?resolved-module-path?#f)
mpi:module-path-index?
procedure
(module-path-index-submodulempi)
->(or/c#f(non-empty-listofsymbol?))
mpi:module-path-index?
procedure
(module-path-index-joinpathbase[submod])->module-path-index?
path:(or/cmodule-path?#f)
base:(or/cmodule-path-index?resolved-module-path?#f)
submod:(or/c#f(non-empty-listofsymbol?))=#f
procedure
(compiled-module-expression?v)->boolean?
v:any/c
procedure
(module-compiled-namecompiled-module-code)
->(or/csymbol?(cons/csymbol?(non-empty-listofsymbol?)))
compiled-module-code:compiled-module-expression?
(module-compiled-namecompiled-module-code
                    name)               
->compiled-module-expression?
compiled-module-code:compiled-module-expression?
name:(or/csymbol?(cons/csymbol?(non-empty-listofsymbol?)))
procedure
(module-compiled-submodulescompiled-module-code
                          non-star?)          
->(listofcompiled-module-expression?)
compiled-module-code:compiled-module-expression?
non-star?:any/c
(module-compiled-submodulescompiled-module-code
                          non-star?           
                          submodules)         
->compiled-module-expression?
compiled-module-code:compiled-module-expression?
non-star?:any/c
submodules:(listofcompiled-module-expression?)
procedure
(module-compiled-importscompiled-module-code)
->(listof(cons/c(or/cexact-integer?#f)
    (listofmodule-path-index?)))
compiled-module-code:compiled-module-expression?
procedure
(module-compiled-exports compiled-module-code
                       [verbosity])         
->(listof(cons/cphase+space?list?))
    (listof(cons/cphase+space?list?))
compiled-module-code:compiled-module-expression?
verbosity:(or/c#f'defined-names)=#f
procedure
(module-compiled-indirect-exportscompiled-module-code)
->(listof(cons/cexact-integer?(listofsymbol?)))
compiled-module-code:compiled-module-expression?
procedure
(module-compiled-language-infocompiled-module-code)
->(or/c#f(vector/cmodule-path?symbol?any/c))
compiled-module-code:compiled-module-expression?
procedure
(module-compiled-cross-phase-persistent?compiled-module-code)
->boolean?
compiled-module-code:compiled-module-expression?
procedure
(module-compiled-realmcompiled-module-code)->symbol?
compiled-module-code:compiled-module-expression?
procedure
(dynamic-requiremodprovided[fail-thunk])->(or/cvoid?any/c)
mod:(or/cmodule-path?
        resolved-module-path?
        module-path-index?)
provided:(or/csymbol?#f0void?)
fail-thunk:(->any)=(lambda()....)
procedure
(dynamic-require-for-syntax mod          
                           provided     
                          [fail-thunk])->any
mod:module-path?
provided:(or/csymbol?#f)
fail-thunk:(->any)=(lambda()....)
procedure
(module-declared?mod[load?])->boolean?
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
load?:any/c=#f
procedure
(module->language-infomod[load?])
->(or/c#f(vector/cmodule-path?symbol?any/c))
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
load?:any/c=#f
procedure
(module->importsmod)
->(listof(cons/c(or/cexact-integer?#f)
    (listofmodule-path-index?)))
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
procedure
(module->exportsmod[verbosity])
->(listof(cons/cphase+space?list?))
    (listof(cons/cphase+space?list?))
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
verbosity:(or/c#f'defined-names)=#f
procedure
(module->indirect-exportsmod)
->(listof(cons/cexact-integer?(listofsymbol?)))
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
procedure
(module->realmmod)->symbol?
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
procedure
(module-predefined?mod)->boolean?
mod:(or/cmodule-path?module-path-index?
        resolved-module-path?)
procedure
(module-cache-clear!)->void?
procedure
(impersonator?v)->boolean?
v:any/c
procedure
(chaperone?v)->boolean?
v:any/c
procedure
(impersonator-of?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(chaperone-of?v1v2)->boolean?
v1:any/c
v2:any/c
procedure
(impersonator-ephemeronv)->ephemeron?
v:any/c
procedure
(procedure-impersonator*?v)->boolean?
v:any/c
procedure
(impersonate-procedureproc        
                     wrapper-proc
                     prop        
                     prop-val...
                     ...)        
->(and/cprocedure?impersonator?)
proc:procedure?
wrapper-proc:(or/cprocedure?#f)
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-procedure*proc        
                      wrapper-proc
                      prop        
                      prop-val...
                      ...)        
->(and/cprocedure?impersonator?)
proc:procedure?
wrapper-proc:(or/cprocedure?#f)
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-struct v                 
                  [struct-type]      
                   orig-proc         
                   redirect-proc... 
                   ...               
                   prop              
                   prop-val...      
                   ...)             ->any/c
v:any/c
struct-type:struct-type?=unspecified
orig-proc:(or/cstruct-accessor-procedure?
              struct-mutator-procedure?
              struct-type-property-accessor-procedure?)
redirect-proc:(or/cprocedure?#f)
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-vectorvec         
                  ref-proc    
                  set-proc    
                  prop        
                  prop-val...
                  ...)        
->(and/cvector?impersonator?)
vec:(and/cvector?(not/cimmutable?))
ref-proc:(or/c(vector?exact-nonnegative-integer?any/c. ->
.any/c)#f)
set-proc:(or/c(vector?exact-nonnegative-integer?any/c. ->
.any/c)#f)
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-vector*vec         
                   ref-proc    
                   set-proc    
                   prop        
                   prop-val...
                   ...)        
->(and/cvector?impersonator?)
vec:(and/cvector?(not/cimmutable?))
ref-proc:(or/c(vector?vector?exact-nonnegative-integer?any/c.
-> .any/c)#f)
set-proc:(or/c(vector?vector?exact-nonnegative-integer?any/c.
-> .any/c)#f)
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-boxbox          
               unbox-proc   
               set-proc     
               prop         
               prop-val... 
               ...)        ->(and/cbox?impersonator?)
box:(and/cbox?(not/cimmutable?))
unbox-proc:(box?any/c. -> .any/c)
set-proc:(box?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-hash hash            
                 ref-proc        
                 set-proc        
                 remove-proc     
                 key-proc        
                [clear-proc      
                 equal-key-proc] 
                 prop            
                 prop-val...    
                 ...)           ->(and/chash?impersonator?)
hash:(and/chash?(not/cimmutable?))
ref-proc:(hash?any/c. -> .(values
             any/c
             (hash?any/cany/c. -> .any/c)))
set-proc:(hash?any/cany/c. -> .(valuesany/cany/c))
remove-proc:(hash?any/c. -> .any/c)
key-proc:(hash?any/c. -> .any/c)
clear-proc:(or/c#f(hash?. -> .any))=#f
equal-key-proc:(or/c#f(hash?any/c. -> .any/c))=#f
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-channelchannel     
                   get-proc    
                   put-proc    
                   prop        
                   prop-val...
                   ...)        
->(and/cchannel?impersonator?)
channel:channel?
get-proc:(channel?. -> .(valueschannel?(any/c. -> .any/c)))
put-proc:(channel?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-prompt-tag prompt-tag              
                       handle-proc             
                       abort-proc              
                      [cc-guard-proc           
                       callcc-impersonate-proc]
                       prop                    
                       prop-val...            
                       ...)                    
->(and/ccontinuation-prompt-tag?impersonator?)
prompt-tag:continuation-prompt-tag?
handle-proc:procedure?
abort-proc:procedure?
cc-guard-proc:procedure?=values
callcc-impersonate-proc:(procedure?. -> .procedure?)
                       =(lambda(p)p)
prop:impersonator-property?
prop-val:any/c
procedure
(impersonate-continuation-mark-keykey         
                                 get-proc    
                                 set-proc    
                                 prop        
                                 prop-val...
                                 ...)        
->(and/ccontinuation-mark?impersonator?)
key:continuation-mark-key?
get-proc:procedure?
set-proc:procedure?
prop:impersonator-property?
prop-val:any/c
value
prop:impersonator-of:struct-type-property?
value
prop:authentic:struct-type-property?
procedure
(chaperone-procedureproc        
                   wrapper-proc
                   prop        
                   prop-val...
                   ...)        
->(and/cprocedure?chaperone?)
proc:procedure?
wrapper-proc:(or/cprocedure?#f)
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-procedure*proc        
                    wrapper-proc
                    prop        
                    prop-val...
                    ...)        
->(and/cprocedure?chaperone?)
proc:procedure?
wrapper-proc:(or/cprocedure?#f)
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-struct v                 
                [struct-type]      
                 orig-proc         
                 redirect-proc... 
                 ...               
                 prop              
                 prop-val...      
                 ...)             ->any/c
v:any/c
struct-type:struct-type?=unspecified
orig-proc:(or/cstruct-accessor-procedure?
              struct-mutator-procedure?
              struct-type-property-accessor-procedure?
              (one-of/cstruct-info))
redirect-proc:(or/cprocedure?#f)
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-vectorvec          
                ref-proc     
                set-proc     
                prop         
                prop-val... 
                ...)        ->(and/cvector?chaperone?)
vec:vector?
ref-proc:(or/c(vector?exact-nonnegative-integer?any/c. ->
.any/c)#f)
set-proc:(or/c(vector?exact-nonnegative-integer?any/c. ->
.any/c)#f)
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-vector*vec          
                 ref-proc     
                 set-proc     
                 prop         
                 prop-val... 
                 ...)        ->(and/cvector?chaperone?)
vec:(and/cvector?(not/cimmutable?))
ref-proc:(or/c(vector?vector?exact-nonnegative-integer?any/c.
-> .any/c)#f)
set-proc:(or/c(vector?vector?exact-nonnegative-integer?any/c.
-> .any/c)#f)
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-boxbox          
             unbox-proc   
             set-proc     
             prop         
             prop-val... 
             ...)        ->(and/cbox?chaperone?)
box:box?
unbox-proc:(box?any/c. -> .any/c)
set-proc:(box?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-hash hash            
               ref-proc        
               set-proc        
               remove-proc     
               key-proc        
              [clear-proc      
               equal-key-proc] 
               prop            
               prop-val...    
               ...)           ->(and/chash?chaperone?)
hash:hash?
ref-proc:(hash?any/c. -> .(values
             any/c
             (hash?any/cany/c. -> .any/c)))
set-proc:(hash?any/cany/c. -> .(valuesany/cany/c))
remove-proc:(hash?any/c. -> .any/c)
key-proc:(hash?any/c. -> .any/c)
clear-proc:(or/c#f(hash?. -> .any))=#f
equal-key-proc:(or/c#f(hash?any/c. -> .any/c))=#f
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-struct-typestruct-type          
                     struct-info-proc     
                     make-constructor-proc
                     guard-proc           
                     prop                 
                     prop-val...         
                     ...)                 
->(and/cstruct-type?chaperone?)
struct-type:struct-type?
struct-info-proc:procedure?
make-constructor-proc:(procedure?. -> .procedure?)
guard-proc:procedure?
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-evtevtprocpropprop-val......)
->(and/cevt?chaperone?)
evt:evt?
proc:(evt?. -> .(valuesevt?(any/c. -> .any/c)))
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-channelchannel      
                 get-proc     
                 put-proc     
                 prop         
                 prop-val... 
                 ...)        ->(and/cchannel?chaperone?)
channel:channel?
get-proc:(channel?. -> .(valueschannel?(any/c. -> .any/c)))
put-proc:(channel?any/c. -> .any/c)
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-prompt-tag prompt-tag            
                     handle-proc           
                     abort-proc            
                    [cc-guard-proc         
                     callcc-chaperone-proc]
                     prop                  
                     prop-val...          
                     ...)                  
->(and/ccontinuation-prompt-tag?chaperone?)
prompt-tag:continuation-prompt-tag?
handle-proc:procedure?
abort-proc:procedure?
cc-guard-proc:procedure?=values
callcc-chaperone-proc:(procedure?. -> .procedure?)
                     =(lambda(p)p)
prop:impersonator-property?
prop-val:any/c
procedure
(chaperone-continuation-mark-keykey         
                               get-proc    
                               set-proc    
                               prop        
                               prop-val...
                               ...)        
->(and/ccontinuation-mark-key?chaperone?)
key:continuation-mark-key?
get-proc:procedure?
set-proc:procedure?
prop:impersonator-property?
prop-val:any/c
procedure
(make-impersonator-propertyname)
->impersonator-property?
    (->any/cboolean?)
    (->*(impersonator?)(any/c)any)
name:symbol?
procedure
(impersonator-property?v)->boolean?
v:any/c
procedure
(impersonator-property-accessor-procedure?v)->boolean?
v:any/c
value
impersonator-prop:application-mark:impersonator-property?
procedure
(security-guard?v)->boolean?
v:any/c
procedure
(make-security-guard parent        
                    file-guard    
                    network-guard 
                   [link-guard]) ->security-guard?
parent:security-guard?
file-guard:(symbol?
               (or/cpath?#f)
               (listofsymbol?)
               . -> .any)
network-guard:(symbol?
                  (or/c(and/cstring?immutable?)#f)
                  (or/c(integer-in165535)#f)
                  (or/c'server'client)
                  . -> .any)
link-guard:(or/c(symbol?path?path?. -> .any)#f)=#f
parameter
(current-security-guard)->security-guard?
(current-security-guardguard)->void?
guard:security-guard?
procedure
(custodian?v)->boolean?
v:any/c
procedure
(make-custodian[cust])->custodian?
cust:(and/ccustodian?(not/ccustodian-shut-down?))
    =(current-custodian)
procedure
(custodian-shutdown-allcust)->void?
cust:custodian?
procedure
(custodian-shut-down?cust)->boolean?
cust:custodian?
parameter
(current-custodian)->custodian?
(current-custodiancust)->void?
cust:custodian?
procedure
(custodian-managed-listcustsuper)->list?
cust:custodian?
super:custodian?
procedure
(custodian-memory-accounting-available?)->boolean?
procedure
(custodian-require-memorylimit-cust 
                        need-amt   
                        stop-cust)->void?
limit-cust:custodian?
need-amt:exact-nonnegative-integer?
stop-cust:custodian?
procedure
(custodian-limit-memory limit-cust  
                       limit-amt   
                      [stop-cust])->void?
limit-cust:custodian?
limit-amt:exact-nonnegative-integer?
stop-cust:custodian?=limit-cust
procedure
(make-custodian-boxcustv)->custodian-box?
cust:custodian?
v:any/c
procedure
(custodian-box?v)->boolean?
v:any/c
procedure
(custodian-box-valuecb)->any
cb:custodian-box?
procedure
(make-thread-group[group])->thread-group?
group:thread-group?=(current-thread-group)
procedure
(thread-group?v)->boolean?
v:any/c
parameter
(current-thread-group)->thread-group?
(current-thread-groupgroup)->void?
group:thread-group?
procedure
(inspector?v)->boolean?
v:any/c
procedure
(make-inspector[inspector])->inspector?
inspector:inspector?=(current-inspector)
procedure
(make-sibling-inspector[inspector])->inspector?
inspector:inspector?=(current-inspector)
procedure
(inspector-superior?inspector           
                   maybe-subinspector)->boolean?
inspector:inspector?
maybe-subinspector:inspector?
parameter
(current-inspector)->inspector?
(current-inspectorinsp)->void?
insp:inspector?
procedure
(struct-infov)->(or/cstruct-type?#f)boolean?
v:any/c
procedure
(struct-type-infostruct-type)
->symbol?
    exact-nonnegative-integer?
    exact-nonnegative-integer?
    struct-accessor-procedure?
    struct-mutator-procedure?
    (listofexact-nonnegative-integer?)
    (or/cstruct-type?#f)
    boolean?
struct-type:struct-type?
procedure
(struct-type-sealed?struct-type)->boolean?
struct-type:struct-type?
procedure
(struct-type-authentic?struct-type)->boolean?
struct-type:struct-type?
procedure
(struct-type-make-constructor struct-type       
                            [constructor-name])
->struct-constructor-procedure?
struct-type:struct-type?
constructor-name:(or/csymbol?#f)=#f
procedure
(struct-type-make-predicatestruct-type)->any
struct-type:any/c
procedure
(object-namev)->any
v:any/c
value
prop:object-name:struct-type-property?
parameter
(current-code-inspector)->inspector?
(current-code-inspectorinsp)->void?
insp:inspector?
procedure
(plumber?v)->boolean?
v:any/c
procedure
(make-plumber)->plumber?
parameter
(current-plumber)->plumber?
(current-plumberplumber)->void?
plumber:plumber?
procedure
(plumber-flush-allplumber)->void?
plumber:plumber?
procedure
(plumber-flush-handle?v)->boolean?
v:any/c
procedure
(plumber-add-flush!plumberproc[weak?])->plumber-flush-handle?
plumber:plumber?
proc:(plumber-flush-handle?. -> .any)
weak?:any/c=#f
procedure
(plumber-flush-handle-remove!handle)->void?
handle:plumber-flush-handle?
procedure
(make-evaluator                                                       
               language                                             
               input-program...                                    
              [#:requiresrequires                                  
               #:allow-for-requireallow-for-require                
               #:allow-for-loadallow-for-load                      
               #:allow-readallow-read                              
               #:allow-syntactic-requiresallow-syntactic-requires])
->(any/c. -> .any)
language:(or/cmodule-path?
             (list/c'specialsymbol?)
             (cons/c'beginlist?))
input-program:any/c
requires:(listof(or/cmodule-path?path-string?
             (cons/c'for-syntax(listofmodule-path?))))
        =null
allow-for-require:(listof(or/cmodule-path?path?))=null
allow-for-load:(listofpath-string?)=null
allow-read:(listof(or/cmodule-path?path-string?))=null
allow-syntactic-requires:(or/c#f(listofmodule-path?))
                        =#f
(make-module-evaluator                                                       
                      module-decl                                          
                     [#:languagelang                                      
                      #:readersreaders                                    
                      #:allow-for-requireallow-for-require                
                      #:allow-for-loadallow-for-load                      
                      #:allow-readallow-read                              
                      #:allow-syntactic-requiresallow-syntactic-requires])
->(any/c. -> .any)
module-decl:(or/csyntax?pair?path?input-port?string?bytes?)
lang:(or/c#fmodule-path?)=#f
readers:(or/c#f(listofmodule-path?))
       =(andlang(default-language-readerslang))
allow-for-require:(listof(or/cmodule-path?path?))=null
allow-for-load:(listofpath-string?)=null
allow-read:(listof(or/cmodule-path?path-string?))=null
allow-syntactic-requires:(or/c#f(listofmodule-path?))
                        =#f
procedure
(exn:fail:sandbox-terminated?v)->boolean?
v:any/c
(exn:fail:sandbox-terminated-reasonexn)->symbol?
exn:exn:fail:sandbox-terminated?
procedure
(call-with-trusted-sandbox-configurationthunk)->any
thunk:(->any)
parameter
(sandbox-init-hook)->(->any)
(sandbox-init-hookthunk)->void?
thunk:(->any)
parameter
(sandbox-reader)->(any/c. -> .any)
(sandbox-readerproc)->void?
proc:(any/c. -> .any)
parameter
(sandbox-input)->(or/c#f
                   string?bytes?
                   input-port?
                   'pipe
                   (->input-port?))
(sandbox-inputin)->void?
in:(or/c#f
       string?bytes?
       input-port?
       'pipe
       (->input-port?))
parameter
(sandbox-output)->(or/c#f
                    output-port?
                    'pipe
                    'bytes
                    'string
                    (->output-port?))
(sandbox-outputin)->void?
in:(or/c#f
       output-port?
       'pipe
       'bytes
       'string
       (->output-port?))
parameter
(sandbox-error-output)->(or/c#f
                          output-port?
                          'pipe
                          'bytes
                          'string
                          (->output-port?))
(sandbox-error-outputin)->void?
in:(or/c#f
       output-port?
       'pipe
       'bytes
       'string
       (->output-port?))
parameter
(sandbox-coverage-enabled)->boolean?
(sandbox-coverage-enabledenabled?)->void?
enabled?:any/c
parameter
(sandbox-propagate-breaks)->boolean?
(sandbox-propagate-breakspropagate?)->void?
propagate?:any/c
parameter
(sandbox-propagate-exceptions)->boolean?
(sandbox-propagate-exceptionspropagate?)->void?
propagate?:any/c
parameter
(sandbox-namespace-specs)->(cons/c(->namespace?)
                             (listofmodule-path?))
(sandbox-namespace-specsspec)->void?
spec:(cons/c(->namespace?)
         (listofmodule-path?))
procedure
(sandbox-make-namespace)->namespace?
parameter
(sandbox-gui-available)->boolean?
(sandbox-gui-availableavail?)->void?
avail?:any/c
parameter
(sandbox-override-collection-paths)->(listofpath-string?)
(sandbox-override-collection-pathspaths)->void?
paths:(listofpath-string?)
parameter
(sandbox-security-guard)
->(or/csecurity-guard?(->security-guard?))
(sandbox-security-guardguard)->void?
guard:(or/csecurity-guard?(->security-guard?))
parameter
(sandbox-path-permissions)
->(listof(list/c(or/c'execute'write'delete
    'read-bytecode'read'exists)
    (or/cbyte-regexp?bytes?string?path?)))
(sandbox-path-permissionsperms)->void?
perms:(listof(list/c(or/c'execute'write'delete
          'read-bytecode'read'exists)
          (or/cbyte-regexp?bytes?string?path?)))
parameter
(sandbox-network-guard)
->(symbol?
    (or/c(and/cstring?immutable?)#f)
    (or/c(integer-in165535)#f)
    (or/c'server'client)
    . -> .any)
(sandbox-network-guardproc)->void?
proc:(symbol?
         (or/c(and/cstring?immutable?)#f)
         (or/c(integer-in165535)#f)
         (or/c'server'client)
         . -> .any)
parameter
(sandbox-exit-handler)->(any/c. -> .any)
(sandbox-exit-handlerhandler)->void?
handler:(any/c. -> .any)
parameter
(sandbox-memory-limit)->(or/c(>=/c0)#f)
(sandbox-memory-limitlimit)->void?
limit:(or/c(>=/c0)#f)
parameter
(sandbox-eval-limits)->(or/c(list/c(or/c(>=/c0)#f)
                         (or/c(>=/c0)#f))
                         #f)
(sandbox-eval-limitslimits)->void?
limits:(or/c(list/c(or/c(>=/c0)#f)
           (or/c(>=/c0)#f))
           #f)
parameter
(sandbox-eval-handlers)
->(list/c(or/c#f((->any). -> .any))
    (or/c#f((->any). -> .any)))
(sandbox-eval-handlershandlers)->void?
handlers:(list/c(or/c#f((->any). -> .any))
             (or/c#f((->any). -> .any)))
parameter
(sandbox-run-submodules)->(list/csymbol?)
(sandbox-run-submodulessubmod-syms)->void?
submod-syms:(list/csymbol?)
parameter
(sandbox-make-inspector)->(->inspector?)
(sandbox-make-inspectormake)->void?
make:(->inspector?)
parameter
(sandbox-make-code-inspector)->(->inspector?)
(sandbox-make-code-inspectormake)->void?
make:(->inspector?)
parameter
(sandbox-make-logger)->(->logger?)
(sandbox-make-loggermake)->void?
make:(->logger?)
parameter
(sandbox-make-plumber)->(or/c(->plumber?)'propagate)
(sandbox-make-plumbermake)->void?
make:(or/c(->plumber?)'propagate)
parameter
(sandbox-make-environment-variables)
->(->environment-variables?)
(sandbox-make-environment-variablesmake)->void?
make:(->environment-variables?)
procedure
(default-language-readerslang)->(listofmodule-path?)
lang:module-path?
procedure
(evaluator-alive?evaluator)->boolean?
evaluator:(any/c. -> .any)
procedure
(kill-evaluatorevaluator)->void?
evaluator:(any/c. -> .any)
procedure
(break-evaluatorevaluator)->void?
evaluator:(any/c. -> .any)
procedure
(get-user-custodianevaluator)->void?
evaluator:(any/c. -> .any)
procedure
(set-eval-limitsevaluatorsecsmb)->void?
evaluator:(any/c. -> .any)
secs:(or/cexact-nonnegative-integer?#f)
mb:(or/cexact-nonnegative-integer?#f)
procedure
(set-eval-handlerevaluatorhandler)->void?
evaluator:(any/c. -> .any)
handler:(or/c#f((->any). -> .any))
procedure
(call-with-custodian-shutdownthunk)->any
thunk:(->any)
(call-with-killing-threadsthunk)->any
thunk:(->any)
procedure
(put-inputevaluator)->output-port?
evaluator:(any/c. -> .any)
(put-inputevaluatori/o)->void?
evaluator:(any/c. -> .any)
i/o:(or/cbytes?string?eof-object?)
procedure
(get-outputevaluator)->(or/c#finput-port?bytes?string?)
evaluator:(any/c. -> .any)
(get-error-outputevaluator)
->(or/c#finput-port?bytes?string?)
evaluator:(any/c. -> .any)
procedure
(get-uncovered-expressions evaluator 
                         [prog?     
                          src])    ->(listofsyntax?)
evaluator:(any/c. -> .any)
prog?:any/c=#t
src:any/c=default-src
procedure
(call-in-sandbox-context evaluator       
                        thunk           
                       [unrestricted?])->any
evaluator:(any/c. -> .any)
thunk:(->any)
unrestricted?:boolean?=#f
value
gui?:boolean?
procedure
(call-with-limitssecsmbthunk)->any
secs:(or/cexact-nonnegative-integer?#f)
mb:(or/cexact-nonnegative-integer?#f)
thunk:(->any)
syntax
(with-limitssec-exprmb-exprbody...)
procedure
(call-with-deep-time-limitsecsthunk)->any
secs:exact-nonnegative-integer?
thunk:(->any)
syntax
(with-deep-time-limitsecs-exprbody...)
procedure
(exn:fail:resource?v)->boolean?
v:any/c
(exn:fail:resource-resourceexn)
->(or/c'time'memory'deep-time)
exn:exn:fail:resource?

(linklet[[imported-id/renamed...]...]
[exported-id/renamed...]
defn-or-expr...)

imported-id/renamed=imported-id
                  |(external-imported-idinternal-imported-id)
                  
exported-id/renamed=exported-id
                  |(internal-exported-idexternal-exported-id)
procedure
(linklet?v)->boolean?
v:any/c
procedure
(compile-linklet form        
               [name        
                import-keys 
                get-import  
                options])  ->linklet?
form:(or/ccorrelated?any/c)
name:any/c=#f
import-keys:#f=#f
get-import:#f=#f
options:(listof(or/c'serializable'unsafe'static'quick
            'use-prompt'uninterned-literal))
       ='(serializable)
(compile-linklet form        
                name        
                import-keys 
               [get-import  
                options])  ->linklet?vector?
form:(or/ccorrelated?any/c)
name:any/c
import-keys:vector?
get-import:(or/c#f(any/c. -> .(values(or/clinklet?instance?#f)
               (or/cvector?#f))))
          =#f
options:(listof(or/c'serializable'unsafe'static'quick
            'use-prompt'uninterned-literal))
       ='(serializable)
procedure
(recompile-linklet linklet     
                 [name        
                  import-keys 
                  get-import  
                  options])  ->linklet?
linklet:linklet?
name:any/c=#f
import-keys:#f=#f
get-import:#f=#f
options:(listof(or/c'serializable'unsafe'static'quick
            'use-prompt'uninterned-literal))
       ='(serializable)
(recompile-linklet linklet     
                  name        
                  import-keys 
                 [get-import  
                  options])  ->linklet?vector?
linklet:linklet?
name:any/c
import-keys:vector?
get-import:(or/c(any/c. -> .(values(or/clinklet?#f)
               (or/cvector?#f)))
               #f)
          =(lambda(import-key)(values#f#f))
options:(listof(or/c'serializable'unsafe'static'quick
            'use-prompt'uninterned-literal))
       ='(serializable)
procedure
(eval-linkletlinklet)->linklet?
linklet:linklet?
procedure
(instantiate-linklet linklet          
                    import-instances 
                   [target-instance? 
                    use-prompt?])   ->instance?
linklet:linklet?
import-instances:(listofinstance?)
target-instance?:#f=#f
use-prompt?:any/c=#t
(instantiate-linklet linklet          
                    import-instances 
                    target-instance  
                   [use-prompt?])   ->any
linklet:linklet?
import-instances:(listofinstance?)
target-instance:instance?
use-prompt?:any/c=#t
procedure
(linklet-import-variableslinklet)->(listof(listofsymbol?))
linklet:linklet?
procedure
(linklet-export-variableslinklet)->(listofsymbol?)
linklet:linklet?
procedure
(linklet-directory?v)->boolean?
v:any/c
procedure
(hash->linklet-directorycontent)->linklet-directory?
content:(and/chash?hash-eq?immutable?(not/cimpersonator?))
procedure
(linklet-directory->hashlinklet-directory)
->(and/chash?hash-eq?immutable?(not/cimpersonator?))
linklet-directory:linklet-directory?
procedure
(linklet-bundle?v)->boolean?
v:any/c
procedure
(hash->linklet-bundlecontent)->linklet-bundle?
content:(and/chash?hash-eq?immutable?(not/cimpersonator?))
procedure
(linklet-bundle->hashlinklet-bundle)
->(and/chash?hash-eq?immutable?(not/cimpersonator?))
linklet-bundle:linklet-bundle?
procedure
(linklet-body-reserved-symbol?sym)->boolean?
sym:symbol?
procedure
(instance?v)->boolean?
v:any/c
procedure
(make-instance name               
             [data               
              mode]              
              variable-name      
              variable-value... 
              ...)              ->instance?
name:any/c
data:any/c=#f
mode:(or/c#f'constant'consistent)=#f
variable-name:symbol?
variable-value:any/c
procedure
(instance-nameinstance)->any/c
instance:instance?
procedure
(instance-datainstance)->any/c
instance:instance?
procedure
(instance-variable-namesinstance)->(listsymbol?)
instance:instance?
procedure
(instance-variable-value instance 
                        name     
                       [fail-k])->any
instance:instance?
name:symbol?
fail-k:any/c=(lambda()(error....))
procedure
(instance-set-variable-value! instance 
                             name     
                             v        
                            [mode])  ->void?
instance:instance?
name:symbol?
v:any/c
mode:(or/c#f'constant'consistent)=#f
procedure
(instance-unset-variable!instancename)->void?
instance:instance?
name:symbol?
procedure
(instance-describe-variable!instance 
                           name     
                           desc-v) ->void?
instance:instance?
name:symbol?
desc-v:any/c
procedure
(variable-reference->instance varref     
                            [ref-site?])
->(ifref-site?(or/cinstance?#fsymbol?)instance?)
varref:variable-reference?
ref-site?:any/c=#f
procedure
(correlated?v)->boolean?
v:any/c
procedure
(correlated-sourcecrlt)->any
crlt:correlated?
procedure
(correlated-linecrlt)->(or/cexact-positive-integer?#f)
crlt:correlated?
procedure
(correlated-columncrlt)->(or/cexact-nonnegative-integer?#f)
crlt:correlated?
procedure
(correlated-positioncrlt)->(or/cexact-positive-integer?#f)
crlt:correlated?
procedure
(correlated-spancrlt)->(or/cexact-nonnegative-integer?#f)
crlt:correlated?
procedure
(correlated-ecrlt)->any
crlt:correlated?
procedure
(correlated->datumcrlt)->any
crlt:(or/ccorrelated?any/c)
procedure
(datum->correlatedv[srclocprop])->correlated?
v:any/c
srcloc:(or/ccorrelated?#f
           (list/cany/c
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f))
           (vector/cany/c
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)
           (or/cexact-positive-integer?#f)
           (or/cexact-nonnegative-integer?#f)))
      =#f
prop:(or/ccorrelated?#f)=#f
procedure
(correlated-propertycrltkeyval)->correlated?
crlt:correlated?
key:any/c
val:any/c
(correlated-propertycrltkey)->any/c
crlt:correlated?
key:any/c
procedure
(correlated-property-symbol-keyscrlt)->list?
crlt:correlated?
procedure
(path?v)->boolean?
v:any/c
procedure
(path-string?v)->boolean?
v:any/c
procedure
(path-for-some-system?v)->boolean?
v:any/c
procedure
(string->pathstr)->path?
str:string?
procedure
(bytes->pathbstr[type])->path?
bstr:bytes?
type:(or/c'unix'windows)=(system-path-convention-type)
procedure
(path->stringpath)->string?
path:path?
procedure
(path->bytespath)->bytes?
path:path-for-some-system?
procedure
(string->path-element str                    
                    [false-on-non-element?])
->(or/c(and/cpath?path-element?)#f)
str:string?
false-on-non-element?:any/c=#f
procedure
(bytes->path-element bstr                   
                   [type                   
                    false-on-non-element?])
->(or/cpath-element?#f)
bstr:bytes?
type:(or/c'unix'windows)=(system-path-convention-type)
false-on-non-element?:any/c=#f
procedure
(path-element->stringpath)->string?
path:path-element?
procedure
(path-element->bytespath)->bytes?
path:path-element?
procedure
(path<?a-pathb-path...)->boolean?
a-path:path?
b-path:path?
procedure
(path-convention-typepath)->(or/c'unix'windows)
path:path-for-some-system?
procedure
(system-path-convention-type)->(or/c'unix'windows)
procedure
(build-pathbasesub...)->path-for-some-system?
base:(or/cpath-string?path-for-some-system?'up'same)
sub:(or/c(and/c(or/cpath-string?path-for-some-system?)
        (not/ccomplete-path?))
        (or/c'up'same))
procedure
(build-path/convention-typetype     
                          base     
                          sub...)->path-for-some-system?
type:(or/c'unix'windows)
base:(or/cpath-string?path-for-some-system?'up'same)
sub:(or/c(and/c(or/cpath-string?path-for-some-system?)
        (not/ccomplete-path?))
        (or/c'up'same))
procedure
(absolute-path?path)->boolean?
path:(or/cpath?string?path-for-some-system?)
procedure
(relative-path?path)->boolean?
path:(or/cpath?string?path-for-some-system?)
procedure
(complete-path?path)->boolean?
path:(or/cpath?string?path-for-some-system?)
procedure
(path->complete-pathpath[base])->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
base:(or/cpath-string?path-for-some-system?)
    =(current-directory)
procedure
(path->directory-pathpath)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
procedure
(resolve-pathpath)->path?
path:path-string?
procedure
(cleanse-pathpath)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
procedure
(expand-user-pathpath)->path?
path:path-string?
procedure
(simplify-pathpath[use-filesystem?])->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
use-filesystem?:boolean?=#t
procedure
(normal-case-pathpath)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
procedure
(split-pathpath)->(or/cpath-for-some-system?'relative#f)
                     (or/cpath-for-some-system?'up'same)
                     boolean?
path:(or/cpath-string?path-for-some-system?)
procedure
(explode-pathpath)
->(listof(or/cpath-for-some-system?'up'same))
path:(or/cpath-string?path-for-some-system?)
procedure
(path-replace-extensionpathext)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
ext:(or/cstring?bytes?)
procedure
(path-add-extensionpathext[sep])->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
ext:(or/cstring?bytes?)
sep:(or/cstring?bytes?)=#"_"
procedure
(path-replace-suffixpathext)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
ext:(or/cstring?bytes?)
procedure
(path-add-suffixpathext)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
ext:(or/cstring?bytes?)
procedure
(reroot-pathpathroot-path)->path-for-some-system?
path:(or/cpath-string?path-for-some-system?)
root-path:(or/cpath-string?path-for-some-system?)
procedure
(file-name-from-pathpath)->(or/cpath-for-some-system?#f)
path:(or/cpath-string?path-for-some-system?)
procedure
(path-get-extensionpath)->(or/cbytes?#f)
path:(or/cpath-string?path-for-some-system?)
procedure
(path-has-extension?pathext)->boolean?
path:(or/cpath-string?path-for-some-system?)
ext:(or/cbytes?string?)
procedure
(filename-extensionpath)->(or/cbytes?#f)
path:(or/cpath-string?path-for-some-system?)
procedure
(find-relative-path base                               
                   path                               
                  [#:more-than-root?more-than-root?  
                   #:more-than-same?more-than-same?  
                   #:normalize-case?normalize-case?])
->(or/cpath-for-some-system?path-string?)
base:(or/cpath-string?path-for-some-system?)
path:(or/cpath-string?path-for-some-system?)
more-than-root?:any/c=#f
more-than-same?:any/c=#t
normalize-case?:any/c=#t
procedure
(normalize-pathpath[wrt])->path?
path:path-string?
wrt:(and/cpath-string?complete-path?)
   =(current-directory)
procedure
(path-element?path)->boolean?
path:any/c
procedure
(path-onlypath)->(or/c#fpath-for-some-system?)
path:(or/cpath-string?path-for-some-system?)
procedure
(simple-form-pathpath)->path?
path:path-string?
procedure
(some-system-path->stringpath)->string?
path:path-for-some-system?
procedure
(string->some-system-pathstrkind)->path-for-some-system?
str:string?
kind:(or/c'unix'windows)
procedure
(shrink-path-wrtpthother-pths)->(or/c#fpath?)
pth:path?
other-pths:(listofpath?)
procedure
(find-system-pathkind)->path?
kind:symbol?
procedure
(path-list-string->path-liststr               
                           default-path-list)
->(listof(or/cpath?'same))
str:(or/cstring?bytes?)
default-path-list:(listof(or/cpath?'same))
procedure
(find-executable-path program    
                    [related    
                     deepest?])->(or/cpath?#f)
program:path-string?
related:(or/cpath-string?#f)=#f
deepest?:any/c=#f
procedure
(file-exists?path)->boolean?
path:path-string?
procedure
(link-exists?path)->boolean?
path:path-string?
procedure
(file-or-directory-typepath[must-exist?])
->(or/c'file'directory'link'directory-link#f)
path:path-string?
must-exist?:any/c=#f
procedure
(delete-filepath)->void?
path:path-string?
procedure
(rename-file-or-directory old          
                         new          
                        [exists-ok?])->void?
old:path-string?
new:path-string?
exists-ok?:any/c=#f
procedure
(file-or-directory-modify-seconds path     
                                [secs-n])->exact-integer?
path:path-string?
secs-n:#f=#f
(file-or-directory-modify-secondspath    
                                secs-n)->void?
path:path-string?
secs-n:exact-integer?
(file-or-directory-modify-seconds path         
                                [secs-n       
                                 fail-thunk])->any
path:path-string?
secs-n:(or/cexact-integer?#f)=#f
fail-thunk:(->any)
          =(lambda()(raise(make-exn:fail:filesystem....)))
procedure
(file-or-directory-permissionspath[mode])
->(listof(or/c'read'write'execute))
path:path-string?
mode:#f=#f
(file-or-directory-permissionspathmode)->(integer-in065535)
path:path-string?
mode:'bits
(file-or-directory-permissionspathmode)->void
path:path-string?
mode:(integer-in065535)
procedure
(file-or-directory-statpath[as-link?])
->(and/c(hash/csymbol?any/c)hash-eq?)
path:path-string?
as-link?:boolean?=#f
procedure
(file-or-directory-identitypath[as-link?])
->exact-positive-integer?
path:path-string?
as-link?:any/c=#f
procedure
(file-sizepath)->exact-nonnegative-integer?
path:path-string?
procedure
(copy-file src                                           
          dest                                          
         [exists-ok?/pos                                
          #:exists-ok?exists-ok?                       
          #:permissionspermissions                     
          #:replace-permissions?replace-permissions?])->void?
src:path-string?
dest:path-string?
exists-ok?/pos:any/c=#f
exists-ok?:any/c=exists-ok?/pos
permissions:(or/c#f(integer-in065535))=#f
replace-permissions?:any/c=#t
procedure
(make-file-or-directory-linktopath)->void?
to:path-string?
path:path-string?
parameter
(current-force-delete-permissions)->boolean?
(current-force-delete-permissionsforce?)->void?
force?:any/c
=#t
parameter
(current-directory)->(and/cpath?complete-path?)
(current-directorypath)->void?
path:path-string?
parameter
(current-directory-for-user)->(and/cpath?complete-path?)
(current-directory-for-userpath)->void?
path:path-string?
procedure
(current-drive)->path?
procedure
(directory-exists?path)->boolean?
path:path-string?
procedure
(make-directorypath[permissions])->void?
path:path-string?
permissions:(integer-in065535)=#o777
procedure
(delete-directorypath)->void?
path:path-string?
procedure
(directory-list[path#:build?build?])->(listofpath?)
path:path-string?=(current-directory)
build?:any/c=#f
procedure
(filesystem-root-list)->(listofpath?)
procedure
(filesystem-change-evt?v)->boolean?
v:any/c
procedure
(filesystem-change-evtpath[failure-thunk])
->(or/cfilesystem-change-evt?any)
path:path-string?
failure-thunk:(or/c(->any)#f)=#f
procedure
(filesystem-change-evt-cancelevt)->void?
evt:filesystem-change-evt?
syntax
(define-runtime-pathidmaybe-runtime?-idexpr)

maybe-runtime?-id=
                |#:runtime?-idruntime?-id
syntax
(define-runtime-paths(id...)maybe-runtime?-idexpr)
syntax
(define-runtime-path-listidmaybe-runtime?-idexpr)
syntax
(define-runtime-module-path-indexidmaybe-runtime?-idmodule-path-expr)
syntax
(runtime-requiremodule-path)
syntax
(define-runtime-module-pathidmodule-path)
syntax
(runtime-pathsmodule-path)
procedure
(file->stringpath[#:modemode-flag])->string?
path:path-string?
mode-flag:(or/c'binary'text)='binary
procedure
(file->bytespath[#:modemode-flag])->bytes?
path:path-string?
mode-flag:(or/c'binary'text)='binary
procedure
(file->valuepath[#:modemode-flag])->any
path:path-string?
mode-flag:(or/c'binary'text)='binary
procedure
(file->listpath[proc#:modemode-flag])->(listofany/c)
path:path-string?
proc:(input-port?. -> .any/c)=read
mode-flag:(or/c'binary'text)='binary
procedure
(file->lines path                    
           [#:modemode-flag        
            #:line-modeline-mode])->(listofstring?)
path:path-string?
mode-flag:(or/c'binary'text)='binary
line-mode:(or/c'linefeed'return'return-linefeed'any'any-one)
         ='any
procedure
(file->bytes-lines path                    
                 [#:modemode-flag        
                  #:line-modeline-mode])->(listofbytes?)
path:path-string?
mode-flag:(or/c'binary'text)='binary
line-mode:(or/c'linefeed'return'return-linefeed'any'any-one)
         ='any
procedure
(display-to-file v                      
                path                   
               [#:modemode-flag       
                #:existsexists-flag])->void?
v:any/c
path:path-string?
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(write-to-file v                      
              path                   
             [#:modemode-flag       
              #:existsexists-flag])->void?
v:any/c
path:path-string?
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(display-lines-to-file lst                    
                      path                   
                     [#:separatorseparator  
                      #:modemode-flag       
                      #:existsexists-flag])->void?
lst:list?
path:path-string?
separator:any/c=#"\n"
mode-flag:(or/c'binary'text)='binary
exists-flag:(or/c'error'append'update
                'replace'truncate'truncate/replace)
           ='error
procedure
(copy-directory/files                                             
                     src                                        
                     dest                                       
                    [#:keep-modify-seconds?keep-modify-seconds?
                     #:preserve-links?preserve-links?])        
->void?
src:path-string?
dest:path-string?
keep-modify-seconds?:any/c=#f
preserve-links?:any/c=#f
procedure
(delete-directory/files path                        
                      [#:must-exist?must-exist?])->void?
path:path-string?
must-exist?:any/c=#t
procedure
(find-files                                                     
           predicate                                          
          [start-path                                         
           #:skip-filtered-directory?skip-filtered-directory?
           #:follow-links?follow-links?])                    
->(listofpath?)
predicate:(path?. -> .any/c)
start-path:(or/cpath-string?#f)=#f
skip-filtered-directory?:any/c=#f
follow-links?:any/c=#f
procedure
(pathlist-closure path-list                      
                [#:path-filterpath-filter      
                 #:follow-links?follow-links?])
->(listofpath?)
path-list:(listofpath-string?)
path-filter:(or/c#f(path?. -> .any/c))=#f
follow-links?:any/c=#f
procedure
(fold-files proc            
           init-val        
          [start-path      
           follow-links?])->any
proc:(or/c(path?(or/c'file'dir'link)any/c
         . -> .any/c)
         (path?(or/c'file'dir'link)any/c
         . -> .(valuesany/cany/c)))
init-val:any/c
start-path:(or/cpath-string?#f)=#f
follow-links?:any/c=#t
procedure
(make-directory*path)->void?
path:path-string?
procedure
(make-parent-directory*path)->void?
path:path-string?
procedure
(make-temporary-file[template             
                    #:copy-fromcopy-from
                    #:base-dirbase-dir  
                    compat-copy-from     
                    compat-base-dir])    
->(and/cpath?complete-path?)
template:string?="rkttmp~a"
copy-from:(or/cpath-string?#f'directory)=#f
base-dir:(or/cpath-string?#f)=#f
compat-copy-from:(or/cpath-string?#f'directory)
                =copy-from
compat-base-dir:(or/cpath-string?#f)=base-dir
procedure
(make-temporary-directory[template             
                         #:base-dirbase-dir])
->(and/cpath?complete-path?)
template:string?="rkttmp~a"
base-dir:(or/cpath-string?#f)=#f
procedure
(make-temporary-file* prefix               
                     suffix               
                    [#:copy-fromcopy-from
                     #:base-dirbase-dir])
->(and/cpath?complete-path?)
prefix:bytes?
suffix:bytes?
copy-from:(or/cpath-string?#f)=#f
base-dir:(or/cpath-string?#f)=#f
procedure
(make-temporary-directory* prefix               
                          suffix               
                         [#:base-dirbase-dir])
->(and/cpath?complete-path?)
prefix:bytes?
suffix:bytes?
base-dir:(or/cpath-string?#f)=#f
procedure
(call-with-atomic-output-file                                             
                             file                                       
                             proc                                       
                            [#:security-guardsecurity-guard            
                             #:rename-fail-handlerrename-fail-handler])
->any
file:path-string?
proc:(output-port?path?. -> .any)
security-guard:(or/c#fsecurity-guard?)=#f
rename-fail-handler:(or/c#f(exn:fail:filesystem?path?. -> .any))
                   =#f
procedure
(get-preference name                                    
              [failure-thunk                           
               flush-mode                              
               filename                                
               #:use-lock?use-lock?                   
               #:timeout-lock-theretimeout-lock-there 
               #:lock-therelock-there])              ->any
name:symbol?
failure-thunk:(->any)=(lambda()#f)
flush-mode:any/c='timestamp
filename:(or/cpath-string?#f)=#f
use-lock?:any/c=#t
timeout-lock-there:(or/c(path?. -> .any)#f)=#f
lock-there:(or/c(path?. -> .any)#f)
          =(make-handle-get-preference-locked
               0.01namefailure-thunkflush-modefilename
               #:lock-theretimeout-lock-there)
procedure
(put-preferences names       
                vals        
               [locked-proc 
                filename]) ->void?
names:(listofsymbol?)
vals:list?
locked-proc:(or/c#f(path?. -> .any))=#f
filename:(or/c#fpath-string?)=#f
procedure
(preferences-lock-file-mode)->(or/c'exists'file-lock)
procedure
(make-handle-get-preference-locked delay                  
                                  name                   
                                 [failure-thunk          
                                  flush-mode             
                                  filename               
                                  #:lock-therelock-there
                                  #:max-delaymax-delay])
->(path-string?. -> .any)
delay:real?
name:symbol?
failure-thunk:(->any)=(lambda()#f)
flush-mode:any/c='timestamp
filename:(or/cpath-string?#f)=#f
lock-there:(or/c(path?. -> .any)#f)=#f
max-delay:real?=0.2
procedure
(call-with-file-lock/timeout filename                
                            kind                    
                            thunk                   
                            failure-thunk           
                           [#:lock-filelock-file   
                            #:delaydelay           
                            #:max-delaymax-delay])->any
filename:(or/cpath-string?#f)
kind:(or/c'shared'exclusive)
thunk:(->any)
failure-thunk:(->any)
lock-file:(or/c#fpath-string?)=#f
delay:(and/creal?(not/cnegative?))=0.01
max-delay:(and/creal?(not/cnegative?))=0.2
procedure
(make-lock-file-namepath)->path?
path:(or/cpath-string?path-for-some-system?)
(make-lock-file-namedirname)->path?
dir:(or/cpath-string?path-for-some-system?)
name:path-element?
value
file-type-bits:#o170000
value
socket-type-bits:#o140000
value
symbolic-link-type-bits:#o120000
value
regular-file-type-bits:#o100000
value
block-device-type-bits:#o060000
value
directory-type-bits:#o040000
value
character-device-type-bits:#o020000
value
fifo-type-bits:#o010000
value
set-user-id-bit:#o004000
value
set-group-id-bit:#o002000
value
sticky-bit:#o001000
value
user-permission-bits:#o000700
value
user-read-bit:#o000400
value
user-write-bit:#o000200
value
user-execute-bit:#o000100
value
group-permission-bits:#o000070
value
group-read-bit:#o000040
value
group-write-bit:#o000020
value
group-execute-bit:#o000010
value
other-permission-bits:#o000007
value
other-read-bit:#o000004
value
other-write-bit:#o000002
value
other-execute-bit:#o000001
procedure
(tcp-listen port-no        
          [max-allow-wait 
           reuse?         
           hostname])    ->tcp-listener?
port-no:listen-port-number?
max-allow-wait:exact-nonnegative-integer?=4
reuse?:any/c=#f
hostname:(or/cstring?#f)=#f
procedure
(tcp-connect hostname        
            port-no         
           [local-hostname  
            local-port-no])->input-port?output-port?
hostname:string?
port-no:port-number?
local-hostname:(or/cstring?#f)=#f
local-port-no:(or/cport-number?#f)=#f
procedure
(tcp-connect/enable-break hostname       
                         port-no        
                        [local-hostname]
                         local-port-no) 
->input-port?output-port?
hostname:string?
port-no:port-number?
local-hostname:(or/cstring?#f)=#f
local-port-no:(or/cport-number?#f)
procedure
(tcp-acceptlistener)->input-port?output-port?
listener:tcp-listener?
procedure
(tcp-accept/enable-breaklistener)->input-port?output-port?
listener:tcp-listener?
procedure
(tcp-accept-ready?listener)->boolean?
listener:tcp-listener?
procedure
(tcp-closelistener)->void?
listener:tcp-listener?
procedure
(tcp-listener?v)->boolean?
v:any/c
procedure
(tcp-accept-evtlistener)->evt?
listener:tcp-listener?
procedure
(tcp-abandon-porttcp-port)->void?
tcp-port:tcp-port?
procedure
(tcp-addressestcp-port[port-numbers?])
->(or/c(valuesstring?string?)
    (valuesstring?port-number?
    string?listen-port-number?))
tcp-port:(or/ctcp-port?tcp-listener?udp?)
port-numbers?:any/c=#f
procedure
(tcp-port?v)->boolean?
v:any/c
value
port-number?:contract?
value
listen-port-number?:contract?
procedure
(udp-open-socket[family-hostname  
                family-port-no])->udp?
family-hostname:(or/cstring?#f)=#f
family-port-no:(or/cport-number?#f)=#f
procedure
(udp-bind! udp-socket      
          hostname-string 
          port-no         
         [reuse?])       ->void?
udp-socket:udp?
hostname-string:(or/cstring?#f)
port-no:listen-port-number?
reuse?:any/c=#f
procedure
(udp-connect!udp-socket      
            hostname-string 
            port-no)       ->void?
udp-socket:udp?
hostname-string:(or/cstring?#f)
port-no:(or/cport-number?#f)
procedure
(udp-send-to udp-socket 
            hostname   
            port-no    
            bstr       
           [start-pos  
            end-pos]) ->void?
udp-socket:udp?
hostname:string?
port-no:port-number?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-sendudp-socketbstr[start-posend-pos])->void?
udp-socket:udp?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send-to* udp-socket 
             hostname   
             port-no    
             bstr       
            [start-pos  
             end-pos]) ->boolean?
udp-socket:udp?
hostname:string?
port-no:port-number?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send*udp-socketbstr[start-posend-pos])->boolean?
udp-socket:udp?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send-to/enable-break udp-socket 
                         hostname   
                         port-no    
                         bstr       
                        [start-pos  
                         end-pos]) ->void?
udp-socket:udp?
hostname:string?
port-no:port-number?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send/enable-break udp-socket 
                      bstr       
                     [start-pos  
                      end-pos]) ->void?
udp-socket:udp?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-receive! udp-socket 
             bstr       
            [start-pos  
             end-pos]) ->exact-nonnegative-integer?
                             string?
                             port-number?
udp-socket:udp?
bstr:(and/cbytes?(notimmutable?))
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-receive!* udp-socket
              bstr      
             [start-pos 
              end-pos]) 
->(or/cexact-nonnegative-integer?#f)
    (or/cstring?#f)
    (or/cport-number?#f)
udp-socket:udp?
bstr:(and/cbytes?(notimmutable?))
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-receive!/enable-break udp-socket
                          bstr      
                         [start-pos 
                          end-pos]) 
->exact-nonnegative-integer?
    string?
    port-number?
udp-socket:udp?
bstr:(and/cbytes?(notimmutable?))
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-set-receive-buffer-size!udp-socket 
                            size)     ->void?
udp-socket:udp?
size:exact-positive-integer?
procedure
(udp-closeudp-socket)->void?
udp-socket:udp?
procedure
(udp?v)->boolean?
v:any/c
procedure
(udp-bound?udp-socket)->boolean?
udp-socket:udp?
procedure
(udp-connected?udp-socket)->boolean?
udp-socket:udp?
procedure
(udp-send-ready-evtudp-socket)->evt?
udp-socket:udp?
procedure
(udp-receive-ready-evtudp-socket)->evt?
udp-socket:udp?
procedure
(udp-send-to-evt udp-socket 
                hostname   
                port-no    
                bstr       
               [start-pos  
                end-pos]) ->evt?
udp-socket:udp?
hostname:string?
port-no:port-number?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-send-evt udp-socket 
             bstr       
            [start-pos  
             end-pos]) ->evt?
udp-socket:udp?
bstr:bytes?
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-receive!-evt udp-socket 
                 bstr       
                [start-pos  
                 end-pos]) ->evt?
udp-socket:udp?
bstr:(and/cbytes?(notimmutable?))
start-pos:exact-nonnegative-integer?=0
end-pos:exact-nonnegative-integer?=(bytes-lengthbstr)
procedure
(udp-addressesudp-port[port-numbers?])
->(or/c(valuesstring?string?)
    (valuesstring?listen-port-number?
    string?listen-port-number?))
udp-port:udp?
port-numbers?:any/c=#f
procedure
(udp-set-ttl!udp-socketttl)->void?
udp-socket:udp?
ttl:byte?
procedure
(udp-ttludp-socket)->byte?
udp-socket:udp?
procedure
(udp-multicast-join-group!udp-socket     
                         multicast-addr 
                         hostname)     ->void?
udp-socket:udp?
multicast-addr:string?
hostname:(or/cstring?#f)
procedure
(udp-multicast-leave-group!udp-socket     
                          multicast-addr 
                          hostname)     ->void?
udp-socket:udp?
multicast-addr:string?
hostname:(or/cstring?#f)
procedure
(udp-multicast-interfaceudp-socket)->string?
udp-socket:udp?
procedure
(udp-multicast-set-interface!udp-socket 
                            hostname) ->void?
udp-socket:udp?
hostname:(or/cstring?#f)
procedure
(udp-multicast-set-loopback!udp-socket 
                           loopback?)->void?
udp-socket:udp?
loopback?:any/c
procedure
(udp-multicast-loopback?udp-socket)->boolean?
udp-socket:udp?
procedure
(udp-multicast-set-ttl!udp-socketttl)->void?
udp-socket:udp?
ttl:byte?
procedure
(udp-multicast-ttludp-socket)->byte?
udp-socket:udp?
procedure
(subprocess stdout  
           stdin   
           stderr  
          [group]  
           command 
           arg...)
->subprocess?
    (or/c(and/cinput-port?file-stream-port?)#f)
    (or/c(and/coutput-port?file-stream-port?)#f)
    (or/c(and/cinput-port?file-stream-port?)#f)
stdout:(or/c(and/coutput-port?file-stream-port?)#f)
stdin:(or/c(and/cinput-port?file-stream-port?)#f)
stderr:(or/c(and/coutput-port?file-stream-port?)#f'stdout)
group:(or/c#f'newsubprocess)
     =(and(subprocess-group-enabled)'new)
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
(subprocess stdout 
           stdin  
           stderr 
          [group] 
           command
           exact  
           arg)   
->subprocess?
    (or/c(and/cinput-port?file-stream-port?)#f)
    (or/c(and/coutput-port?file-stream-port?)#f)
    (or/c(and/cinput-port?file-stream-port?)#f)
stdout:(or/c(and/coutput-port?file-stream-port?)#f)
stdin:(or/c(and/cinput-port?file-stream-port?)#f)
stderr:(or/c(and/coutput-port?file-stream-port?)#f)
group:(or/c#f'newsubprocess)
     =(and(subprocess-group-enabled)'new)
command:path-string?
exact:'exact
arg:string?
procedure
(subprocess-waitsubproc)->void?
subproc:subprocess?
procedure
(subprocess-statussubproc)->(or/c'running
                               exact-nonnegative-integer?)
subproc:subprocess?
procedure
(subprocess-killsubprocforce?)->void?
subproc:subprocess?
force?:any/c
procedure
(subprocess-pidsubproc)->exact-nonnegative-integer?
subproc:subprocess?
procedure
(subprocess?v)->boolean?
v:any/c
parameter
(current-subprocess-custodian-mode)
->(or/c#f'kill'interrupt)
(current-subprocess-custodian-modemode)->void?
mode:(or/c#f'kill'interrupt)
parameter
(subprocess-group-enabled)->boolean?
(subprocess-group-enabledon?)->void?
on?:any/c
parameter
(current-subprocess-keep-file-descriptors)
->(or/c'inherited'all'())
(current-subprocess-keep-file-descriptorskeeps)->void?
keeps:(or/c'inherited'all'())
procedure
(shell-executeverb       
             target     
             parameters 
             dir        
             show-mode)->#f
verb:(or/cstring?#f)
target:string?
parameters:string?
dir:path-string?
show-mode:symbol?
procedure
(systemcommand[#:set-pwd?set-pwd?])->boolean?
command:(or/cstring-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(system*commandarg...[#:set-pwd?set-pwd?])->boolean?
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
(system* command               
        exact                 
        arg                   
       [#:set-pwd?set-pwd?])->boolean?
command:path-string?
exact:'exact
arg:string?
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(system/exit-code command               
                [#:set-pwd?set-pwd?])->byte?
command:(or/cstring-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(system*/exit-code command               
                  arg...               
                 [#:set-pwd?set-pwd?])->byte?
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
(system*/exit-code command               
                  exact                 
                  arg                   
                 [#:set-pwd?set-pwd?])->byte?
command:path-string?
exact:'exact
arg:string?
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(processcommand[#:set-pwd?set-pwd?])
->(listinput-port?
    output-port?
    exact-nonnegative-integer?
    input-port?
    ((or/c'status'wait'interrupt'kill). -> .any))
command:(or/cstring-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(process* command               
         arg...               
        [#:set-pwd?set-pwd?])->list?
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
(process* command               
         exact                 
         arg                   
        [#:set-pwd?set-pwd?])->list?
command:path-string?
exact:'exact
arg:string?
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(process/ports out                   
              in                    
              error-out             
              command               
             [#:set-pwd?set-pwd?])->list?
out:(or/c#foutput-port?)
in:(or/c#finput-port?)
error-out:(or/c#foutput-port?'stdout)
command:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(process*/ports out                   
               in                    
               error-out             
               command               
               arg...               
              [#:set-pwd?set-pwd?])->list?
out:(or/c#foutput-port?)
in:(or/c#finput-port?)
error-out:(or/c#foutput-port?'stdout)
command:path-string?
arg:(or/cpath?string-no-nuls?bytes-no-nuls?)
set-pwd?:any/c=(member(system-type)'(unixmacosx))
(process*/ports out                   
               in                    
               error-out             
               command               
               exact                 
               arg                   
              [#:set-pwd?set-pwd?])->list?
out:(or/c#foutput-port?)
in:(or/c#finput-port?)
error-out:(or/c#foutput-port?'stdout)
command:path-string?
exact:'exact
arg:string?
set-pwd?:any/c=(member(system-type)'(unixmacosx))
procedure
(string-no-nuls?x)->boolean?
x:any/c
procedure
(bytes-no-nuls?x)->boolean?
x:any/c
procedure
(logger?v)->boolean?
v:any/c
procedure
(make-logger[topic                
            parent               
            propagate-level      
            propagate-topic...] 
            ...)                ->logger?
topic:(or/csymbol?#f)=#f
parent:(or/clogger?#f)=#f
propagate-level:log-level/c='debug
propagate-topic:(or/c#fsymbol?)=#f
procedure
(logger-namelogger)->(or/csymbol?#f)
logger:logger?
parameter
(current-logger)->logger?
(current-loggerlogger)->void?
logger:logger?
syntax
(define-loggeridmaybe-parent)

maybe-parent=
           |#:parentparent-expr

parent-expr:(or/clogger?#f)
procedure
(log-message logger            
            level             
           [topic]            
            message           
           [data              
            prefix-message?])->void?
logger:logger?
level:log-level/c
topic:(or/csymbol?#f)=(logger-namelogger)
message:string?
data:any/c=#f
prefix-message?:any/c=#t
procedure
(log-level?loggerlevel[topic])->boolean?
logger:logger?
level:log-level/c
topic:(or/csymbol?#f)=#f
procedure
(log-max-levellogger[topic])->(or/clog-level/c#f)
logger:logger?
topic:(or/csymbol?#f)=#f
procedure
(log-all-levelslogger)->(list/c(or/c#flog-level/c)
                           (or/c#fsymbol?)
                           ......)
logger:logger?
procedure
(log-level-evtlogger)->evt?
logger:logger?
syntax
(log-fatalstring-expr)
(log-fatalformat-string-exprv...)
syntax
(log-errorstring-expr)
(log-errorformat-string-exprv...)
syntax
(log-warningstring-expr)
(log-warningformat-string-exprv...)
syntax
(log-infostring-expr)
(log-infoformat-string-exprv...)
syntax
(log-debugstring-expr)
(log-debugformat-string-exprv...)
procedure
(log-receiver?v)->boolean?
v:any/c
procedure
(make-log-receiverloggerlevel[topic...]...)->log-receiver?
logger:logger?
level:log-level/c
topic:(or/c#fsymbol?)=#f
procedure
(log-level/cv)->boolean?
v:any/c
procedure
(with-intercepted-logging interceptor      
                         proc             
                        [#:loggerlogger] 
                         level            
                        [topic...]       
                         ...)            ->any
interceptor:(->(vector/c
                log-level/c
                string?
                any/c
                (or/csymbol?#f))
                any)
proc:(->any)
logger:logger?=#f
level:log-level/c
topic:(or/c#fsymbol?)=#f
procedure
(with-logging-to-port port             
                     proc             
                    [#:loggerlogger] 
                     level            
                    [topic...]       
                     ...)            ->any
port:output-port?
proc:(->any)
logger:logger?=#f
level:log-level/c
topic:(or/c#fsymbol?)=#f
procedure
(current-seconds)->exact-integer?
procedure
(current-inexact-milliseconds)->real?
procedure
(current-inexact-monotonic-milliseconds)->real?
procedure
(seconds->datesecs-n[local-time?])->date*?
secs-n:real?
local-time?:any/c=#t
struct
(structdate(second
          minute
          hour
          day
          month
          year
          week-day
          year-day
          dst?
          time-zone-offset)
#:extra-constructor-namemake-date
#:transparent)
second:(integer-in060)
minute:(integer-in059)
hour:(integer-in023)
day:(integer-in131)
month:(integer-in112)
year:exact-integer?
week-day:(integer-in06)
year-day:(integer-in0365)
dst?:boolean?
time-zone-offset:exact-integer?
struct
(structdate*date(nanosecond time-zone-name)
#:extra-constructor-namemake-date*)
nanosecond:(integer-in0999999999)
time-zone-name:(and/cstring?immutable?)
procedure
(current-milliseconds)->exact-integer?
procedure
(current-process-milliseconds[scope])->exact-integer?
scope:(or/c#fthread?'subprocesses)=#f
procedure
(current-gc-milliseconds)->exact-integer?
procedure
(time-applyproclst)->list?
                         exact-integer?
                         exact-integer?
                         exact-integer?
proc:procedure?
lst:list?
syntax
(timebody...+)
procedure
(current-date)->date*?
procedure
(date->stringdate[time?])->string?
date:date?
time?:any/c=#f
parameter
(date-display-format)->(or/c'american
                         'chinese
                         'german
                         'indian
                         'irish
                         'iso-8601
                         'rfc2822
                         'julian)
(date-display-formatformat)->void?
format:(or/c'american
           'chinese
           'german
           'indian
           'irish
           'iso-8601
           'rfc2822
           'julian)
procedure
(date->secondsdate[local-time?])->exact-integer?
date:date?
local-time?:any/c=#t
procedure
(date*->secondsdate[local-time?])->real?
date:date?
local-time?:any/c=#t
procedure
(find-seconds second        
             minute        
             hour          
             day           
             month         
             year          
            [local-time?])->exact-integer?
second:(integer-in061)
minute:(integer-in059)
hour:(integer-in023)
day:(integer-in131)
month:(integer-in112)
year:exact-nonnegative-integer?
local-time?:any/c=#t
procedure
(date->julian/scaligerdate)->exact-integer?
date:date?
procedure
(julian/scaliger->stringdate-number)->string?
date-number:exact-integer?
procedure
(date->julian/scalingerdate)->exact-integer?
date:date?
procedure
(julian/scalinger->stringdate-number)->string?
date-number:exact-integer?
procedure
(environment-variables?v)->boolean?
v:any/c
parameter
(current-environment-variables)->environment-variables?
(current-environment-variablesenv)->void?
env:environment-variables?
procedure
(bytes-environment-variable-name?v)->boolean?
v:any/c
procedure
(make-environment-variablesnameval......)
->environment-variables?
name:bytes-environment-variable-name?
val:bytes-no-nuls?
procedure
(environment-variables-refenvname)
->(or/c#f(and/cbytes-no-nuls?immutable?))
env:environment-variables?
name:bytes-environment-variable-name?
procedure
(environment-variables-set! env        
                           name       
                           maybe-bstr 
                          [fail])    ->any
env:environment-variables?
name:bytes-environment-variable-name?
maybe-bstr:(or/cbytes-no-nuls?#f)
fail:(->any)=(lambda()
                    (raise(make-exn:fail....)))
procedure
(environment-variables-namesenv)
->(listof(and/cbytes-environment-variable-name?immutable?))
env:environment-variables?
procedure
(environment-variables-copyenv)->environment-variables?
env:environment-variables?
procedure
(getenvname)->(or/cstring-no-nuls?#f)
name:string-environment-variable-name?
procedure
(putenvnamevalue)->boolean?
name:string-environment-variable-name?
value:string-no-nuls?
procedure
(string-environment-variable-name?v)->boolean?
v:any/c
procedure
(system-type[mode])
->(or/csymbol?string?bytes?exact-positive-integer?vector?#f)
mode:(or/c'os'os*'arch'word'vm'gc'link'machine'target-machine
         'so-suffix'so-mode'fs-change'cross)
    ='os
procedure
(system-language+country)->string?
procedure
(system-library-subpath[mode])->path?
mode:(or/c'cgc'3m'cs#f)=(system-type'gc)
procedure
(version)->(and/cstring?immutable?)
procedure
(banner)->(and/cstring?immutable?)
parameter
(current-command-line-arguments)
->(vectorof(and/cstring?immutable?))
(current-command-line-argumentsargv)->void?
argv:(vectorofstring?)
parameter
(current-thread-initial-stack-size)->exact-positive-integer?
(current-thread-initial-stack-sizesize)->void?
size:exact-positive-integer?
procedure
(vector-set-performance-stats!results[thd])->void?
results:(and/cvector?
            (not/cimmutable?))
thd:(or/cthread?#f)=#f
syntax
(command-lineoptional-name-exproptional-argv-expr
flag-clause...
finish-clause)

optional-name-expr=
                 |#:programname-expr
                 
optional-argv-expr=
                 |#:argvargv-expr
                 
       flag-clause=#:multiflag-spec...
                 |#:once-eachflag-spec...
                 |#:once-anyflag-spec...
                 |#:finalflag-spec...
                 |#:usage-helpstring...
                 |#:help-labelsstring...
                 |#:psstring...
                 
         flag-spec=(flagsid...help-specbody...+)
                 |(flags=>handler-exprhelp-expr)
                 
             flags=flag-string
                 |(flag-string...+)
                 
         help-spec=string
                 |(string-expr...+)
                 
     finish-clause=
                 |#:argsarg-formalsbody...+
                 |#:handlershandlers-exprs
                 
       arg-formals=rest-id
                 |(arg...)
                 |(arg...+. rest-id)
                 
               arg=id
                 |[iddefault-expr]
                 
    handlers-exprs=finish-exprarg-strings-expr
                 |finish-exprarg-strings-exprhelp-expr
                 |finish-exprarg-strings-exprhelp-expr
                     unknown-expr
procedure
(parse-command-line name           
                   argv           
                   table          
                   finish-proc    
                   arg-help-strs  
                  [help-proc      
                   unknown-proc])->any
name:(or/cstring?path?)
argv:(or/c(listofstring?)(vectorofstring?))
table:(listof(cons/csymbol?list?))
finish-proc:((list?)()#:restlist?. ->* .any)
arg-help-strs:(listofstring?)
help-proc:(string?. -> .any)=(lambda(str)....)
unknown-proc:(string?. -> .any)=(lambda(str)...)
procedure
(gethostname)->string?
procedure
(getpid)->exact-integer?
procedure
(make-weak-boxv)->weak-box?
v:any/c
procedure
(weak-box-valueweak-box[gced-v])->any/c
weak-box:weak-box?
gced-v:any/c=#f
procedure
(weak-box?v)->boolean?
v:any/c
procedure
(make-ephemeronkeyv)->ephemeron?
key:any/c
v:any/c
procedure
(ephemeron-valueephemeron[gced-vretain-v])->any/c
ephemeron:ephemeron?
gced-v:any/c=#f
retain-v:any/c=#f
procedure
(ephemeron?v)->boolean?
v:any/c
procedure
(make-will-executor)->will-executor?
procedure
(will-executor?v)->boolean?
v:any/c
procedure
(will-registerexecutorvproc)->void?
executor:will-executor?
v:any/c
proc:(any/c. -> .any)
procedure
(will-executeexecutor)->any
executor:will-executor?
procedure
(will-try-executeexecutor[v])->any
executor:any/c
v:any/c=#f
procedure
(collect-garbage[request])->void?
request:(or/c'major'minor'incremental)='major
procedure
(current-memory-use[mode])->exact-nonnegative-integer?
mode:(or/c#f'cumulativecustodian?)=#f
procedure
(dump-memory-statsv...)->any
v:any/c
procedure
(phantom-bytes?v)->boolean?
v:any/c
procedure
(make-phantom-bytesk)->phantom-bytes?
k:exact-nonnegative-integer?
procedure
(set-phantom-bytes!phantom-bstrk)->phantom-bytes?
phantom-bstr:phantom-bytes?
k:exact-nonnegative-integer?
procedure
(unsafe-fx+a...)->fixnum?
a:fixnum?
procedure
(unsafe-fx-ab...)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx*a...)->fixnum?
a:fixnum?
procedure
(unsafe-fxquotientab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxremainderab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxmoduloab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxabsa)->fixnum?
a:fixnum?
procedure
(unsafe-fxanda...)->fixnum?
a:fixnum?
procedure
(unsafe-fxiora...)->fixnum?
a:fixnum?
procedure
(unsafe-fxxora...)->fixnum?
a:fixnum?
procedure
(unsafe-fxnota)->fixnum?
a:fixnum?
procedure
(unsafe-fxlshiftab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxrshiftab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxpopcounta)->fixnum?
a:(and/cfixnum?(not/cnegative?))
procedure
(unsafe-fxpopcount32a)->fixnum?
a:(and/cfixnum?(integer-in0#xFFFFFFFF))
procedure
(unsafe-fxpopcount16a)->fixnum?
a:(and/cfixnum?(integer-in0#xFFFF))
procedure
(unsafe-fx+/wraparoundab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx-/wraparoundab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx*/wraparoundab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxlshift/wraparoundab)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx=ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx<ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx>ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx<=ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fx>=ab...)->boolean?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxminab...)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fxmaxab...)->fixnum?
a:fixnum?
b:fixnum?
procedure
(unsafe-fl+a...)->flonum?
a:flonum?
procedure
(unsafe-fl-ab...)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-fl*a...)->flonum?
a:flonum?
procedure
(unsafe-fl/ab...)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-flabsa)->flonum?
a:flonum?
procedure
(unsafe-fl=ab...)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-fl<ab...)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-fl>ab...)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-fl<=ab...)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-fl>=ab...)->boolean?
a:flonum?
b:flonum?
procedure
(unsafe-flminab...)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-flmaxab...)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-flrounda)->flonum?
a:flonum?
procedure
(unsafe-flfloora)->flonum?
a:flonum?
procedure
(unsafe-flceilinga)->flonum?
a:flonum?
procedure
(unsafe-fltruncatea)->flonum?
a:flonum?
procedure
(unsafe-flsinglea)->flonum?
a:flonum?
procedure
(unsafe-flsina)->flonum?
a:flonum?
procedure
(unsafe-flcosa)->flonum?
a:flonum?
procedure
(unsafe-fltana)->flonum?
a:flonum?
procedure
(unsafe-flasina)->flonum?
a:flonum?
procedure
(unsafe-flacosa)->flonum?
a:flonum?
procedure
(unsafe-flatana)->flonum?
a:flonum?
procedure
(unsafe-flloga)->flonum?
a:flonum?
procedure
(unsafe-flexpa)->flonum?
a:flonum?
procedure
(unsafe-flsqrta)->flonum?
a:flonum?
procedure
(unsafe-flexptab)->flonum?
a:flonum?
b:flonum?
procedure
(unsafe-make-flrectangularab)
->(and/ccomplex?
    (lambda(c)(flonum?(real-partc)))
    (lambda(c)(flonum?(imag-partc))))
a:flonum?
b:flonum?
procedure
(unsafe-flreal-parta)->flonum?
a:(and/ccomplex?
      (lambda(c)(flonum?(real-partc)))
      (lambda(c)(flonum?(imag-partc))))
procedure
(unsafe-flimag-parta)->flonum?
a:(and/ccomplex?
      (lambda(c)(flonum?(real-partc)))
      (lambda(c)(flonum?(imag-partc))))
procedure
(unsafe-fx->fla)->flonum?
a:fixnum?
procedure
(unsafe-fl->fxa)->fixnum?
a:flonum?
procedure
(unsafe-flrandomrand-gen)->(andflonum?(>/c0)(</c1))
rand-gen:pseudo-random-generator?
procedure
(unsafe-char=?ab...)->boolean?
a:char?
b:char?
procedure
(unsafe-char<?ab...)->boolean?
a:char?
b:char?
procedure
(unsafe-char>?ab...)->boolean?
a:char?
b:char?
procedure
(unsafe-char<=?ab...)->boolean?
a:char?
b:char?
procedure
(unsafe-char>=?ab...)->boolean?
a:char?
b:char?
procedure
(unsafe-char->integera)->fixnum?
a:char?
procedure
(unsafe-carp)->any/c
p:pair?
procedure
(unsafe-cdrp)->any/c
p:pair?
procedure
(unsafe-mcarp)->any/c
p:mpair?
procedure
(unsafe-mcdrp)->any/c
p:mpair?
procedure
(unsafe-set-mcar!pv)->void?
p:mpair?
v:any/c
procedure
(unsafe-set-mcdr!pv)->void?
p:mpair?
v:any/c
procedure
(unsafe-cons-listvrest)->(and/cpair?list?)
v:any/c
rest:list?
procedure
(unsafe-list-reflstpos)->any/c
lst:pair?
pos:(and/cexact-nonnegative-integer?fixnum?)
procedure
(unsafe-list-taillstpos)->any/c
lst:any/c
pos:(and/cexact-nonnegative-integer?fixnum?)
procedure
(unsafe-set-immutable-car!pv)->void?
p:pair?
v:any/c
procedure
(unsafe-set-immutable-cdr!pv)->void?
p:pair?
v:any/c
procedure
(unsafe-unboxb)->fixnum?
b:box?
procedure
(unsafe-set-box!bk)->void?
b:box?
k:fixnum?
procedure
(unsafe-unbox*v)->any/c
v:(and/cbox?(not/cimpersonator?))
procedure
(unsafe-set-box*!vval)->void?
v:(and/cbox?(not/cimpersonator?))
val:any/c
procedure
(unsafe-box*-cas!locoldnew)->boolean?
loc:box?
old:any/c
new:any/c
procedure
(unsafe-vector-lengthv)->fixnum?
v:vector?
procedure
(unsafe-vector-refvk)->any/c
v:vector?
k:fixnum?
procedure
(unsafe-vector-set!vkval)->void?
v:vector?
k:fixnum?
val:any/c
procedure
(unsafe-vector*-lengthv)->fixnum?
v:(and/cvector?(not/cimpersonator?))
procedure
(unsafe-vector*-refvk)->any/c
v:(and/cvector?(not/cimpersonator?))
k:fixnum?
procedure
(unsafe-vector*-set!vkval)->void?
v:(and/cvector?(not/cimpersonator?))
k:fixnum?
val:any/c
procedure
(unsafe-vector*-cas!vkold-valnew-val)->boolean?
v:(and/cvector?(not/cimpersonator?))
k:fixnum?
old-val:any/c
new-val:any/c
procedure
(unsafe-vector*->immutable-vector!v)
->(and/cvector?immutable?)
v:(and/cvector?(not/cimpersonator?))
procedure
(unsafe-string-lengthstr)->fixnum?
str:string?
procedure
(unsafe-string-refstrk)
->(and/cchar?(lambda(ch)(<=0(char->integerch)255)))
str:string?
k:fixnum?
procedure
(unsafe-string-set!strkch)->void?
str:(and/cstring?(not/cimmutable?))
k:fixnum?
ch:char?
procedure
(unsafe-string->immutable-string!str)
->(and/cstring?immutable?)
str:string?
procedure
(unsafe-bytes-lengthbstr)->fixnum?
bstr:bytes?
procedure
(unsafe-bytes-refbstrk)->byte?
bstr:bytes?
k:fixnum?
procedure
(unsafe-bytes-set!bstrkb)->void?
bstr:(and/cbytes?(not/cimmutable?))
k:fixnum?
b:byte?
procedure
(unsafe-bytes-copy! dest       
                   dest-start 
                   src        
                  [src-start  
                   src-end]) ->void?
dest:(and/cbytes?(not/cimmutable?))
dest-start:fixnum?
src:bytes?
src-start:fixnum?=0
src-end:fixnum?=(bytes-lengthsrc)
procedure
(unsafe-bytes->immutable-bytes!bstr)
->(and/cbytes?immutable?)
bstr:bytes?
procedure
(unsafe-fxvector-lengthv)->fixnum?
v:fxvector?
procedure
(unsafe-fxvector-refvk)->fixnum?
v:fxvector?
k:fixnum?
procedure
(unsafe-fxvector-set!vkx)->void?
v:fxvector?
k:fixnum?
x:fixnum?
procedure
(unsafe-flvector-lengthv)->fixnum?
v:flvector?
procedure
(unsafe-flvector-refvk)->flonum?
v:flvector?
k:fixnum?
procedure
(unsafe-flvector-set!vkx)->void?
v:flvector?
k:fixnum?
x:flonum?
procedure
(unsafe-f64vector-refveck)->flonum?
vec:f64vector?
k:fixnum?
procedure
(unsafe-f64vector-set!veckn)->void?
vec:f64vector?
k:fixnum?
n:flonum?
procedure
(unsafe-s16vector-refveck)->(integer-in-3276832767)
vec:s16vector?
k:fixnum?
procedure
(unsafe-s16vector-set!veckn)->void?
vec:s16vector?
k:fixnum?
n:(integer-in-3276832767)
procedure
(unsafe-u16vector-refveck)->(integer-in065535)
vec:u16vector?
k:fixnum?
procedure
(unsafe-u16vector-set!veckn)->void?
vec:u16vector?
k:fixnum?
n:(integer-in065535)
procedure
(unsafe-stencil-vectormaskv...)->stencil-vector?
mask:(integer-in0(sub1(expt2(stencil-vector-mask-width))))
v:any/c
procedure
(unsafe-stencil-vector-maskvec)
->(integer-in0(sub1(expt2(stencil-vector-mask-width))))
vec:stencil-vector?
procedure
(unsafe-stencil-vector-lengthvec)
->(integer-in0(sub1(stencil-vector-mask-width)))
vec:stencil-vector?
procedure
(unsafe-stencil-vector-refvecpos)->any/c
vec:stencil-vector?
pos:exact-nonnegative-integer?
procedure
(unsafe-stencil-vector-set!vecposv)->avoid?
vec:stencil-vector?
pos:exact-nonnegative-integer?
v:any/c
procedure
(unsafe-stencil-vector-updatevec         
                            remove-mask 
                            add-mask    
                            v...)     ->stencil-vector?
vec:stencil-vector?
remove-mask:(integer-in0(sub1(expt2(stencil-vector-mask-width))))
add-mask:(integer-in0(sub1(expt2(stencil-vector-mask-width))))
v:any/c
procedure
(unsafe-struct-refvk)->any/c
v:any/c
k:fixnum?
procedure
(unsafe-struct-set!vkval)->void?
v:any/c
k:fixnum?
val:any/c
procedure
(unsafe-struct*-refvk)->any/c
v:(not/cimpersonator?)
k:fixnum?
procedure
(unsafe-struct*-set!vkval)->void?
v:(not/cimpersonator?)
k:fixnum?
val:any/c
procedure
(unsafe-struct*-cas!vkold-valnew-val)->boolean?
v:(not/cimpersonator?)
k:fixnum?
old-val:any/c
new-val:any/c
procedure
(unsafe-mutable-hash-iterate-firsthash)->(or/c#fany/c)
hash:(and/chash?(not/cimmutable?)hash-strong?)
procedure
(unsafe-mutable-hash-iterate-nexthashpos)->(or/c#fany/c)
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
procedure
(unsafe-mutable-hash-iterate-keyhashpos)->any/c
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
procedure
(unsafe-mutable-hash-iterate-keyhash         
                               pos          
                               bad-index-v)->any/c
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-mutable-hash-iterate-valuehash 
                                 pos)->any/c
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
procedure
(unsafe-mutable-hash-iterate-valuehash         
                                 pos          
                                 bad-index-v)->any/c
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-mutable-hash-iterate-key+valuehash 
                                     pos)->any/cany/c
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
procedure
(unsafe-mutable-hash-iterate-key+valuehash        
                                     pos         
                                     bad-index-v)
->any/cany/c
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-mutable-hash-iterate-pairhashpos)->pair?
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
procedure
(unsafe-mutable-hash-iterate-pairhash         
                                pos          
                                bad-index-v)->pair?
hash:(and/chash?(not/cimmutable?)hash-strong?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-immutable-hash-iterate-firsthash)->(or/c#fany/c)
hash:(and/chash?immutable?)
procedure
(unsafe-immutable-hash-iterate-nexthash 
                                  pos)->(or/c#fany/c)
hash:(and/chash?immutable?)
pos:any/c
procedure
(unsafe-immutable-hash-iterate-keyhash 
                                 pos)->any/c
hash:(and/chash?immutable?)
pos:any/c
procedure
(unsafe-immutable-hash-iterate-keyhash         
                                 pos          
                                 bad-index-v)->any/c
hash:(and/chash?immutable?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-immutable-hash-iterate-valuehash 
                                   pos)->any/c
hash:(and/chash?immutable?)
pos:any/c
procedure
(unsafe-immutable-hash-iterate-valuehash         
                                   pos          
                                   bad-index-v)->any/c
hash:(and/chash?immutable?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-immutable-hash-iterate-key+valuehash 
                                       pos)->any/cany/c
hash:(and/chash?immutable?)
pos:any/c
procedure
(unsafe-immutable-hash-iterate-key+valuehash        
                                       pos         
                                       bad-index-v)
->any/cany/c
hash:(and/chash?immutable?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-immutable-hash-iterate-pairhash 
                                  pos)->pair?
hash:(and/chash?immutable?)
pos:any/c
procedure
(unsafe-immutable-hash-iterate-pairhash         
                                  pos          
                                  bad-index-v)->pair?
hash:(and/chash?immutable?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-weak-hash-iterate-firsthash)->(or/c#fany/c)
hash:(and/chash?hash-weak?)
procedure
(unsafe-weak-hash-iterate-nexthashpos)->(or/c#fany/c)
hash:(and/chash?hash-weak?)
pos:any/c
procedure
(unsafe-weak-hash-iterate-keyhashpos)->any/c
hash:(and/chash?hash-weak?)
pos:any/c
procedure
(unsafe-weak-hash-iterate-keyhash         
                            pos          
                            bad-index-v)->any/c
hash:(and/chash?hash-weak?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-weak-hash-iterate-valuehashpos)->any/c
hash:(and/chash?hash-weak?)
pos:any/c
procedure
(unsafe-weak-hash-iterate-valuehash         
                              pos          
                              bad-index-v)->any/c
hash:(and/chash?hash-weak?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-weak-hash-iterate-key+valuehash 
                                  pos)->any/cany/c
hash:(and/chash?hash-weak?)
pos:any/c
procedure
(unsafe-weak-hash-iterate-key+valuehash         
                                  pos          
                                  bad-index-v)->any/cany/c
hash:(and/chash?hash-weak?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-weak-hash-iterate-pairhashpos)->pair?
hash:(and/chash?hash-weak?)
pos:any/c
procedure
(unsafe-weak-hash-iterate-pairhash         
                             pos          
                             bad-index-v)->pair?
hash:(and/chash?hash-weak?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-ephemeron-hash-iterate-firsthash)->(or/c#fany/c)
hash:(and/chash?hash-ephemeron?)
procedure
(unsafe-ephemeron-hash-iterate-nexthash 
                                  pos)->(or/c#fany/c)
hash:(and/chash?hash-ephemeron?)
pos:any/c
procedure
(unsafe-ephemeron-hash-iterate-keyhash 
                                 pos)->any/c
hash:(and/chash?hash-ephemeron?)
pos:any/c
procedure
(unsafe-ephemeron-hash-iterate-keyhash         
                                 pos          
                                 bad-index-v)->any/c
hash:(and/chash?hash-ephemeron?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-ephemeron-hash-iterate-valuehash 
                                   pos)->any/c
hash:(and/chash?hash-ephemeron?)
pos:any/c
procedure
(unsafe-ephemeron-hash-iterate-valuehash         
                                   pos          
                                   bad-index-v)->any/c
hash:(and/chash?hash-ephemeron?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-ephemeron-hash-iterate-key+valuehash 
                                       pos)->any/cany/c
hash:(and/chash?hash-ephemeron?)
pos:any/c
procedure
(unsafe-ephemeron-hash-iterate-key+valuehash        
                                       pos         
                                       bad-index-v)
->any/cany/c
hash:(and/chash?hash-ephemeron?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-ephemeron-hash-iterate-pairhash 
                                  pos)->pair?
hash:(and/chash?hash-ephemeron?)
pos:any/c
procedure
(unsafe-ephemeron-hash-iterate-pairhash         
                                  pos          
                                  bad-index-v)->pair?
hash:(and/chash?hash-ephemeron?)
pos:any/c
bad-index-v:any/c
procedure
(unsafe-make-srclocsource   
                  line     
                  column   
                  position 
                  span)   ->srcloc?
source:any/c
line:(or/cexact-positive-integer?#f)
column:(or/cexact-nonnegative-integer?#f)
position:(or/cexact-positive-integer?#f)
span:(or/cexact-nonnegative-integer?#f)
procedure
(unsafe-extfl+ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl-ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl*ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl/ab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extflabsa)->extflonum?
a:extflonum?
procedure
(unsafe-extfl=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl<ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl>ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl<=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extfl>=ab)->boolean?
a:extflonum?
b:extflonum?
procedure
(unsafe-extflminab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extflmaxab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-extflrounda)->extflonum?
a:extflonum?
procedure
(unsafe-extflfloora)->extflonum?
a:extflonum?
procedure
(unsafe-extflceilinga)->extflonum?
a:extflonum?
procedure
(unsafe-extfltruncatea)->extflonum?
a:extflonum?
procedure
(unsafe-extflsina)->extflonum?
a:extflonum?
procedure
(unsafe-extflcosa)->extflonum?
a:extflonum?
procedure
(unsafe-extfltana)->extflonum?
a:extflonum?
procedure
(unsafe-extflasina)->extflonum?
a:extflonum?
procedure
(unsafe-extflacosa)->extflonum?
a:extflonum?
procedure
(unsafe-extflatana)->extflonum?
a:extflonum?
procedure
(unsafe-extflloga)->extflonum?
a:extflonum?
procedure
(unsafe-extflexpa)->extflonum?
a:extflonum?
procedure
(unsafe-extflsqrta)->extflonum?
a:extflonum?
procedure
(unsafe-extflexptab)->extflonum?
a:extflonum?
b:extflonum?
procedure
(unsafe-fx->extfla)->extflonum?
a:fixnum?
procedure
(unsafe-extfl->fxa)->fixnum?
a:extflonum?
procedure
(unsafe-extflvector-lengthv)->fixnum?
v:extflvector?
procedure
(unsafe-extflvector-refvk)->extflonum?
v:extflvector?
k:fixnum?
procedure
(unsafe-extflvector-set!vkx)->void?
v:extflvector?
k:fixnum?
x:extflonum?
procedure
(unsafe-impersonate-procedureproc            
                            replacement-proc
                            prop            
                            prop-val...    
                            ...)            
->(and/cprocedure?impersonator?)
proc:procedure?
replacement-proc:procedure?
prop:impersonator-property?
prop-val:any
procedure
(unsafe-chaperone-procedureproc        
                          wrapper-proc
                          prop        
                          prop-val...
                          ...)        
->(and/cprocedure?chaperone?)
proc:procedure?
wrapper-proc:procedure?
prop:impersonator-property?
prop-val:any
procedure
(unsafe-impersonate-vectorvec            
                         replacement-vec
                         prop           
                         prop-val...   
                         ...)           
->(and/cvector?impersonator?)
vec:vector?
replacement-vec:(and/cvector?(not/cimpersonator?))
prop:impersonator-property?
prop-val:any/c
procedure
(unsafe-chaperone-vectorvec            
                       replacement-vec
                       prop           
                       prop-val...   
                       ...)           
->(and/cvector?chaperone?)
vec:vector?
replacement-vec:(and/cvector?(not/cimpersonator?))
prop:impersonator-property?
prop-val:any/c
procedure
(unsafe-assert-unreachable)->none/c
value
unsafe-undefined:any/c
procedure
(check-not-unsafe-undefinedvsym)
->(and/cany/c(not/c(one-of/cunsafe-undefined)))
v:any/c
sym:symbol?
procedure
(check-not-unsafe-undefined/assignvsym)
->(and/cany/c(not/c(one-of/cunsafe-undefined)))
v:any/c
sym:symbol?
procedure
(chaperone-struct-unsafe-undefinedv)->any/c
v:any/c
value
prop:chaperone-unsafe-undefined:struct-type-property?
procedure
(find-library-collection-paths[pre-extras  
                              post-extras 
                              config]     
                              name)      ->(listofpath?)
pre-extras:(listofpath-string?)=null
post-extras:(listofpath-string?)=null
config:hash?=(read-installation-configuration-table)
name:(get-installation-nameconfig)
procedure
(find-library-collection-links[config]name)
->(listof(or/c#f(and/cpath?complete-path?)))
config:hash?=(read-installation-configuration-table)
name:(get-installation-nameconfig)
procedure
(collection-file-path file                               
                     collection...+                    
                    [#:check-compiled?check-compiled?])
->path?
file:path-string?
collection:path-string?
check-compiled?:any/c=(regexp-match?#rx"[.]rkt$"file)
(collection-file-path file                                
                     collection...+                     
                     #:failfail-proc                    
                    [#:check-compiled?check-compiled?])->any
file:path-string?
collection:path-string?
fail-proc:(string?. -> .any)
check-compiled?:any/c=(regexp-match?#rx"[.]rkt$"file)
procedure
(collection-pathcollection...+)->path?
collection:path-string?
(collection-pathcollection        
               ...+              
               #:failfail-proc)->any
collection:path-string?
fail-proc:(string?. -> .any)
parameter
(current-library-collection-paths)
->(listof(and/cpath?complete-path?))
(current-library-collection-pathspaths)->void?
paths:(listof(and/cpath-string?complete-path?))
parameter
(current-library-collection-links)
->(listof(or/c#f
    (and/cpath?complete-path?)
    (hash/c(or/c(and/csymbol?module-path?)#f)
    (listof(and/cpath?complete-path?)))))
(current-library-collection-linkspaths)->void?
paths:(listof(or/c#f
          (and/cpath-string?complete-path?)
          (hash/c(or/c(and/csymbol?module-path?)#f)
          (listof(and/cpath-string?complete-path?)))))
parameter
(use-user-specific-search-paths)->boolean?
(use-user-specific-search-pathson?)->void?
on?:any/c
parameter
(use-collection-link-paths)->boolean?
(use-collection-link-pathson?)->void?
on?:any/c
procedure
(read-installation-configuration-table)
->(and/chash?immutable?)
syntax
help
(helpstring...)
(helpid)
(helpid#:frommodule-path)
(help#:searchdatum...)
parameter
(current-interaction-info)
->(or/c#f(vector/cmodule-path?symbol?any/c))
(current-interaction-infoinfo)->void?
info:(or/c#f(vector/cmodule-path?symbol?any/c))
syntax
(enter!module-path)
(enter!#f)
(enter!module-pathflag...+)

flag=#:quiet
   |#:verbose-reload
   |#:verbose
   |#:dont-re-require-enter
procedure
(dynamic-enter! mod                                     
              [#:verbosityverbosity                   
               #:re-require-enter?re-require-enter?])->void?
mod:(or/cmodule-path?#f)
verbosity:(or/c'all'reload'none)='reload
re-require-enter?:any/c=#t
procedure
(dynamic-rerequire module-path             
                 [#:verbosityverbosity])->(listofpath?)
module-path:module-path?
verbosity:(or/c'all'reload'none)='reload
syntax
(traceid...)
syntax
(trace-defineidexpr)
(trace-define(headargs)body...+)
syntax
(trace-define-syntaxidexpr)
(trace-define-syntax(headargs)body...+)
syntax
(trace-lambda[#:nameid]argsexpr)
syntax
(trace-letid([argexpr]...+)body...+)
syntax
(untraceid...)
parameter
(current-trace-notify)->(string?. -> .any)
(current-trace-notifyproc)->void?
proc:(string?. -> .any)
procedure
(trace-callidproc#:<kw>kw-arg...)->any/c
id:symbol?
proc:procedure?
kw-arg:any/c
parameter
(current-trace-print-args)->(->symbol?
                              list?
                              (listofkeyword?)
                              list?
                              number?
                              void?)
(current-trace-print-argstrace-print-args)->void?
trace-print-args:(->symbol?
                     list?
                     (listofkeyword?)
                     list?
                     number?
                     void?)
parameter
(current-trace-print-results)->(->symbol?
                                 list?
                                 number?
                                 any)
(current-trace-print-resultstrace-print-results)->void?
trace-print-results:(->symbol?
                        list?
                        number?
                        any)
parameter
(current-prefix-in)->string?
(current-prefix-inprefix)->void?
prefix:string?
parameter
(current-prefix-out)->string?
(current-prefix-outprefix)->void?
prefix:string?
